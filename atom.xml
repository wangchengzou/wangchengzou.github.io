<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>~~博客园~~</title>
  <subtitle>千帆渡</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="www.wangchengzou.cn/"/>
  <updated>2017-07-23T03:52:11.433Z</updated>
  <id>www.wangchengzou.cn/</id>
  
  <author>
    <name>汪成邹</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>link和@import有什么区别</title>
    <link href="www.wangchengzou.cn/2017/07/23/link%E5%92%8C-import%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB/"/>
    <id>www.wangchengzou.cn/2017/07/23/link和-import有什么区别/</id>
    <published>2017-07-23T03:50:15.000Z</published>
    <updated>2017-07-23T03:52:11.433Z</updated>
    
    <content type="html"><![CDATA[<p>（1）link属于XHTML标签，除了加载CSS外，还能用于定义RSS, 定义rel连接属性等作用；而@import是CSS提供的，只能用于加载CSS; （2）页面被加载的时，link会同时被加载，而@import引用的CSS会等到页面被加载完再加载; （3）import是CSS2.1 提出的，只在IE5以上才能被识别，而link是XHTML标签，无兼容问题;</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;（1）link属于XHTML标签，除了加载CSS外，还能用于定义RSS, 定义rel连接属性等作用；而@import是CSS提供的，只能用于加载CSS; （2）页面被加载的时，link会同时被加载，而@import引用的CSS会等到页面被加载完再加载; （3）import是
    
    </summary>
    
      <category term="面试题目" scheme="www.wangchengzou.cn/categories/%E9%9D%A2%E8%AF%95%E9%A2%98%E7%9B%AE/"/>
    
    
      <category term="html" scheme="www.wangchengzou.cn/tags/html/"/>
    
      <category term="css" scheme="www.wangchengzou.cn/tags/css/"/>
    
  </entry>
  
  <entry>
    <title>行内元素有哪些？块级元素有哪些？ 空(void)元素有那些？</title>
    <link href="www.wangchengzou.cn/2017/07/23/%E8%A1%8C%E5%86%85%E5%85%83%E7%B4%A0%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F%E5%9D%97%E7%BA%A7%E5%85%83%E7%B4%A0%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F-%E7%A9%BA-void-%E5%85%83%E7%B4%A0%E6%9C%89%E9%82%A3%E4%BA%9B%EF%BC%9F/"/>
    <id>www.wangchengzou.cn/2017/07/23/行内元素有哪些？块级元素有哪些？-空-void-元素有那些？/</id>
    <published>2017-07-23T02:47:53.000Z</published>
    <updated>2017-07-23T03:49:03.701Z</updated>
    
    <content type="html"><![CDATA[<p>行内元素有：a b span img input select strong（强调的语气）<br>块级元素有：div ul ol li dl dt dd h1 h2 h3 h4…p<br>常见的空元素：<br> <hr> <img> <input> <link> <meta></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;行内元素有：a b span img input select strong（强调的语气）&lt;br&gt;块级元素有：div ul ol li dl dt dd h1 h2 h3 h4…p&lt;br&gt;常见的空元素：&lt;br&gt; &lt;hr&gt; &lt;img&gt; &lt;input&gt; &lt;link&gt; &lt;meta
    
    </summary>
    
      <category term="面试题目" scheme="www.wangchengzou.cn/categories/%E9%9D%A2%E8%AF%95%E9%A2%98%E7%9B%AE/"/>
    
    
      <category term="html" scheme="www.wangchengzou.cn/tags/html/"/>
    
  </entry>
  
  <entry>
    <title>javaScript基础知识</title>
    <link href="www.wangchengzou.cn/2017/07/22/javaScript/"/>
    <id>www.wangchengzou.cn/2017/07/22/javaScript/</id>
    <published>2017-07-22T15:48:26.000Z</published>
    <updated>2017-07-23T12:37:23.180Z</updated>
    
    <content type="html"><![CDATA[<p>JavaScript</p>
<pre><code>什么是JavaScript: 专门编写网页交互行为的语言
为什么: HTML和CSS是静态语言，编写静态内容，无法编写逻辑，无法执行计算。
何时: 今后所有静态网页必须使用JavaScript添加上交互行为，才能让用户使用。
什么是交互: 3步:
 1. 用户输入数据或执行操作
 2. 程序接受并处理用户输入的数据
 3. 程序返回处理结果
JavaScript典型用途: 3个
1. 客户端表单验证:
2. 数据计算:
3. 动画效果:
ECMAScript  JavaScript  JScript
ECMA: 欧洲计算机制造协会:
ECMAScript: 是欧洲计算机制造协会以第一版JavaScript为基础，指定的JavaScript语言标准。简称ES。3.1  5  6
  只固定了JS语言的核心语法
JavaScript: 狭义: 网景参照ES标准，实现的自己的JavaScript语言版本。
JScript: 微软参照ES标准，实现的自己的JavaScript语言版本。
</code></pre><p>广义的JavaScript: 包括三大部分:</p>
<pre><code>1. ES: 固定了核心语法， 7天+4天
2. DOM: 专门操作网页内容的程序 3天
3. BOM: 专门操作浏览器窗口的程序 2天
</code></pre><p>JavaScript语言的特点:</p>
<pre><code>1、 运行在脚本解释引擎中:
  1. 浏览器已经自带: 不用单独安装
     内容排版引擎：专门解析HTML和CSS，并绘制网页内容的软件
     脚本解释引擎: 专门解析js程序，并执行任务的软件
     鄙视题: 做动画首选css，还是js
       首先CSS，因为CSS是内容排版引擎执行，效率高
       但如果动画要求交互，就只能用js做

  2. 独立安装: Node.js    Chrome V8-&gt;单独提取
     以前: 前端 JS  服务器端 PHP/Java  数据库 SQL
     现在: 前端 JS  服务器端 Node.js   数据库 MongoDB JS
    启动: win+R 输入node 回车
2、 弱类型: 3个特点:
  1. 声明变量时，不必提前固定变量的数据类型

练习: 所有程序都可概括为3步:
 网页中的所有js程序，必须写在script标签内:
 script标签可放在网页任何位置，但强烈建议放在body最后
 1. Input输入:  input=prompt(&quot;提示信息&quot;)
 2. Process处理数据
 3. Output输出: 3种:
   1. 在网页内容中输出一句话: document.write(&quot;内容&quot;)
                               网页    写
     问题: 会破坏网页结构 —— 几乎不用
   2. 弹出提示框: alert(&quot;内容&quot;)
     问题: 无法修改样式和字体 ——少用
   3. 在控制台输出: console.log(&quot;内容&quot;)
                   控制台 输出一行日志
     控制台: 专门编写和测试javascript程序的窗口
      为什么: 即不影响网页内容，又可修改字体大小
      何时: 1. 测试简短的js小程序
           2. 查看正式的js程序的输出结果和错误提示
      如何: 1. 输出一条js语句，回车执行
           2. 多行输入: shift+回车
           3. 清屏: ctrl+L 或 点左上角×
           4. 切换出曾经写过的程序 上下箭头

错误: 程序执行过程中，导致程序无法正常执行的现象
一旦出错，程序立刻停止。预期的效果出不来。
今后只要想要的效果没出来，先开F12-&gt;console，看错误原因，定义错误位置。
</code></pre><p>2、变量:</p>
<pre><code>什么是: 内存中存储一个数据的存储空间
何时: 今后只要反复使用的数据，必须先保存在变量中，再反复使用变量。
如何: 3件事:
1. 声明: 创建一个存储空间，并起一个名字
   何时: 所有变量使用前必须先声明再使用
   如何: var 变量名;
     强调: 所有变量都用var声明
     简写: var 变量1,变量2,...;
   变量名:
      1. 不能使用js语言的保留字
      2. 字母，数字或下划线，不能以数字开头
      3. 见名知意
      4. 驼峰命名: 首字母小写，之后每个单词首字母大写
         list-style-type    listStyleType
         background-color  backgroundColor
   强调: 仅声明，但暂未赋值的变量，默认值为undefined
    什么是undefined: 一个特殊值，表示空变量
2. 赋值: 将等号右边的数据，保存到等号左边的变量中
    如何: 变量=值;
    简写: var 变量名=值;
    特殊: 鄙视: var a , b=2;
          结果: a=undefined    b=2
          如果非要简写: var a,
                          b=2,
                          c=3;
3. 取值: 取出变量中的值做处理
    如何: 任何情况下，使用变量等效于使用变量中的值
    强调: 只有=才能改变变量的值
          如果仅取出变量值做计算，则原变量中的值不变。
特殊:
 1. 仅声明但未赋值的变量，其中不是空的，而是保存默认值undefined
 2. 尝试从未声明过的变量中取值，会报错！——ReferenceError
    引用错误: 要找的变量没找到
       可能: 1. 根本没声明
            2. 声明了，但后边使用时，变量名拼写错误
 3. 尝试给未声明的变量赋值，会自动创建该变量，并保存值
     会产生歧义，禁止使用！
    ES5: 严格模式: 比普通js运行模式更严格的机制
     何时: 今后，凡是新项目，所有js必须启用严格模式
     要求1: 禁止给未声明过的变量赋值，报错: ReferenceError
</code></pre><p>3、常量:</p>
<pre><code>什么是: 一旦赋值，值不能改变的变量
何时: 只要一个变量的值不允许修改，就必须使用常量
如何: const 常量名=值;
 强调: 常量声明时必须初始化
   什么是初始化: 第一个为变量赋值
 命名: 常量习惯全大写
 问题: 在旧版本浏览器中:
   修改常量的值，虽然无法修改，但也不报错。——静默失败
   解决: 启用严格模式:
     严格模式要求2: 将所有静默失败升级为错误！
练习: 角度 to 弧度
 弧度: 弧长等于半径的角度，称为1弧度
   周长: 2πr  一周: 2π个弧度=360角度
   30角度=π/6弧度
</code></pre><p>4、数据类型:</p>
<pre><code>什么是: 数据在内存中的存储格式
为什么: 不同用途的数据，就必须保存为对应的数据类型
包括: 2大类:
  1. 原始类型: 值直接保存在变量本地的数据类型
     5个: number string boolean undefined null
  2. 引用类型: 值无法直接保存在变量本地的数据类型

补: typeof 变量 返回变量中数据的类型名

number:
什么是: 专门存储数字的数据类型
何时: 凡是用作比较和计算的数字都必须保存为number类型
如何: 凡是不加引号的数字，自动就是number类型
存储结构: 都是用二进制存储数字
  十进制转二进制:  n.toString(2)
存储空间: 整数: 4字节, 浮点数(小数):8字节
  强调: 不管数值大小，所有整数所占空间都是一样的。

string:
什么是: 专门存储文字字符的数据类型
何时: 经常用作标识和描述的字符内容保存为string类型
如何: 凡是包裹在一对儿引号之间的字符，都是字符串类型
存储结构:
 unicode编码: 人为的为全球主要语言中的每个文字编一个号
      为什么: 因为计算机只认数字，不认字符
   查看每个字符的unicode编码:
     str.charCodeAt();
 存储空间: 一位字母或数字，占1个字节(8位)
           一位汉字，占2个字节
 &quot;张东666&quot; 共7个字节
转义字符:
 1. 防止字符串内容和程序的标点符号冲突
   比如: &quot;来自\&quot;新华社\&quot;的消息&quot;
 2. 表示特殊意义: \n换行  \t 制表符  \u unicode编码的一个字符
   比如: &quot;\u4e00&quot; 表示汉字&quot;一&quot;
 特殊: 路径:&quot;c:\window\temp&quot;
   问题: 1. 查找不到\w，就擅自去掉\，就保留w
        2. \t误翻译为制表符
   解决: 1. 字符串中所有作为正文的\，都必须写为\\
     如果是路径: 2. 所有路径中的\必须都换位/
        &quot;/imgs/products/product01-s.jpg&quot;
boolean:
什么是: 只有两个值true/false的数据类型
何时: 经常用作表示判断的结果
如何: 只要不加引号的true/false,自动就保存为bool类型
undefined:
什么是: 专门表示一个变量声明后暂时未赋值
何时: 不会主动使用
      都是js程序自动为变量赋初值之用
经常用于判断变量赋值错误。
null:
什么是: 专门用于清空一个变量的特殊值
何时: 如果一个变量中的值不想要了，可将变量赋值为null
经常用于程序员主动清空变量
</code></pre><p>4、 数据类型转换:</p>
<pre><code>弱类型: 1. 声明变量时不必提前指定变量的数据类型
       2. 同一个变量先后可保存不同类型的数据
       3.  js引擎会根据自身的需要隐式自动转换数据的类型
优: 为程序员省事
缺: 混乱, 转换的结果也不一定是想要的。
解决: 如果数据类型不是想要的，就需要类型转换
包括: 隐式转换和强制转换
  隐式转换: 程序根据自身的需要，自动完成的数据类型转换
            无需程序员干预
       何时: 伴随运算和判断自动执行。
  强制转换: 程序员主动调用功能，执行的数据类型转换
       何时: 如果隐式转换的结果还不是想要的，就要强制转换
隐式转换: 暂时只以算数计算中的隐式转换为例
  算数计算:
      默认: 一切转为数字(number)类型，再计算
               bool:  true 转为1   false  转为0
        因为: 只有数字类型才最适合算数计算
      特殊: +运算中，只要碰到一个字符串，另一个也被转为字符串，+法计算，变为字符串拼接。
        因为: 开发中字符串拼接使用非常频繁，所以为了简化字符串拼接，就用+代替。

练习: 强调: 凡是从页面上获得的数据，都是字符串类型
            不可能从页面上直接获得number和bool类型
   问题: 字符串参与+运算，不再做加法计算，而改为字符串拼接
         隐式转换不是想要的
   解决：凡是从页面上获得的字符串，要参与算数计算，必须先强制转为数字类型，再计算。

强制转换: 3种:
  转数字: 2种:
    何时: 今后只要参与算数计算的非数字类型，都要先转数字再计算
    1. 将纯数字字符串或布尔类型转为数字: Number(x)
      其实，隐式转换中，转数字，用的都是Number(x)
      特殊: Number(null/&quot;&quot;) =&gt; 0   Number(undefined) =&gt; NaN
      问题: CSS中样式属性都是带单位，Number不能转换包含非数字字符的字符串。
      现象: 如果Number无法转换，就返回NaN
      什么是NaN: 一个特殊值，表示所有非数字的数据
             Not a Number
           何时: 不会主动使用，只在无法转为数字时，自动返回。
           NaN参与任何算数计算，结果依然为NaN
      解决:
    2. 将带单位的字符串，去单位后，转为数字:
      parseFloat(str) :
        原理: 从第一个字符开始，读取字符串中每个字符
              碰到第一个非数字字符就停止
        坑: parseFloat(true) =&gt; parseFloat(&quot;true&quot;) =&gt; NaN
        说明: 只能去掉结尾的非数字字符，不能去掉开头的非数字字符
      parseInt(str): 原理同parseFloat,只不过，不认识小数点
             结果: 省略小数部分,转为整数
      开发中: 首选parseFloat，除非确实需要去掉小数部分时，采用parseInt
  转字符串: 2种:
    何时: 今后，只要查看一个复杂数据结构中的内容时，就可将复杂的数据结构转为字符串再输出。
    1. x.toString(); 将除null和undefined之外的任意数据，转为字符串
       无法转null和undefined，报错！
    2. String(x); 万能！将任意x数据，转为字符串
    总结: 今后，只要转字符串，就用String(x)
    固定用法: 进制转换:
      1. 如果查看十进制数字的2,8,16进制结果，可用toString(n)
      2. 将其他进制转回十进制: parseInt(&quot;num&quot;,进制)
  转布尔: Boolean(x)
    结论: 只有5个值被转为false:  0, NaN, null, undefined, &quot;&quot;
      将来判断中只要见到这五个值，就等同于false
          其余都转为true
</code></pre><p>5、 运算符和表达式:</p>
<pre><code>什么是程序: 人的想法在计算机中的执行
什么是运算符: 程序中模拟人的想法的特殊符号
什么是表达式: 又数据，变量和运算符组成的一条程序语句

包括:
算数计算: +, -, *, /, %
 %模运算(取余数): m%n m除以n，不取商，取除不尽的余数部分
  何时: 1. 取零头
       2. 限制计算的结果不能超出一个最大值
 隐式转换:
   默认: 一切都转为数字, 布尔(true: 1, false: 0)
     如果转不了，返回NaN，NaN参与任何计算，结果还是NaN
   特殊: +运算, 只要碰到字符串，就都转为字符串，+法计算变为字符串拼接
 舍入误差: 计算机中也有计算不尽的小数
     解决: 1. 存储: 尽量多的保留小数位数, 比如: 8位或9位
          2. 显示: 按指定小数位数四舍五入
                   n.toFixed(2) 将n按2位小数四舍五入
             今后，只要显示钱数，都要toFixed(2)

关系运算: 做比较做判断
  包括: &gt;  &lt;   &gt;=   &lt;=   ==  !=
  返回值: 一定返回bool: true/false
  隐式转换:
    默认: 都转为数字比较大小
      如果转不了，返回NaN，
      NaN做比较: 不大于,不小于,不等于任何值
                  NaN不等于一切
    特殊:
     1. 两个字符串作比较: 不再转数字
            而是依次比较每个字符的unicode号大小
        unicode范围: 数字: &quot;0&quot;-&quot;9&quot;  48~57
                          &quot;A&quot;-&quot;Z&quot;  65~90
                          &quot;a&quot;-&quot;z&quot;  97~122
     2. NaN: 问题: 用普通的==无法鉴别一个值是否是NaN
                因为NaN不等于一切，甚至NaN==NaN 返回false
            解决: 今后只要判断NaN，必须用专门的isNaN(num)
        扩大用途: 可用isNaN来判断一个数据是否是数字或是否可当做数字使用
     3. null和undefined:
       问题: 关系运算中，自动将undefined隐式转为null，再比较
       解决: 全等=== 首先类型相同，其次值相等
                相当于不带隐式转换的==比较
                优: 严格，避免不必要的隐式转换
                缺: 必须自己手动转换数据类型，再比较
           不全等!==  全等的反义词
       何时使用===: 今后只要不希望比较时，自动隐式转换，就可用===代替==

逻辑运算: 将多个关系运算综合起来，得出一个最终结论
         其实还是做比较和做判断
包括: &amp;&amp;  ||   !
  &amp;&amp;: 而且
   如何使用: 条件1&amp;&amp;条件2&amp;&amp;....
       何时: 只要必须满足多个条件时，就使用&amp;&amp;
  ||: 或者/要么
   如何使用: 条件1||条件2||....
       何时: 多个条件，只要满足其一即可
  !: 颠倒一个判断结果: !true=&gt;false  !false=&gt;true
  返回结果: 依然是bool类型: true/false
  隐式转换: 将每个条件自动转为bool类型
  短路逻辑: 只要前一个条件已经可以得出最终结论，则后续条件不再执行
    &amp;&amp;: 只要前一个条件为false，则后续所有条件不再执行
    ||: 只要前一个条件为true，则后续条件不再执行
    鄙视: 见9_logic
   利用短路: 不再关心逻辑运算的返回值
     利用&amp;&amp;短路: 实现简单分支结构:
         一个条件，一件事儿，满足条件才执行，不满足就不执行
         如何: 条件&amp;&amp;(操作)
     利用||短路: 实现默认值
         如何: var 变量=值1||默认值
           如果值1有效: 不是0,null,undefined,NaN,&quot;&quot;，就使用值1
              否则，使用值2
练习: 运算符优先级:

位运算: 用二进制移动位置
 1. 左移/右移:
    左移: m&lt;&lt;n  读作m左移n位: 相当于m*  2的n次方
      比如: 1&lt;&lt;2=4   1&lt;&lt;3=8 (不用位运算: 1*Math.pow(2,3))
    右移: m&gt;&gt;n  读作m右移n 位: 相当于m/  2的n次方
      比如: 4&gt;&gt;2=1   8&gt;&gt;3=1
 2. 取整:
   m^0  m&gt;&gt;&gt;0   m|0
 3. 不声明第三个变量，而交换两个变量的值，共有几种方法:
   方法一: a+=b; b=a-b; a-=b
   方法二: a^=b; b^=a; a^=b
   问题: +和^运算只能计算数字，所以以上两种方法只能交换数字类型

赋值运算:
 扩展赋值运算: 对普通赋值运算的简写:
   a=a+b 可简写为: a+=b 也称为将b累加到a中
   a=a-b  可简写为: a-=b
   a=a*b  可简写为: a*=b
   a=a/b  可简写为: a/=b
   a=a%b  可简写为: a%=b
 更简写: 等b始终等于1时:
   a+=1 可简写为a++，也称为递增
   a-=1 可简写为a--，也称为递减
 前++和后++:  a++ 和 ++a
   相同: 无论前++还是后++，a中的值都被+1
   不同: a++返回+1之前的&quot;旧&quot;值
          何时: 只要希望先用旧值做操作，然后再加一
        ++a返回+1之后的&quot;新&quot;值
          何时: 只要希望先加一，再用新值做操作
 鄙视题:
   var n=3;
   n++ + ++n + n++;
  //?  +  ? +  ?
   //++n + n++ + ++n;
   n=6
   提示: 所有表达式都是从左向右依次执行
         先执行的会影响后执行的
</code></pre><p>5、 函数:</p>
<pre><code>什么是函数: 封装一项任务的步骤清单的代码段，再起一个名字。
为什么: 代码重用！
何时: 只要一项任务，可能被反复使用，都要将任务的代码定义为一个函数，再反复使用函数。
如何:
声明:
 function 函数名(参数1,参数2,...){
   函数体;
   return 返回值;
 }
 参数: 保存一项任务必须的数据的变量
  参数其实就是变量，只不过不用var声明, 用逗号分隔多个参数变量
  参数变量只能在函数内使用
  何时: 只要一项任务必须某些数据才能正常执行时
  为什么: 让函数变的更灵活
 函数体: 就是执行任务的步骤清单的代码段
 返回值: 任务的执行结果
  何时: 如果使用函数的人希望获得函数的执行结果时

调用: 让引擎按照函数的步骤执行任务
  强调: 任何函数，只要不调用！就不执行！
        只有调用才执行函数中的代码段
  如何: var 变量=函数名(参数值1,参数值2,...)
    其中:
      参数值: 传递给函数参数变量的执行任务必须的数据
        强调: 参数值的顺序，个数和定义函数是参数变量的顺序和个数保持一致。
      返回值: 除非定义函数时，内部定义了return 返回值，才有必要用变量保存住函数的执行结果。
</code></pre><p>6、 函数的原理:</p>
<pre><code>存储:
 函数名其实就是一个普通的变量
 函数本身是一个引用类型的对象(保存多个数据的复杂数据结构)
 函数名通过函数的地址值，引用函数对象
强调: 声明时，不会执行函数的内容。
调用:
  1. window中声明变量，准备保存函数的返回值
  2. 找到函数对象，创建函数执行时的临时存储空间
  3. 将调用时传入的参数值，放入临时存储空间的参数变量中
  4. 执行函数体，修改临时存储空间中的变量值
  5. 将返回值，返回window中，保存到指定变量
  6. 函数执行后，临时存储空间释放！导致，函数内局部变量一同释放
  所以: 函数中的参数变量和var的变量，只能在函数调用时，内部使用，出了函数，无法使用。
</code></pre><p>7、 作用域(scope): 一个变量的可用范围</p>
<pre><code>包括: 2种:
 1. 全局作用域: window
    特点: 始终存在
    全局变量: 直接保存在window中的变量
        特点: 可重复使用，随处可用
    何时: 如果希望一个变量可反复使用，可随处使用时
 2. 函数作用域: Actived Object(AO 活动对象)
    特点: 仅函数调用时存在，调用后就释放了！
    局部变量: 保存在函数作用AO中的变量
        特点: 不可重用，仅函数调用时，函数内可用
    何时: 如果希望变量仅在函数内可用时

 调用函数时，变量的使用顺序: 优先使用局部变量
                              只要局部有，就不用全局的
                              如果局部没有，会去全局找
 判断函数是否包含局部变量: 2种: 1. 参数变量; 2. 函数内var的变量
</code></pre><p>8、 循环:</p>
<pre><code>什么是: 让程序反复执行相同代码段
何时: 只要让程序反复执行同一任务
三要素:
  1. 循环条件: 让循环可以继续执行的条件
  2. 循环变量: 循环条件中用作判断和比较的变量
      循环变量的值，每循环一次，都要向着不满足循环条件的趋势不断变化。
      如果循环变量值不变，或循环条件始终为true，循环无法退出——死循环。
  3. 循环体: 反复执行的代码段
如何: 3种:
 1. while循环:
   声明并初始化循环变量;
   while(循环条件){
     循环体;
     修改循环变量的值;
   }
  当循环条件和逻辑非常复杂时:
    1. 使用while(true), 不用预设循环条件，也能先进入循环再说
    2. 循环体中，根据条件，手动退出循环: break;
 2. do while循环: 其实就是有一次试用机会的while循环
  声明并初始化循环变量;
  do{
     循环体;
     修改循环变量的值;
  }while(循环条件); //强调: 结尾必须有分号!
  vs while:
    如果第一次循环条件都满足，则while和do while完全等效
    如果第一次循环条件不满足，则while是一次都不执行
                                 do while至少可以执行一次
 3. for循环: 就是循环变量的变化有规律的while循环
  for(声明并初始化循环变量;循环条件;修改循环变量的值){
     循环体;
  }
  总结: 循环变量要考虑三件事:
         1. 从几开始;  2. 每次递增/减几;  3.到几结束
  for循环的简写:
   1. for的第一部分: 可同时声明并初始化多个变量:
      强调: js语言没有块级作用域: if(){}  while(){}  for(){}都不是作用域。其中的变量，在块{}外，依然可用。
           只有function(){}才是作用域
         vs Java: 有块级作用域。if(){}  while(){}  for(){}都是块级作用域。其中的变量出了块{}，就无法使用。
   2. for的第三部分: 可同时执行多个短小的表达式，用逗号分隔
      简写不能改变原程序的执行顺序
 简写: 其实if else else if while for之后如果只有一句话,都可省略大括号

 循环嵌套:
      什么是: 在一个循环内，又执行了另一个循环
</code></pre><p>8、数组:</p>
<pre><code>什么是: 内存中连续存储多个数据的存储空间，再起一个名字
为什么: 便于批量管理和操作多个相关的数据
何时: 今后，只要存储多个相关的数据，都要放在数组中
程序=数据结构+算法
  好的数据结构可极大提高程序的执行效率
如何:
 创建: 3种:
   1. 创建空数组: var arr=[];
                 var arr=new Array();
       何时: 如果创建数组时，暂时不知道数组的内容
   2. 创建数组时就初始化数组内容: var arr=[值1,值2,...]
                                 var arr=new Array(值1,值2,...)
       何时: 如果创建数组时，已经知道数组的内容
   3. 创建n个空元素的数组: var arr=new Array(n);
       何时: 如果创建数组时，已知数组的元素个数，但暂时不知道内容时。
 访问数组元素:
   数组中每一个数据称为一个元素
   下标(index): 数组中唯一标示一个元素存储位置的序号
     从0开始，默认连续不重复
       索引数组: 下标都是数字序号的数组
     每个元素都有其对应的下标
   访问数组元素: arr[i]
     每个数组元素的用法和普通变量完全一样!
     所以，数组也称为一组连续的变量的集合，共用同一个变量名
   特殊: 3个:
     1. js数组不限制元素的数据类型
     2. js数组不限制下标越界
        赋值: 如果下标越界，不报错，会自动在新位置创建新元素保存数据。
          稀疏数组: 下标不连续的数组
        取值: 如果下标越界，不报错，会返回undefined
     3. js数组不限制元素的个数
数组的length属性:
   属性: 保存在对象中的一个变量
       访问属性: arr.length  属性的用法和普通变量完全一样
       强调: 访问length必须用arr. ，其中.读作&quot;的&quot;
   length属性，记录了数组中理论上的元素个数。
        还可修改元素个数: arr.length-- ; 相当于数组容量-1，最后一个
     length属性始终等于最大下标+1
     length属性始终标记着最后一个元素之后的下一个新位置
   固定套路:
    1. 向数组末尾追加一个新元素: arr[arr.length]=新值;
    2. 获取数组最后一个位置的元素: arr[arr.length-1]
       获取数组倒数第n个元素: arr[arr.length-n]
    3. 删除末尾的n个元素: arr.length-=n;

数组是引用类型的对象:
 按值传递: 两变量间赋值或将变量传递给函数作为参数时，其实仅是将原变量中的值复制一个副本给对方。
     原始类型: 修改新变量，不影响原变量的值
     引用类型: 用新变量修改对象，等效于直接修改原对象，原变量同样受影响。

垃圾回收:
什么是: 引擎会自动释放不再被任何变量引用的对象
垃圾回收器: 专门释放不再被使用的对象的小程序
  垃圾回收器，伴随主程序执行而执行，会自动回收不再使用的对象
原理:
  每个对象都有一个引用计数器count: 记录该对象被几个变量引用着。
     每多一个变量引用对象，count就+1，每当一个变量不再引用该对象时，count就-1。
  垃圾回收器会定时检查每个变量的引用计数器。
  如果对象的引用计数器为0，垃圾回收器会自动回收该对象。
建议: 如果使用一个较大的对象后，应该尽快主动释放: 赋值为null
</code></pre><p>9、遍历数组:</p>
<pre><code>什么是: 依次访问数组中每个元素，并对每个元素执行相同的操作。
何时: 只要对数组中每个元素执行相同操作时
如何: 固定套路:
  for(var i=0; i&lt;arr.length;i++){
    arr[i] //当前正在遍历的元素
  }
</code></pre><p>10、关联数组:</p>
<pre><code>什么是: 下标可自定义名称的数组
为什么: 索引数组的下标是无意义的数字，不便于快速定位想要的元素
       如果可给每个元素起一个有意义的名字，就可用名称，快速定义想要的元素
何时: 只要希望使用名称，快速定位想要的元素时
如何定义: 2步:
  1. 先定义空数组: var ym=[];
  2. 向空数组中添加新元素，下标使用自定义的名称字符串
     ym[&quot;name&quot;]=&quot;杨幂&quot;;
     ym[&quot;math&quot;]=81;
     ym[&quot;chs&quot;]=59;
     ym[&quot;eng&quot;]=89;
  如何访问关联数组的元素: ym[&quot;下标名称&quot;]
遍历关联数组:
  问题: 关联数组的下标都是自定义的字符串:
        导致: 关联数组length属性失效，始终为0
             导致: for(var i=0;i&lt;arr.length;i++) 中i和lenght都不能用了
  解决: for(var key in ym){
        //in会自动依次取出关联数组中每个元素的下标名称，保存到变量key中。
         //要想进一步获得每个元素值: ym[key]
             //强调: key是变量，不要加&quot;&quot;
       }
</code></pre><p>11、 数组API:</p>
<pre><code>数组转字符串: 2种:
  1. String(arr): 将每个元素都转为字符串，然后用逗号连接
  2. arr.join(&quot;连接符&quot;):将每个元素都转为字符串，可自定义连接符
    固定套路: 1. 将字符数组，拼接为单词——无缝拼接: arr.join(&quot;&quot;)
             2. 动态生成页面元素的内容:
拼接和选取:
 拼接: var newArr=arr1.concat(值1,值2,arr2,...);
   强调: 1. 不修改原数组，而是返回新数组
        2. 将另一个数组作为参数，则首先打撒数组为单个元素，再分别拼接。
 选取: 复制出原数组中开始位置到结束位置之前的元素组成临时子数组
   如何: var subarr=arr.slice(starti,endi+1);
   强调: 1. 不修改原数组，仅复制指定位置的元素，组成新的临时数组
        2. 凡是两个参数都是下标的函数，都含头不含尾
   简写: 1. 省略第二个参数: 从starti位置开始选取所有剩余元素
        2. 两个参数全省略: 复制一个数组
        3. 支持负数参数: 表示倒数第n个
           何时: 只要位置离结尾近时
            arr.slice(-n)等效于: arr.slice(arr.length-n)
修改数组: splice，删除，插入，替换
  删除: arr.splice(starti,n)删除arr中starti位置开始的n个元素
    强调: 1. 直接修改原数组
    简写: 1. 省略n : 表示删除starti之后所有剩余元素
         2. starti支持负数参数: 表示倒数下标
    其实: splice是有返回值的: 被删除的元素组成的临时数组
        var deletes=arr.splice(starti,n);
  插入: arr.splice(starti,0,值1,值2,....) 在arr中starti位置插入值1,值2,...
    强调: splice不能打散数组参数，后果，将数组作为一个整体保存在一个元素中——形成二维数组
   vs concat: 1. concat不修改原数组，而是返回新数组
              splice 直接修改原数组
            2. concat会打散数组参数，单个元素拼接
              splice 不打散数组参数，将数组整体插入到一个元素中
            3. concat只能在数组结尾拼接
              splice 可插入到任何位置
  替换: 先删除，再插入
    arr.splice(starti,n,值1,值2,...)
    强调: 删除的元素个数和插入的新元素个数不必相同
</code></pre><p>12、 排序: arr.sort()</p>
<pre><code>原理: 默认将所有元素，临时转为字符串，再按字符串，升序排列
问题1: 只能按字符串类型升序排列
解决: 比较器函数:
  什么是: 比较任意两数大小的函数
  何时: 只要按数字类型排序时，都要定义比较器函数
  如何: 2步:
   1. 定义比较器函数: function compare(a,b){return a-b;}
   2. 将比较器函数作为sort函数的参数传入:
         arr.sort(compare)
  强调: 将比较器函数作为sort的参数时，不加()
问题2: 按数字降序排列:
解决: 颠倒比较器结果的正负号
  如何: function compare(a,b){return b-a;}
</code></pre><p>13、 栈和队列:</p>
<pre><code>今后，只要必须按一定的顺序使用数组元素时
js中没有专门的栈和队列结构，都是用普通数组模拟的
栈(stack): 一端封闭，只能从另一端进出的数组
特点: FILO 先进后出
  如何: 2种:
    1. 结尾出入栈:
       入: arr.push(值) 代替 arr[arr.length]=值
       出: var last=arr.pop();
    2. 开头出入栈:
       入: arr.unshift(值)
       出: var first=arr.shift()
    强调: 开头入栈的结果和结尾入栈的结果刚好是颠倒的
队列(queue): 只能从一头进入，从另一头出的数组
特点: FIFO
  如何: 结尾入: arr.push(值); 开头出: var first=arr.shift()
</code></pre><p>14、 二维数组:</p>
<pre><code>什么是: 数组中的元素又引用了另一个子数组
何时: 1. 在大数组中，对内部元素，进行更细致分类时
     2. 保存横行竖列的二维数据时
如何:
  创建: 2种
    1. 先创建空数组，再向数组中添加子数组
       var arr=[];
       arr[0]=[0,0,0,0];
       arr[1]=[0,0,0,0];
    2. 创建数组同时，就初始化子数组:
       var arr=[
        [0,0,0,0],//0 \n
        [0,0,0,0],//1 \n
        [0,0,0,0],//2 \n
        [0,0,0,0] //3
       ]
  访问元素: arr[r][c] 二维数组中每个元素的用法和普通数组元素的用法完全一样!
    强调: 访问二维数组: 列下标越界，不报错，返回undefined
                        行下标越界，报错！
  遍历: 外层循环控制行，内存循环控制列
    for(var r=0;r&lt;arr.length;r++){
      for(var c=0;c&lt;arr[r].length;c++){
         arr[r][c] //当前正在遍历的元素
      }
    }
</code></pre><p>15、String</p>
<pre><code>什么是: 一串字符组成的字符数组
  vs 数组: 相同: 1. 下标
                2. .length
                3. slice
          不同: 类型不同: String不能使用数组类型的API
                   因为String是只读的字符数组
内置对象: ES标准中规定的，浏览器厂商已经实现的类型
  包括11个:
    String Number Boolean ——包装类型
    Array Date RegExp Math
    Error
    Function Object
    Global(在浏览器中被window代替)
包装类型:
什么是: 专门封装原始类型的值，并提供操作原始类型值的API 的对象
为什么: 原始类型的值本身不具有任何功能
        如果要对原始类型的值做操作，必须有其他工具的辅助
何时: 只要希望对原始类型的值执行操作时
如何: 不用自己使用。都是自动调用。
  原理: 浏览器中内置了3种包装类型的对象，一一对应一种原始类型:
     String   Number  Boolean
     每种包装类型，都能够保存一个原始类型的值，并已经预定义了操作原始类型值的现成API
     当试图对原始类型的值调用函数时，引擎首先判断原始类型值的类型名，根据类型名，创建对应的包装类型的对象，保存原始类型的值。再调用包装类型对象预定义好的方法。
     任务执行完，包装类型对象自动释放。
</code></pre><p>16、String API:</p>
<pre><code>大小写转换: 将一个字符串中的字母统一都转为大写/小写
 何时: 只要不区分大小写时，都要先转为统一的大小写，再判断和比较
       比如: 验证码,
 如何: str.toUpperCase();
      str.toLowerCase();
获得指定位置的字符:  str.charAt(i) =&gt; str[i]
获得指定位置字符的unicode号: var uncode=str.charCodeAt(i);
    从unicode号转回字符: var char=String.fromCharCode(unicode);
获得子字符串:
  str.substring(starti,endi+1) =&gt; str.slice(starti,endi+1)
   强调: substring用法和slice几乎完全一样
        唯一的差别: substring不支持负数参数 =&gt; 可用length-n代替
  str.substr(starti, n) 选取str中starti位置开始的n个字符
</code></pre><p>17、 查找: 在一个字符串中查找指定关键词出现的位置</p>
<pre><code>4种:
1. 查找一个固定的关键词出现的位置:
  var index=str.indexOf(&quot;关键词&quot;,fromi);
    在str中查找fromi 位置后的下一个&quot;关键词&quot;出现的位置
    省略fromi: 默认从头开始查找
  强调:1. 每次只找一个
       2. 如果找不到，返回-1
  var lastIndex=str.lastIndexOf(&quot;关键词&quot;);
    查找str中最后一个&quot;关键词&quot;的位置
 问题: 关键词稍微一变化，就找不到
   比如: 我操, 我草，我艹，卧槽
 解决: 用正则表达式模糊查找:
2. 判断是否包含指定关键词(支持正则):
 var i=str.search(/正则表达式/);
  在str中找符合正则表达式要求的敏感词的位置
  返回值: 返回第一个找到的敏感词的下标
           如果没找到返回-1。
  问题: 正则表达式默认都是区分大小写的
  解决: 第二个/后加后缀i: ignore 忽略大小写
  缺: 1. 永远只能找第一个
     2. 只能返回位置，无法返回关键词内容。
3. 获得所有关键词的内容:
  var kwords=str.match(/正则表达式/ig);
   查找str中所有和正则表达式匹配的关键词内容
   返回值: 包含所有关键词内容的数组
        如果没找到，返回null!
   问题: 正则表达式默认仅匹配第一个关键词
   解决: 第二个/后加后缀g: global 全部
   缺: 仅返回关键词的内容，无法返回每个关键词的位置
   解决:
4. 即查找每个关键词的内容，又查找每个关键词的位置:
</code></pre><p>18、 替换: 将找到的关键词替换为指定的新字符</p>
<pre><code> 简单替换: 将所有敏感词都替换为统一的新值:
   str=str.replace(/正则/ig,&quot;替换值&quot;);
   强调: 所有字符串API都无权修改原字符串，只能返回新字符串
 高级替换: 根据不同的关键词，动态选择替换不同的值
   str=str.replace(/正则/ig,function(kw){
     return 根据本次kw的不同，动态决定返回何种替换值
   });
 删除: 其实就是将敏感词替换为&quot;&quot;

分隔: 按指定的字符，将字符串分割为多段子字符串
  var arr=str.split(&quot;固定的分隔符&quot;|/正则表达式/);
    返回值: 切割后的子字符串组成的数组
    强调: 切割后的结果中，不包含切割符本身
    固定套路: 将字符串打散为字符数组: var chars=str.split(&quot;&quot;);
</code></pre><p>19、正则表达式:</p>
<pre><code>什么是: 规定一个字符串中字符出现规律的规则
何时: 2种:
  1. 使用规则模糊查找多种关键词
  2. 表单中验证输入项的格式
如何:
  1. 最简单的规则，就是关键词原文:
  2. 字符集:
    什么是: 规定一位字符备选字符列表的集合
    何时: 如果关键词中某一位字符有多种备选时
    如何: [备选字符列表]
      强调: 1. 一个字符集[]，包含的字符再多，也只能匹配1位
           2. 不能不选
    简写: 如果备选字符列表中部分字符是连续的，可用-省略中间字符
      常用字符集:
        [0-9] 1位数字;
        [a-z] 1位小写字母; [A-Z] 1位大写字母
        [A-Za-z] 1位字母
        [A-Za-z0-9] 1位字母或数字
        [\u3e00-\u9fa5] 1位汉字
    特殊: 除了xxx  [^xxx]
  3. 预定义字符集: 4个
    \d  1位数字: [0-9]
    \w  1位字母,数字或下划线: [A-Za-z0-9_]
    \s   1位空白字符: 空格 制表符...
    .    1位任意字符
  问题: 只能匹配固定字符个数的关键词
  解决: 量词:
  4. 量词:
    什么是: 规定一位字符集出现次数的规则
    何时: 只要规定一位字符集出现的次数
    如何: 2种:
      1. 有明确个数限制: 3种
        字符集{m,n} 至少出现m次，最多n次
        字符集{m,}  至少出现m次，多了不限
        字符集{m}   必须m位，不能多也不能少
      2. 没有明确个数: 3种:
        字符集?    可有可无，最多1个
        字符集*    可有可无，多了不限
        字符集+    至少一个，多了不限
     问题: 一个量词只能修饰紧邻的前一个字符集
     解决: 分组
   5. 选择和分组:
     分组: 用()将多个字符集，分为一组
       何时: 希望量词同时修饰一个分组内的多个字符集时
     选择: 或  规则1|规则2
       只要匹配任意一个规则即可

   身份证号:  15位数字 2位数字 1位数字或Xx
                \d{15}  (  \d\d      [0-9Xx] )    ?
                        后三位整体可有可无，最多1次
   手机号: +86或0086   可有可无，最多1次
          空字符        可有可无，多了不限
          1
          3,4,5,7,8中任选一个
          9位数字
     (\+86|0086)?\s*1[34578]\d{9}

   微信  微 信 wei xin  w x  wechat
   (微|w(ei)?)\s*(信|x(in)?)

   6. 指定匹配位置: 3个特殊位置:
     ^字符串开头 比如: 开头的空字符: ^\s+
     $字符串结尾 比如: 结尾的空字符: \s+$
        开头或结尾的空字符: ^\s+|\s+$
     \b 单词边界: 开头, 结尾, 空字符, 标点符号...
</code></pre><p>20、 RegExp: (Regular Expression)</p>
<pre><code>什么是: 封装一个正则表达式，并提供使用正则表达式执行验证和查找功能的API的对象
何时: 2种:
  1. 格式验证:
  2. 即查找关键词内容，又查找关键词位置:
如何:
  创建: 2种:
   1. 创建一个固定的正则表达式: var reg=/正则/ig;
       字符冲突: 两/之间如果再包含/，需要将内部的/转为\/
         比如: /&lt;\/option&gt;/
   2. 动态生成一个正则表达式:
      var reg=new RegExp(&quot;正则&quot;,&quot;ig&quot;);
       字符冲突: &quot;&quot;之间如果包含\和&quot;, 都要变为\\和\&quot;
         比如: new RegExp(&quot;\\d{6}&quot;,&quot;ig&quot;)
  验证格式:
    var bool=reg.test(str); 验证str是否符合reg的规则要求
    问题: 正则表达式默认只要包含就算匹配
    解决: 今后，凡是验证，必须前加^，后加$，表示从头到尾完全匹配
  查找关键词: 即查找所有关键词内容，又查找位置:
    var arr=reg.exec(str); 在str中查找符合reg要求的下一个关键词的位置和内容保存在数组arr中
      返回值: arr: [0: 关键词,  &quot;index&quot;: 下标 ]
      强调: 1. reg.exec可自动从本次查找位置开始执行下一次查找。但是需要循环推动。
           2. 要想找所有，reg也必须加g
</code></pre><p>21、 Math:</p>
<pre><code>什么是: 专门封装算数计算的常量和函数的对象
强调: 不能new！所有API都通过大写Math直接调用
API:
  1. 取整: 3种:
   上取整: Math.ceil(num)
   下取整: Math.floor(num)
     vs parseInt(str): 类型转换: Math.floor只能对纯数字的内容下取整
                             parseInt 可去掉结尾非数字单位
   四舍五入取整: Math.round(num)
     vs n.toFixed(d):
       1. round只能取整, toFixed可按任意小数位数四舍五入
       2. 返回值: round返回数字，可直接做计算
                 toFixed返回字符串，做+运算前必须强转为数字
     自定义四舍五入:
  2. 乘方和开平方:
      Math.pow(底数,幂) 比如: Math.pow(10,2) =&gt;10的2次方=&gt;100
      Math.sqrt(num) 比如Math.sqrt(9)=3
  3. 最大值和最小值:
     Math.max/min(值1, 值2,....)
     强调: 不支持获得数组中的最大/最小值
     解决: Math.max.apply(null,arr);
  4. 随机数:
       Math.random()   返回0~1之间的一个随机小数0&lt;=r&lt;1
       公式: 在任意min~max之间取一个随机整数:
       parseInt(Math.random()*(max-min+1)+min)
       简化: 从0~n之间生成一个随机整数
       parseInt(Math.random()*(n+1))
</code></pre><p>22、Date:</p>
<pre><code>什么是: 封装一个时间，并提供操作时间的API的对象
何时: 只要存储时间或计算时间
如何:
  创建: 4种:
   1. 创建日期对象，同时获得客户端当前系统时间:
       var now=new Date();
   2. 创建日期对象并保存自定义时间:
       var date=new Date(&quot;yyyy/MM/dd hh:mm:ss&quot;)
               new Date(yyyy,MM-1,dd,hh,mm,ss)
   3. 使用毫秒数创建日期对象:
     日期对象的原理: 日期对象中保存的是一个毫秒数
                     起点: 1970年1月1日至今
       为什么: 毫秒数不受时区影响。
       惯例: 在跨国系统中存储时间，不要使用字符串
             而要使用毫秒数。
     何时: 只要将存储的毫秒数，转化为日期对象时
     如何: var date=new Date(ms);
   4. 复制一个日期对象:
     为什么: 日期计算时，都是直接修改原日期对象
             无法同时保存计算前后的两个时间
     何时: 只要希望同时保存计算前后的两个时间
           就要在计算前，将起始时间复制一个副本，再用副本计算截止时间。
     如何: var date2=new Date(date1);
</code></pre><p>  23、 日期API:</p>
<pre><code>8个单位: FullYear   Month   Date    Day  没有s结尾
         Hours    Minutes  Seconds  Milliseconds
1. 每个单位都有一对儿get/set方法:
  其中getXXX()负责获取指定单位的值
      setXXX()负责设置指定单位的值
   比如: date.getDate() //获得date中的日期
        date.getHours() //获得date中的小时
        date.setDate(20) //将date中的日期设置为20号
        date.setHours(11) //将date中的小时设置为11点
   特例: Day没有set方法，因为星期几是通过换算得到的，不能人为修改。
2. 返回值/取值范围:
  FullYear  年份该是多少就是多少
  Month  0~11  计算机中保存的月份比现实中小1
  Date    1~31
  Day     0~6
  Hours   0~23
  Minutes/Seconds  0~59
</code></pre><p>   24、 日期计算: 2种:</p>
<pre><code>  1. 两日期对象可相减,结果是毫秒差:
     何时: 计算倒计时或时间差
  2. 对任意单位做加减: 3步:
    简写: date.setDate(date.getDate()+/-n)
      比如: 当前时间+30天
        now.setDate(now.getDate()+30) //52
            当前时间-2个月
        now.setMonth(now.getMonth()-2)
    问题: setXXX会直接修改原日期对象，旧时间无法保存
    解决: 先将起始时间复制一个副本，再用副本计算截止时间
日期转字符串:
  String(date) 将date转为当地时间的完整日期格式
  date.toLocaleString() 转为当地时间的简化版格式
  date.toLocaleDateString() 仅保留日期部分
  date.toLocaleTimeString() 仅保留时间部分
  date.toGMTString()  转为国际标准时间(0时区)
</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;JavaScript&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;什么是JavaScript: 专门编写网页交互行为的语言
为什么: HTML和CSS是静态语言，编写静态内容，无法编写逻辑，无法执行计算。
何时: 今后所有静态网页必须使用JavaScript添加上交互行为，才能让用户使用
    
    </summary>
    
      <category term="学习笔记" scheme="www.wangchengzou.cn/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="javaScript" scheme="www.wangchengzou.cn/tags/javaScript/"/>
    
  </entry>
  
  <entry>
    <title>Angular基础知识</title>
    <link href="www.wangchengzou.cn/2017/07/22/Angular/"/>
    <id>www.wangchengzou.cn/2017/07/22/Angular/</id>
    <published>2017-07-22T15:48:26.000Z</published>
    <updated>2017-07-23T14:55:42.834Z</updated>
    
    <content type="html"><![CDATA[<p>1、设计原则和设计模式</p>
<pre><code>拙劣的设计：
①僵化
②脆弱
③不必要的复杂
④晦涩。。

1、YAGNI（不要写不需要的代码）
you aren&apos;t gonna need it

2、KISS （越简单越好）
keep it simple and stupid
语义化的标记、命名规则、减少嵌套

3、DRY（善于使用封装和重用）
Don&apos;t Repeat Yourself

4、高内聚 低耦合（High cohesion,low coupling）
内聚：一个组件（模块）内部的不同部分的关系
耦合：不同组件（模块）之间的关系

5、SRP 单一责任原则
Single Responsibility Principle
实现功能的时候，尽可能的做到每一个模块实现一个单一的功能

6、OCP原则(对于扩展开放、对于修改关闭)
open close principle

7、LCP（迪米特法则）
Least Knowledge Principle 最少知识法则：封装的功能单位要尽可能的小，尽量做到只与自己相关

常用的设计模式分为3大类：①创建 ②结构 ③行为

常用的设计模式：工厂方法模式、单例模式、组合模式、迭代子模式、适配器。。
先去实现功能，在迭代的过程中优化代码。
</code></pre><p>2、AngularJS</p>
<pre><code>认识新东西最好的方式：
①官网
②维基百科 wikipedia.org
what?--ng(AngularJS)是一个开源的js框架
where？--用来实现SPA应用程序（单一页面应用程序single page application）
Gmail邮箱是由Google退出的前端历史中第一个SPA应用
why？
四大特征：
①采用了MVC的设计模式
Model 模型数据
View  视图
Controller 控制器
</code></pre><p>3、MVC的工作原理：</p>
<pre><code>View视图 接收用户的输入，通过控制器（Controller）当中的方法，完成对于Model的增删改查的操作。
1.数据绑定：将数据和视图绑定起来，一旦数据被修改了，视图就会更新
2.双向数据绑定
    数据-》视图
    视图用户的输入 -》 数据
3.依赖注入
4.模块化设计
</code></pre><p>4、使用ng</p>
<pre><code>1、基本语法
    &lt;any&gt;{{表达式}} &lt;/any&gt;
    直接按照上述方法写，结果是不对的，解决方案：在html标签写上了ng-app

2、常用指令
    ngApp
        ①启动ng
        ②指定作用范围，将指令写在根标签
    快捷键：在webStorm中alt+f2,快速选中要去执行在哪个浏览器。
    ngInit 指令 来完成数据的初始化
    &lt;any ng-init=&quot;num=2&quot;&gt;&lt;/any&gt;
        ①不需要在通过ngInit指令定义数据时候，加上var关键字
        ②ngInit所初始化的变量是可以在整个html去使用变量
</code></pre><p>5、常用指令</p>
<pre><code>ng中指令：由angularJS提供了，可以用在html中作为扩展属性、扩展标签。。

作为扩展属性来使用：
    &lt;div ng-**&gt;&lt;/div&gt;
    ngInit  --&gt; ng-init
    ngApp --&gt; ng-app
作为扩展标签来使用：
    &lt;ngView/&gt;
①ngApp
    启动ng
    指定作用范围，将指令写在根标签
    注意事项：调用一次ngApp
②ngInit
    通过ngInit调用一次，初始化多个变量？？
    &lt;any ng-init=&quot;a=1;b=2&quot;/&gt;
③ngRepeat
    重复实例化模板
    两种语法：
    &lt;any ng-repeat=&quot;临时变量的名称 in 集合的名称&quot;&gt;&lt;/any&gt;
    &lt;any ng-repeat=&quot;（key,value） in 集合的名称&quot;&gt;&lt;/any&gt;

    注意事项：在使用ngRpeat的时候要遍历的集合默认是不允许有重复的数据，
        可以通过 track by $index来指定一个不会重复的值就可以解决报错的问题。

④ngIf、ngShow、ngHide、ngSrc、ngDisabled、ngChecked
    ngIf-》选择是否要显示出来（挂载到DOM，从DOM中删除）
    ngShow/ngHide -&gt;选择是否要显示出来(显示或者隐藏)
    &lt;any ng-if=&quot;表达式&quot;&gt;&lt;/any&gt;
    &lt;any ng-show=&quot;表达式&quot;&gt;&lt;/any&gt;
    &lt;any ng-hide=&quot;表达式&quot;&gt;&lt;/any&gt;
    注意事项：在使用ngSrc去读取变量中值的时候，要记得加上双花括号
    &lt;img ng-src=&quot;img/{{imgUrl}}&quot; /&gt; 如果你写的不是ngSrc而是src，显示是ok的，但是控制台是会报错的，通过ngSrc去指定就搞定了
    &lt;any ng-disabled=&apos;表达式&apos;&gt;&lt;/any&gt;
    &lt;input type=&apos;checkbox&apos; ng-checked=&quot;表达式&quot;/&gt;
</code></pre><p>6、MVC</p>
<pre><code>在ng中：
    Model 模型数据：在ng中定义的一些变量
    View  视图：通过ng指令和表达式增强版的html
    Controller 控制器：负责数据的增删改查的
MVC的好处:在实现大型应用程序，可以通过将视图和数据隔离开，有效的降低代码的复杂度、耦合度
在ng中应该怎么做才能实现一个SPA？
准备工作：
①创建一个模块
    因为在ng中是以模块为基本单位的
    var app = angular.module(&apos;模块的名称&apos;，[&apos;依赖模块1&apos;,&apos;依赖模块2&apos;])
②使用模块
    采用ngApp指令
    &lt;html ng-app=&quot;模块的名称&quot;&gt;&lt;/html&gt;
③创建一个控制器
    app.controller(&apos;控制器的名称&apos;,function(){})
    第二个参数时控制器被调用时，要执行的方法
④调用控制器
    采用ngController指令来调用控制器
    &lt;div ng-controller=&apos;控制器的名称&apos;&gt;&lt;/div&gt;
    实现数据的创建和显示等：
⑤操作数据、显示出来

$scope是一个对象，称之为作用域对象，是一个非常重要的概念，
    建立起控制器中的数据和控制器的所指定的视图的桥梁

绑定事件的时候，在ng的做法： &lt;any ng-eventName=&quot;handle()&quot;&gt;
&lt;button ng-click=&quot;handleClick()&quot;&gt;&lt;/button&gt;

注意事项：
由于ngInit和$scope都可以完成数据的初始化，建议使用$scope,因为ngInit会增加代码的耦合度和复杂度。
</code></pre><p>7、ng是由很多指令的：</p>
<pre><code>ngApp ngRepeat ngIf ngShow ngHide ngChecked ngDisabled ngSrc
ngBind ngClass ngStyle

在webStorm中创建一个文件模板的基本步骤：
①拷贝要使用的代码
②点击左上角的file，选择new
③选择Edit File Templates
④点击弹窗中右上角的+号
⑤修改name和extension为创建的文件模板的名称以及格式，点击ok保存即可
</code></pre><p>8、自定义指令</p>
<pre><code>1、如何自定义？？
    angular.module()
    app.controller()
    //创建指令
    app.directive(&apos;指令的名称&apos;，function(){
        return {}
    })
    指令的命令规则：指令的名称由两部分构成，前缀：一般使我们模块或者项目的名字缩写； 后缀：用来描述指令的功能
    属性：
    template：指定要显示的模板内容
    restrict: &quot;EAC&quot; //E(Element)A(Attribute)C(Class)M(Comment)
    replace: true,替换并显示出来
    scope

2、如何使用自定义的指令？？
    注意事项：指令在命名时是要遵循驼峰式命名规则；在使用时要遵循烤串式用方
    &apos;tsHello&apos; --&gt; ts-hello
    根据配置指令时的restrict属性所对应的值，在合适的场景下使用指令。

3、自定义指令传递参数
    怎么传？
        在调用指令的时候可以传 将参数作为属性对应的值
    怎么接受？
        scope
</code></pre><p>9、双向数据绑定</p>
<pre><code>方向1：从&apos;数据&apos;绑定到&apos;视图&apos;
绑定方式：
①常用指令： ngRepeat/ngIf/ngShow...
②双花括号：{{}}

方向2：从‘视图中用户的输入’绑定到‘数据’
绑定方式：指令：ngModel

如果要监听数据的变化：
$scope.$watch(&apos;txt&apos;,function(){

})

在实现下拉框的过程中，如果数据是动态的，可以通过ngOptions将数据绑定到视图中。
ngOptions语法：
 &lt;select
    ng-model=&quot;city&quot;
    ng-options=&quot;city.cityName for city in cities&quot;&gt;
 &lt;/select&gt;
</code></pre><p>10、过滤器</p>
<pre><code>a.内置的过滤器
    ng中的过滤器为了实现对于表达式结果的筛选、过滤、格式化，达到更好的表现效果。
    过滤器的语法：支持多重过滤和传参
    {{expression | 过滤器名称 : '参数' | 过滤器名称2：‘参数’ }
            | => 管道
            常用的过滤器：
                currency 货币样式的过滤器
                date 日期
                uppercase/lowercase 大小写的处理
                orderBy 对指定的数组进行升序或者降序排列
                number 格式化数字为文本（对有小数点的数据的处理）
                limitTo 限定数组或者字符串要显示的个数
        b.自定义过滤器
            自定义过滤器方式：
            app.filter('过滤器名称',function(){
                return function(input，arg){
                        //input是传递给过滤器的数据
                        //arg 是过滤器本身的参数
                    return '过滤后的结果'
                }
            })
            使用自定义的过滤器:
            和内置的过滤器用法是一样的

11、ng模块内置的方法

        序列化、反序列化
        toJson:将对象或者数组 序列化 为json格式的字符串
        fromJson：相反的过程

12、服务

    服务的本质是一个单例对象，提供数据和对象。
    两大类：
    ①内置服务
        $location、$http、$window、$scope...
        使用内置服务中提供的方法：
            第一步 将需要用到的服务注入进来 function($scope,$location)
            第二步 调用服务中提供的方法 数据。。
    ②自定义的服务
        面试题：$scope与$rootScope之间的关系
        1、不同的控制器之间的数据是彼此隔离的
        2、不同的控制器之间如何共享数据？？
        $scope的id是从2开始依次往上递增，
        id为1的是谁？ $rootScope是根作用域对象，其余的$scope都是子对象
            方式1：借助于$rootScope
                把要共享的数据存在$rootScope,所有的子对象就可以读取该数据
            方式2：借助于控制器之间的嵌套
                在调用控制器的元素 之间的嵌套关系
                @@div ng-controller='myCtrl02'>
                    @@<div ng-controller="myCtrl03"></div>
                @@
            方式3：触发事件传递参数
                绑定事件：
                $scope.$on('事件名称',function(event,data){

                })
        触发事件：
        //从子作用对象 向 父作用域对象 传递事件
        $scope.$emit()
        //从父作用对象 向 子作用域对象 传递事件
        $scope.$broadcaset()

13、服务

        双向数据绑定的工作原理：
        绑定时，ng会自动添加一个监听watcher,当数据发生变化时，会执行更新DOM操作的函数。
        怎么知道数据发生了变化？
        在ng中有一个循环$digest,会不断的对比数据，
        需要手工的触发循环做对比，可以通过：
        $scope.$digest();
        $scope.$apply();//触发$rootScope.$digest();

14、ng内置的服务：

        $location $scope $rootScope $window $interval $timeout
        1、在ng中定时器相关的处理--》$interval $timeout
        2、$http
        $http({method:'',url:''}).success().error()
        $http.get()
        $http.post()
        注意：如果需要发起post请求，需要设置:
         app.run(function ($http) {
                $http.defaults.headers.post =
        {'Content-Type':'application/x-www-form-urlencoded'};})

        在发起post请求时，如果需要对参数进行序列化:
        借助于$httpParamSerializer服务，首先注入进来，$httpParamSerializer（obj）。

15、自定义服务

        服务的目的是为了封装业务逻辑，提高代码的复用率
        自定义指令 app.directive
        自定义过滤器 app.filter
        自定义服务的方法：
        app.factory ('服务名称',function(){//普通方法 return {}})
app.service(&apos;服务名称&apos;,function(){//构造函数})
app.constant(&apos;服务名称&apos;，{})//创建常量服务
app.value(&apos;服务名称&apos;，{})//创建变量服务

注意事项：
自定义的服务 需要用到其它服务中方法
图：两个按钮：开始 结束。
</code></pre><p>16、依赖注入</p>
<pre><code>将代码部署到线上，都会对代码做压缩。
使用YUI-Compressor.jar （有java的运行环境）
①借助于CLI（command line）
    java -jar yui**.jar  c:\demo10.js &gt; c:\demo10.min.js

②IDE（webStorm）
    file-&gt;settings-&gt;tools-&gt;fileWathchers-&gt;+-&gt;选中YUI-Compressor JS，在弹窗中的program选中对应的jar，保存即可
压缩效果：
会删除所有的注释、删除没有语义的空白字符、尽可能的简化变量的名称（混淆），但是数字、字符串、关键字是不会改变的。

解决压缩后的问题方式：
依赖注入：将依赖的服务或者其他，通过参数形式注入进来，背后ng框架会帮助对服务等做实例化的操作，让我们可以去直接使用

注入的方式：
①推断式（猜测）
    这种方式在进行压缩会有问题
    app.controller(&apos;myCtrl&apos;,function($scope){});

②标记式
    由于文件压缩时，关键数据 字符串 关键字等不会被处理的；将所需要用到的服务，存在一个字符串（服务名称）数组。
    注意事项：在数组中服务名称的顺序和创建对应的处理函数参数的顺序是要保持一致的
    实现方式：1、将处理函数单独的存在一个变量中 2、给变量设置$inject，值是一个由字符串构成的数组 3、使用服务即可
③行内式（内联式）
    在构建一个ng对象时，允许将一个字符型数组 作为对象的参数，在数组中可以：服务名称、函数（必须是在数组的最后一个元素）
    app.controller(&apos;myCtrl&apos;,[&apos;$scope&apos;,function($scope){}])
    依赖注入3种方式，官方推荐采用行内式依赖注入。
    依赖注入的背后：$injector 注入器：快速的定位到应用需要用到的各种该服务，整个ng应用的注入对象都是由$injector定位和创建。
    $injector.has(&apos;服务名称&apos;) ==》判断指定的服务是否存在
    $injector.get(&apos;服务名称&apos;) ==》 得到指定的服务对应的实例
</code></pre><p>17、模块化设计</p>
<pre><code>ng有4大特征：
①MVC
②双向数据绑定
③依赖注入
④模块化设计

高内聚低耦合，在ng中有两种：①内置的模块 ②自定义的模块

如何自定义模块？
angular.module();

使用模块？
ng-app=&quot;&quot;
在创建模块时，在第二个参数所对应的数组中写上服务的名称

一个ng的模块都可以包含哪些？
控制器：对应部分业务逻辑的封装
服务：经常用到的重复代码封装
指令：扩展html标签、属性
过滤器：针对数据做一些筛选 过滤 格式化的处理
</code></pre><p>18、ngRoute（路由模块）</p>
<pre><code>ng是主要实现SPA（单一页面应用程序）
SPA的工作原理：
    1、页面url
    http://127.0.0.1/index.html#/路由地址
    例如：http://127.0.0.1/index.html#/start
    2、解析index.html 是一个完整的html页面，再解析路由地址(start)
    3、在路由词典中寻找路由地址(start)所对应的路由信息
    4、在路由信息所对应的对象中找到真实的模板页面地址
    5、（发起异步ajax）加载模板页面到指定的容器中，实现局部刷新

ngRoute（路由模块）可以定义路由词典，自动解析路由地址，查找路由词典，自动发起ajax请求加载页面显示。
    0、在创建自定义模块，在依赖列表中指定ngRoute
    1、指定盛放代码片段的容器
    2、配置路由词典

使用ngRoute的基本步骤：
①创建一个完整的html页面
    记得引入angular.js angular-route.js

②创建模块，并指定依赖于ngRoute模块
    angular.module(&apos;myApp&apos;,[&apos;ng&apos;,&apos;ngRoute&apos;])

③使用指令创建一个盛放代码片段的容器
    调用ngView指令：创建一个容器，代码片段会加载到这里

④创建模板页面

⑤配置路由词典
    $routeProvider
    when是用来添加一条路由信息的(路由地址的字符串是以/开始)
    $routeProvider.when(&apos;/myStart&apos;,{controller:&apos;&apos;,template/templateUrl:&apos;&apos;})
    otherwise是用来指定异常的处理
    $routePriovder.otherwise({redirectTo:&apos;路由地址&apos;})

SPA在ng实现过程，代码片段的跳转：
①直接修改地址栏中的路由地址
    http://localhost:63342/day4/demo03_SPA%E7%BB%83%E4%B9%A0.html#/myLogin
    http://localhost:63342/day4/demo03_SPA%E7%BB%83%E4%B9%A0.html#/myRegister
②通过js的方式
    $location.path(&apos;路由地址&apos;)
③超链接的方式
    a href=&quot;#/myRegister&quot;
    login-&gt;start 10

SPA应用程序通过ngRoute来传递参数：
①搞明白 发送 接收
②配置接收方的路由
    $routeProvider.when(&apos;/myStart/:num&apos;,{
    templateUrl:&apos;tpl/start.html&apos;
    })
③拿到传递过来的参数
    $routeParams.num
④发送
    a href=&apos;#/myStart/10&apos;
    $location.path(&apos;/myStart/10&apos;)

注意事项：配置接收方路由时的冒号后的变量名称要和通过$routeParams解析参数的属性是要保持一致
    myStart/:id $routeParams.id

练习：实现一个SPA
完整的html manager.html
代码片段： checkProduct.html pay.html send.html

要求：能够实现不同页面的跳转以及参数的传递
checkProduct.html 能够a跳转到pay，传递price，在pay接收传递过来的参数显示在pay页面
pay 点击button跳转到send
send button以及a跳转到check.html

优化思路：如果多个控制器需要用到同一个方法或者数据，
    ①将方法和数据封装成一个服务
    ②$rootScope
    ③控制器之间的嵌套
    ④借助于事件

由于不同的代码片段都显示在了body的子元素中：body是所有代码片段的父元素，可以在body指定控制器，
控制器中的方法和数据，代码片段就可以用了。
①发送 接收
    checkProduct --&gt; pay

②配置接收方路由
    .when(&apos;/myPay/:price&apos;,{})

③$routeParams
    $routeParams.price

④发送参数
    href=&apos;#/myPay/20&apos;
    $location.path(&apos;/myPay/20&apos;)

ngInclude 引入多个地方同时需要用到的，比如页头、页尾。。。

要求：给综合练习的3个代码片段加上头信息(显示一个p标签)

注意事项：在使用ngInclude进行赋值的时候，对应的路径字符串要在双引号内 加上一对单引号
</code></pre><p>19、ngAnimate（动画模块）</p>
<pre><code>在angularJS添加动画效果，需要用到ngAnimate模块
基本步骤：
①引入对应的js文件
    angular-animate.js
②指定自定义模块依赖于ngAnimate
    angular.module(&apos;myModule&apos;,[&apos;ng&apos;,&apos;ngRoute&apos;,&apos;ngAnimate&apos;])
③css给ng应用程序添加动画效果：
    ngEnter 准备进入
    ngEnterActive 进入完成
    ngLeave 准备离开
    ngLeaveActive 离开完成
④引入对应的css文件

如果用到其它的模块整体思路：
    ①在ng每一个模块都有自己的js文件，用到哪个模块，把指定模块的js文件引入进来
    ②在创建模块，指定依赖列表
    ③根据模块中所提供的指令、服务。。结合业务需要进行
</code></pre><p>20、表单验证</p>
<pre><code>在ng中，针对表单和空间提供了属性，用于验证控件交互的状态
布尔类型：
$valid
$invalid
$dirty
$pristine
对象：
$error

注意事项：
①给表单以及表单组件 加上name属性
②给需要用到的表单组件 ，加上ngModel
③属性的用法
myForm.t_age.$dirty/$pristine/$valid/$invalid/$error
</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;1、设计原则和设计模式&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;拙劣的设计：
①僵化
②脆弱
③不必要的复杂
④晦涩。。

1、YAGNI（不要写不需要的代码）
you aren&amp;apos;t gonna need it

2、KISS （越简单越好）
keep it simple 
    
    </summary>
    
      <category term="学习笔记" scheme="www.wangchengzou.cn/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Angular" scheme="www.wangchengzou.cn/tags/Angular/"/>
    
  </entry>
  
  <entry>
    <title>CSS3有哪些新特性</title>
    <link href="www.wangchengzou.cn/2017/07/22/CSS3%E6%9C%89%E5%93%AA%E4%BA%9B%E6%96%B0%E7%89%B9%E6%80%A7/"/>
    <id>www.wangchengzou.cn/2017/07/22/CSS3有哪些新特性/</id>
    <published>2017-07-22T15:48:26.000Z</published>
    <updated>2017-07-23T08:01:09.332Z</updated>
    
    <content type="html"><![CDATA[<p>举例：<br>  新增各种CSS选择器  （: not(.input)：所有 class 不是“input”的节点）<br>  圆角           （border-radius:8px）<br>  多列布局        （multi-column layout）<br>  阴影和反射        （Shadow\Reflect）<br>  文字特效      （text-shadow、）<br>  文字渲染      （Text-decoration）<br>  线性渐变      （gradient）<br>  旋转          （transform）<br>  增加了旋转,缩放,定位,倾斜,动画，多背景<br>  transform:\scale(0.85,0.90)\ translate(0px,-30px)\ skew(-9deg,0deg)\Animation:</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;举例：&lt;br&gt;  新增各种CSS选择器  （: not(.input)：所有 class 不是“input”的节点）&lt;br&gt;  圆角           （border-radius:8px）&lt;br&gt;  多列布局        （multi-column layout）&lt;b
    
    </summary>
    
      <category term="面试题目" scheme="www.wangchengzou.cn/categories/%E9%9D%A2%E8%AF%95%E9%A2%98%E7%9B%AE/"/>
    
    
      <category term="html" scheme="www.wangchengzou.cn/tags/html/"/>
    
      <category term="css" scheme="www.wangchengzou.cn/tags/css/"/>
    
  </entry>
  
  <entry>
    <title>CSS3新增伪类有那些</title>
    <link href="www.wangchengzou.cn/2017/07/22/CSS3%E6%96%B0%E5%A2%9E%E4%BC%AA%E7%B1%BB%E6%9C%89%E9%82%A3%E4%BA%9B/"/>
    <id>www.wangchengzou.cn/2017/07/22/CSS3新增伪类有那些/</id>
    <published>2017-07-22T15:48:26.000Z</published>
    <updated>2017-07-23T07:55:42.524Z</updated>
    
    <content type="html"><![CDATA[<p>举例：<br>p:first-of-type 选择属于其父元素的首个 </p><p> 元素的每个 </p><p> 元素。<br>p:last-of-type  选择属于其父元素的最后 </p><p> 元素的每个 </p><p> 元素。<br>p:only-of-type  选择属于其父元素唯一的 </p><p> 元素的每个 </p><p> 元素。<br>p:only-child        选择属于其父元素的唯一子元素的每个 </p><p> 元素。<br>p:nth-child(2)  选择属于其父元素的第二个子元素的每个 </p><p> 元素。</p>
<p>:after          在元素之前添加内容,也可以用来做清除浮动。<br>:before         在元素之后添加内容<br>:enabled<br>:disabled       控制表单控件的禁用状态。<br>:checked        单选框或复选框被选中。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;举例：&lt;br&gt;p:first-of-type 选择属于其父元素的首个 &lt;/p&gt;&lt;p&gt; 元素的每个 &lt;/p&gt;&lt;p&gt; 元素。&lt;br&gt;p:last-of-type  选择属于其父元素的最后 &lt;/p&gt;&lt;p&gt; 元素的每个 &lt;/p&gt;&lt;p&gt; 元素。&lt;br&gt;p:only-of-type  
    
    </summary>
    
      <category term="面试题目" scheme="www.wangchengzou.cn/categories/%E9%9D%A2%E8%AF%95%E9%A2%98%E7%9B%AE/"/>
    
    
      <category term="html" scheme="www.wangchengzou.cn/tags/html/"/>
    
      <category term="css" scheme="www.wangchengzou.cn/tags/css/"/>
    
  </entry>
  
  <entry>
    <title>CSS3笔记</title>
    <link href="www.wangchengzou.cn/2017/07/22/CSS3%E7%AC%94%E8%AE%B0/"/>
    <id>www.wangchengzou.cn/2017/07/22/CSS3笔记/</id>
    <published>2017-07-22T15:48:26.000Z</published>
    <updated>2017-07-23T10:29:58.932Z</updated>
    
    <content type="html"><![CDATA[<p>1、CSS概述</p>
<pre><code>1、问题
    1、控制页面中所有的文本颜色为 红色
    2、控制页面中所有div的文本颜色 为蓝色
    3、将 所有div 的颜色 变为 黄色

    HTML元素的不足：
        1、要完成相同的效果，使用的是不同的属性
            &lt;body text=&quot;red&quot;&gt;
            &lt;font color=&quot;blue&quot;&gt;
        2、没有提升 html属性的 可重用性和可维护性
            可重用性：重复的操作 不用重复的写

        可以通过 CSS 解决以上两个问题
2、什么是CSS
    CSS (Cascading Style Sheets),层叠样式表，级联样式表，简称：样式表。专门用于定义页面元素的样式的。
    以统一的方式定义页面元素的样式

    CSS实现了内容与表现相分离
    提升了代码的可重用性 和 可维护性
3、CSS 与 HTML之间的关系
    HTML : 专门用于构建网页结构
    CSS : 专门构建HTML网页的样式

    HTML属性效果 与 CSS样式效果相冲突的话：
    优先使用 CSS 定义页面元素的效果
</code></pre><p>2、CSS语法</p>
<pre><code>1、使用CSS样式表
    1、内联方式
        又称为 ：行内样式
        将样式定义在某个html元素中
        语法：
        &lt;ANY style=&quot;样式声明;样式声明;&quot;&gt;&lt;/ANY&gt;
        样式声明：
            由 属性名称 和 属性值 来组成，属性名称和属性值之间用 : 来关联
        ex:
            属性名称          属性值
            color             red,blue,yellow...
            background-color  合法颜色值即可..(同上)
            font-size         以px，pt，为单位的数值

            控制以下 文本颜色为 红色，背景颜色为 黄色，文字大小为 24px
            &lt;p&gt;静夜思&lt;/p&gt;
    2、内部样式表
        将样式定义在网页的一块独立位置处
        在 &lt;head&gt;&lt;/head&gt; 中 增加一对 &lt;style&gt;&lt;/style&gt;元素，在 &lt;style&gt; 元素中 定义元素的样式,具体语法如下：
        &lt;head&gt;
            &lt;title&gt;&lt;/title&gt;
            &lt;style&gt;
                样式规则1
                样式规则2
                ...
                样式规则n
            &lt;/style&gt;
        &lt;/head&gt;
        样式规则，由两部分组成
            1、选择器
                选择(规范)页面中哪些元素能够使用声明好的样式
                比如：元素选择器，由元素名称来充当选择器，控制某标记对应所有页面元素的样式
            2、若干样式声明

            样式规则 语法结构：
            选择器{
                样式声明1;
                样式声明2;
                ...
                样式声明n;
            }
            ex:
            p{
                color:red;
                background-color:yellow;
                font-size:24px;
            }

    3、外部样式表
        将样式定义在外部的&quot;样式表文件(*.css)&quot;中
        1、创建 .css 文件，编写样式规则
        2、在要使用 样式表的 html文件中进行引入
            &lt;head&gt;
                &lt;link rel=&quot;stylesheet&quot; href=&quot;样式表文件url&quot;&gt;
            &lt;/head&gt;
2、CSS样式表特征
    1、继承性
        大部分样式属性是可以被继承
    2、层叠性
        可以为一个元素定义多个样式规则
        如果 属性 不冲突时，多个样式规则可以层叠为一个(即都可以应用到当前元素上)
    3、优先级
        在层叠性基础上，如果 样式定义 冲突的话，那么就会按照不同使用方式的优先级，来选择性应用样式
        低 ：浏览器默认设置
        中 ：外部样式表 和 内部样式表
            就近原则
            后定义优先
        高 ：内联方式
    4、!important 规则
        显示调整样式属性的优先级
        语法：
            属性名:值 !important;
        谨慎使用!
3、选择器(重点)
    1、作用
        选择(规范)页面中哪些元素能够使用声明好的样式
        为了匹配页面的元素
    2、详解
        1、通用选择器
            作用：匹配页面中所有的元素
            语法：*{}
            缺点：效率较低，尽可能少用,可以通过 使用 body 的继承性 来替代 *
        2、元素选择器
            作用：匹配某一标记所对应的页面中所有的元素
            语法：元素/标签 {}
            ex:
            div{/*匹配页面中所有div*/}
            span{/*匹配页面中所有span*/}
            li{/*匹配页面中所有li*/}
        3、类选择器
            作用：事先定义好样式，可以由任意元素通过class属性进行引用
            语法：
                定义：.类名{}
                引用：&lt;ANY class=&quot;类名&quot;&gt;&lt;/ANY&gt;

            多类选择器的引用方式：
            让一个元素引用多个类选择器，中间用 空格 隔开即可

            分类选择器的声明方式：
                将元素选择器和类选择器结合到一起进行声明，实现对某种元素中的不同样式细分控制

                ex:想要控制 class为important的div元素，文字大小为 48px
                语法：元素选择器.类选择器{}
        4、id选择器
            作用：匹配 指定id值的元素的 样式
            ex:
                &lt;div id=&quot;nav&quot;&gt;&lt;/div&gt;

            语法：#ID值{}
        5、群组选择器
            群组选择器的声明以一个以 , 隔开的选择器列表
            语法：
                选择器1,选择器2,...{}
            ex:
                #title,p.redColor,.important,span{
                    color:red;
                }
        6、后代选择器
            后代：
                多于 一级 层级关系的元素，只能叫后代
                只具备 一级 层级关系的 也可以叫后代
            语法：
                选择器1 选择器2{}
                语义：匹配 在选择器1 中的  所有后代元素 选择器2
                ex:
                    #content span{}
        7、子代选择器
            子代：
                只具备 一级 层级关系的 称之为 子代
            语法：
                选择器1&gt;选择器2{}
                语义：匹配 在选择器1 中的 子级元素 选择器2
        8、伪类选择器
            伪类：专门匹配元素不同状态的选择器
            分类：
                1、链接伪类
                2、动态伪类

                3、目标伪类
                4、元素状态伪类
                5、结构伪类
                6、否定伪类
            语法：
                以 :作为开始的选择器

                1、链接伪类
                    1、:link
                        适用于未被访问的超链接
                    2、:visited
                        适用于访问过的超链接
                2、动态伪类
                    1、:hover
                        适用于鼠标悬停在html元素时
                    2、:active
                        适用于html元素被激活时
                    3、:focus
                        适用于html元素获取焦点时
</code></pre><p>3、尺寸与边框</p>
<pre><code>1、CSS单位
    1、尺寸单位
        1、px ：像素
        2、pt ：磅 (1pt=1/72in)
        3、in ：英寸，1in=2.54cm
        4、%  ：百分比，占据 当前元素 或 父元素 对应属性的 占比
        5、em ：倍数，多数用于 文字大小的描述
        6、mm ：毫米
        7、cm ：厘米
        注意：css中尺寸单位是不能省略的。
    2、颜色单位(取值)
        1、rgb(r,g,b)
                r : red , 范围 0-255
                g : green,范围 0-255
                b : blue, 范围 0-255

             ex：
                background-color:rgb(0,0,0);黑色
                background-color:rgb(255,0,0);红色
                background-color:rgb(255,255,255);白色
        2、rgb(r%,g%,b%)
        3、rgba(r,g,b,alpha)
            alpha : 透明度 0-1之间的数字
                0 : 完全透明
                1 : 完全不透明
                0.5 : 半透明
        4、#rrggbb
            通过6位16进制数字表示一个颜色
            每位数字范围：0-9 A-F
            #00ff00 : 绿色
            #ff0000 : 红色
            #1a2b3c : ?
        5、#rgb
            #rrggbb 每两位数字相同时，可以使用#rgb简化
            #00ff00 -&gt; #0f0
            #aabbcc -&gt; #abc
            #accdda -&gt; ×
        6、颜色的英文表示
            red,green,blur,orange,yellow...
2、尺寸属性
    1、作用
        用于设置元素的宽度和高度
        单位一般为 px 或 %(父元素对应属性的占比)
    2、语法
        1、宽度
            width
            min-width : 最小宽度
            max-width : 最大宽度
        2、高度
            height
            min-height : 最小高度
            max-height : 最大高度
        注意：
            页面中所有元素的高度，在不指定的情况全部是自适应(以内容为主)。

            页面中所有块级元素的宽度，默认占据父元素的100%
            页面中所有行内元素的宽度，默认自适应(以内容为主)
    3、页面中允许修改 尺寸 属性的元素
        1、所有块级元素都允许修改
        2、大部分的行内块元素
            所有的表单元素都是行内块元素
            除radio、checkbox之外，其他元素允许修改尺寸
        3、本身html元素就具备width 和 height的
            img，table 可以修改尺寸
        4、行内元素(除具备width和height之外)是不能修改尺寸
            span,b,a,i,s,b ... 不能修改尺寸
    4、溢出
        1、什么是溢出
            使用尺寸属性限制元素大小时，如果内容所需要的空间大于元素本身空间，则会导致内容溢出
        2、溢出处理属性
            属性：
                overflow
                overflow-x : 横向溢出处理
                overflow-y : 纵向溢出处理
            取值：
                1、visible
                    默认值，溢出可见
                2、hidden
                    隐藏
                3、scroll
                    滚动，让元素出现滚动条，溢出时，滚动条可用
                4、auto
                    自动，溢出时显示滚动条并可用，非溢出时，不显示滚动条
3、边框属性
    1、边框
        1、简写方式
            border:width style color;
            作用：设置元素上下左右四个边框的宽度，样式以及颜色
                width:边框的宽度(尺寸)
                style:边框的样式
                    取值：
                        1、solid ：直线
                        2、dotted ：虚线(点状)
                        3、dashed ：虚线(线状)
                color:边框的颜色,可以取值为 transparent(透明)

            ex:
                div{
                    border:1px solid red;
                }
        2、单边定义
            border-方向:width style color;
            方向可以被以下关键字所取代
            top : 上
            right : 右
            bottom : 下
            left:左
            ex:
                border-bottom:2px dashed #00ff00;
        3、单属性定义
            border-属性:值;
            属性可以被以下关键字取代：
            width:宽度
            style:样式
            color:颜色
            ex:
                border-width:5px;
                border-style:solid;
                border-color:#f00f00;
        4、单边单属性定义
            border-方向-属性:值;
            方向：top/right/bottom/left
            属性：width/style/color
            ex:
                border-top-color:yellow;
                border-right-style:dotted;
</code></pre><hr>
<p>1、边框</p>
<pre><code>1、边框
    边框实际上是由四个三角形组成的
2、边框倒角
    属性：border-radius
    取值：
        具体数值(px) 或 %
        最少一个值，最多4个值
    单角定义
        border-top-left-radius:左上角倒角半径
        border-bottom-right-radius:右下角
        ... ...
3、边框阴影
    属性：box-shadow
    取值：h-shadow v-shadow blur spread color inset;
        h-shadow:(必须)
            阴影的水平偏移距离
            取值为正，右偏移
            取值为负，左偏移
        v-shadow:(必须)
            阴影的垂直偏移距离
            取值为正，下偏移
            取值为负，上偏移
        blur : 模糊距离,取值为数值
        spread : 阴影的大小
        color : 颜色
        inset : 值，将默认的外阴影改为内阴影
4、轮廓
    1、什么是轮廓
        位于元素外围的一条线,位于边框之外的
    2、属性
        outline:width style color;
        outline-width:宽度;
        outline-style:样式;
        outline-color:颜色;

        常用：
            outline:none;
            或
            outline:0;
    练习：作业基础上
        1、为每幅图像增加四个角的倒角(5px)
        2、鼠标移入的时候，为每幅图像增加阴影
            右下偏移，大小不限，颜色不限
</code></pre><p>2、框模型(重难点)</p>
<pre><code>1、框 &amp; 框模型
    框：页面元素皆为框
    框模型：Box Model ,定义了元素框处理元素内容尺寸，内边距，边框和外边距的一种方式

    元素一旦增加框模型对应属性的属性，那么实际的占地区域会发生改变

    元素的实际宽度=左右外边距 + 左右边框 + 左右内边距 + width;

    元素的实际高度=上下外边距 + 上下边框 + 上下内边距 + height;
2、外边距
    1 、外边距
        围绕在元素边缘周围的空白区域
        默认不能被其他元素所占据
        作用：拉伸两个元素间的距离
    2、语法
        属性：
            margin:值;
            单边设置：
            margin-方向:值;
                方向：top/right/bottom/left
        取值：
            1、具体数值 px
            2、%
            3、负值
                左外边距取负值 ：左移动
                左外边距取正值 ：右移动
                上外边距取负值 ：上移动
                上外边距取正值 ：下移动
            4、auto
                自动，由浏览器计算外边距的值应该是多少
                注意：默认情况下，auto只对左右有效，上下无效。

                为块级元素设置宽度后，再设置其左右外边距为 auto，该元素能水平居中显示
        margin的简洁写法：
            margin:value; 四个方向外边距的值
                margin:5px;
            margin:v1 v2; v1 上下外边距 v2 左右外边距
                margin:5px 10px;
            margin:v1 v2 v3;v1 上外边距 v2 左右外边距 v3 下外边距
                margin:5px 15px 3px;
            margin:v1 v2 v3 v4;上 右 下 左
    3、页面中具备默认外边距的元素
    4、特殊注意
        1、外边距合并
            当两个垂直外边距相遇时，将合并成一个
        2、外边距的溢出
            特殊场合下，为子元素设置外边距(上下)会作用到父元素上
            特殊场合：
                1、父元素没有边框(上下)
                2、为第一个(最后一个)子元素设置外边距
            解决方案：
                1、为父元素增加边框(透明的)
                    弊端：父元素会变高
                2、可以为父元素设置上内边距来取代子元素上外边距
                    弊端：父元素高度会变高
                3、为父元素增加一个空子元素
                    &lt;table&gt;&lt;/table&gt;
                    弊端：多一个子元素
                4、后续讲解...(CSS3高级)
        3、为行内元素和行内块元素设置垂直外边距
            1、大部分行内元素垂直外边距无效
                img允许设置
            2、行内块元素设置垂直外边距，该行的所有元素都跟着变
3、内边距
    1、什么是内边距
        内容区域 和 边框(边缘)之间的距离
        注意：内边距会扩大边框所占用的区域
    2、语法
        属性：
            padding:值;
            padding-方向:值;
                方向：top/right/bottom/left
            取值：
                1、px
                2、%
                3、auto
        简写方式：
            padding:value; 上下左右
            padding:v1 v2; 上下  左右
            padding:v1 v2 v3;上  左右  下
            padding:v1 v2 v3 v4;上 右 下 左
    3、特殊注意
        1、为行内元素增加上下内边距时
            只影响自己，并不影响其他元素
4、box-sizing
    1、作用
        重新指定元素尺寸计算模式
        占地宽度 = margin+border+padding+width
        可见宽度 = border+padding+width
    2、语法
        属性：box-sizing
        取值：
            1、content-box
                默认值，width只表示内容区域的宽度，border和padding额外进行计算
                可见宽度=border+padding+width
            2、border-box
                width包含边框内所有的距离(padding,border)
                可见宽度=width(border+padding+宽度);
</code></pre><p>3、背景</p>
<pre><code>1、背景颜色
    属性：background-color
    取值：颜色值 或 transparent
    注意：背景颜色从边框位置处开始绘制
2、背景图像
    属性：background-image
    取值：url(背景图url)
3、背景重复
    属性：background-repeat
    取值：
        1、repeat
            默认值，即横向又纵向平铺
        2、repeat-x
            只在横向平铺
        3、repeat-y
            只在纵向平铺
        4、no-repeat
            不平铺
4、背景图片尺寸
    属性：background-size
    取值：
        1、value1 value2
            指定背景图像宽度 和 高度
        2、value1% value2%
            采用当前元素宽和高的占比，来作为背景图大小
        3、cover
            覆盖，会将背景图像等比放大，直到背景图完全覆盖到元素为止
        4、contain
            包含，会将背景图像等比放大，直到右边或下边碰到元素边缘为止
5、背景图片固定
    属性：background-attachment
    取值：
        1、scroll
            滚动，默认值
        2、fixed
            固定，让背景图一直在可视化区域中
6、背景图片定位
    改变背景图在元素中的位置
    属性：background-position
    取值：
        1、x y
            指定背景图水平 和 垂直偏移距离
            x : 水平偏移距离
                取值为正，背景图右偏移
                取值为负，背景图左偏移
            y : 垂直偏移距离
                取值为正，背景图下偏移
                取值为负，背景图上偏移
        2、x% y%
            0% 0% : 背景图在左上
            0% 100% : 背景图在左下
            100% 100% : 背景图在右下
        3、关键字
            x : left / center / right
            y : top / center/ bottom
7、背景属性
    在一个 background 属性中声明所有的北京属性值

    属性：background
    取值：color url repeat attachment position;

    ex:
        background:red;
        background:url(a.jpg) no-repeat;
8、特殊使用
    CSS Sprites(精灵图/雪碧图)
</code></pre><p>1、渐变</p>
<pre><code>1、什么是渐变
    多种颜色之间平缓过度的显示效果
2、渐变分类
    1、线性渐变(linear-gradient)
        按照直线的方式填充渐变颜色和方向
    2、径向渐变(radial-gradient)
        以圆的方式填充渐变效果(圆心位置，半径)
    3、重复渐变
        1、重复线性渐变
            repeating-linear-gradient
        2、重复径向渐变
            repeating-radial-gradient
3、渐变中的重要信息
    1、色标
        由 颜色 及其 出现的位置 来组成的
4、渐变的语法
    1、属性
        background-image
    2、取值
        1、linear-gradient()
            linear-gradient(angle,color-point1,color-point2);
            1、angle
                填充的方向或角度
                1、关键字
                    1、to top ：从下向上填充
                    2、to right ：从左向右填充
                    3、to bottom ：从上向下填充
                    4、to left ：从右向左填充
                2、角度
                    0deg ~ 360deg

                    0deg : to top
                    90deg : to right
                    180deg : to bottom
                    270deg : to left
            2、color-point
                渐变中的色标,由 颜色 及其 出现的位置组成
                ex:
                    1、red 0px
                        该色标颜色为 red ，位置为填充方向的 0px 处
                    2、green 50px
                        该色标颜色为 green,位置为填充方向的 50px 处
                    3、blue 50%
                        该色标颜色为 blue，位置为填充方向的 50% 处
                    4、
                        linear-gradient(to top,red,blue,green);
                        自动分配位置
        2、radial-gradient()
            radial-gradient([size at position,]color-point,color-point)

            1、[size at position,] : 允许被省略
                size:圆的半径
                at : 关键字
                position:圆心的位置
                    1、x y
                        以px为单位的具体数值
                    2、x% y%
                    3、关键字
                        x : left , center , right
                        y : top , center, bottom
        3、repeating-linear-gradient()
        4、repeating-radial-gradient()
5、浏览器兼容性问题
    主流浏览器都支持渐变
    对于不支持的浏览器，需要添加浏览器前缀的方式实现兼容性
        浏览器前缀：
            1、Firefox ：-moz-
            2、Chrome 和 Safari ：-webkit-
            3、Opear ：-o-
            4、Microsoft IE ：-ms-
        如果浏览器不支持属性的话，则将前缀添加到属性名称前
            ex:
                animation:值;
                -moz-aniamtion:值;
                -webkit-aniamtion:值;
                -o-aniamtion:值;
                -ms-animation:值;
        如果浏览器支持属性，但不支持属性值的话，则将前缀添加到属性值前
            ex:
                background-image:linear-gradient();
                background-image:-moz-linear-gradient();
                background-image:-webkit-linear-gradient();
                background-image:-o-linear-gradient();
                background-image:-ms-linear-gradient();
</code></pre><p>2、文本格式化</p>
<pre><code>1、字体属性
    1、指定字体
        属性：font-family
        取值：字体1,字体2,字体3;
        注意：字体中包含中文或特殊字符的话，尽量使用 &quot;&quot; 引起来
        ex:
            font-family:&quot;微软雅黑&quot;,Arial;
    2、字体大小
        属性：font-size
        取值：px 或 pt 为单位的数值
    3、字体加粗
        属性：font-weight
        取值：
            1、normal
                非加粗显示，正常体
            2、bold
                加粗显示 &lt;b&gt;&lt;/b&gt;
            3、400 ~ 900
                400 ：normal
                900 ：bold
    4、字体样式
        属性：font-style
        取值：
            1、normal
                正常体
            2、italic
                斜体 &lt;i&gt;&lt;/i&gt;
    5、小型大写字符
        效果：将小写英文字符变成大写，但是大小和小写字符一样
        属性：font-variant
        取值：
            1、normal
                正常，默认值
            2、small-caps
                小型大写字符
    6、字体属性
        属性：font
        取值：style variant weight size family;
        注意：该简写属性中，必须包含 family 的值
2、文本属性
    1、文本颜色
        属性：color
        取值：~
    2、文本排列
        作用：控制内容的的水平对齐方式
        属性：text-align
        取值：left/center/right/justify(两端对齐)
    3、文本修饰
        线条修饰
        属性：text-decoration
        取值：
            1、none
                无线条修饰
            2、underline
                显示下划线
            3、line-through
                显示删除线 &lt;s&gt;&lt;/s&gt;
            4、overline
                显示上划线
    4、行高
        作用：一行数据的高度
        属性：line-height
        取值：以px为单位 或 当前字体大小的倍数
            line-height:50px;
            line-height:1.5;
        注意：文字将在指定行高的范围内垂直居中显示
        场合：
            1、文字垂直居中
            2、行间距的设置
    5、文本阴影
        属性：text-shadow
        取值：h-shadow v-shadow blur color;
</code></pre><p>3、表格</p>
<pre><code>1、表格常用属性
    1、边距属性
        padding，margin(不能为td设置margin)
    2、尺寸属性
        width,height
    3、文本格式化属性
        font-*,text-*,line-height,color,... ...
    4、背景属性
        颜色，图片，渐变
    5、border属性
    6、垂直方向对齐
        属性：vertical-align
        取值：top / middle / bottom
2、表格特有属性
    1、边框合并属性
        属性：border-collapse
        取值：
            1、separate
                默认值
            2、collapse
                合并
    2、边框边距
        类似于 cellspacing
        属性：border-spacing
        取值：
            1、指定1个值
                每个单元格的水平和垂直间距相同
            2、指定2个值
                第一个值，表示水平间距
                第二个值，表示垂直间距
        注意：
            必须保证border-collapse是separate时才有效
    3、标题位置
        默认情况下，标题表格上方，水平居中
        属性：caption-side
        取值：
            1、top
                默认值
            2、bottom
                底部
    4、显示规则
        作用：指定浏览器如何来布局一张表格(指定行和列的尺寸的计算模式)
        属性：table-layout
        取值：
            1、auto
                自动，即自动表格布局，默认值
                列的宽度高度实际上是由内容来决定的
            2、fixed
                固定，即固定表格布局。
                列的宽度和高度由设定的值决定
        自动表格布局 VS 固定表格布局
            1、自动表格布局
                1、单元格的大小会适应内容
                2、表格复杂时，加载速度较慢(缺点)
                3、适用于不确定每列大小时使用
                4、特别灵活(优点)
            2、固定表格布局
                1、尺寸取决于设定的值，与单元格内容无关
                2、任何情况下，都会加速显示表格(优点)
                3、不够灵活(缺点)
        推荐：
            复杂的布局不能使用table
            简单，显示数据的布局，可以使用table
</code></pre><p>4、浮动</p>
<pre><code>1、定位
    改变元素在网页中的默认位置
2、定位的分类
    按照定位效果，可以分为以下几种方式：
    1、普通流定位/文档流定位
    2、浮动定位
    3、相对定位
    4、绝对定位
    5、固定定位
3、定位-普通流定位
    普通流定位，又称为 文档流定位，网页元素默认定位方式
    1、页面中所有元素都有自己的位置
    2、按照从左到右，从上到下的方式排列
    3、块级元素 - 从上到下排列
    4、行内/行内块 - 从左到右排列

    问题：让多个块级元素在一行内显示?
4、定位 - 浮动定位
    1、浮动定位特点
        将元素设置为浮动定位，将具备以下特征
        1、会排除在文档流之外即&quot;脱离文档流&quot;，不再占据页面空间，后续元素则上前补位
        2、浮动元素只在当前行内浮动
        3、浮动元素会停靠在父元素的左边或右边或其他已浮动元素的边缘上
        4、浮动元素依然位于父元素之内
        5、解决问题-多个块级元素在一行内的显示问题
    2、语法
        属性：float
        取值：
            1、none
                默认值，即无任何浮动
            2、left
                元素左浮动
                停靠在父元素的左边 或 其他已浮动元素的右边上
            3、right
                元素右浮动
                停靠在父元素的右边 或 其他已浮动元素的左边上
    3、浮动引发的特殊效果
        1、当父元素容纳不下所有已浮动子元素，最后一个将换行显示(有可能被卡住)
        2、元素一旦浮动起来后，宽度将变成自适应(非手动指定情况下)
        3、元素一旦浮动起来后，都将变成块级元素
            块级：允许修改尺寸，允许设置上下margin
            行内元素：不能改尺寸，不能设置上下margin
        4、行内元素，行内块元素，文本 采用的是环绕的排列方式，无法被浮动元素压在底下
</code></pre><p>1、浮动定位</p>
<pre><code>1、清除浮动
    1、什么是清除浮动
        清除当前元素前面的元素浮动所带来的影响
        清除浮动影响后，当前元素不会上前占位
    2、属性
        属性：clear
        取值：
            1、none
                默认值，无清除效果
            2、left
                清除当前元素前面元素左浮动带来的影响
            3、right
                清除当前元素前面元素右浮动带来的影响
            4、both
                清除当前元素前面元素任何一种浮动方向所带来的影响
    3、浮动元素为父元素高度带来的影响
        父元素的高度是以未浮动的子元素高度为准
        如果一个元素中所有的子元素全部都是浮动的，那么该父元素的高度为 0
        解决父元素的高度问题方案：
        1、直接设置父元素高度
            弊端：必须知道父元素的高度
        2、让父元素也浮动
            弊端：对后续元素会产生影响
        3、为父元素增加溢出处理属性
            属性：overflow
            取值：hidden 或 auto
            弊端：要溢出显示的内容，也一同被隐藏
        4、在父元素中，增加空子元素到最后一个位置处,并且设置其clear属性为both
            弊端：多一个子元素在页面上
</code></pre><p>2、显示</p>
<pre><code>1、显示方式
    属性：display
    取值：
        1、none
            让指定的元素不显示 并且 不占据页面空间
            (脱离文档流)
        2、block
            将指定的元素显示为块级
        3、inline
            将指定的元素显示为行内
        4、inline-block
            将指定的元素显示为行内块
            行内块特点：
                1、多个元素能够在一行内显示
                2、允许修改尺寸
        5、table
            将指定的元素显示为 table
2、显示效果
    1、visibility 属性
        作用：规范元素可见性
        取值：
            1、visible
                默认值，元素可见
            2、hidden
                元素不可见，但是占据页面空间
            3、collapse
                用在表格元素上，删除一行或一列时，不影响表格整体布局
        面试：
            display:none 和 visibility:hidden 区别
            1、display:none; 脱离文档流，所以不占据页面空间
            2、visibility:hidden; 只是改变可见性，并不脱离文档流，空间依然占据
    2、opacity 属性
        作用：改变元素的透明度
        取值：从0.0(完全透明) ~ 1.0(完全不透明) 之间的数字
    3、vertical-align 属性
        1、在 td 中，设置文本的垂直对齐方式
        2、设置行内块元素两边文本的垂直对齐方式
        3、设置图片两端文本垂直对齐方式

        语法：
            属性：vertical-align
            取值：
                1、top
                2、middle
                3、bottom
                4、baseline
                    基线对齐
3、光标
    改变鼠标在页面(元素)中的状态
    属性：cursor
    取值：
        1、default
        2、pointer
            小手
        3、crosshair
            +
        4、text
            文本状态 I
        5、wait
            等待
        6、help
            帮助
</code></pre><p>3、列表</p>
<pre><code>1、列表项标识
    属性：list-style-type
    取值：
        1、none
        2、disc ：实心圆
        ... ...
2、列表项图像
    属性：list-style-image
    取值：url()
3、列表项标识位置
    列表项标识的默认位置是在内容区域之外
    属性：list-style-position
    取值：
        1、outside
            默认值
        2、inside
            将列表项标识的位置改为内容区域之内
4、列表属性
    属性：list-style
    取值：type url position;
    常用方式：list-style:none;
5、CSS重写
    CSS Reset，修改元素的默认样式
    body,p,h1,h2,h3,h4,h5,h6,pre,ul,ol,dl,dd{
        margin:0;
        padding:0;
        list-style:none;
    }
</code></pre><p>4、定位(相对，绝对，固定)</p>
<pre><code>1、定位属性
    1、定位属性
        属性：position
        作用：改变元素定位方式
        取值：
            1、static
                静态的，默认值
            2、relative
                相对的
            3、absolute
                绝对的
            4、fixed
                固定定位
        注意：relative，absolute，fixed被称之为 &quot;已定位元素&quot;
    2、偏移属性
        作用：改变元素在页面中的位置
        属性：
            1、top
            2、bottom
            3、left
            4、right
        取值：偏移距离(px)
    3、堆叠顺序
        作用：在已定位元素中调整堆叠顺序
        属性：z-index
        取值：无单位的数字
2、定位 - 相对定位
    1、什么是相对定位
        元素会相对于它原来的位置偏移某个距离
        元素原来所占的空间会被保留
    2、语法
        position:relative;
        配合 top/right/bottom/left 偏移属性实现位置的微调
    3、使用场合
        1、元素位置微调
3、定位 - 绝对定位
    1、什么是绝对定位 &amp; 特点
        1、绝对定位的元素会脱离文档流即不占据页面空间
        2、绝对定位的元素会相对于离它最近的已定位的祖先元素去实现定位
        3、如果没有已定位的祖先元素，那么就会相对于最初的包含块去实现定位比如body或html
    2、语法
        position:absolute;
        配合着 top/right/bottom/left 实现位置定位
    3、特点
        1、绝对定位元素会变成块级元素
        2、绝对定位元素的margin可以使用，默认情况下，auto会失效
        &lt;div id=&quot;d1&quot;&gt;(无定位)
            &lt;div id=&quot;d2&quot;&gt;(无定位)
                &lt;p id=&quot;p1&quot;&gt;(无定位)
                    &lt;span&gt;这是一个span&lt;/span&gt;
                &lt;/p&gt;
            &lt;/div&gt;
        &lt;/div&gt;
4、堆叠顺序
    属性：z-index
    取值：无单位的数值
        数值越大，越靠前，默认是0
        可以取负值，当前元素在页面所有内容之下
    注意：
        1、只有已定位元素才能设置z-index
        2、默认的堆叠顺序是 后来者居上
        3、父子元素中，永远都是子压在父上,是不受z-index影响的
</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;1、CSS概述&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;1、问题
    1、控制页面中所有的文本颜色为 红色
    2、控制页面中所有div的文本颜色 为蓝色
    3、将 所有div 的颜色 变为 黄色

    HTML元素的不足：
        1、要完成相同的效果，使
    
    </summary>
    
      <category term="学习笔记" scheme="www.wangchengzou.cn/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="CSS" scheme="www.wangchengzou.cn/tags/CSS/"/>
    
      <category term="CSS3" scheme="www.wangchengzou.cn/tags/CSS3/"/>
    
  </entry>
  
  <entry>
    <title>CSS3高级笔记</title>
    <link href="www.wangchengzou.cn/2017/07/22/CSS3%E9%AB%98%E7%BA%A7/"/>
    <id>www.wangchengzou.cn/2017/07/22/CSS3高级/</id>
    <published>2017-07-22T15:48:26.000Z</published>
    <updated>2017-07-23T10:33:13.367Z</updated>
    
    <content type="html"><![CDATA[<p>1、复杂选择器</p>
<pre><code>1、兄弟选择器
    通过兄弟级别的位置关系来匹配页面元素
    注意，兄弟选择器，只能向后找，不能向前找
    语法：
        相邻兄弟选择器：通过相邻（紧紧挨着的）位置关系匹配元素
        选择器1+选择器2
        如：div+p   #top+.important
                通用兄弟选择器：用于匹配某元素后面所有的兄弟元素
        选择器1~选择器2
        如#d1~div
2、属性选择器
    通过元素所附带的属性及其值来匹配页面中的元素
    语法：
        基础属性选择器  [attr]
            匹配页面中的有附带attr属性的元素
        elem[attr]
            elem:表示任意元素名称
            attr:表示任意属性名称
            匹配页面中附带attr属性的elem元素
            如：div[id]:匹配页面中所有附带id属性的div元素
        [attr1][attr2][attr3]
            匹配页面中同时附带attr1和attr2属性的所有元素
            如 input[name][hype]
        [attr=value]
            匹配页面中所有attr属性的值为value的元素
            如input[type=text]
        [class~=value]
            主要使用在多类选择器上，匹配页面中class属性值中包含value选择器的元素
        [attr^=value]
            匹配以value值作为开始的attr属性的元素
        [attr$=value]
            匹配以value值作为结束的attr属性的元素
        [attr*=value]
            匹配attr属性值中包含value字符的所有元素
3、伪类选择器
    目标伪类
        突出显示活动的HTML锚元素
        语法： ：target
    结构伪类
        通过元素之间的结构关系来匹配元素
        ：first-child     获取属于其父元素中的首个子元素
        ：last-child     获取属于其父元素中的尾（最后）子元素
        :nth-child(N)  获取属于其父元素中的第N个子元素
        ：empty   空的，匹配没有子元素的元素，包含文本
        ：only-child   匹配属于其父元素中的唯一子元素
    否定伪类
        把匹配某选择器元素排除出去
        ：not(选择器 )
4、伪元素选择器
    伪类与伪元素
        伪类：匹配元素不同的状态
        伪元素：是匹配元素中的内容
    语法：
        ：first-letter
        ::first-letter  匹配某元素的首字符
        ：first-line    匹配某元素的首行字符
        ：：selection 匹配用户选取的内容部分
    ：和：：区别
        在CSS2.1中，伪类选择器和仿元素选择器都是用：来表示
        在CSS3中，所有伪类选择器用：表示，所有的伪元素选择器用：：表示
</code></pre><p>2、内容生成</p>
<pre><code>通过CSS动态的向某个元素的内容区域之前、之后增加一部分内容
伪元素选择器
    ：before   定位到元素内容区域之前
    ：after    定位到元素内容区域之后
语法：
    属性：content
    取值：普通文本
         图像，url(...)
         计数器
问题处理：
    外边距溢出问题
        为父元素添加边框
        使用父元素的内边距取代子元素的外边距
        在父元素的第一个或最后一个子元素位置处增加一个空的table
    浮动元素父元素的高度问题
</code></pre><p>3、弹性布局</p>
<pre><code>flexible box,可伸缩布局，为普通布局带来更大的灵活性
基本概念‘
    flex容器：简称容器，将元素设置为flex容器后，其子元素允许实现灵活的位置摆放
    flex项目：简称项目，存放在flex容器中的内容

语法：
    容器：display
        取值：flex 将块级元素变为flex容器
              inline-flex  将行内元素变为flex容器
        注意：将元素设置为flex布局后，子元素的float,clear,vertical-align属性将失去作用
    容器属性;
        该组属性要添加在容器元素上，控制子元素的位置
        flex-direction  决定主轴的方向（main-axsis）
            取值：
                row  主轴为水平方向的轴，起点在容器左端，默认值
                row-reverse 主轴为水平方向的轴，起点在容器右端
                column  主轴为交叉轴，起点在容器的顶端
                column-reverse 主轴为交叉轴，起点在容器的底端
        flex-wrap   当一条轴线（一行）排列不下时，子元素将如何换行
            取值：
                nowrap     默认值，不换行
                wrap        换行
                wrap-reverse  反方向换行
        flex-flow   dirextion和wrap的缩写方式
            取值：
                row nowrap 默认值
                direction wrap
        justify-content   定义项目在主轴上的对齐方式
            取值：
                flex-start   主轴起点对齐
                flex-end   主轴终点对齐
                center    居中对齐
                space-between  两端对齐，项目之间的距离是相等的
                space-around  每个项目两侧间距是相等的 项目与项目之间的间距，要比项目与父元素之间的间距大一倍
        align-items  定义项目在交叉轴的对齐方式（单行项目有效）
            取值：
                flex-start  交叉轴起点对齐
                flex-end   交叉轴终点对齐
                center     交叉轴中间对齐
                baseline   基线对齐，以所有项目中的第一行文本为准
                stretch    默认值，如果项目不设置高度或为auto时，那么项目将占满整个容器的高度
        align-content  定义了多跟轴线的对齐方式，如果项目只一根轴线，该属性无效
            取值：
                flex-start   交叉轴顶端对齐
                flex-end    交叉轴底端对齐
                center      交叉轴中间对齐
                space-between  与交叉轴两端对齐
                space-around     项目与项目间对齐
    项目属性：
        该组属性主要设置于项目中
        order  定义项目在排列顺序，值越小，越靠前，默认为0
        flex-grow  指定项目的放大比例，默认为0，即不放大
        flex-shrink 指定项目的缩小比例，默认为1，即空间不足时，等比缩小，为0时不缩小
        flex-basis  指定项目占据主轴的剩余空间大小 auto 默认值，项目本身大小
        flex  是flex-grow,flex-shrink,flex-basis 的简写模式
            取值，auto  相当于1  1   auto
                 none  相当于0 0  auto
                 flex-grow【,flex-shrink,flex-basis】
        align-self  允许定义当个项目与其他项目不一样的交叉轴对齐方式（类似于align-items）,能够覆盖align-items的效果
            取值： auto 默认值，使用
                  flex-start   主轴起点对齐
                flex-end   主轴终点对齐
                center    居中对齐
                base-line
                stretch
</code></pre><p>4、CSS Hack 兼容性</p>
<pre><code>标准模式和混杂模式和准标准模式
IE6之前，没有兼容性说法
IE6之后，各个浏览器追求标准统一，开始支持标准，IE的其它浏览器要向前兼容，所以出现各种模式
    混杂模式  无标准可言
        编写代码时，不写&lt;!doctylpe&gt;就是混杂模式，采用的是IE5.5的内核进行渲染
    标准模式  安全支持
    准标准模式，即支持标准，也同时向前兼容非标准代码
如何根据不同的浏览器编写不同的css
    css类内部Hack
        在属性名称前和值添加前后缀以便识别不同的浏览器
    选择器Hack
        在选择器前添加特殊标识以便识别不同的浏览器
    头部引用hack
        通过html的条件注释来判断浏览器版本，去执行不同的CSS
        条件注释
            条件：
                gt:判断当前浏览器是否大于指定定版本
                gte：判断当前浏览器是否大于等于指定定版本
                it:   判断当前浏览器是否小于指定版本
                ite： 判断当前浏览器是否小于等于指定版本
                !：   判断当前浏览器是否为非指定版本
                    &lt;!--[if !IE 8]&gt;
                        该段内容在除IE8以外浏览器中显示
                    &lt;![endif]--&gt;
</code></pre><p>5、转换</p>
<pre><code>说明：改变元素在页面中的形状，角度 大小 位置的一种效果
    允许进行2D和3D方向的转换
    2D转换：在平面中进行的操作
    3D转换：在空间中进行的操作
转换属性：
    rtansform:为元素应用2D或3D转换效果
        取值：none;  没有效果

            transform-functions:一组转换函数
                位移转换函数：translate()
                改变形状函数：skew()
                注意：如果指定多个转换函数的话中间用空格隔开
    转换原点：
        属性：transform-origin
        默认：转换原点在元素中心处
        取值：轴线给值
            两个轴线值：X Y
            三个轴线值：X Y Z
2D转换
    位移：改变元素在页面中的位置
        语法：transform
            fransform(x)  改变元素在X轴的位置
            fransform(X ,Y)  改变元素在两轴的位置
            fransformX(X) 只在X轴上位置移动
            fransformY(Y)  只在Y轴上位置移动
    缩放： 改变元素在页面中的大小】
        语法：transform
            scale(value)  表示两轴等比缩放
                取值：默认  为1
                    放大   为大于1的数值
                    缩小   为0~1之间小数
                    返转   负数
            sacle(X,Y)
            saclex(y)
            sacley(y)
    旋转：改变元素在页面上的角度，要根据原点实现转换效果
        语法：transform
            rotate(ndeg)
                n 取值正，顺时针旋转
                n 取值负，逆时针旋转
                deg 为角度
                0~360范围
        注意：转换原点问题
            元素坐标轴也跟着旋转
    倾斜：改变元素在页面中形状
        语法：transform
            skew(xdeg)  横向倾斜指定度数
                x 取值正，y轴逆时针倾斜一定角度
                  取值负，Y轴顺时针倾斜一定角度
            skew(xdeg,ydeg)
            skewx(xdeg)
            skewy(ydeg)
3D转换
    感觉空间
    属性：perspetive 假定人眼到投射平面的距离
    注意：该属性要放在3D转换元素的父元素上
        兼容性chrome和safari需要加前缀
            -wedkit-perspective:500px;
    旋转：以X轴中心轴旋转
            rotatex(xdeg)
          以Y轴中心轴旋转
            rotatey(ydeg)
          以Z轴中心轴旋转
            rotatez(zdeg)
        取值：正  顺时针
            负   逆时针
        以多个轴同时进行旋转
            rotate3d(x ,y, z ,ndeg)
                x y z 取值为1，该轴参与旋转
                x y z  取值为0 ，该轴不参与旋转
    位移：改变元素在Z轴上的位置
        语法：transform
            translatez(z)

            transform-style
                取值：flat  默认值，子元素不保留3D位置
                     preserve-3D  子元素保留3D位置
</code></pre><p>6、过渡</p>
<pre><code>作用效果：使得css属性值在一段时间内平缓变化的效果
要素与属性：
    指定过渡属性：指定哪个属性值在变化时使用过渡效果展示
        transition-property: 属性名称（width）
                      all   全部属性
                      none
        允许设置过渡效果的属性：
            颜色属性
            渐变属性
            取值为数字属性
            转换属性 transition-property:transform;
            visibility属性
            阴影属性
    指定过渡时长
        transition-duration: 以S、MS为单位数值
    指定过渡时速曲线函数  可选
        transition-timing-function
            取值：ease  默认值，慢速开始，快速变快，慢速结束
                 linear  匀速进行
                 ease-in   慢速开始，快速结束
                 ease-out  快速开始，慢速结束
                 ease-in-out  慢速开始和结束，先加速后减速
    指定过渡的延迟时间   可选
        transition-delay
            取值：以S或MS做为单位
    简写属性：transition:prop duration  timing-fun delay;
        多个过渡效果
            transition:prop1 duration1 timing-fun1 delay1,prop2 duration2 timing-fun2 delay2........;
触发过渡条件
    将过渡编写在元素声明的样式中，由:hover,:active等，进行触发,
    将过渡编写在:hover,:active伪类中
</code></pre><p>7、动画</p>
<pre><code>使元素从一种样式逐渐变化为另一种样式的过程，与动画相关的属性，增加浏览器前缀
动画使用步骤
    声明动画
        指定动画名称
        指定动画中的关键帧（keyframes）
            时间点（以百分比描述时间）
            元素状态（CSS样式）
    为元素调用动画
        指定调用动画的名称以及执行时长
语法：
    声明动画     注意前缀，兼容性问题
        &lt;style&gt;
            @keyframes 名称{
                0%{   动画开始时，元素的状态   }
                。。。。
                100%{  动画结束时，元素的状态  }
            }
        &lt;/style&gt;
    调用动画(animation)
        animation-name  指定调用动画名称
        animation-duration   指定动画周期时长，以S或MS为单位
        animation-timing-function  指定动画的速度时间出线函数
            取值：ease  默认值，慢速开始，快速变快，慢速结束
                 linear  匀速进行
                 ease-in   慢速开始，快速结束
                 ease-out  快速开始，慢速结束
                 ease-in-out  慢速开始和结束，先加速后减速
        animation-delay  指定动画延迟时间
        animation-iteration-count  指定动画播放次数
            取值：默认1次，具体数值
                infinite:无限次播放
        animation-direction  指定动画的播放方向
            取值：normal  从0%~100%
                reverse  从100%~0%
                alternate  轮流来回播放 奇数 0%~100%
                                 偶数 100%~0%
        animation  简写方式
            取值：name  duration  timing-fun delay  iteration-count direction;
        animation-fill-mode  指定动画播放之前、之后的填充模式
            取值：none  默认值
                 forwards  动画播放完成后，保持在最后一帧的位置
                 backwards 动画播放前，延迟时间内，动画保持在开始第一帧上的位置
                 both 同时应用在开始和最后的位置帧上
        animation-play-state  动画播放状态
            取值：paused 暂停
                 running 播放
</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;1、复杂选择器&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;1、兄弟选择器
    通过兄弟级别的位置关系来匹配页面元素
    注意，兄弟选择器，只能向后找，不能向前找
    语法：
        相邻兄弟选择器：通过相邻（紧紧挨着的）位置关系匹配元素
        选择器1+选
    
    </summary>
    
      <category term="学习笔记" scheme="www.wangchengzou.cn/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="CSS" scheme="www.wangchengzou.cn/tags/CSS/"/>
    
      <category term="CSS3" scheme="www.wangchengzou.cn/tags/CSS3/"/>
    
  </entry>
  
  <entry>
    <title>CSS选择符有哪些？哪些属性可以继承</title>
    <link href="www.wangchengzou.cn/2017/07/22/CSS%E9%80%89%E6%8B%A9%E7%AC%A6%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F%E5%93%AA%E4%BA%9B%E5%B1%9E%E6%80%A7%E5%8F%AF%E4%BB%A5%E7%BB%A7%E6%89%BF/"/>
    <id>www.wangchengzou.cn/2017/07/22/CSS选择符有哪些？哪些属性可以继承/</id>
    <published>2017-07-22T15:48:26.000Z</published>
    <updated>2017-07-23T07:53:18.490Z</updated>
    
    <content type="html"><![CDATA[<p> 1.id选择器（ # myid）<br> 2.类选择器（.myclassname）<br> 3.标签选择器（div, h1, p）<br> 4.相邻选择器（h1 + p）<br> 5.子选择器（ul &gt; li）<br> 6.后代选择器（li a）<br> 7.通配符选择器（ * ）<br> 8.属性选择器（a[rel = “external”]）<br> 9.伪类选择器（a:hover, li:nth-child）</p>
<ul>
<li>可继承的样式： font-size font-family color, UL LI DL DD DT;</li>
<li>不可继承的样式：border padding margin width height ;</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt; 1.id选择器（ # myid）&lt;br&gt; 2.类选择器（.myclassname）&lt;br&gt; 3.标签选择器（div, h1, p）&lt;br&gt; 4.相邻选择器（h1 + p）&lt;br&gt; 5.子选择器（ul &amp;gt; li）&lt;br&gt; 6.后代选择器（li a）&lt;br&gt; 7.通配符
    
    </summary>
    
      <category term="面试题目" scheme="www.wangchengzou.cn/categories/%E9%9D%A2%E8%AF%95%E9%A2%98%E7%9B%AE/"/>
    
    
      <category term="html" scheme="www.wangchengzou.cn/tags/html/"/>
    
      <category term="css" scheme="www.wangchengzou.cn/tags/css/"/>
    
  </entry>
  
  <entry>
    <title>DOM_BOM笔记</title>
    <link href="www.wangchengzou.cn/2017/07/22/DOM_BOM%E7%AC%94%E8%AE%B0/"/>
    <id>www.wangchengzou.cn/2017/07/22/DOM_BOM笔记/</id>
    <published>2017-07-22T15:48:26.000Z</published>
    <updated>2017-07-23T10:57:34.367Z</updated>
    
    <content type="html"><![CDATA[<ol>
<li><p>DOM: Document Object Model</p>
<p> DOM是专门操作网页内容的API标准<br> 为什么: 早起js操作不同浏览器的API没有标准，有严重兼容性问题<br> 所以，W3C制定了统一的操作网页内容的API标准,所有浏览器厂商都遵照执行。<br> 结果，使用DOM API操作网页内容，几乎100%兼容所有浏览器<br> 何时: 只要操作网页内容，就用DOM API查找, 修改(内容,属性,样式), 添加, 删除.</p>
</li>
</ol>
<p>DOM Tree:</p>
<pre><code>什么是: 网页中一切内容在内存中都是以树形结构存储的
       网页中每一项内容都是树上的一个节点对象
       包括: 元素, 文字, 属性...
       树只有一个根节点: document, 包含了所有网页内容
Node: 每个节点都是一个node类型的对象
      node是所有节点的父类型
</code></pre><p>三大公共: nodeType  nodeName  nodeValue</p>
<pre><code>nodeType: 节点的类型
  值: document   9
     element     1
     attribute     2
     text         3
  何时: 只要判断节点类型，就用nodeType
        因为不同类型的节点，能执行的操作是不一样的
  问题: 不能进一步区分元素的名称
  解决:
nodeName: 节点的名称
  值: document   #document
     element    全大写的标签名
     attribute    属性名
     text        #text
  何时: 只要细致鉴别元素的标签名时
    强调: nodeName返回的是全大写的标签名
nodeValue: 节点值:
  值: document   null
     element     null
     attribute     属性值
     text         文本内容
</code></pre><p>2、查找: 4种:</p>
<pre><code>  a. 不需要查找，可直接获得的元素
        html   document.documentElement
        head   document.head
        body   document.body
  b. 按节点间关系查找:
节点树: 包含所有节点: 元素和文本
  1. 父子: elem.parentNode  找elem的父节点
        elem.childNodes  找elem的所有*直接*子节点
            返回，所有直接子节点组成的集合(类数组)
        elem.firstChild   找elem的第一个*直接*子节点
        elem.lastChild   找elem的最后一个*直接*子节点
  2. 兄弟: elem.previousSibling 找elem的前一个兄弟
        elem.nextSibling   找elem的下一个兄弟
 何时: 前提: 已经获得了一个节点
      要找周围临近的节点时
 问题: 连看不见的空字符，也算文本节点——干扰
 解决:
元素树: 仅包含元素节点的树结构
       不是一棵新树，仅是节点树的子集
 1. 父子: elem.parentElement  找elem的父元素
        elem.children  找elem的所有*直接*子元素
            返回，所有直接子元素组成的集合(类数组)
        elem.firstElementChild   第一个*直接*子元素
        elem.lastElementChild   最后一个*直接*子元素
 2. 兄弟:
   elem.previousElementSibling 找elem的前一个兄弟元素
   elem.nextElementSibling   找elem的下一个兄弟元素
 何时: 只要仅关心元素节点，不关心文本节点时
 问题: IE9+
 强调: childNodes和children返回的都是动态集合！
   凡是遍历动态集合，都要先缓存元素个数，再遍历
   for(var i=0,len= childNodes.length;i&lt;len;i++)
     不会导致反复查找DOM树
</code></pre><p>3、 按HTML查找:</p>
<pre><code>    优: 范围可大可小,可设置条件
a、按id查找: var elem=document.getElementById(&quot;id&quot;)
  强调: 1. 只能在document对象上调用
       2. 返回一个元素对象
b、按标签名查找:
    var elems=parent.getElementsByTagName(&quot;标签名&quot;);
  强调: 1. 可在任意父元素上
       2. 返回多个元素组成的集合
       3. 不但查找直接子元素，还查找所有后代元素
c、按name属性查找: 了解
   专门找表单中有name属性的表单元素
    var elems=document.getElementsByName(&quot;name&quot;)
    强调: 1. 只能在document上调用
         2. 返回多个元素组成的集合
d、按class属性查找:
    var elems=parent.getElementsByClassName(&quot;class&quot;)
    强调: 1. 可在任意父元素上调用
         2. 返回多个元素组成的集合
         3. 不要求完整匹配，只要包含即可！
缺: 每次只能按一个条件查找
   如果条件复杂，就无法一句话获得想要的元素
</code></pre><p>4、 按选择器查找:</p>
<pre><code>a. 只找一个元素:
  var elem=parent.querySelector(&quot;selector&quot;);
b. 找多个元素
  var elems=parent.querySelectorAll(&quot;selector&quot;);
</code></pre><p>5、 总结:</p>
<pre><code> A首次查找:
    1. 如果条件简单: 按HTML查找: id, 标签, className
    2. 如果条件复杂: 按选择器查找:
 B已经获得一个元素，找周围相邻: 按节点间关系
鄙视: 按HTML查找 vs 按选择器查找
 1.使用的难易程度: 当条件复杂时:
    按选择器查找——简单, 按HTML查找——繁琐
 2.返回值:
    getElementsByTagName() 返回多个元素的*动态*集合
      什么是动态集合: 不实际存储对象的属性值，每次访问，都要重新查找DOM树
    querySelectorAll()  返回多个元素的*非动态*集合
      什么是非动态集合: 实际存储对象的所有属性值，即使反复访问集合，也不会导致反复查找DOM树
 3.单次效率:
    按HTML查找——效率高!
    按选择器查找——效率低
</code></pre><p>3、 修改: (内容, 属性, 样式)</p>
<pre><code>1. 修改:
标准属性: 2种:
  1. 核心DOM: 操作一切结构化文档的API(HTML，XML)
    elem.attributes集合: 保存了当前元素的所有属性节点
    获取属性值: elem.getAttribute(&quot;属性名&quot;)
    修改属性值: elem.setAttribute(&quot;属性名&quot;,&quot;值&quot;)
    判断是否包含属性: elem.hasAttribute(&quot;属性名&quot;)
    移除属性: elem.removeAttribute(&quot;属性名&quot;)
  2. HTML DOM: 对部分常用DOM API的简化版本
     HTML DOM将标准属性都预定义在元素对象中
    获取属性值: elem.属性名
    修改属性值: elem.属性名=&quot;值&quot;;
    判断是否包含属性: elem.属性名===&quot;&quot; 不包含
    移除属性: elem.属性名=&quot;&quot;
    特例: class属性和ES标准中的class重名
          -&gt; DOM -&gt; className
    自定义属性: 比如: data-toggle=&quot;dropdown&quot;
      HTML DOM不能操作自定义属性
      暂时只能用核心DOM操作:
    三大状态: disabled  selected   checked
      核心DOM无法操作三大状态属性
      HTMLDOM: elem.disabled elem.selected  elem.checked
            值都是bool类型true/false
</code></pre><p>3.1、修改css样式:</p>
<pre><code>1. 仅获取/修改内联样式:  elem.style.css属性名
  问题1: css属性名有的带-
  解决: 所有css属性名都要去横线变驼峰
     比如: background-color: backgroundColor
          list-style-type: listStyleType
  问题2: 所有数值类型的属性值都是带单位的字符串
  解决: 获取时: 都要去单位，转数值
        修改时: 将单位拼回数值
  问题3: 仅能获得内联样式, 无法获得样式表中的样式
  解决: 计算后的样式: 最终应用到元素上的完整样式
    何时: 只要希望获得元素完整的样式时
    如何: 2步:
      1. 获得完整样式对象style
        var style=getComputedStyle(elem)
      2. 获得style对象中的css属性
        style.css属性名
     强调: style对象中的样式都是只读
结论: 1. 获取样式: getComputedStyle
     2. 修改样式: elem.style.css属性名
2. 运行时修改样式表中的样式:
  Step1: 获得样式表对象:
   var sheet=document.styleSheets[i]
  Step2: 获得样式表对象中某个CSSRule(一个选择器{})
   var rule=sheet.cssRules[i]
  Step3: 修改rule.style.css属性名=值
</code></pre><p>4、 添加和删除:</p>
<pre><code>添加: 3步:
 Step1: 创建空元素:
  var a=document.createElement(&quot;a&quot;);
  &lt;a&gt;&lt;/a&gt;
 Step2: 设置关键属性:
     a.href=&quot;http://tmooc.cn&quot;
     a.innerHTML=&quot;go to tmooc&quot;;
  &lt;a href=&quot;http://tmooc.cn&quot;&gt;go to tmooc&lt;/a&gt;
 Step3: 将元素添加到DOM树: 3种:
   1. 末尾追加: parent.appendChild(child)
   2. 中间插入: parent.insertBefore(child, oldChild)
   3. 替换: parent.replaceChild(child, oldChild)
</code></pre><p>优化: 尽量少的修改DOM树</p>
<pre><code>原因: 页面加载过程:
  html -&gt; DOM Tree(松树)
           ↓
        render Tree(圣诞树)-&gt; layout(计算绝对布局)-&gt;paint
           ↑                 最耗时
  css  -&gt; cssRules(装饰品)
  每次修改DOM树，都会导致重新layout，耗时。
如何: 2种:
 1. 如果同时添加父元素和子元素时，应该先在内存将子元素都添加到父元素中，再将父元素一次性整体添加到DOM树
    结果: 只触发一次layout
</code></pre><p>1、 HTML DOM 常用对象: 对常用HTML元素操作的简化</p>
<pre><code>Select: 代表页面上的一个select元素
 属性: select.value 当前选中项的value
                 没有value，就返回选中项的内容
      select.options 保存select下所有option元素对象
        相当于: select.getElementsByTagName(&quot;option&quot;)
        select.options.length 保存select下option的个数
        清空select下所有option: select.options.length=0;
      select.length 等效于select.options.length
        清空select下所有option: select.length=0;
                               select.innerHTML=&quot;&quot;;
      select.selectedIndex 当前选中项的下标
  事件: onchange 当选中项发生改变时
  方法: select.add(option) 向select中添加一个option
         相当于: select.appendChild(option)
         不支持文档片段
       select.remove(i) 移除select中i位置的一个option
Option: 代表页面上的一个option元素
  创建: var opt=new Option(text,value);
     创建一个option对象，同时设置opt的内容为text，设置opt的值为value
     相当于: var opt=document.createElement(&quot;option&quot;);
            opt.innerHTML=text;
            opt.value=value;
  属性: .text 代替.innerHTML
       .index  表示当前option在select下的下标位置
</code></pre><p>Table: 代表网页中一个table元素</p>
<pre><code> 管着行分组：
   添加行分组: var 行分组=table.createTHead|TBody|TFoot();
       强调: 即创建，同时又将行分组添加到table
   删除行分组: table.deleteTHead|TFoot()
   获取行分组: table.tHead|tFoot
              table.tBodies[i]
行分组: THead TBody TFoot
  管着行:
   添加行: var tr=行分组.insertRow(i)
       在行分组中i位置插入一个新行
       强调: 中间插入行，原i位置的行向后顺移
       固定套路: 1. 末尾追加一个新行: 行分组.insertRow()
                2. 开头插入: 行分组.insertRow(0)
   删除行: 行分组.deleteRow(i)
       删除行分组中第i行
       强调: i是当前行在行分组内的相对下标位置
   获取行: 行分组.rows

行: tr
  管着td:
    添加td: var td=tr.insertCell(i);
        省略i表示右侧末尾追加
        insertCell不支持添加th，只能添加td
    删除td: tr.deleteCell(i);
    获取td: tr.cells

删除行:
 tr上都有一个属性: tr.rowIndex 行在整个表的绝对下标
 问题：行分组，无法使用tr.rowIndex删除行。
 解决: table.deleteRow(tr.rowIndex)
 总结: 今后，删除行都用table.deleteRow(tr.rowIndex)
</code></pre><p>form: 代表页面上一个表单元素</p>
<pre><code> 获取: var form=document.forms[i/id]
 属性: form.elements 保存了表单中所有表单元素的数组
        包括: input   select   textarea  button
      form.elements.length 获得表单中表单元素的个数
      form.length =&gt; form.elements.length
 方法: form.submit();  用于手动提交表单
 事件: form.onsubmit  以任何方式提交表单之前自动触发
          常用于在提交之前，验证所有表单元素的内容
表单元素:
 获取: var elem=form.elements[i/id/name]
        简写: 如果表单元素有name属性: form.name
 方法: elem.focus() 让elem获得焦点
      elem.blur()  让elem失去焦点

Image: 代表页面上一个img元素
  创建: var img=new Image();
</code></pre><p>DOM总结: 查找-&gt;绑定事件-&gt;查找-&gt;修改/添加/删除</p>
<pre><code>查找: 4种:
  1. 不需要查找可直接获得: html  head  body  form
  2. 节点间关系: 节点树/元素树
      鄙视: 递归遍历
  3. 按HTML: 4种: ById, ByTagName, ByName, ByClassName
  4. 按选择器: 2种:
      只找一个: querySelector()
      找多个: querySelectorAll()
修改:
  内容: .innerHTML  .textContent/.innerText  .value
  属性:
    1. 标准属性: 1. 核心DOM; 2. HTML DOM
    2. 自定义属性: 核心DOM
    3. 状态属性: HTML DOM
  样式:
    修改: elem.style.css属性=值
    获取: var style=getComputedStyle(elem)
         style.css属性 ——只读
    可通过修改class属性批量应用修改多个css属性
添加: 3步:
   1. createElement,
   2.设置关键属性,
   3. appendChild/insertBefore/replaceChild
  优化: 尽量少的操作DOM树
  如何: 2种:
   1. 同时添加父子元素: 先将子元素加入父元素，再将父元素整体添加到页面
   2. 同时添加多个平级子元素: fragment
删除: parent.removeChild(child)
HTML DOM: Select/Option  Table/...  From/Element  Image
过渡动画: 2步:
  css中: 添加transition
  js中: 修改css属性值
   不支持transition: display  zIndex
   支持: width  height  opacity   bottom/top/left/right ...
</code></pre><p>2、BOM: Browser Object Model</p>
<pre><code>什么是: 专门操作浏览器窗口的API
比如: alert prompt confirm
问题: 1. 没有标准——兼容性问题;
     2. 不可定制
window对象: 2个角色:
  1. 代替ES中的Global充当全局作用域对象
  2. 封装所有BOM和DOM的API

打开超链接: 4种:
  1. 在当前窗口打开，可后退
    html: &lt;a href=&quot;url&quot; target=&quot;_self&quot;&gt;&lt;/a&gt;
    js: /*window.*/open(&quot;url&quot;,&quot;_self&quot;)
  2. 在当前窗口打开，不可后退
    js: location.replace(&quot;url&quot;);
       用新url代替history中当前url，结果: 无法后退
  3. 在新窗口打开，可打开多个
    html: &lt;a href=&quot;url&quot; target=&quot;_blank&quot;&gt;&lt;/a&gt;
    js: open(&quot;url&quot;,&quot;_blank&quot;)
  4. 在新窗口打开，只能打开一个
    html: &lt;a href=&quot;url&quot; target=&quot;自定义name属性值&quot;&gt;&lt;/a&gt;
    js: open(&quot;url&quot;,&quot;自定义name属性值&quot;)
    原理: 内存中每个窗口都有一个唯一的name属性来唯一标示一个窗口
      浏览器规定，相同name属性的窗口只能打开一个
    其实: html中的target属性就是在设置新窗口的name属性值。
    如果target中使用自定义的窗口名，则只能打开一个
    预定义:
      _self: 默认使用当前窗口自己的name属性
           结果，新窗口覆盖当前窗口
      _blank: 意为不指定窗口名, 浏览器会随机生成不同的窗口名。
           结果: 每次打开新窗口都随机生成不同的name
                 结果: 可打开任意多个
</code></pre><p>定时器: 2种:</p>
<pre><code>1. 周期性定时器:
  什么是: 让程序按照指定时间间隔，反复执行一项任务
  何时: 只要让程序按照指定时间间隔，反复执行一项任务
  如何: 3件事:
    1. 任务函数: 让定时器反复调用的函数
    2. 启动定时器:
     var timer=setInterval(任务函数, 间隔的毫秒数)
    3. 停止定时器: clearInterval(timer)
        问题: timer中的序号会残留在timer变量中
        解决: 停止定时器后，主动清空timer
             timer=null
  停止定时器: 2种:
    1. 用户手动停止定时器: 用按钮调用clearInterval
    2. 自动停止定时器: 在任务函数中:
       1. 设定临界条件
       2. 如果达到临界条件就自动调用clearInterval

2. 一次性定时器:
 什么是: 让程序先等待一段时间，再自动执行一次任务
         执行一次后，定时器自动停止
 何时: 只要先等待，再执行一次任务
 如何: 三件事
   1. 任务函数
   2. 启动: var timer=setTimeout(任务函数, 等待的毫秒数)
   3. 停止: clearTimeout(timer)
</code></pre><p>鄙视: 定时器中的函数，只能在主程序所有程序执行后才能执行</p>
<pre><code>for(var i=0;i&lt;3;i++){
  setTimeout(function(){
    console.log(i);
  },0);
}//结果: 3 3 3
//alert(&quot;Hello&quot;) 如果不点确定，则永远不输出333
</code></pre><p>window:<br> history，location，document，navigator，screen，event</p>
<pre><code>history: 保存当前窗口打开后，成功访问过的历史记录的栈
  history封装的非常严密
  只能前进，后退，刷新: history.go(n)
   前进: go(1)  后退:go(-1)  刷新:go(0)

location: 专门保存当前窗口正在打开的url的对象
 属性: location.href 保存了完整的url
        在当前窗口打开: location.href=新url
      location.protocol: 协议
            .host: 主机名+端口号
            .hostname: 主机名
            .port: 端口号
      location.pathname: 相对路径
            .hash: 锚点地址#xxx
            .search: 表单提交后地址栏中的查询字符串
                   ?变量名=值&amp;变量名=值&amp;...
 方法:
   1. 替换history中当前url,实现进制后退:
     location.replace(&quot;新url&quot;)
   2. 在当前页面打开，可后退:
     location.assign(&quot;新url&quot;)
       =&gt; location.href=&quot;新url&quot;
        =&gt; location=&quot;新url&quot;
   3. 刷新页面:  location.reload(false/true);
     鄙视: false/true的差别
       浏览器本地是有缓存的
         浏览器的缓存中会保存css，图片等静态资源
       每次请求时，首先查看缓存中是否有想要文件
         没有想要文件，或文件过期，才去服务器下载新文件
       reload(false) 优先使用本地缓存的文件
       reload(true) 强制去服务器下载新文件
     查 浏览器缓存的原理！
</code></pre><p>1、event</p>
<pre><code>绑定事件: 2种:
 1. 在HTML中绑定: &lt;ANY on事件名=&quot;js语句&quot;
    问题: 不符合内容与行为分离的原则——不便于维护
 2. 在js中动态绑定: 2种:
    1. 一个事件只绑定一个处理函数:
       elem.on事件名=function(){
         //this-&gt;elem
       }
       解除绑定: elem.on事件名=null;
       问题: 每个事件只能绑定一个处理函数
       解决:
    2. 一个事件可同时绑定多个处理函数:
       elem.addEventListener(&quot;事件名&quot;,function(){
         //this-&gt;elem
       })
       解除绑定:
        elem.removeEventListener(&quot;事件名&quot;,&quot;函数名&quot;);
        强调: 如果一个事件处理函数可能被动态移除，则绑定时，不能使用匿名函数，必须使用有名称的函数

    事件模型: DOM标准: 3个阶段
      1. 捕获: 由外向内，记录各级父元素绑定的事件处理函数
      2. 目标触发: 首先执行目标元素上的事件处理函数
      3. 冒泡: 由内向外，反向执行捕获阶段记录的处理函数

    事件对象: 事件发生时自动创建的
             封装事件信息
             提供操作事件的API 的对象
      何时: 只要希望获得事件信息或修改事件的默认行为
      如何: 事件对象，在事件发生时，通常作为事件处理函数的第一个参数，默认自动传入！
          .on事件名=function(e){
             //e会自动获得事件对象
          }
    阻止蔓延/冒泡: e.stopPropagation();
    利用冒泡:
      优化: 尽量少的添加事件监听
      原理: 因为浏览器触发事件监听，是采用遍历查找的方式。添加的监听越多，遍历的速度越慢
      如何: 如果多个子元素都要绑定相同的事件
          只要在父元素绑定一次，所有子元素即可共用
      难题:
         1. 获得目标元素:
            不能用this, 因为this指父元素
            应该用e.target，保存实际点击的目标元素
         2. 鉴别目标元素:
            先判断目标元素的nodeName或className...
            只有目标元素符合要求时，才执行事件操作
    取消事件/阻止默认行为: e.preventDefault();
    事件坐标: 3对儿:
      1. 相对于整个屏幕左上角的坐标: e.screenX|screenY
      2. 相对于文档显示区左上角的坐标: e.clientX|clientY
      3. 相对于当前元素左上角的坐标: e.offsetX|offsetY

    页面滚动:
      事件: window.onscroll
      获得页面滚动位置: document.body.scrollTop
          页面超出文档显示区顶部的距离
</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;ol&gt;
&lt;li&gt;&lt;p&gt;DOM: Document Object Model&lt;/p&gt;
&lt;p&gt; DOM是专门操作网页内容的API标准&lt;br&gt; 为什么: 早起js操作不同浏览器的API没有标准，有严重兼容性问题&lt;br&gt; 所以，W3C制定了统一的操作网页内容的API标准,所有浏览器厂商
    
    </summary>
    
      <category term="学习笔记" scheme="www.wangchengzou.cn/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="javaScript" scheme="www.wangchengzou.cn/tags/javaScript/"/>
    
      <category term="DOM" scheme="www.wangchengzou.cn/tags/DOM/"/>
    
      <category term="BOM" scheme="www.wangchengzou.cn/tags/BOM/"/>
    
  </entry>
  
  <entry>
    <title>Html5基础知识</title>
    <link href="www.wangchengzou.cn/2017/07/22/HTML5/"/>
    <id>www.wangchengzou.cn/2017/07/22/HTML5/</id>
    <published>2017-07-22T15:48:26.000Z</published>
    <updated>2017-07-23T16:50:23.596Z</updated>
    
    <content type="html"><![CDATA[<p>一、HTML5新特性 —— 十个新特性：凌乱</p>
<pre><code>(1)新的语义标签
(2)增强型表单(表单2.0)
(3)音频和视频
(4)Canvas绘图
(5)SVG绘图
(6)地理定位
(7)拖放API
(8)Web Worker
(9)Web Storage
(10)Web Socket
</code></pre><p>二、HTML5中表单的新特性</p>
<pre><code>(1)新的input type      &lt;input type=&quot;?&quot;&gt;
  H4中的input type：text、password、radio、checkbox、file、hidden、submit、reset、image
  H5中的input type：email、url、number、tel、search、range、color、date、month、week
(2)新的表单元素
  H4中的表单元素：input、textarea、select/option、label
  H5中新增的表单元素：datalist、progress、meter、output
(3)表单元素的新属性
</code></pre><p>三、H5中新增的表单元素 —— datalist</p>
<pre><code>&lt;datalist id=&quot;list3&quot;&gt;        datalist本身不可见
  &lt;option&gt;XX&lt;/option&gt;
  &lt;option&gt;YY&lt;/option&gt;
&lt;/datalist&gt;
&lt;input type=&quot;text&quot; list=&quot;list3&quot;&gt;
  datalist为input提供输入建议列表，用户可以从中选取，也可以手工输入
</code></pre><p>四、H5中新增的表单元素 —— progress</p>
<pre><code>显示一个进度条，有两种形式：
&lt;progress&gt;&lt;/progress&gt; 左右晃动的进度条
&lt;progress value=&quot;0.7&quot;&gt;&lt;/progress&gt; 具有指定进度值的进度条
</code></pre><p>五、H5中新增的表单元素 —— meter</p>
<pre><code>Meter：度量衡、刻度尺，用于标示一个值所处的范围：不可接受(红色)、可以接受(黄色)、非常优秀(绿色)
&lt;meter min=&quot;可取的最小值&quot; max=&quot;可取的最大值&quot; low=&quot;合理的下限值&quot;
      high=&quot;合理的上限值&quot; optimum=&quot;最佳值&quot;  value=&quot;当前实际值&quot;&gt;
&lt;/meter&gt;
</code></pre><p>六、H5中新增的表单元素 —— output</p>
<pre><code>output：输出，语义标签，没有任何外观样式，样式上等同于SPAN。
  商品单价: ￥3.50
购买数量：&lt;input type=&quot;number&quot; value=&quot;1&quot;&gt;
小计：&lt;output&gt;￥3.50&lt;/output&gt;
</code></pre><p>七、H5表单新特性 —— 表单元素的新属性</p>
<pre><code>H4中表单元素的属性：  &lt;input ?&gt;
  id、class、title、style、type、value、name、readonly、disabled、checked
H5中表单元素的新属性：
  (1)placeholder：占位字符
    &lt;input value=&quot;tom&quot; placeholder=&quot;请输入用户名&quot;&gt;
  (2)autofocus：自动获取输入焦点
    &lt;input autofocus&gt;
  (3)multiple：允许输入框中出现多个输入（用逗号分隔），如邮箱输入域
    &lt;input type=&quot;email&quot; multiple&gt;
  (4)form：用于把输入域放置到FORM外部
    &lt;form id=&quot;f5&quot;&gt;&lt;/form&gt;
    &lt;input form=&quot;f5&quot;&gt;
  ====输入验证相关的新属性======
  (5)required：必填项，内容不能为空
    &lt;input required&gt;
  (6)maxlength：指定字符串的最大长度
    &lt;input maxlength=&quot;9&quot;&gt;
  (7)minlength：指定字符串的最小长度
    &lt;input minlength=&quot;6&quot;&gt;
  (8)max：指定数字的最大值
    &lt;input max=&quot;60&quot;&gt;
  (9)min：指定数字的最小值
    &lt;input min=&quot;18&quot;&gt;
  (10)pattern：指定输入必需符合的正则表达式
    &lt;input pattern=&quot;1[35789]\d{9}&quot;&gt;
  上述验证属性会影响表单元素对应的JS对象的validity属性。
</code></pre><p>九、H5新特性——视频播放</p>
<pre><code>H5提供了一个新的标签用于播放视频：
  &lt;video src=&quot;res/birds.mp4&quot;&gt;&lt;/video&gt;
  &lt;video&gt;
          &lt;source src=&quot;res/birds.mp4&quot;&gt;
          &lt;source src=&quot;res/birds.ogg&quot;&gt;
          &lt;source src=&quot;res/birds.webm&quot;&gt;
          您的浏览器不支持VIDEO播放！
  &lt;/video&gt;
它本身是一个300*150的inline-block元素。
VIDEO标签/对象常用的成员：
成员属性：
  autoplay：false，是否自动播放
  controls：false，是否显示播放控件
  loop：false，是否循环播放
  muted：false，是否静音播放
  poster：&apos;&apos;，在播放第一帧之前显示的海报
  preload：视频的预加载策略，可取值：
      auto：预加载视频的元数据以及缓冲一定时长
      metadata：仅预加载视频的元数据(尺寸、时长、第一帧内容)，没有视频缓冲
      none：不预加载任何数据
   -------------JS对象属性---------------------
  currentTime：当前播放的时长
  duration：总时长
  paused：true，当前视频是否处于暂停状态
  volume：1，当前音量
  playbackRate：1，回放速率，大于1表快放，小于1表慢放
成员方法：
  play( )： 播放视频
  pause( )： 暂停播放
成员事件：
  onplay：    当视频开始播放时触发的事件
  onpause：当视频开始暂停时触发的事件
</code></pre><p>十、H5新特性——音频播放</p>
<pre><code>H5提供了一个新的标签用于播放音频：
  &lt;audio src=&quot;res/bg.mp3&quot;&gt;&lt;/audio&gt;
  &lt;audio&gt;
          &lt;source src=&quot;res/bg.mp3&quot;&gt;
          &lt;source src=&quot;res/bg.ogg&quot;&gt;
          &lt;source src=&quot;res/bg.wav&quot;&gt;
          您的浏览器不支持AUDIO播放！
  &lt;/audio&gt;
它默认是一个300*30的inline-block元素；但若没有controls属性，则display:none。
AUDIO标签/对象常用的成员：
成员属性：
  autoplay：false，是否自动播放
  controls：false，是否显示播放控件
  loop：false，是否循环播放
  muted：false，是否静音播放
  preload：视频的预加载策略，可取值：
      auto：预加载视频的元数据以及缓冲一定时长
      metadata：仅预加载视频的元数据(尺寸、时长、第一帧内容)，没有视频缓冲
      none：不预加载任何数据
   -------------JS对象属性---------------------
  currentTime：当前播放的时长
  duration：总时长
  paused：true，当前视频是否处于暂停状态
  volume：1，当前音量
  playbackRate：1，回放速率，大于1表快放，小于1表慢放
成员方法：
  play( )： 播放视频
  pause( )： 暂停播放
成员事件：
  onplay：    当视频开始播放时触发的事件
  onpause：当视频开始暂停时触发的事件
</code></pre><p>十一、网页中可用的绘图技术</p>
<pre><code>  网页中的实时走势图、统计图、在线画图板、网页游戏、地图应用都要使用到绘图技术。有三种绘图技术：
  (1)SVG绘图：2D矢量绘图技术，2000年出现，后纳入H5标准
  (2)Canvas绘图：2D位图绘图技术，H5提出的绘图技术
  (3)WebGL绘图：3D绘图技术，尚未纳入H5标准

Canvas绘图难点所在：
(1)坐标系
(2)单词比较多
</code></pre><p>十二、H5新特性——Canvas绘图技术</p>
<pre><code>Canvas：画布，是H5提供的2D绘图技术。
  &lt;canvas width=&quot;500&quot; height=&quot;400&quot;&gt;
      您的浏览器不支持Canvas标签！
  &lt;/canvas&gt;
CANVAS标签在浏览器中默认是300*150的inline-block。
画布的宽和高只能使用HTML/JS属性来赋值，不能使用CSS样式赋值！
每个画布上有且只有一个“画笔”对象——称为“绘图上下文”对象——使用该对象进行绘图！
  var ctx = canvas.getContext(&apos;2d&apos;)  //得到画布上的画笔对象
  (1)使用Canvas绘制矩形
      矩形的定位点在自己的左上角
      ctx.lineWidth = 1            描边宽度
      ctx.fillStyle = &apos;#000&apos;        填充样式/颜色
      ctx.strokeStyle = &apos;#000&apos;        描边样式/颜色
      ctx.fillRect( x, y, w, h )        填充一个矩形
      ctx.strokeRect( x, y, w, h )    描边一个矩形
      ctx.clearRect( x, y, w, h )        清除一个矩形范围内所有的绘图
  (2)使用Canvas绘制文本
    一段文字的定位点在其文本基线的起点
      ctx.textBaseline = &apos;alphabetic&apos;    文本基线
      ctx.font = &apos;12px sans-serif&apos;    文本大小和字体
      ctx.fillText( str, x, y )            填充一段文本
      ctx.strokeText( str, x, y )        描边一段文本
      ctx.measureText( str )    基于当前文字大小字体设置测量文本，返回一个对象：{width: x}
</code></pre><p>十三、Canvas绘图中使用渐变对象</p>
<pre><code>线性渐变： linearGradient
径向渐变： radialGradient
可以参考PS中的渐变效果。
var g = ctx.createLinearGradient( x1, y1,  x2,  y2 );
g.addColorStop( offset,  color )
....
g.addColorStop( offset,  color )
ctx.strokeStyle = g;
ctx.fillStyle = g;
</code></pre><p>十四、Canvas：是H5提供的2D位图绘图技术。</p>
<pre><code>&lt;canvas id=&quot;c1&quot; width=&quot;500&quot; height=&quot;400&quot;&gt;
    您的浏览器不支持Canvas
&lt;/canvas&gt;
var ctx = c1.getContext(&apos;2d&apos;)
//绘制矩形  ctx.fillRect()/strokeRect()/clearRect()
//绘制文本  ctx.fillText()/strokeText()/measureText()
//绘制路径
//绘制图像

1.Canvas的尺寸不能用CSS指定
  使用CSS指定的Canvas尺寸，实际不是修改了画布尺寸，而是进行了拉伸，上面的绘图内容也会随着进行拉伸。
  可以使用HTML标签的width和height属性，也可以使用JS对象的width和height属性。

2.使用Canvas进行绘图 —— 路径
  Path：类似于PS中的“钢笔工具”，由多个坐标点组成的任意形状，路径不可见，可用于“描边”、“填充”、“裁剪”。
  ctx.beginPath()        开始一条新路径
  ctx.closePath()        闭合当前路径
  ctx.moveTo(x, y)        移动到指定点
  ctx.lineTo(x, y)        从当前点到指定点画直线
  ctx.arc(cx, cy, r, start, end)    绘制圆拱路径

  ctx.stroke()            对当前路径描边
  ctx.fill()                对当前路径填充
  ctx.clip()            使用当前路径进行裁剪

3.使用Canvas进行绘图 —— 图像
  Canvas属于客户端技术，图片在服务器中，所以浏览器必须先下载要绘制的图片，且等待图片异步加载完成：
  var p3 = new Image();
  p3.src = &apos;img/p3.png&apos;;    //浏览器会自动异步请求图片
  console.log(p3.width);    //0
  p3.onload = function(){      //图片加载完成
        console.log(p3.width);      //200
        //开始绘制图片到画布上....
    ctx.drawImage( p3, x, y );        //原始大小绘图
    ctx.drawImage( p3, x, y, w, h );    //拉伸绘图
  }

Canvas绘图核心知识点：—— 重点
绘制矩形：
  ctx.fillRect()  ctx.strokeRect()   ctx.clearRect()
绘制文本：
  ctx.fillText()  ctx.strokeText()   ctx.measureText().width
绘制路径：
  ctx.beginPath()    ctx.closePath()
  ctx.moveTo()   ctx.lineTo()
  ctx.arc()
  ctx.stroke()   ctx.fill()    ctx.clip()
绘制图像：
  ctx.drawImage()


4.使用Canvas绘图时进行变形操作
  CSS中有变形相关样式： transform: rotate/scale/translate/skew，这些变形只能作用于某个HTML元素。
  Canvas绘图中也有变形技术，可以针对某一个图像/图形的绘制过程进行变形：rotate、scale、translate。
  ctx.rotate( 弧度 )     旋转绘图上下文对象(即画笔),轴点是画布的原点
  ctx.translate( x, y )  将整个画布的原点平移到指定的点
  ctx.save()         保存画笔当前的所有变形状态值（游戏中从存盘）
  ctx.restore()        恢复画笔变形状态到最近的一次保存（游戏中读取存盘）

5.第三方绘制统计图工具
  (1)Chart.js：免费的，提供了八种统计图表
  (2)FusionCharts.js：收费的，提供了90+中统计图表
  (3)ECharts：百度提供的免费的绘图工具，与地图整合的很好
  (4)FreeCharts ....

提示：第三方工具使用无需记忆！重点掌握自学的过程：
(1)打开官网，查看说明
    http://www.chartjs.org/
(2)仿照DEMO编写示例
    开源免费的、8种图表、基于H5 Canvas、支持响应式
(3)在实际项目中加以应用，查看详细API说明
    &lt;canvas id=&quot;c15&quot; width=&quot;500&quot; height=&quot;400&quot;&gt;
            您的浏览器不支持Canvas绘图！
    &lt;/canvas&gt;
    &lt;script src=&quot;js/Chart.js&quot;&gt;&lt;/script&gt;
    &lt;script&gt;
        new Chart(c15, {
            type: &apos;bar&apos;,//line、pie、noughnut...
            data: {},
            options: {}
            });
    &lt;/script&gt;

位图(Photoshop)：由一个又一个像素点组成，每个点各有自己的颜色，色彩细腻，但放大会失真
矢量图(Illustrator)：由一个又一个线条组成，每个线条可以指定颜色、方向，可以无限缩放，但细节不够丰富
</code></pre><p>十五、HTML5新特性——SVG绘图</p>
<pre><code>Scalable Vector Graph：可缩放的矢量图
Canvas绘图    SVG绘图
类型    2D位图    2D矢量图
如何绘图    使用JS代码绘图    使用标签绘图
事件绑定    每个图形不是元素，无法直接绑定事件    每个图形都是元素，可以直接绑定事件监听
应用场合    统计图、游戏    统计图、图标、地图
  SVG技术诞生于2000年，早期作为XML的扩展应用出现；H5标准把常用的SVG标签采纳为标准，但有些被废弃掉。

SVG技术在HTML5出现之前的使用方法：
    (1)在一个XML文档中声明要绘制的图形
    (2)再编写HTML文档，使用IMG/IFRAME应用XML文档即可
SVG技术在HTML5出现之后的使用方法：
    直接创建HTML5文档，在其中书写SVG标签即可
    &lt;svg&gt;&lt;/svg&gt;本身是一个300*150的inline-block。

使用SVG标签绘制矩形：
    &lt;rect&gt;
使用SVG标签绘制圆形：
    &lt;circle&gt;
使用SVG标签绘制椭圆：
    &lt;ellipse&gt;
使用SVG标签绘制直线：
    &lt;line&gt;
使用SVG标签绘制折线：
    &lt;polyline&gt;
使用SVG标签绘制多边形：
    &lt;polygon&gt;
</code></pre><p>十六、补充：Canvans上如何按照特定的顺序绘制图片</p>
<pre><code>Canvas绘图中若需要多张图片，他们的加载都是异步的，无法预测哪一张先加载完成！
但是绘图往往需要按照一定顺序，如先绘背景，再绘上面的内容。所以必须等待所有图片全部加载完成，才能开始绘图。
var progress = 0; //所有图片的总加载进度
var imgBg = new Image();
imgBg.src = &apos;img/bg.jpg&apos;;
imgBg.onload = function(){
  progress += 40;    //为每张图片赋一个权重值
  if(progress===100){
    startDraw();
  }
}
var imgDisc = new Image();
imgDisc.src = &apos;img/disc.png&apos;;
imgDisc.onload = function(){
  progress += 60;
  if(progress===100){
    startDraw();
  }
}
</code></pre><p>十七、补充：如何为Canvas上的图形/图像绑定事件监听</p>
<pre><code>网页中只能为HTML元素绑定监听函数，Canvas上的图形/图像都是用JS绘制的，不是DOM元素，不能直接进行事件绑定！
只能绑定给整个Canvas！然后再具体计算事件发生坐标是否处于某个图像/图形内部——仅适用于规则图像/图形。
  SVG图形中为元素绑定事件监听
  SVG图形中每个图形/图像都是一个标签，可以很方便进行事件绑定
</code></pre><p>十八、SVG绘图的特点——着重注意！</p>
<pre><code>(1)所有的图形默认只有填充色（黑色），没有描边色。
(2)SVG图形的样式可以用元素属性声明，也可以用CSS形式来声明。但用CSS声明时，只能使用SVG专用的样式，不能使用CSS样式，如边框设置只能用stroke，而不用border！
(3)图形可以使用JS来对属性赋值；但不能使用HTML DOM形式，只能用核心DOM操作，如：
  r.x = 10;   r.width = 100;    //无效
  r.setAttribute(&apos;x&apos;, 10); r.setAttribute(&apos;width&apos;, 100)//有效
(4)动态添加SVG图形可以使用两种方式：
   1)HTML字符串拼接
       var html = `&lt;rect&gt;&lt;/rect&gt;`;
       svg.innerHTML = html;
   2)使用document.createElementNS(&apos;http://www.w3.org/2000/svg&apos;,&apos;标签名&apos;)创建

4.使用SVG进行绘图——矩形
  &lt;rect width=&quot;&quot; height=&quot;&quot; x=&quot;&quot; y=&quot;&quot; fill=&quot;&quot; fill-opacity=&quot;&quot; stroke=&quot;&quot; stroke-width=&quot;&quot; stroke-opacity=&quot;&quot;&gt;&lt;/rect&gt;

5.使用SVG进行绘图——圆形
  &lt;circle r=&quot;&quot; cx=&quot;&quot; cy=&quot;&quot; fill=&quot;&quot; fill-opacity=&quot;&quot; stroke=&quot;&quot; stroke-opacity=&quot;&quot;&gt;&lt;/circle&gt;

6.使用SVG进行绘图——椭圆
  &lt;ellipse rx=&quot;&quot; ry=&quot;&quot; cx=&quot;&quot; cy=&quot;&quot;&gt;&lt;/ellipse&gt;

7.使用SVG进行绘图——直线
  &lt;line x1=&quot;&quot; y1=&quot;&quot; x2=&quot;&quot; y2=&quot;&quot; stroke=&quot;&quot; stroke-width=&quot;&quot; stroke-linecap=&quot;butt/square/round&quot;&gt;&lt;/line&gt;
 练习：使用SVG中的直线绘制如下的图标

提示：若多个SVG图形有完全一样的属性，可以抽出来，放在一个公共的父元素中（小组）
&lt;g stroke=&quot;#000&quot;&gt;
   &lt;line&gt;&lt;/line&gt;
   &lt;line&gt;&lt;/line&gt;
&lt;/g&gt;

8.使用SVG进行绘图——折线
  一条折线上可以有任意多个连续的点
  &lt;polyline points=&quot;50,50  100,300 ...&quot; fill=&quot;transparent&quot; stroke=&quot;#000&quot;&gt;&lt;/polyline&gt;
 练习：使用折线绘制如下图标

9.使用SVG进行绘图——多边形
&lt;polygon points=&quot;50,50  100,300 ...&quot; fill=&quot;&quot;&gt;&lt;/ polygon&gt;
  练习：使用多边形绘制如下两个图标

10.附加：使用SVG进行绘图——文本
  SVG画布上不允许使用普通的HTML元素绘制文本，如SPAN、P等！只能使用：
  &lt;text font-size=&quot;&quot; alignment-baseline=&quot;before-edge&quot; fill=&quot;&quot; stroke=&quot;&quot; x=&quot;&quot; y=&quot;&quot;&gt;文本内容 &lt;/text&gt;

11.附加：使用SVG进行绘图——图像
  不能使用IMG置于SVG画布上！只能使用：
  &lt;image xlink:href=&quot;disc.png&quot; width=&quot;200&quot; height=&quot;200&quot; x=&quot;&quot; y=&quot;&quot;&gt;&lt;/image&gt;
SVG绘图的主要知识点：
&lt;svg&gt;
  &lt;rect&gt;&lt;/rect&gt;
  &lt;circle&gt;&lt;/circle&gt;
  &lt;ellipse&gt;&lt;/ellipse&gt;
  &lt;line&gt;&lt;/line&gt;
  &lt;polyline&gt;&lt;/polyline&gt;
  &lt;polygon&gt;&lt;/polygon&gt;
  &lt;text&gt;&lt;/text&gt;
  &lt;image&gt;&lt;/image&gt;
&lt;/svg&gt;

12.补充小知识：如何在SVG中使用渐变
  &lt;defs&gt;      定义特效对象：渐变对象属于一种特效对象
    &lt;linearGradient id=&quot;g3&quot; x1=&quot;&quot; y1=&quot;&quot; x2=&quot;&quot; y2=&quot;&quot;&gt;
        &lt;stop offset=&quot;0&quot; stop-color=&quot;&quot; stop-opacity=&quot;&quot;/&gt;
        &lt;stop offset=&quot;1&quot; stop-color=&quot;&quot; stop-opacity=&quot;&quot;/&gt;
    &lt;/linearGradient&gt;
  &lt;/defs&gt;
  &lt;ANY fill=&quot;url(#g3)&quot;  stroke=&quot;url(#g3)&quot;&gt;&lt;/ANY&gt;
 练习：使用渐变对象，为不同的柱子分配不同的渐变色


13.补充小知识：如何在SVG中使用滤镜
  &lt;defs&gt;
    &lt;filter id=&quot;f2&quot;&gt;
        &lt;feGaussianBlur stdDeviation=&quot;3&quot;/&gt;
    &lt;/filter&gt;
  &lt;/defs&gt;
  &lt;ANY filter=&quot;url(#f2)&quot;&gt;

SVG中支持的所有滤镜：
https://developer.mozilla.org/en-US/docs/Web/SVG/Element/filter

网页中可用的绘图技术：
(1)Canvas绘图
(2)SVG绘图
(3)WebGL绘图

14.第三方绘图工具库  —— Two.js

 (1)打开官网，查看说明
    https://two.js.org/
    是一个2D绘图函数库，提供了一套API，可用于不同的技术下的绘图，如SVG/CANVAS/WEBGL。
 (2)参考DEMO，编写示例
    var two = new Two({ }).appendTo(box);
    //绘制一个圆形
    var c = two.makeCircle(200,200,100);
    //绘制一个矩形——定位点在矩形中心，而不是左上角
    var r = two.makeRectangle(600,200, 200,200);
    //把绘图对象中的内容绘制到DOM树
    two.update(); //更新DOM树
 (3)查看API，在项目中加以应用
</code></pre><p>十九、HTML5新特性之六 —— 地理定位</p>
<pre><code>  Geolocation：地理定位，使用JS获取当前浏览器所在的地理坐标
  （经度、维度、海拔、速度）数据，用于实现LBS应用(Location Based Service)，
  如饿了么、高德导航...
  手机浏览器如何获得定位信息：
    (1)首选手机中的GPS芯片与卫星通信，定位精度在米
    (2)次选手机通信基站进行定位获取，定位精度在公里
  PC浏览器如何获得定位信息：
    通过IP地址进行反向解析，定位精度取决于IP地址库的大小

HTML5中提供了一个新的对象，用于获取当前浏览器的定位信息：
  window.navigator.geolocation{
    getCurrentPosition: fn,    获得当前定位信息
    watchPosition: fn, 监视定位数据的改变
    clearWatch: fn  取消监视
  }
获得客户端的定位信息：
navigator.geolocation.getCurrentPosition(
    (pos)=&gt;{ pos.coords.latitude   pos.coords.longitude },
    (err)=&gt;{    err.code   err.message }
)

2.扩展小知识：在网页中如何嵌入百度地图
  (1)注册百度开发者账号
    http://lbsyun.baidu.com/
  (2)创建一个网站；登录百度地图，为网站申请一个地图的AccessKey
    http://lbsyun.baidu.com/apiconsole/key

  (3)在自己的网页中嵌入百度地图提供的API，嵌入百度地图
    官方手册：http://lbsyun.baidu.com/index.php?title=jspopular
    var map = new BMap.Map(&quot;container&quot;);          // 创建地图实例
    var point = new BMap.Point(116.300829,39.915836);  // 创建点坐标
    map.centerAndZoom(point, 17);   // 以指定点为中心并缩放
</code></pre><p>二十、HTML5新特性之七 —— 拖放API</p>
<pre><code>Drag &amp; Drop：拖动和释放
HTML5为拖放行为提供了7个事件，分为两组：
拖动的源对象(会动)可以触发的事件：
  dragstart：拖动开始
  drag：拖动中
  dragend：拖动结束
  整个拖动过程： dragstart*1 + drag*n + dragend*1
拖动的目标对象(不动)可以触发的事件：
  dragenter：拖动着进入
  dragover：拖动着悬停在上方
  dragleave：拖动着离开
  drop：在上方释放
  整个拖动过程1： dragenter*1 + dragover*n + dragleave*1
  整个拖动过程2： dragenter*1 + dragover*n + drop*1
注意：必须阻止dragover的默认行为，drop才可能触发！
</code></pre><p>二十一、HTML5新特性之八 —— Web Worker —— 代码就3行</p>
<pre><code>  程序：Program，指可被CPU执行的代码，存储在外存中
  进程：Process/Task，指程序被OS调入内存，分配执行空间，随时供CPU调度执行
  线程：Thread，线程是进程内执行代码基本单位

  进程和线程：
    (1)进程是操作系统分配内存的基本单位；
    (2)线程是CPU执行代码的基本单位；
    (3)线程必须处于某个进程内部；
    (4)一个进程内必须至少有一个线程；也可以有多个；
    (5)一个操作系统中可能同时存在几千个线程，它们是“并发执行的”—— 宏观上看同时执行，微观上看是依次循环执行

    Chrome浏览器中的线程模型：
    一个Chrome进程内，至少有6个线程，可以“同时/并发”向Web服务器发起HTTP请求，以获得所需的资源——资源请求线程。
    还有一个线程负责将所有内容绘制到浏览器页面中——UI主线程——不允许多线程同时绘图，防止内容布局错乱。

    5.观察如下一段代码执行特点
      &lt;button onclick=&quot;console.log(111)&quot;&gt;按钮1&lt;/button&gt;
      &lt;script src=&quot;14.js&quot;&gt;很耗时的JS任务&lt;/script&gt;
      &lt;button onclick=&quot;console.log(222)&quot;&gt;按钮

      现象：JS执行过程中，按钮1可见，但点击无效；按钮2不可见。
      原因：浏览器中执行代码的只有一个线程——UI主线程
      解决办法：创建新的线程，由它来执行耗时的JS任务；UI主线程继续执行后续的HTML渲染：
      &lt;button onclick=&quot;console.log(111)&quot;&gt;按钮1&lt;/button&gt;
      &lt;script&gt;
        var w = new Worker(&apos;14.js&apos;)
      &lt;/script&gt;
      &lt;button onclick=&quot;console.log(222)&quot;&gt;按钮

1.补充小知识：在拖动源对象和目标对象间传递数据
  如：拖动开始时(src.ondragstart)记录被拖动元素的ID，释放时(target.ondrop)根据ID查找拖动的源对象，进行相关操作。
  方法1：使用一个全局变量 —— 造成全局对象的污染
  方法2：使用H5拖放API专供的e.dataTransfer（数据传递）

  //拖动的源对象
  src.ondragstart = function(e){
    //海南：往拖拉机中装数据
    e.dataTransfer.setData(&apos;key&apos;, &apos;value&apos;)
  }
  //拖动的目标对象
  target.ondrop = function(e){
    //哈尔滨：从拖拉机中读取数据
    var data = e.dataTransfer.getData(&apos;key&apos;);            //value
  }
</code></pre><p>二十二、HTML5新特性之八——WebWorker——代码就3行，重点在理论理解</p>
<pre><code>进程：操作系统分配内存的单位 —— 工厂
线程：处于进程内部，用于执行代码 —— 生产线
线程并发：操作系统中所有的线程宏观上看“同时执行”；微观上看是“依次交替执行”
Chrome中的线程模型： 请求资源——6个线程；运行代码/渲染页面内容——1个线程
&lt;button&gt;按钮1&lt;/button&gt;
&lt;script src=&quot;x.js&quot;&gt;&lt;/script&gt;
&lt;button&gt;按钮2&lt;/button&gt;
上述代码中若x.js很耗时，按钮1无法点击，按钮2在运行js过程中不可见——所有的代码(HTML/CSS/JS)都在单线程(UI主线程)中执行

解决方案：创建一个并发执行的新线程，让它来执行耗时的JS任务

3.Worker线程的致命缺陷
浏览器不允许Worker线程操作任何的DOM&amp;BOM对象！！
原因：浏览器只允许UI主线程操作DOM&amp;BOM！若多个线程同时都可以操作DOM结构，页面将混乱。
所以，类似jQuery的脚步决不能使用Worker来加载执行。

Worker线程可以给UI主线程发数据消息：
  UI主线程：
      var w6 =new Worker(&apos;6.js&apos;);
      w6.onmessage = function(e){ e.data }
  Worker线程：
      postMessage(stringMsg)
UI主线程可以给Worker线程发数据消息：
  UI主线程：
      var w6 =new Worker(&apos;6.js&apos;);
      w6.postMessage(stringMsg)
  Worker线程：
      onmessage = function(e){ e.data }

  项目中Worker的使用场景：
  (1)只要js中有DOM&amp;BOM就不能用Worker！
  (2)Worker适合于执行耗时的JS任务！如复杂计算、加密和解密、大数据统计、路径规划......
</code></pre><p>二十三、HTML5新特性之九 —— WebStorage</p>
<pre><code>  在浏览器中存储当前用户专有的数据：访问历史、内容定制、样式定制...
  在客户端存储数据可以使用的技术：
  (1)Cookie技术：浏览器兼容性好；不能超过4KB，操作复杂
  (2)Flash存储：依赖于Flash播放器
  (3)H5 WebStorage：不能超过8MB，操作简单
  (4)IndexedDB：可存大量数据，还不是标准技术

Session：会话，浏览器从打开某个网站的一个页面开始，中间可能打开很多页面，
直到关闭浏览器，整个过程称为“浏览器与Web服务器的一次会话”。

WebStorage技术中，浏览器为用户提供了两个对象：
  (1)window.sessionStorage：类数组对象，会话级数据存储
    在浏览器进程所分得的内存存储着一次Web会话可用的数据，可供此次会话中所有的页面共同使用
    ；浏览器一旦关闭就消失了。
作用：在同一个会话中的所有页面间共享数据，如登录用户名。
    sessionStorage[key] = value            //保存一个数据
    sessionStorage.setItem(key, value)        //保存一个数据
    var v = sessionStorage[key]            //读取一个数据
    var v = sessionStorage.getItem(key)    //读取一个数据
    sessionStorage.removeItem(key)        //删除一个数据
    sessionStorage.clear()                //清除所有数据
    sessionStorage.length                //数据的数量
    sessionStorage.key(i)                //获取第i个key

  (2)window.localStorage：类数组对象，本地存储(跨会话级存储)
    在浏览器所能管理的外存(硬盘)中存储着用户的浏览数据，可供此次会话以及后续的会话中的页面共同使用；
即使浏览器关闭也不会消失——永久存在。作用：在当前客户端所对应的所有会话中共享数据，如登录用户名。
    localStorage[key] = value            //保存一个数据
    localStorage.setItem(key, value)        //保存一个数据
    var v = localStorage [key]            //读取一个数据
    var v = localStorage.getItem(key)        //读取一个数据
    localStorage.removeItem(key)        //删除一个数据
    localStorage.clear()                //清除所有数据
    localStorage.length            //数据的数量
    localStorage.key(i)                //获取第i个key

localStorage中若数据发生了修改，会触发一次window.onstorage事件，可以监听此事件，实现监视localStorage数据改变的目的，
用于在一个窗口中监视其它窗口中对localStorage数据的修改——不能监视sessionStorage数据的修改！

5.HTML5新特性之十 —— WebSocket——代码不复杂重点在原理的理解
  HTTP协议：属于“请求-响应”模型，只有客户端发起请求消息，服务器才会返回响应消息，没有请求就没有响应；
一个请求，只能得到一个响应。有些场景中，此模型就力不从心了：实时走势应用、在线聊天室。
解决方案：长轮询(Long-Polling)/心跳请求——定时器+AJAX——请求过于频繁，服务器压力过大；
不够频繁，客户端数据延迟较大。
  WebSocket协议：属于“广播-收听”模型，客户端连接到服务器就不再断开，永久的连接，双方就随时向对方发送消息，
且是全双工不对等发送。WS协议在实时走势应用、在线聊天室应用中有着特别的优势。


  WS协议的应用程序也分为客户端程序和服务器端程序：
  WS服务器端应用：
    监听指定端口，接收客户端请求，向对方发消息，并接收消息；可以使用php/java/node.js等语言编写
  WS客户端应用：
    主动发起连接请求，保持永久的连接，向对方消息，并接收消息，可以使用php/java/node.js/html5等语言编写

6.了解：使用Node.js创建WS协议的服务器
  node.js官方没有提供ws协议的模块，必须使用NPM下载第三方ws协议模块：  npm  i  ws
  查看README,编写WS协议的服务器：
  ......

7.掌握：使用HTML5创建WS协议的客户端应用
  //连接到WS服务器
  var socket = new WebSocket(&apos;ws://127.0.0.1:9001&apos;)
  //向服务器发消息
  socket.send(stringMsg)
  //接收服务器发来的消息
  socket.onmessage = function(e){
    e.data   //消息内容
  }
  //断开到WS服务器的连接
  socket.close();
</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;一、HTML5新特性 —— 十个新特性：凌乱&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;(1)新的语义标签
(2)增强型表单(表单2.0)
(3)音频和视频
(4)Canvas绘图
(5)SVG绘图
(6)地理定位
(7)拖放API
(8)Web Worker
(9)Web Stora
    
    </summary>
    
      <category term="学习笔记" scheme="www.wangchengzou.cn/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="html" scheme="www.wangchengzou.cn/tags/html/"/>
    
      <category term="h5" scheme="www.wangchengzou.cn/tags/h5/"/>
    
  </entry>
  
  <entry>
    <title>HTML5的form如何关闭自动完成功能</title>
    <link href="www.wangchengzou.cn/2017/07/22/HTML5%E7%9A%84form%E5%A6%82%E4%BD%95%E5%85%B3%E9%97%AD%E8%87%AA%E5%8A%A8%E5%AE%8C%E6%88%90%E5%8A%9F%E8%83%BD/"/>
    <id>www.wangchengzou.cn/2017/07/22/HTML5的form如何关闭自动完成功能/</id>
    <published>2017-07-22T15:48:26.000Z</published>
    <updated>2017-07-23T07:45:05.164Z</updated>
    
    <content type="html"><![CDATA[<p>给不想要提示的 form 或某个 input 设置为 autocomplete=off</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;给不想要提示的 form 或某个 input 设置为 autocomplete=off&lt;/p&gt;

    
    </summary>
    
      <category term="面试题目" scheme="www.wangchengzou.cn/categories/%E9%9D%A2%E8%AF%95%E9%A2%98%E7%9B%AE/"/>
    
    
      <category term="html" scheme="www.wangchengzou.cn/tags/html/"/>
    
      <category term="H5" scheme="www.wangchengzou.cn/tags/H5/"/>
    
  </entry>
  
  <entry>
    <title>CSS优先级算法如何计算</title>
    <link href="www.wangchengzou.cn/2017/07/22/CSS%E4%BC%98%E5%85%88%E7%BA%A7%E7%AE%97%E6%B3%95%E5%A6%82%E4%BD%95%E8%AE%A1%E7%AE%97/"/>
    <id>www.wangchengzou.cn/2017/07/22/CSS优先级算法如何计算/</id>
    <published>2017-07-22T15:48:26.000Z</published>
    <updated>2017-07-23T07:53:48.776Z</updated>
    
    <content type="html"><![CDATA[<ul>
<li>优先级就近原则，同权重情况下样式定义最近者为准;</li>
<li>载入样式以最后载入的定位为准;<br>优先级为:    !important &gt;  id &gt; class &gt; tag<br>important 比 内联优先级高</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;优先级就近原则，同权重情况下样式定义最近者为准;&lt;/li&gt;
&lt;li&gt;载入样式以最后载入的定位为准;&lt;br&gt;优先级为:    !important &amp;gt;  id &amp;gt; class &amp;gt; tag&lt;br&gt;important 比 内联优先级高&lt;/li&gt;
&lt;/
    
    </summary>
    
      <category term="面试题目" scheme="www.wangchengzou.cn/categories/%E9%9D%A2%E8%AF%95%E9%A2%98%E7%9B%AE/"/>
    
    
      <category term="html" scheme="www.wangchengzou.cn/tags/html/"/>
    
      <category term="css" scheme="www.wangchengzou.cn/tags/css/"/>
    
  </entry>
  
  <entry>
    <title>html知识点</title>
    <link href="www.wangchengzou.cn/2017/07/22/HTML%E7%AC%94%E8%AE%B0/"/>
    <id>www.wangchengzou.cn/2017/07/22/HTML笔记/</id>
    <published>2017-07-22T15:48:26.000Z</published>
    <updated>2017-07-23T10:22:26.610Z</updated>
    
    <content type="html"><![CDATA[<p>1、Web基础知识</p>
<pre><code>1、Internet
    1、简介
        Internet 实际上就是由计算机所组成的网络结构
        服务：
            1、Telnet
                远程登录
            2、Email
                电子邮件
            3、WWW
                万维网服务，World Wide Web
            4、BBS
                电子公告板 (论坛)
                百度贴吧，天涯论坛，... ...
                CSDN ... ...
            5、FTP
                文件传输协议
        基本实现技术：
            1、分组交换原理
                将传递的数据 拆分成若干数据包
            2、TCP/IP协议
2、Web
    Web ：运行在Internet上的最流行的应用
        WWW : World Wide Web
        W3C : World Wide Web Consortium(万维网联盟)

        将 各类信息 以及 服务 进行无缝连接：
            信息：文字，图像，音频，视频，文件
            服务：BBS，Telnet，Email
3、Web的工作原理
    WEB是 基于 浏览器 / 服务器 模式的程序(B/S)
        B : Browser 浏览器
        S : Server 服务器

    基于 客户端 / 服务器 模式的程序(C/S)
        C : Client 客户端
        S : Server 服务器
        必须通过指定的客户端才能访问服务器数据的一种模式
    由Web服务器，浏览器 以及 通信协议 来组成
        服务器：提供服务的机器
        浏览器：工具
        通信协议：web中使用的时http通信协议
            http: Hyper Text Transfer Protocol
                    超级  文本 传输     协议
            规范了
                数据是如何打包的
                数据是如何传递的
    1、Web服务器
        功能：
            1、存储Web上内容信息
            2、接收客户端请求，并给出响应
            3、具备一定的安全功能
        产品：
            1、Tomcat
            2、Apache
            3、IIS
            ... ...
    2、WEB浏览器
        功能:
            1、代替用户提交请求(User Agent)
            2、作为HTML/CSS/Javascript 的解析器
            3、以图像化的方式显示网页文档
        产品:
            1、Microsoft IE
            2、Mozilla FireFox
            3、Google Chrome
            4、Apple Safari
            5、Opera
4、Web相关技术
    1、服务器端技术
        运行于服务器端，具备访问数据库的能力

        1、PHP
        2、JSP
        3、ASP
        4、ASP.NET
        5、Python
        6、NodeJS
    2、浏览器端技术(客户端)
        运行在客户端，由浏览器负责解释
        1、HTML
        2、CSS
        3、JavaScript(JS)
</code></pre><p>2、HTML入门</p>
<pre><code>1、HTML概述
    Web : 一种应用
    HTML是开发Web网页程序的一种语言

    1、什么是HTML
        HTML：Hyper Text Markup Language
                  超级  文本 标签   语言
            超级文本：具备超能力的文本
                字符 a ：首字符
                超文本 a ：链接
            标签/标记：超文本的组成形式
            语言：具备不同的语法规范
        由HTML编写的文本最终是以 .html 或 .htm作为结尾的文件 , 并且由浏览器解释运行
2、HTML语法规范(重点)
    1、标记
        在HTML中，用于描述功能的符号称之为 &quot;标记&quot;

        语法：
            标记在书写时，必须用 尖括号 括起来(&lt;&gt;)
            标记分成 封闭类型的标记 和 非封闭类型的标记
            1、封闭类型标记
                必须成对出现
                &lt;标记&gt; 内容 &lt;/标记&gt;
                注意：
                    1、封闭类型标记必须成对出现
                    2、标记必须要完整,否则会有意想不到的效果

            2、非封闭类型标记
                又称为 单标记 或 空标记
                &lt;标记&gt; 或 &lt;标记/&gt;
                ex :
                    &lt;br&gt; : 换行
                    &lt;hr/&gt;: 水平线
    2、元素
        元素 即 标记
        ex:
            &lt;a&gt;百度&lt;/a&gt;

        1、元素的嵌套
            元素之间可以相互嵌套，形成更为复杂的页面结构
            语法：
                &lt;标记&gt;&lt;标记1&gt;&lt;/标记1&gt;&lt;/标记&gt;
            注意：
                1、注意嵌套顺序
                2、必须完整嵌套
                3、格式问题
                    被嵌套的内容要通过缩进(Tab)表示层级关系
                ex:
                    &lt;a&gt;&lt;b&gt;&lt;span&gt;&lt;i&gt;&lt;u&gt;Hello World&lt;/u&gt;&lt;/i&gt;&lt;/span&gt;&lt;/b&gt;&lt;/a&gt;
                    推荐的格式：
                    &lt;a&gt;
                        &lt;b&gt;
                            &lt;span&gt;
                                &lt;i&gt;
                                    &lt;u&gt;
                                        Hello World
                                    &lt;/u&gt;
                                &lt;/i&gt;
                            &lt;/span&gt;
                        &lt;/b&gt;
                    &lt;/a&gt;
        2、属性 和 值
            属性 是用来修饰 元素的
            语法：
                1、属性的声明必须位于开始标记中
                2、属性名称与标记名称之间用空格隔开
                    &lt;标记 属性&gt;&lt;/标记&gt;
                    &lt;标记 属性/&gt;
                3、属性值 与 属性之间 用 &quot;=&quot; 来连接
                     属性值要用 &quot;&quot; 或 &apos;&apos; 引起来
                    &lt;标记 属性=&quot;值&quot;&gt;
                4、一个元素允许有多属性，多属性之间排名不分先后，中间用 空格 隔开
                    &lt;标记 属性1=&quot;值&quot; 属性2=&quot;值&quot;&gt;

                    ex:
                        &lt;p align=&quot;center&quot; id=&quot;p1&quot;&gt;&lt;/p&gt;

            通用属性：大部分元素都会具备的属性
                1、id
                    定义元素在页面中独一无二的名称
                2、title
                    鼠标移入到元素上时所提示的信息
                3、class
                    指定元素所引用的类选择器(CSS中使用)
                4、style
                    定义元素的内联样式(css中使用)
        3、注释
            要编写在源文档中，但不想被浏览器解释运行的内容
            &lt;!--  注释  --&gt;
            注意：
                1、注释不能嵌套
                    &lt;!--
                        这是一段注释
                        &lt;!--
                            这是另一段注释
                        --&gt;
                    --&gt;
                    以上结构是错的
                2、注释不能出现在标记(&lt;&gt;)里
                    &lt;a &lt;!-- 这是一个a --&gt;&gt;&lt;/a&gt;
                    以上的写法是错误的
        4、文档结构
            1、两部分组成
                1、文档类型声明
                    指定当前html文档用的时哪个版本
                    语法：
                        文档中的第一句话位置处
                        &lt;!doctype html&gt;
                2、html页面
                    网页要表示的信息的开始与结束
                    语法：
                        &lt;html&gt;&lt;/html&gt;
                        属性：
                            1、lang
                                取值：zh-cn
                    子级内容：
                        1、网页头部信息
                            作用：用于定义网页的全局信息
                            语法：
                                &lt;head&gt;&lt;/head&gt;
                            子级：
                                1、网页标题
                                    &lt;title&gt;标题内容&lt;/title&gt;
                                2、网页元数据
                                    指定网页编码格式
                                    &lt;meta charset=&quot;utf-8&quot;&gt;
                                    注意：
                                        必须保证网页文档的编码格式也是 utf-8 的
                        2、网页主体信息
                            包含要显示给用户去看的所有内容
                            &lt;body&gt;&lt;/body&gt;
                            属性：
                                1、text
                                    作用：控制当前文档的文本颜色
                                    取值：颜色的英文表示方式
                                2、bgcolor
                                    作用：控制当前文档的背景颜色
                                    取值：同上
    3、文本
        1、作用
            以不同的形式展现文字
        2、特殊字符
            默认下，任意多个 回车 和 空格 最后都会被折叠成一个空格
            通过转义字符表示特殊字符：
            1、&amp;nbsp;
                一个空格
            2、&amp;gt;
                &gt;
            3、&amp;lt;
                &lt;
            4、&amp;copy;
                ©
            5、&amp;yen;
                ￥
        3、文本标记
            1、文本样式
                &lt;i&gt;内容&lt;/i&gt; 斜体显示文本
                &lt;u&gt;内容&lt;/u&gt; 下划线的文本
                &lt;s&gt;内容&lt;/s&gt; 删除线的文本
                &lt;b&gt;内容&lt;/b&gt; 加粗显示文本
                &lt;sub&gt;&lt;/sub&gt; 下标
                &lt;sup&gt;&lt;/sup&gt; 上标

                特点：
                    所有的内容会在一行内显示
            2、标题元素
                作用：以标题的方式显示文本(突出显示)
                语法：
                    &lt;hn&gt;&lt;/hn&gt;
                        n : 1~6
                        &lt;h1&gt;&lt;/h1&gt;
                        ...
                        &lt;h6&gt;&lt;/h6&gt;
                属性：
                    1、align ：文本的水平排列方式
                        取值：left / center / right
                特点：
                    1、独自成行
                    2、加粗显示文本
                    3、上下会有垂直的空白
            3、段落元素
                语法：
                    &lt;p&gt;&lt;/p&gt;
                属性：
                    align
                特点：
                    1、垂直空白
                    2、独占一行
            4、换行元素
                语法：&lt;br&gt; 或 &lt;br/&gt;
            5、分割线元素
                语法：&lt;hr&gt; 或 &lt;hr/&gt;
                属性：
                    1、size
                        尺寸，以px或%为单位(省略单位的话是px)
                    2、width
                        宽度，以px或%为单位
                    3、align
                        水平对齐方式
                    4、color
                        颜色
            6、行分区元素
                语法：&lt;span&gt;&lt;/span&gt;
                作用：包裹文本并且设置不同的样式
            7、块分区元素
                语法：&lt;div&gt;&lt;/div&gt;
                作用：布局
            8、预格式化
                作用：保留标记内的格式(回车 和 空格)
                语法：&lt;pre&gt;&lt;/pre&gt;
            9、块级元素和行内元素
                1、块级元素
                    每一个块级元素独占一行
                    块级元素的主要作用：布局
                2、行内元素
                    多个元素会在一行内显示，显示不下自动换行
                    span,i,b,s,u,sub,sup
                    作用：设置文本样式
</code></pre><p>  图像和链接</p>
<pre><code>URL 表示地址
    目录    WEB站点中保存文件的文件夹
    目录结构
    URL:Uniform Resource Locator 即统一资源定位器，俗称路径
                                 是描述资源文件位置的信息
        a.html 中想使用 b.html
        a.html 当前文件
        b.html 资源文件
    URL：表达三种方式
            绝对路径：从资源文件所在的最高级目录下开始的完整路径表示
                        获取网络资源文件《只能是绝对路径》
                            由通信协议“http/https”、主机名(域名、IP地址)、目录路径、文件名组成
                        获取本机资源文件
                            从盘符开始到资源文件名结尾
            相对路径：从当前文件位置处开始开始，去查找资源文件所经过的路径
            根相对路径  从WEB站点所在的服务器根目录上开始查找的
                        以/作为开始
图像  语法
      标记：&lt;img&gt;或&lt;img/&gt;
      属性：src(全称：source 源)
            &lt;img src=&quot;ur1&quot;&gt;
            &lt;img src=&quot;a.jpg&quot;&gt;
            &lt;img src=&quot;images/a.jpg&quot;&gt;
            注意：URL严格区分大小写
            width
            height
            注意：如果width 和height只设置其中一个属性的话，那么另外一个将等比缩放
链接 （超链接）
        语法：由&lt;a&gt;内容&lt;/a&gt;
              注意：默认情况下，A是不能被点击的
        属性：href 链接的URL 只有设置href属性后，才允许被点击
              target  目标，打开新网页的方式
                      取值：_self 默认值，在自身标签页中，打开新网页
                            _blank 在新标签页中，打开新网页
        链接表现形式： 资源下载
                        链接地址为**.zip/**.rar
                       电子邮件链接 &lt;a href=&quot;mailto:zhaoxu@tedu.cn&quot;&gt;发送邮件&lt;/a&gt;
                       返回页面顶部的空链接&lt;a href=&quot;#&quot;&gt;返回顶部&lt;/a&gt;
                       链接到Javascript &lt;a href=&quot;javascript:js代码&quot;&gt;&lt;/a&gt;
        锚点：anchor   在html文档的某行位置做一个记号，允许通过超链接跳转到该记号位置
                定义锚点（做记号）
                    通过A标记的name属性 &lt;a name=&quot;名称&quot;&gt;&lt;/a&gt;
                    通过任意标记的ID属性&lt;标记 ID=&quot;标记名称&quot;&gt;&lt;/标记&gt;
                链接到锚点（跳转到锚点）&lt;a href=&quot;#锚点名称&quot;&gt;&lt;/a&gt;
                                        &lt;a href=&quot;页面URL#锚点名称&quot;&gt;&lt;/a&gt;
</code></pre><p>表格:表格的作用</p>
<pre><code>表格，是由一些称为单元格的东西按照从左到右，从上到下的顺序排列而成的
    语法：&lt;table&gt;&lt;/table&gt;  定义表格
          &lt;tr&gt;&lt;/tr&gt;        定义表行
          &lt;td&gt;&lt;/td&gt;           定义单元格
         尽量保证默认情况下，每行中的单元格数量是相同的
    表格属性：width   宽度
          height  高度
          align   对齐方式
          border  边框
          cellpadding  设置单元格内边距
          cellspacing  设置单元格外边距
          bgcolor  背景颜色
    表行属性：align   水平对齐
              valign  取值top/middle/bottom    垂直对齐方法
              bgcolor 背景颜色
          单元格属性：align
              valign
              width
              height
              bgcolor
              colspan    设置单元格跨列
              rowspan    设置单元格跨行
    单元格特点
            某一行单元格的高度，以最高的单元格高度为准
            某一列单元格的宽度，以最宽的单元格宽度为主
table的子元素：表格标题&lt;caption&gt;标题文本&lt;/caption&gt;
                注意：一个表格最多只能有一个标题
                     caption 必须位于&lt;table&gt;下的第一句话
               td允许被 th替换  加粗。居中
表格的复杂应用：行分组 表头行分组 &lt;thead&gt;&lt;/thead&gt; 允许包含一行或多行tr
                       表主体行分组&lt;tbody&gt;&lt;/tbody&gt; 允许包含任意多的连续tr
                       表尾行分组&lt;tfoot&gt;&lt;/tfoot&gt; 允许包含一行或多行tr
                    注意：如果不对table中的数据进行显示分组的话，默认都在tbody中
                不规则表格  通td的 colspan和 rowspan属性来完成
                            colspan 跨列，在一行中，从指定单元格位置处开始，横向向右合并几个单元格
                                    被合并的单元格，要删除
                            rowspan 跨行。在一列中，从指定单元格位置处开始，纵向向下合并几个单元格
                                    被合并的单元格，要删除
                表格的嵌套  允许在单元格中在放入一个表格
                            &lt;table&gt;
                                &lt;tr&gt;
                                    &lt;td&gt;
                                        &lt;table&gt;
                                            &lt;tr&gt;
                                                &lt;td&gt;
                                                &lt;/td&gt;
                                            &lt;/tr&gt;
                                        &lt;/table&gt;
                                    &lt;/td&gt;
                                &lt;/tr&gt;
                            &lt;/table&gt;
</code></pre><p>  列表</p>
<pre><code>列表语法
    组成  列表的类型：有序列表：&lt;ol&gt;&lt;/ol&gt;
                      无序列表：&lt;ul&gt;&lt;/ul&gt;
             列 表项：显示在列表中的内容 &lt;li&gt;&lt;/li&gt;
    属性  有序列表（ol）的属性 type 取值 1   a   A   i   I
                               start  起始编号是多少 具体为数字
          无序列表（ul）的属性 type 取值 disc 实心圆点
                                         circle 空心圆
                                         none 不显示标识
                                         square  方块
列表的嵌套： 允许在一个列表中出现另一个列表被嵌套的列表必须放在&lt;li&gt;中
定义列表：作用，往往用于给出一类事物的定义情形，如名词解释
          语法，&lt;dl&gt;&lt;/dl&gt;  表示定义列表
                    &lt;dt&gt;&lt;/dt&gt; 定义列表中标题
                    &lt;dd&gt;&lt;/dd&gt; 对标题解释说明的内容
        使用场合：图文混排时使用
</code></pre><p>  结构标记</p>
<pre><code>网页结构布局：为了取代做布局的Div，从而体现出布局标记的语义性
    块级元素做布局，Div
    常用结构标记
        header 用来表示页面或某部分内容的顶部信息
               &lt;header&gt;&lt;/header&gt;
         nav   用来表示页面的主导航信息
                &lt;nav&gt;&lt;/nav&gt;
        section  表示页面中的小节，也可以用来表示页面的主体内容
                 &lt;section&gt;&lt;/section&gt;
        article  表示页面中的文章信息或是文字居多的部分，比如博客信息，微博的条目，论坛中的主贴和回帖
                  &lt;article&gt;&lt;/article&gt;
        footer   表示页面中底部信息，一般用户关注度较低
                 &lt;footer&gt;&lt;/footer&gt;
        aside  表示页面中的边档信息
                &lt;aside&gt;&lt;/aside&gt;
</code></pre><p>  表单</p>
<pre><code>表单概述：表单用于显示，收集用户信息，并提交给服务器
 完整表单由两部分组成：实现表单以及可交互的界面元素（前端）
      表单元素：用于定义表单的提交信息如：提交地址，提交方式
      表单控件：能够与用户交互的界面无素如：文本框，密码框
              表单提交后的处理（服务器端）
          表单元素：语法 &lt;form&gt;&lt;/form&gt;
              注意：只有出现在form中的表单控件的数据才会被提交
                    form在页面中没有显示效果，只有功能
          属性：action :指定提交给服务器处理程序的地址，该地址要与服务器端人员商量
                  注意：如果省略不写，默认提交给本页
               method ：指定提交数据的方法（模式）
                   取值：get 获取（默认方式）
                          以明文的方式提交数据到服务器（数据会显示在地址栏上），安全性低
                          最大提交2KB数据
                          向服务器要数据时用get方式
                        post  邮寄
                             以隐式的方式提交数据到服务器不会显示，安全性高
                             无提交数据大小限制
                             让服务器处理数据时使用post
                        put
                        delete
               enctype ：指定表单数据的编码方式（什么样的数据允许提交）
                   取值：application/x-www-form-urlencoded
                         默认值，可以将所有的数据提交给服务器（文件除外）
                        multipart/form-data
                            允许将文件（图像，音频，视频，文档）提交给服务器
                        text/plain
                            允许将普通字符提交给服务器，特殊字符无法提交（=，&amp;，？）
                        name ：定义表单名称
                         id： 定义表达独一的标识
          表单控件：都是与用户进行交互的元素
              语法:input     收集用户信息
                  属性：type  根据不同的type值创建不同的输入控件
                       name  定义控件的名称提供给服务器端使用，采用匈牙利命名法，控件缩写+功能
                       value  定义控件的值，提供给服务器端使用
                       disabled 禁用控件（无法操作，无法提交），该属性无值
                       说明：文本框和密码框
                            文本框：type=“text”
                            密码框：type=“password”
                            属性：maxlength 限制输入的字符数，超出不显示
                                 readonly  只读（只能看，不能改，但允许被提交） 无值属性
                                 name 缩写txt+功能 如 name=“txtpassword”
                            单选按钮和复选框
                                单选按钮 ：type=“‘radio’”   radio缩写rdo
                                复选框 ：type=“checkbox”    checkbox缩写chk
                                 属性：：name 定义控件的名称
                                              为控件分组
                                         value 值
                                         checked 预选中
                             按钮：提交按钮
                                  type=“submit” 必须放入表单中进行
                                  重置按钮
                                   type=“reset”
                                  普通按钮
                                     type=“button”
                                      属性：name  缩写btn
                                           value  按钮上的文字
                                  其它按钮：图片按钮
                                      &lt;input type=&quot;image&quot;&gt;
                                        属性：src
                                            按钮《提交》可以放图
                                       &lt;button&gt;内容&lt;/button&gt;
          隐藏域和文件选择框
               隐藏域：type=“hidden”  想提交给服务器，但不想被用户看见的数据放在隐藏域中
                 属性：name
                      value
               文件选择框：type=“file”
                    注意，要求form的methods属性必须为post
                         form的enctype属性为multipart/form-data
          textarea  多行文本域 允许 录入多行数据
               语法：&lt;textarea&gt;&lt;/textarea&gt;
               属性：name缩写 txt
                     cols  指定文本区域列数
                     rows  指定文本区域行数
                     readonly  只读
          select  选择框下拉框
               语法：&lt;select&gt;&lt;/select&gt;
               属性 name 缩写sel
                    size 默认显示的数量，如果大于1的话，则为滚动列表
                    multiple 设置多选，同时变以滚动列表配合ctrl或shift实现多选
                选项
                     &lt;option&gt;/&lt;option&gt;
                 属性  value 值
                       selected 默认预选中，无值
          其它
               label  关联文本与控件
                     &lt;label&gt;&lt;/label&gt;
                属性  for 表示与该元素关联的控件的ID值
                      控件分组控件
                         &lt;fieldset&gt;&lt;/fieldset&gt;  分组
                         &lt;legend&gt;&lt;/legend&gt;    分组标题
               浮动框架
                   可以在一个浏览器窗口中同时显示多个页面文档的内容，在一个页面中引入另一个页面
                   语法  &lt;iframe&gt;文字&lt;/iframe&gt;
                    属性 src 浮动框架中要引入的页面URL
                          width
                          height
                          frameborder 浮动框架边框 默认有边框，无需边框设置为0
</code></pre><p>新表单元素（HTML5新标记）</p>
<pre><code>统一属性：name缩写txt
    required  非空限制，必须填入内容
电子邮件类型：&lt;input type=&quot;email&quot;&gt; 缩写txt
搜索类型：&lt;input type=&quot;search&quot;&gt;
URL类型：&lt;input type=&quot;url&quot;&gt;  数据必须符合URL规范
电话号码类型：&lt;input type=&quot;tel&quot;&gt;    移动终端：弹出数字键盘
数字类型：&lt;input type=&quot;number&quot;&gt;
    属性：min 控件接受的最小值
        max 控件接受的最大值
        step 控件递增的步长，默认为1
范围类型：允许选择指定范围内的一个值（左右滑块类型）
    &lt;input type=&quot;range&quot;&gt;
    属性：min 指定范围最小值
        max 指定范围最大值
        step 指定值变化步长
        value 设置初始值
颜色类型：颜色拾取控件
        &lt;input type=&quot;color&quot;&gt;
日期类型：允许用户选择日期
        &lt;input type=&quot;date&quot;&gt;
周类型：与date类似，但只能选择周
        &lt;input type=&quot;week&quot;&gt;
月类型：与date类似，但只能选择月份
        &lt;input type=&quot;month&quot;&gt;
</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;1、Web基础知识&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;1、Internet
    1、简介
        Internet 实际上就是由计算机所组成的网络结构
        服务：
            1、Telnet
                远程登录
   
    
    </summary>
    
      <category term="学习笔记" scheme="www.wangchengzou.cn/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="笔记" scheme="www.wangchengzou.cn/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>Ionic基础知识</title>
    <link href="www.wangchengzou.cn/2017/07/22/Ionic/"/>
    <id>www.wangchengzou.cn/2017/07/22/Ionic/</id>
    <published>2017-07-22T15:48:26.000Z</published>
    <updated>2017-07-23T15:53:37.919Z</updated>
    
    <content type="html"><![CDATA[<p>一、当前移动端开发的整体趋势</p>
<pre><code>三种趋势
WebApp:通过前端技术来实现的接近传统应用程序体验的app
NativeApp:通过（Google或者Apple）SDK（software development kit 软件开发包）提供的原生的组件和服务，编写的app称之为原生应用
HybridApp：通过前端技术与原生技术混合编程所生成的app称为hybirdApp

学习WebApp以及HybridApp。

将3中开发模式对比，hybridApp是非常有潜力的，可以实现原生应用程序的功能，支持上传到应用市场，让用户去下载 去使用

前端+原生
想要创建ios的应用程序，开发工具：xcode（apple）,模拟器需要在MacOSX
想要创建Android的应用程序，开发工具：eclipse/AndroidStudio,模拟器是可以运行PC、MacOSX、Linux
</code></pre><p>二、第一个Android应用程序–搭建Android的开发环境</p>
<pre><code>采用的开发语言：java

使用Goolge公司所提供的SDK，java

①安装jdk
    java development kit java开发工具箱
②安装eclipse
③安装sdk
    http://www.androiddevtools.cn/
    ①、下载jdk 直接安装
    ②、下载ADT bundle（集成了eclipse、sdk）
</code></pre><p>三、使用Eclipse创建第一个AndroidApp</p>
<pre><code>操作注意事项：
    工具条--》window--》show/hide toolbar 显示隐藏工具条
    工具条--》window--》reset perspective 恢复默认视图
    工具条--》window--》preferences-&gt;genaeral-&gt;apperance-&gt;color and fonts-&gt;basic-&gt; text font-&gt;edit

    sdk manager：更新SDK
    Android Virtual Device Manager:管理模拟器的创建、编辑、删除
    创建模拟器：1、testPhone 2、选中4寸的设备 3、给SD卡指定大小
    start-》launch

创建Android项目
file-&gt;new -&gt;Android Application Project-&gt;配置应用名称以及包的名称-》配置icon，finish完成Android工程的创建

运行Android项目
选中项目，点击右键，run as-&gt;Android Application Project

对于AndroidApp来说，添加权限，基本步骤：
①找到工程中根目录下的AndroidManefiest.xml文件
②打开，选中选项卡permissions
③点击add，在弹窗中选中uses permission
④在右侧的下拉菜单中选中需要用到的权限，保存即可

Android工程所对应的目录功能：
src(source) 源代码，java文件的修改
gen 自动生成的文件夹 R.java非常关键的文件，可以通过R这个类找到android工程中所有的资源文件
Android* 是google所提供的sdk文件
assets 不希望被处理的文件放在该文件夹(在将工程代码打包成可执行文件的，多数文件都会被处理)
bin 运行工程（编译、链接）时所生成的可执行文件(apk)
libs(libraries) 库文件：使用第三方的包
res（resource） 资源文件：图片、布局文件、变量
AndroidManifest.xml： 版本号、权限、图标的配置、应用的配置。。。
</code></pre><p>四、第一个hybridApp  – webView</p>
<pre><code>1、基本步骤：
①按照功能和要求 把前端代码编写完毕
②将前端代码 放到 Android工程的assets目录
③创建一个WebView（网页视图组件），配置webView加载指定的html页面
④将webView作为一个app的内容视图展现出来
⑤运行，最终是生成了安装包

2、练习：（15:40 - 15：55）
创建一个混合编程app，有一个p、有一个按钮，点击按钮将段落隐藏。
要求：创建一个新的Android。
问题：判断变量、数据，通过console.log控制台打印出来，确认是不是要的数据。
解决：借助于webview的setWebChromeClient

3、混合编程的常见的两种方式
①直接将在pc端测试好的前端代码 全部拷贝到 android工程，打包生成一个app
②将测试号的代码直接部署在服务器端， 让webview去加载指定的服务器的地址，加上网络权限


练习：将开饭啦项目部署在服务器端（本地的服务器 apache mysql），然后通过webview加载，生成app
http://localhost/chaptor4_code/angularjs/kfl/kaifanle.html
localhost替换成当前pc的真实的ip地址：windows+R-&gt;cmd-&gt;ipconfig 查看ipv4的地址
http://172.163.100.53/chaptor4_code/angularjs/kfl/kaifanle.html
注意事项：①加上网络权限 ②允许执行js

技巧：
①timeout 超时
    只需要将eclipse和模拟器关掉再打开
②ActivityManager: Warning: Activity not started, its current task has been brought to the front
    没有对原有的项目做任何的修改，又去重复去运行，会提示该警告
③android library projects can&apos;t be launched
    创建Android工程，把工程标记为了一个库项目，只能重新新建工程
ADB：Android Debug Bridge 建立起PC端和移动端的桥梁。

如何完成Android工程的创建、运行基本流程以及工作方式
学习HybridApp的创建和运行

扩展1：
js调用原生组件：
①创建一个接口类的文件
②activity配置使用接口
③在js中调用java中的一些接口

扩展2：
js调用原生组件：
①创建一个接口类的文件
    @JavascriptInterface

②activity配置使用接口
 wv.addJavascriptInterface(
new webInterfac(getApplicationContext()),&quot;android&quot;);

③在js中调用java中的一些接口
function callShowToast(){
    android.showToast();
  }
</code></pre><p>五、Ionic概述</p>
<pre><code>移动端app的开发有很多实现方案，原生、现成的框架（ionic、jQueryMobile）
Ionic是一个强大的h5的混合编程app开发框架
Ionic集成了ng、cordova、一套非常漂亮的移动的ui库
注意事项：Ionic放弃了iOS6、Android4.1以下版本的支持
特点：
    ①完美融合了ng
    ②集成了cordova，能够通过前端代码调用智能设备的底层硬件
    ③设计风格好
    ④性能优越，运行速度块
    Ionic = ng + cordova + 移动ui库
</code></pre><p>六、搭建Ionic的开发环境</p>
<pre><code>1、方式1 （命令行）
http://ionicframework.com/getting-started/
①npm install -g cordova ionic
    全局安装cordova以及ionic
②ionic start myApp tabs/sidemenu
    创建一个基于ionic的项目myApp，类型为tabs、sideMenu
③ionic serve
2、方式2：借助于官方所提供的js、css文件
</code></pre><p>七、学习Ionic样式类</p>
<pre><code>1、color
    9个常用的值 ，参考手册中最后一个color的介绍

2、button按钮
    button/button-small/button-large/button-outline/
    button-clear/buttn-block/icon-left/icon-right/
    ion-***/button-bar

3、list 列表
    list/item/item-icon-left/item-icon-right/list-inset(嵌入效果)/
    item-divider(分隔符)/badge(badge-assertive)
    item-avator/item-thumbnail-left/right

4、card 卡片式

5、form 表单
    list/item/item-input/input-label/item-stacked-label/item-floating-label
    item-toggle(ionToggle)/item-select/ionCheckbox /ionRadio

6、grid
    row/col
    col-10/20/50..(指定列的宽度)
    .col-10    10%
    .col-20    20%
    .col-25    25%
    .col-33    33.3333%
    .col-50    50%
    .col-67    66.6666%
    .col-75    75%
    .col-80    80%
    .col-90    90%(设置列与列之间的offset)

    .col-offset-10    10%
    .col-offset-20    20%
    .col-offset-25    25%
    .col-offset-33    33.3333%
    .col-offset-50    50%
    .col-offset-67    66.6666%
    .col-offset-75    75%
    .col-offset-80    80%
    .col-offset-90    90%
    col-center/col-top/col-bottom
</code></pre><p>八、IonRefresher 下拉刷新</p>
<pre><code>①指定下拉刷新的处理函数
on-refresh
②处理完之后，结束刷新动作
$scope.$broadcast(&apos;scroll.refreshComplete&apos;);
③ionContent第一个子元素
</code></pre><p>九、IonInfiniteScroll 无限滚动（上拉加载更多）</p>
<pre><code>①指定上拉的处理函数
on-infinite
②数据更新完成之后，结束刷新
scroll.infiniteScrollComplete
③ionContent最后一个子元素
immediate-check=&apos;false&apos;
</code></pre><p>十、$ionicScrollDelegate</p>
<pre><code>scrollTop/Bottom() 滚动到顶部或者底部
scrollTo(left,top) 滚动到指定的位置
getScrollPostion() 得到当前的滚动位置（返回对象：top\left）
</code></pre><p>十一、ionTabs 实现选项卡</p>
<pre><code>ionTabs 常用属性：
tabs-icon-top/left/right/bottom/only tabs-positive
http://ionicons.com/
ionTab 常用的属性：title/icon/icon-on/icon-off/on-select(ionTabs默认是第一个被选中)
                  badge/badge-style/on-select/ng-click
</code></pre><p>十二、ionSideMenus 侧边栏菜单</p>
<pre><code>ionSideMenus父级元素，在中间写上:ionSideMenuContent(正文),ionSideMenu（侧边栏菜单）
操作侧边栏菜单打开或者关闭：
1、js：
    $ionicSideMenuDelegate.toggleLeft/toggleRight(true/false);
2、滑动打开
3、属性
    menu-close 将现在打开的侧边栏菜单关掉
    menu-toggle=&apos;left/right&apos; 对左边或则右边的侧边栏菜单进行开关的切换
</code></pre><p>十三、ActionSheet</p>
<pre><code>给用户提供有多种选择的小菜单，借助于$ionicActionSheet来实现
    $ionicActionSheet.show({

    })
在show方法的对象中常用属性：titleText/cancelText/buttons/destructiveText/
cancel/buttonClicked/destructiveButtonClicked
(处理方法中，可以通过返回true，关掉当前打开的actionSheet)
</code></pre><p>十四、$ionicLoading</p>
<pre><code>在移动端当需要处理的时间比较久时，通过该服务显示一个遮盖层
$ionicLoading.show({template/templateUrl/duration/delay})
$ionicLoading.hide();
</code></pre><p>十五、$ionicPopup</p>
<pre><code>在ionic中内容弹窗（警告、确认。。）
$ionicPopup.alert/confirm/prompt/show()
</code></pre><p>十六、自定义弹窗</p>
<pre><code>$ionicModal 模态窗
①指定要去显示的模板内容
②调用fromTemplate/fromTemplateUrl加载模板，并在then方法中得到对应的ionicModal的实例:$scope.modal
③调用$scope.modal.show()
</code></pre><p>十七、uiRouter</p>
<pre><code>定位：UI-Router is a client-side router for single page web applications.
注意：uiRouter用在ng、react中
uiRouter与ngRoute最大的区别：uiRouter支持路由的嵌套。

ngRoute：
①路由的基本步骤
   自定义模块，指定ngRoute模块（angular-route.js）
   指定盛放代码片段的容器 ngView
   创建代码片段
   配置路由词典
    $routerProvider.when().otherwise()
②跳转
  直接修改地址栏
  $location.path(路由地址)
  a href=&apos;#路由地址&apos;
③参数的传递
  发送方、接收方
  配置接收方的路由
  $routeParams
  发送参数

uiRouter的基本使用步骤：
 指定依赖的模块‘ui.router’
 盛放代码片段的容器 uiView
 创建模板文件
 设置状态
    $stateProvider.state()
注意事项：在ionic中的ionic模块 本身在创建时已经指定过依赖于ui.router模块，
        在ionic的项目没有必须要指定ui.router
</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;一、当前移动端开发的整体趋势&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;三种趋势
WebApp:通过前端技术来实现的接近传统应用程序体验的app
NativeApp:通过（Google或者Apple）SDK（software development kit 软件开发包）提供的原生的组件
    
    </summary>
    
      <category term="学习笔记" scheme="www.wangchengzou.cn/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="App" scheme="www.wangchengzou.cn/tags/App/"/>
    
      <category term="Ionic" scheme="www.wangchengzou.cn/tags/Ionic/"/>
    
  </entry>
  
  <entry>
    <title>JQuery基础知识</title>
    <link href="www.wangchengzou.cn/2017/07/22/JQuery/"/>
    <id>www.wangchengzou.cn/2017/07/22/JQuery/</id>
    <published>2017-07-22T15:48:26.000Z</published>
    <updated>2017-07-23T13:47:56.493Z</updated>
    
    <content type="html"><![CDATA[<p>1、 DOM分为三部分：</p>
<pre><code>(1)核心DOM：操作任意标签树
(2)HTML DOM：操作HTML标签树
(3)XML DOM：操作XML标签树
</code></pre><p>2、常用的核心DOM操作</p>
<pre><code>(1)查找元素的方法
    document.getElementById(&apos;p1&apos;)
    document.getElementsByName(&apos;uname&apos;)
    document.getElementsByTagName(&apos;div&apos;)
    document.getElementsByClassName(&apos;btn&apos;)
    document.querySelector(&apos;选择器&apos;)
    document.querySelectorAll(&apos;选择器&apos;)
    遍历DOM节点：
    node.parentNode
    parent.childNodes、parent.children
    node.nextSibling、node.previousSibling
(2)修改元素的属性
    node.setAttribute(&apos;title&apos;,&apos;值&apos;)
    node.getAttribute(&apos;title&apos;)
(3)修改元素的内容
    element.innerHTML
    element.textContent/innerText
(4)修改元素的样式
    element.style.color = &apos;red&apos;;
    element.className = &apos;btn btn-danger&apos;
(5)修改元素的值
    inputElement.value
(6)添加新元素
    var newElement = document.createElement(&apos;div&apos;);
    parent.appendChild(newElement)
(7)删除已有元素
    parent.removeChild(node)
(8)替换旧元素
    parent.replaceChild(oldChild, newChild)
(9)元素克隆
    element.cloneNode()

总结：核心DOM操作的问题
  · 方法名普遍比较长
  · 操作比较僵硬
  · 方法存在浏览器兼容性
</code></pre><p>3、jQuery 概述</p>
<pre><code>jQuery是一个DOM操作的函数库，简化了常用的DOM操作。
理念：Write Less，Do More
jQuery提供了四类函数：
  (1)DOM操作 —— 重点
  (2)事件处理
  (3)动画函数
  (4)AJAX
</code></pre><p>4、 jQuery的版本问题：</p>
<pre><code>(1)jQuery 1.x：比较大、功能偏弱、兼容老IE
(2)jQuery 2.x：比较小、功能强大、不兼容老IE
(3)jQuery 3.x：比较小、功能更强大、不兼容老IE
面试题：jQuery3的新特性有哪些？
HTML中使用jQuery，只需要使用SCRIPT标签引入jquery-*.js即可，会为window添加两个新的成员：
    window.$
    window.jQuery
</code></pre><p>5、jQuery函数的特点</p>
<pre><code>(1) $或者jQuery是一个函数，返回值是一个jQuery类数组对象
(2)即使没有查找到需要的元素，jQuery类数组对象也不会是null/undefined，调用jQuery函数不会报错！
(3)jQuery类数组对象提供的函数都自带for循环遍历每个查找到的元素
(4)jQuery函数底层都是DOM操作，所以可和原生的DOM操作组合使用
(5)原生DOM对象不能调用jQuery提供的函数；jQuery函数返回的类数组对象也不能调用核心DOM成员
(6)原生DOM对象和jQuery对象间如何转换：
  原生DOM对象封装到一个jQuery类数组对象
      $(domObject)
  jQuery类数组中取出封装的DOM对象：
      $(&apos;button&apos;)[index]
(7)jQuery对象方法的返回值一般还是当前选定的类数组对象，可以实现“链式调用”
</code></pre><p>6、jQuery函数第一部分：DOM操作函数 —— 查找元素</p>
<pre><code>$( &apos;选择器&apos; )
jQuery的选择器语法支持所有的CSS选择器语法！并屏蔽了浏览器兼容性；同时还扩展了一些新的选择器语法。
面试题：jQuery中的哪些选择器是CSS中没有的？ —— 执行效率较低
</code></pre><p>7、 第一组：基本选择器   —— 重点</p>
<pre><code>(1)#id
  练习：点击一个button#bt1，让下方的一个p#p1隐藏起来
  提示：jQuery类数组对象提供的.hide()函数可以隐藏一个元素
(2).className
  练习：点击一个button#bt2，让下方所有的span.badge字体变大为2em
  提示：jQuery类数组对象提供的.css(&apos;color&apos;, &apos;red&apos;)函数可以修改当前选定元素的指定样式
(3)标签名
  练习：li元素上发生鼠标进入事件时，当前li显示出下边框
  提示：使用.on(&apos;mouseover&apos;, fn)监听鼠标进入事件
(4)*
  练习：单击button#bt3后，让所有的元素的box-sizing变为border-box，所有元素的margin变为0
(5)div, p, #c3
  练习：页面加载完成后，为所有的button、.btn、role=&quot;button&quot;的元素，添加事件监听，点击后打印出当前系统时间
</code></pre><p>8、第二组：层级选择器       —— 重点</p>
<pre><code>(6) ancestor descendant   后代选择器
  练习：为所有#alert1中的.btn添加事件监听，单击后，隐藏#alert1
(7) parent &gt; child     直接子代选择器
  练习：为所有#alert2中的直接子元素.btn添加事件监听，单击后，隐藏#alert2
(8) prev + next      下一个相邻兄弟选择器
  练习：为UL中的LI添加上边框，实现如下效果：
  $(&apos;li + li&apos;).....
  $(&apos;li:not(:first-child)&apos;)....
(9) prev ~ siblings    后续的所有兄弟选择器
</code></pre><p>9、第三组：基本过滤选择器       —— 重点</p>
<pre><code>注意：基本过滤选择器把所有满足选中的元素放在一个大集合中进行排序，不论是否在同一个父元素中与否。下标从0开始！
(10) :first
  练习：把所有列表中的第一个LI字体加粗显示
(11) :last:
  练习：把所有列表中的最后一个LI字体斜体显示
(12) :eq(index)
  练习：把所有列表中的第index个LI添加有边框
(13) :gt(index)
  练习：把所有列表中的下标大于index的LI添加删除线
(14) :lt(index)
  练习：把所有列表中的下标小于index的LI添加下划线
(15) :odd
  练习：把所有列表中的下标为奇数的LI背景颜色变为淡黄色
(16) :even
  练习：把所有列表中的下标为偶数的LI背景颜色变为淡蓝色
(17) :not(selector)
</code></pre><p>10、第四组：子元素过滤选择器       —— 重点</p>
<pre><code>注意：在每个父元素中进行分组，查找指定的子元素。下标从1开始。
(18) :first-child
  $(&apos;li:first-child&apos;);
  练习：把每个列表中的第一个子LI字体变浅蓝
(19) :last-child
  练习：把每个列表中的第最后一个子LI字体变红色
(20) :nth-child(index)
  练习：把每个列表中的第2个子LI字体添加绿色背景
  $(&apos;li:nth-child(2)&apos;)...
  $(&apos;li:nth-child(odd)&apos;)       $(&apos;li:nth-child(2n+2)&apos;)
  $(&apos;li:nth-child(even)&apos;)    $(&apos;li:nth-child(2n)&apos;)
(21) :only-child
  $(&apos;li:only-child&apos;)
</code></pre><p>11、第五组：属性选择器</p>
<pre><code>(22) [attribute]
  选中所有具备title属性的a元素： $(&apos;a[title]&apos;)...
(23) [attribute=value]
  选中所有具备data-toggle属性且值为dropddown的元素：
  $(&apos;[data-toggle=&quot;dropdown&quot;]&apos;)....
(24) [attribute!=value]
(25) [attribute^=value]
(26) [attribute$=value]
(27) [attribute*=value]    具备指定的属性，且值中包含指定字符
</code></pre><p>12、第六组：可见性选择器</p>
<pre><code>(28) :visible         $(&apos;:visible&apos;)选中所有可见元素
(29) :hidden        $(&apos;:hidden&apos;)选中所有隐藏元素
测试：哪些是:hidden可以选中的？
      · display: none            可以
      · visibility: hidden        不可以
      · opacity: 0            不可以
      · input[type=&quot;hidden&quot;]    可以
</code></pre><p>13、第七组：内容过滤选择器</p>
<pre><code>  (30) :contains(txt)
    练习：选中文本中包含“提交”字的button元素，让它们变为绿色按钮
  (31) :has(selector)
    练习：选中包含.close按钮的.alert元素，让它们变为红色的警告框；
选中不包含.close按钮的.alert元素，让它们变为红色的警告框
  (32) :empty
    练习：选中内容为空的警告框    $(&apos;.alert:empty&apos;).....
  (33) :parent
    练习：选中内容不为空的警告框，即包含子元素或文本内容
    $(&apos;.alert:parent&apos;).....
</code></pre><p>14、第八组：表单元素选择器</p>
<pre><code>: input         :text         :password     :radio
:checkbox     :submit         :image         :reset
:button     :file             :hidden

:enabled     :disabled     :checked         :selected
  &lt;input type=&quot;image&quot; src=&quot;img/1.jpg&quot;&gt;
</code></pre><p>15、 W3C DOM把HTML文档看做树型结构，并提供操作节点方法；–总结</p>
<pre><code>jQuery是一个函数库，用于简化DOM操作，屏蔽了浏览器兼容性问题。函数分为四类：
  (1)DOM操作
  (2)事件处理
  (3)动画
  (4)AJAX
jQueryDOM操作——查找节点
  jQuery(&apos;选择器&apos;)    =》  类数组对象
基本选择器：
    #id、.class、div、*、button,.btn
层级选择器：
    parent  child
    parent &gt; child
    prev + next
    prev ~ siblings
基本过滤选择器：
    :first        :last        :eq(i)    :gt(i)        :lt(i)
    :odd        :even    :not(selector)
子代过滤选择器：
    :first-child    :last-child        :nth-child(i)
    :nth-child(odd)   :nth-child(even)
属性选择器：
    [attr=&quot;value&quot;]
可见性选择器：
    :visible        :hidden
内容选择器：
    :contains(txt)        :has(selector)
    :empty            :parent
表单元素选择器：
    :text        :radio    :submit
    :disabled    :enabled     :checked    :selected
</code></pre><p>16、操作元素的属性</p>
<pre><code>&lt;a  href=&quot;&quot; title=&quot;&quot;  data-toggle=&quot;dropdown&quot;&gt;
核心DOM：
  element.getAttribute(&apos;title&apos;)
  element.setAttribute(&apos;title&apos;, &apos;abc&apos;)
jQuery：
  var value  = $(..).attr(&apos;title&apos;)        //读取属性的值
  $(..).attr(&apos;title&apos;, &apos;abc&apos;)            //设置属性的值
提示：读取和设置元素的data-*扩展属性，可以使用attr()方法，也可以使用data()方法，如： &lt;a data-my-target=&quot;1.jpg&quot;&gt;
  var v = $(...).data(&apos;my-target&apos;)        //读取
  $(...).data(&apos;my-target&apos;, &apos;2.jpg&apos;)        //设置

练习：点击某个小图，下方就显示出对应的大图
  &lt;img src=&quot;img/4.jpg&quot; data-target=&quot;img/Koala.jpg&quot;&gt;
</code></pre><p>17、操作元素的内容</p>
<pre><code>核心DOM：
  var h = element.innerHTML;
  element.innerHTML = h;
  var t = element.innerText/textContent;
  element.innerText/textContext = t;
jQuery：
  $(..).html( )        //读取innerHTML
  $(..).html( &apos;html&apos; )    //设置innerHTML
  $(..).text( )        //读取innerText
  $(..).text( &apos;txt&apos; )        //设置innerText
练习：点击一个Button，上方显示出已点击的次数
练习：&lt;a href=&quot;#&quot;&gt;再次点击即显示下一张图片&lt;/a&gt;
  1再次点击即显示下一张图片
  2&lt;img src=&quot;1.jpg&quot;&gt;
  3再次点击即显示下一张图片
  4&lt;img src=&quot;2.jpg&quot;&gt;
  5再次点击即显示下一张图片
  6 ....
</code></pre><p>18、操作元素的样式</p>
<pre><code>核心DOM：
  var c = element.style.color        //读取行内样式
  element.style.color = &apos;red&apos;        //设置行内样式
  var n = element.className        //读取ClassName
  element.className = n            //设置ClassName
jQuery：
  $(..).css(&apos;color&apos;)        //读取指定样式的值
  $(..).css(&apos;color&apos;, &apos;red&apos;)    //设置行内样式
  $(..).addClass(&apos;alert&apos;)    //添加一个class
  $(..).removeClass(&apos;alert&apos;)    //删除一个class
  $(..).hasClass(&apos;alert&apos;)    //判断选定元素是否具有指定class
练习：实现一个“双态按钮”，点击一次变为深色，再点击变为浅色
  .up {  }            .down {  }
</code></pre><p>19、操作表单元素的值</p>
<pre><code>核心DOM：
    var v = input.value        //读取值
    input.value = &apos;v&apos;        //设置值
jQuery：
    $(...).val( )            //读取值
    $(...).val(&apos;value&apos;)    //设置值
练习：“用户名”和“密码”输入框，点击“提交注册信息”按钮后，读取用户的两个输入，打印出来，在输入框中清除用户的输入

面试题：在操作元素的相关属性时，使用attr()、val()、prop()、data()有何区别？
attr()一般只用于操作元素的HTML字面属性，如src、href、name...
val()操作的是HTML元素对应的JS对象的value属性
prop()操作的是HTML元素对应的JS对象的disabled、readyonly、selected、checked等Boolean类型属性
data()操作的是HTML元素对应的JS对象的扩展数据属性（对象缓存数据），而attr(&apos;data-xx&apos;)读取/修改的HTML元素字面属性
</code></pre><p>20、遍历DOM树上的节点</p>
<pre><code>核心DOM：
  element.parentNode            //寻找父节点
  element.childNodes/children        //获取子节点
  elemnet.nextSibling            //获取下一个兄弟
  element.previousSibling            //获取上一个兄弟
jQuery：
  $(..).parent()            //返回选定元素的父节点
  $(..).children()            //返回所有子节点
  $(..).next()            //返回下一个兄弟
  $(..).prev()            //返回上一个兄弟
  $(..).siblings()            //返回所有的同辈兄弟
练习：实现一个自己的页签组件

  &lt;ul class=&quot;tabs&quot;&gt;
      &lt;li&gt;&lt;a&gt;十元套餐&lt;/a&gt;&lt;/li&gt;
      &lt;li class=&quot;active&quot;&gt;&lt;a&gt;二十元套餐&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a&gt;三十元套餐&lt;/a&gt;&lt;/li&gt;
  &lt;/ul&gt;
</code></pre><p>21、添加新的元素</p>
<pre><code>核心DOM：
  var li = document.createElement(&apos;li&apos;)    //创建子节点
  //修改li的属性....                    //设置其属性
  ul.appendChild( li );                    //添加到父节点
jQuery：
  var li = $(&apos;&lt;li class=&quot;item&quot;&gt;内容&lt;/li&gt;&apos;)    //创建子节点
  //li.click(fn)
  $(&apos;ul&apos;).append( li );                //在父节点最后追加子节点
  $(li).appendTo( &apos;ul&apos; )            //子节点追加到父节点最后
   -------可以简写为------------------------------
  $(&apos;ul&apos;).append( &apos;&lt;li class=&quot;item&quot;&gt;内容&lt;/li&gt;&apos; )
练习：添加和删除小盒子

  function rc(){            //Random Color:  返回一个随机的颜色
      var r = Math.floor(Math.random()*256)
      var g = Math.floor(Math.random()*256)
      var b = Math.floor(Math.random()*256)
      return `rgb(  ,  ,  )`;
  }
</code></pre><p>22、删除已有的元素</p>
<pre><code>核心DOM：
  ul.removeChild( li )            //由父元素删除孩子
jQuery：
  $(&apos;li&apos;).remove()                //删除当前选定元素
</code></pre><p>23、替换已有元素</p>
<pre><code>核心DOM：
  parent.replaceChild(oldChild,  newChild);
jQuery：
  $(&apos;oldChild&apos;).replaceWith( newChild )    //已有节点用新节点替换，返回被删除的旧节点
  $(&apos;newChild&apos;).replaceAll( oldChild )    //新节点替换所有的旧节点，返回新节点
练习：实现英雄选择效果    div#chosen        div#list
</code></pre><p>24克隆节点</p>
<pre><code>核心DOM：
  var copy = element.cloneNode( )
jQuery：
  var copy = $(..).clone()        //返回选定元素的副本
  var copy = $(..).clone(copyListener)   //参数指示是否复制选定元素绑定的监听函数，默认为false，不复制监听函数
练习：改进“英雄选择”应用，要求点击某个小飞机后，下方仍然有该飞机，上方选中区域出现当前飞机的一个副本
</code></pre><p>25、jQuery函数第二部分：事件处理函数</p>
<pre><code>jQuery的历史上先后出现了若干事件处理函数：
(1)bind() / unbind()            已废弃
(2)one(事件名称, fn)    仅对指定事件监听一次
(3)live() / die()                已废弃
(4)delegate() / undelegate()    已废弃
(5)on() / off()
(6)click() / mouseover() / mouseout() / keyup() ...
  $(..).click(fn)  &lt;=&gt;  $(..).on(&apos;click&apos;, fn)

  on()函数的第一种使用方法——直接绑定在事件源上：
      $(&apos;事件源&apos;).on(&apos;事件名称&apos;, fn)    //绑定监听函数
      $(&apos;事件源&apos;).off(&apos;事件名称&apos;)        //取消所有监听函数
  练习：点击“开始抽奖”按钮，命令行中输出“抽奖中”，按钮上的文字也变为“抽奖中”；要求此后此按钮再被点击无任何处理函数了。
  on()的第一种用法有两个限制：
      (1)若选中元素很多，每个都会有一个监听函数
      (2)无法为后添加的元素执行绑定
  on()函数的第二种使用方法——委托给父元素进行事件代理：
      $(&apos;parent&apos;).on(&apos;事件名称&apos;, &apos;子元素选择器&apos;, fn)
</code></pre><p>26、 DOM中为元素绑定监听函数：</p>
<pre><code>btn.onclick = function(){  }
btn.addEventListener(&apos;click&apos;, function(){  })
jQuery中的on()函数底层是addEventListener
</code></pre><p>27、DOM操作——增删改查</p>
<pre><code>(1)查找元素：  $(&apos;选择器&apos;)   jQuery(&apos;选择器&apos;)
(2)操作元素的属性： $(..).attr()
(3)操作元素的内容： $(..).html()  $(..).text()
(4)操作元素的样式： $(..).css()
    $(..).addClass()   $(..)removeClass()
    $(..).hasClass()  $(..).toggleClass(&apos;.btn&apos;)
 (5)操作元素的值：  $(..).val()
 (6)遍历元素：
    $(..).parent()
    $(..).children()-直接子代
    $(..).find()-所有子元素
    $(..).next()        $(..).nextAll()
    $(..).prev()        $(..).prevAll()
    $(..).siblings()
(7)插入节点：  $(..).append()   $(..).prepend()
(8)删除节点：  $(..).remove()   $(..).empty()
(9)替换节点：  $(..).replaceWith()  $(..).replaceAll()
(10)克隆节点： $(..).clone()
</code></pre><p>28、事件处理函数：</p>
<pre><code>(1)$(&apos;.btn&apos;).one(&apos;click&apos;, fn)
(2)$(&apos;.btn&apos;).click(fn) ....
(3)$(&apos;.btn&apos;).on(&apos;click&apos;, fn)        off(..)
  $(&apos;.container&apos;).on(&apos;click&apos;, &apos;.btn&apos;, fn)  off(..)

  让jQuery放弃使用 $ ：
  jQuery.noConflict()
</code></pre><p>29、面试题：window.onload和$(document).ready()的异同？</p>
<pre><code>window.onload是核心DOM的写法：
  window.onload = function(){ ... }
  只能为绑定一次；
  只有全部的网页内容(html/css/js/图片....)加载完成才能触发。

$(document).ready()是jQuery的写法：
  $(document).ready(function(){ ... })
  底层是addEventListener(&apos;DOMContentLoaded&apos;, fn)，可以先后绑定多次；
  只要“DOM内容(只包括html/js)加载完成”即可触发。
</code></pre><p>30、补充：jQuery中的hover()函数</p>
<pre><code>jQuery监听“鼠标进入+鼠标离开”有如下三种方法：
(1) $(..).mouseover(fn)   +  $(..).mouseout(fn)
(2) $(..).mouseenter(fn)   +   $(..).mouseleave(fn)
(3) $(..).hover( fn, fn )
注意：方法3等同于方法2
</code></pre><p>31、补充：jQuery中的trigger()函数</p>
<pre><code>使用JS代码代替用户触发指定的事件，调用之前绑定的监听函数。
$(&apos;.btn&apos;).trigger( &apos;click&apos; )
可以简写为：
$(&apos;.btn&apos;).click( )
</code></pre><p>32、jQuery中的函数第三部分：动画函数 —— 隐藏和显示动画</p>
<pre><code>隐藏和显示函数通过使用定时器修改目标元素的width / height / opcaity三个样式的值来实现动画：
$(..).show()      $(..).show(&apos;slow/normal/fast&apos;)  $(..).show(3000)
$(..).hide()    $(..).hide(&apos;slow/normal/fast&apos;)  $(..).hide(3000)
$(..).toggle()     ...  在隐藏和显示之间切换
</code></pre><p>33、jQuery中的函数第三部分：动画函数 —— 折叠展开/收起动画</p>
<pre><code>折叠展开/收起动画函数通过使用定时器修改目标元素的height一个样式的值来实现动画：
$(..).slideUp( )    $(..).slideUp( &apos;slow/normal/fast&apos; )   $(..).slideUp( 300 )
$(..).slideDown( )  ....
$(..).slideToggle( )   ....

练习：仿写Bootstrap中的响应式导航条在手机中的效果
&lt;div class=&quot;navbar&quot;&gt;
  &lt;div class=&quot;navbar-header&quot;&gt;
      &lt;a class=&quot;navbar-brand&quot;&gt;TARENA&lt;/a&gt;
      &lt;a class=&quot;navbar-toggle&quot;&gt;三&lt;/a&gt;
  &lt;/div&gt;
  &lt;div class=&quot;navbar-collapse&quot;&gt;
      ul&gt;li&gt;a
  &lt;/div&gt;
&lt;/div&gt;
</code></pre><p>34、jQuery中的函数第三部分：动画函数 —— 淡入/淡出动画</p>
<pre><code>淡入/淡出动画函数通过使用定时器修改目标元素的opacity一个样式的值来实现动画：
$(..).fadeIn( )  $(..).fadeIn(&apos;slow/normal/fast&apos;)  $(..).fadeIn(300)
$(..).fadeOut( )
$(..).fadeToggle( )
提示：上述六个动画函数都可以在最后接收一个参数——函数
  $(..).fadeOut( 300,  function(){ //在动画结束时的回调函数 })
练习：点击小星星后，闪动3次，最后消失
</code></pre><p>35、jQuery中的函数第三部分：动画函数 —— animate()</p>
<pre><code>$(..).animate({
  属性1: 值1;
  ...
}, 300, fn)
动画排队：执行完一个动画后，再执行另一个
动画并发：同时执行多个属性的动画效果

animate({})可以对哪些CSS属性执行动画？
(1)width、height、opacity、fontSize....等等有可渐变属性值（数值型）的样式可以执行动画
(2)display、fontFamily、transform、颜色类属性等没有渐变属性值的样式不能执行动画
</code></pre><p>36、Web应用中可用的动画技术：</p>
<pre><code>(1)CSS3 Transition
(2)CSS3 Keyframes
(3)定时器 + 属性修改            jQuery1/2动画函数
(4)requestAnimationFrame       jQuery3
</code></pre><p>37、jQuery类数组对象的操作</p>
<pre><code>  window.$  &lt;=&gt; window.jQuery
$()函数或jQuery()返回值是一个“类数组对象”—— 有点像数组，但不是Array类型的实例，其中封装着查找到的所有DOM元素。该对象称为“jQuery对象”，其类数组相关操作：
  $(..).length        获取类数组中封装的DOM对象的数量
  $(..)[index]        获取类数组中封装的第index个DOM对象
  $(..).get(index)        获取类数组中封装的第index个DOM对象
  $(..).each(fn)        遍历类数组中封装的每一个DOM对象，针对每个DOM元素执行一次指定的回调函数
  $(..).index(domObj)    返回指定的DOM元素在当前类数组中的下标
</code></pre><p>38、补充：页面DOM内容加载完成后执行指定的函数</p>
<pre><code>$(document).ready(fn)
$().ready(fn)
$(fn)
</code></pre><p>39、jQuery中的插件函数</p>
<pre><code> Plugin：插件，在现有的功能基础上添加更多的功能，扩展整体的应用。
jQuery中的插件（即函数）分为两类：
 1.jQuery全局插件函数
   原本要声明的工具函数（如max()/min()）如果声明为全局函数，会造成“全局对象(window)的污染；
   为了避免污染全局对象，可以把这些函数纳入到 jQuery对象的名下——与jQuery没有必然的关系：
   声明方式：    jQuery.max = function(arr){  }
               jQuery.extend({ max: fn,  min: fn})
   调用方式：    jQuery.max([10,38,50])
 2.jQuery对象插件函数
   jQuery对象插件函数就是为所有的jQuery对象（$()函数的返回值）添加的公共函数，用于操作当前选定的DOM元素。
   声明方式：    jQuery.fn.max = function( ){  }
               jQuery.fn.extend({ max: fn,   min: fn})
   调用方式：    $(&apos;li&apos;).max( )

   jQuery(..) 或 $(..) 的返回值是一个类数组对象——“jQuery对象”，所有的jQuery对象的原型： jQuery.fn;
   若想给所有的jQuery对象都添加一个扩展函数，只需要加给jQuery.fn即可

  3.复杂插件的编写：轮播广告
       $(&apos;..&apos;).carousel( );

  4.复杂插件的编写：滚动监听
       $(&apos;..&apos;).scrollspy( );
</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;1、 DOM分为三部分：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;(1)核心DOM：操作任意标签树
(2)HTML DOM：操作HTML标签树
(3)XML DOM：操作XML标签树
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;2、常用的核心DOM操作&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;(1)查找元
    
    </summary>
    
      <category term="学习笔记" scheme="www.wangchengzou.cn/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="javaScript" scheme="www.wangchengzou.cn/tags/javaScript/"/>
    
      <category term="JQuery" scheme="www.wangchengzou.cn/tags/JQuery/"/>
    
  </entry>
  
  <entry>
    <title>JSON 的了解</title>
    <link href="www.wangchengzou.cn/2017/07/22/JSON%20%E7%9A%84%E4%BA%86%E8%A7%A3/"/>
    <id>www.wangchengzou.cn/2017/07/22/JSON 的了解/</id>
    <published>2017-07-22T15:48:26.000Z</published>
    <updated>2017-07-23T08:39:00.433Z</updated>
    
    <content type="html"><![CDATA[<p>JSON(JavaScript Object Notation) 是一种轻量级的数据交换格式。它是基于JavaScript的一个子集。数据格式简单, 易于读写, 占用带宽小如：{“age”:”12”, “name”:”back”}<br>JSON字符串转换为JSON对象:<br>var obj =eval(‘(‘+ str +’)’);<br>var obj = str.parseJSON();<br>var obj = JSON.parse(str);</p>
<p>JSON对象转换为JSON字符串：<br>var last=obj.toJSONString();<br>var last=JSON.stringify(obj);</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;JSON(JavaScript Object Notation) 是一种轻量级的数据交换格式。它是基于JavaScript的一个子集。数据格式简单, 易于读写, 占用带宽小如：{“age”:”12”, “name”:”back”}&lt;br&gt;JSON字符串转换为JSON对象:&lt;
    
    </summary>
    
      <category term="面试题目" scheme="www.wangchengzou.cn/categories/%E9%9D%A2%E8%AF%95%E9%A2%98%E7%9B%AE/"/>
    
    
      <category term="javaScript" scheme="www.wangchengzou.cn/tags/javaScript/"/>
    
  </entry>
  
  <entry>
    <title>Javascript作用链域?</title>
    <link href="www.wangchengzou.cn/2017/07/22/Javascript%E4%BD%9C%E7%94%A8%E9%93%BE%E5%9F%9F/"/>
    <id>www.wangchengzou.cn/2017/07/22/Javascript作用链域/</id>
    <published>2017-07-22T15:48:26.000Z</published>
    <updated>2017-07-23T08:27:58.046Z</updated>
    
    <content type="html"><![CDATA[<p>全局函数无法查看局部函数的内部细节，但局部函数可以查看其上层的函数细节，直至全局细节。<br>当需要从局部函数查找某一属性或方法时，如果当前作用域没有找到，就会上溯到上层作用域查找，直至全局函数，这种组织形式就是作用域链。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;全局函数无法查看局部函数的内部细节，但局部函数可以查看其上层的函数细节，直至全局细节。&lt;br&gt;当需要从局部函数查找某一属性或方法时，如果当前作用域没有找到，就会上溯到上层作用域查找，直至全局函数，这种组织形式就是作用域链。&lt;/p&gt;

    
    </summary>
    
      <category term="面试题目" scheme="www.wangchengzou.cn/categories/%E9%9D%A2%E8%AF%95%E9%A2%98%E7%9B%AE/"/>
    
    
      <category term="javaScript" scheme="www.wangchengzou.cn/tags/javaScript/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript原型，原型链，有什么特点</title>
    <link href="www.wangchengzou.cn/2017/07/22/JavaScript%E5%8E%9F%E5%9E%8B%EF%BC%8C%E5%8E%9F%E5%9E%8B%E9%93%BE%EF%BC%8C%E6%9C%89%E4%BB%80%E4%B9%88%E7%89%B9%E7%82%B9/"/>
    <id>www.wangchengzou.cn/2017/07/22/JavaScript原型，原型链，有什么特点/</id>
    <published>2017-07-22T15:48:26.000Z</published>
    <updated>2017-07-23T08:22:28.232Z</updated>
    
    <content type="html"><![CDATA[<p>每个对象都会在其内部初始化一个属性，就是prototype(原型)，当我们访问一个对象的属性时，如果这个对象内部不存在这个属性，那么他就会去prototype里找这个属性，这个prototype又会有自己的prototype，于是就这样一直找下去，也就是我们平时所说的原型链的概念。<br>关系：instance.constructor.prototype = instance.<strong>proto</strong><br>特点：JavaScript对象是通过引用来传递的，我们创建的每个新对象实体中并没有一份属于自己的原型副本。当我们修改原型时，与之相关的对象也会继承这一改变。<br>当我们需要一个属性的时，Javascript引擎会先看当前对象中是否有这个属性， 如果没有的话，  就会查找他的Prototype对象是否有这个属性，如此递推下去，一直检索到 Object 内建对象。<br> function Func(){}<br> Func.prototype.name = “Sean”;<br> Func.prototype.getInfo = function() {return this.name;}<br> var person = new Func();//现在可以参考var person = Object.create(oldObject);<br> console.log(person.getInfo());//它拥有了Func的属性和方法<br> //“Sean”<br> console.log(Func.prototype);<br> // Func { name=”Sean”, getInfo=function()}</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;每个对象都会在其内部初始化一个属性，就是prototype(原型)，当我们访问一个对象的属性时，如果这个对象内部不存在这个属性，那么他就会去prototype里找这个属性，这个prototype又会有自己的prototype，于是就这样一直找下去，也就是我们平时所说的原型链
    
    </summary>
    
      <category term="面试题目" scheme="www.wangchengzou.cn/categories/%E9%9D%A2%E8%AF%95%E9%A2%98%E7%9B%AE/"/>
    
    
      <category term="javaScript" scheme="www.wangchengzou.cn/tags/javaScript/"/>
    
  </entry>
  
  <entry>
    <title>Javascript如何实现继承</title>
    <link href="www.wangchengzou.cn/2017/07/22/Javascript%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E7%BB%A7%E6%89%BF/"/>
    <id>www.wangchengzou.cn/2017/07/22/Javascript如何实现继承/</id>
    <published>2017-07-22T15:48:26.000Z</published>
    <updated>2017-07-23T08:23:34.884Z</updated>
    
    <content type="html"><![CDATA[<p>1、构造继承<br>2、原型继承<br>3、实例继承<br>4、拷贝继承<br>原型prototype机制或apply和call方法去实现较简单，建议使用构造函数与原型混合方式。<br>function Parent(){  this.name = ‘wang’;   }<br>function Child(){   this.age = 28;    }<br>Child.prototype = new Parent();//继承了Parent，通过原型<br>var demo = new Child();<br>alert(demo.age);<br>alert(demo.name);//得到被继承的属性   }</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;1、构造继承&lt;br&gt;2、原型继承&lt;br&gt;3、实例继承&lt;br&gt;4、拷贝继承&lt;br&gt;原型prototype机制或apply和call方法去实现较简单，建议使用构造函数与原型混合方式。&lt;br&gt;function Parent(){  this.name = ‘wang’;   }&lt;
    
    </summary>
    
      <category term="面试题目" scheme="www.wangchengzou.cn/categories/%E9%9D%A2%E8%AF%95%E9%A2%98%E7%9B%AE/"/>
    
    
      <category term="javaScript" scheme="www.wangchengzou.cn/tags/javaScript/"/>
    
  </entry>
  
</feed>
