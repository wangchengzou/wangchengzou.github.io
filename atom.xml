<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>~~博客园~~</title>
  <subtitle>千帆渡</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="www.wangchengzou.cn/"/>
  <updated>2017-07-23T03:52:11.433Z</updated>
  <id>www.wangchengzou.cn/</id>
  
  <author>
    <name>汪成邹</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>link和@import有什么区别</title>
    <link href="www.wangchengzou.cn/2017/07/23/link%E5%92%8C-import%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB/"/>
    <id>www.wangchengzou.cn/2017/07/23/link和-import有什么区别/</id>
    <published>2017-07-23T03:50:15.000Z</published>
    <updated>2017-07-23T03:52:11.433Z</updated>
    
    <content type="html"><![CDATA[<p>（1）link属于XHTML标签，除了加载CSS外，还能用于定义RSS, 定义rel连接属性等作用；而@import是CSS提供的，只能用于加载CSS; （2）页面被加载的时，link会同时被加载，而@import引用的CSS会等到页面被加载完再加载; （3）import是CSS2.1 提出的，只在IE5以上才能被识别，而link是XHTML标签，无兼容问题;</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;（1）link属于XHTML标签，除了加载CSS外，还能用于定义RSS, 定义rel连接属性等作用；而@import是CSS提供的，只能用于加载CSS; （2）页面被加载的时，link会同时被加载，而@import引用的CSS会等到页面被加载完再加载; （3）import是
    
    </summary>
    
      <category term="面试题目" scheme="www.wangchengzou.cn/categories/%E9%9D%A2%E8%AF%95%E9%A2%98%E7%9B%AE/"/>
    
    
      <category term="html" scheme="www.wangchengzou.cn/tags/html/"/>
    
      <category term="css" scheme="www.wangchengzou.cn/tags/css/"/>
    
  </entry>
  
  <entry>
    <title>行内元素有哪些？块级元素有哪些？ 空(void)元素有那些？</title>
    <link href="www.wangchengzou.cn/2017/07/23/%E8%A1%8C%E5%86%85%E5%85%83%E7%B4%A0%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F%E5%9D%97%E7%BA%A7%E5%85%83%E7%B4%A0%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F-%E7%A9%BA-void-%E5%85%83%E7%B4%A0%E6%9C%89%E9%82%A3%E4%BA%9B%EF%BC%9F/"/>
    <id>www.wangchengzou.cn/2017/07/23/行内元素有哪些？块级元素有哪些？-空-void-元素有那些？/</id>
    <published>2017-07-23T02:47:53.000Z</published>
    <updated>2017-07-23T03:49:03.701Z</updated>
    
    <content type="html"><![CDATA[<p>行内元素有：a b span img input select strong（强调的语气）<br>块级元素有：div ul ol li dl dt dd h1 h2 h3 h4…p<br>常见的空元素：<br> <hr> <img> <input> <link> <meta></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;行内元素有：a b span img input select strong（强调的语气）&lt;br&gt;块级元素有：div ul ol li dl dt dd h1 h2 h3 h4…p&lt;br&gt;常见的空元素：&lt;br&gt; &lt;hr&gt; &lt;img&gt; &lt;input&gt; &lt;link&gt; &lt;meta
    
    </summary>
    
      <category term="面试题目" scheme="www.wangchengzou.cn/categories/%E9%9D%A2%E8%AF%95%E9%A2%98%E7%9B%AE/"/>
    
    
      <category term="html" scheme="www.wangchengzou.cn/tags/html/"/>
    
  </entry>
  
  <entry>
    <title>javaScript高级基础知识</title>
    <link href="www.wangchengzou.cn/2017/07/22/javaScript%E9%AB%98%E7%BA%A7%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    <id>www.wangchengzou.cn/2017/07/22/javaScript高级基础知识/</id>
    <published>2017-07-22T15:48:26.000Z</published>
    <updated>2017-07-23T12:45:43.316Z</updated>
    
    <content type="html"><![CDATA[<p>1、 错误处理:</p>
<pre><code>错误bug: 程序执行过程中，导致程序无法正常执行的情况
后果: 程序会强行中断退出
错误处理: 即使程序出现错误，也保证程序不异常中断的机制。
如何: try{//始终执行
       //可能出错的代码
     }catch(err){//只有发生错误时才执行
       //err: 错误对象: 发生错误时，自动创建的，封装错误信息的对象
       //出错时，执行的错误处理代码:
         //比如: 通知用户，记录日志，保存进度
     }[finally{//无论是否出错，都必须执行的代码
       //一般用于释放资源
     }]//可有可无，因为放在try catch之后的代码本来就总是执行的。
问题: 放在try catch中的代码，执行效率会降低
解决: 2种:
  1. 尽量少的将代码放入try catch
  2. 如果可提前预知错误原因，可用if...else代替try catch，提前预防错误。

抛出自定义异常:
throw new Error(&quot;错误信息&quot;)

js中错误对象的类型: 6种
  SyntaxError: 语法错误: 程序的语法写错了
  ReferenceError: 引用错误: 要用的变量没找到
  TypeError: 类型错误: 错误的使用对象的类型:
     比如: 对非数组使用[]
           对非函数使用()
           对null/undefined用.xxx
           要调用的函数，对象中没有:
             比如: console.write();
                  document.log();
  RangeError: 范围错误: 参数值超规定范围:
         比如: toFixed(d) d: 0~20之间 如果写-2

  URIError, EvelError;
</code></pre><p>2、 Functions:</p>
<pre><code>创建: 3种:
  1. 声明: function 函数名(参数列表){
            函数体;
            return 返回值;
          }
     问题: 被声明提前
     解决:
  2. 函数直接量: var函数名=function (参数列表){...}
     优点: 不会被声明提前
     揭示: 函数是一个引用类型的对象
           函数名只是一个引用函数对象的普通变量
  3. 用new: 了解
    var函数名=new Function(&quot;参数&quot;,&quot;参数&quot;,&quot;函数体;...&quot;)
 鄙视: 以下创建函数方式正确的是:
    function fun(a,b){return a-b};
    var fun=function(a,b){return a-b};
    var fun=new Function(a,b,&quot;return a-b&quot;); X
    var fun=new Function(&quot;a&quot;,&quot;b&quot;,&quot;return a-b&quot;);

重载: overload
 什么是: 相同函数名，不同参数列表的多个函数，在调用时可自动根据传入参数的不同，选择对应的函数执行。
 为什么: 减少API的名字，减轻调用者的负担
 何时: 只要一项任务，可能根据不同的参数执行不同的逻辑时。
 问题: js语法默认不支持重载
      为什么: js中不允许多个相同名称的函数同时存在
             后定义的同名函数，会覆盖先定义的。
 解决: 2步:
  1. 将多个函数合并为一个函数，省略参数列表
  2. 函数内，用arguments接住所有传入的变量值
    arguments: 每个函数中自动创建的
              自动接收所有参数值的类数组对象
     类数组对象: 长的像数组的对象:
       vs 数组: 相同: 1. 下标, 2. length, 3. for遍历
               不同: 类型不同, 类数组对象不能使用数组的API
       比如: childNodes  children

  参数变量依然必要:
    1. 参数变量可指导调用者正确的使用函数
    2. 参数名都是有意义的，便于维护/提高程序可读性
    3. 自定义的参数名通常简洁

匿名函数:
什么是: 定义函数时，不指定函数名的函数
为什么: 节约内存!
何时: 只要一个函数只使用一次时
  2种:
    1. 回调callback: 将一个函数作为参数传给另一个函数中调用
       比如: arr.sort(function(a,b){return a-b;})
            str.replace(reg,function(kw){return ......})
            addEventListener(&quot;click&quot;,function(){...})
            setInterval/Timeout(function(){...}, ms )
    特例: 如果函数可能被反复调用或可能被多个元素共享时，应该用有名的函数。
    2. 匿名函数自调:
    定义一个函数后，立刻调用该函数，调用后立即释放
    何时: 划分临时作用域，避免全局变量污染时
    如何: 2种:
      1. (function([参数列表]){...})([参数值])
      2. +function(...){}(...)
</code></pre><p>3、作用域和作用域链:</p>
<pre><code>作用域(scope): 变量的可用范围
  包含2种:
    1. 全局作用域对象window
       全局变量: 优: 可重复使用，随处可用
                 缺: 极易造成全局污染
                    ——今后尽量避免使用全局变量
    2. 函数作用域对象AO
       局部变量: 优: 仅函数内可用，不会造成全局污染
                 缺: 不可重用！
作用域链(scope chain):
 什么是: 由各级作用域对象连续引用，形成的链式结构
 函数的声明周期:
   1. 程序开始执行前:
      程序会创建全局作用域对象window
   2. 定义函数时
      在window中创建函数名变量引用函数对象
      函数对象的隐藏属性scope指回函数来自的全局作用域对象window——就好像人的祖籍
   3. 调用函数时
      创建本次函数调用时使用的AO对象
      在AO对象中添加函数的局部变量
      设置AO的隐藏属性parent 指向函数的祖籍作用域对象。——执行时，如果AO中没有的变量可延parnet向祖籍作用域对象找。
   4. 函数调用后
      函数作用域对象AO释放
        导致AO中局部变量释放
 作用域链: 2项任务：
   1. 保存了所有的变量
   2. 控制了变量的使用顺序: 先用局部，局部没有才延作用域链向下查找。
</code></pre><p>4、闭包(closure)</p>
<pre><code>什么是: 即重用变量，又保护变量不被污染的一种结构
为什么: 全局变量: 优: 可重用, 缺: 全局污染
        局部变量: 优: 不会被污染, 缺: 不可重用
何时: 只要希望重用一个变量，并保护变量不被污染。
如何: 3步:
  1. 使用外层函数包裹受保护的变量和操作变量的内层函数
  2. 外层函数将内层函数返回到外部
  3. 调用者用外部变量接住返回的内层函数
问题: 闭包结构比普通函数占用更多的内存: 外层函数的函数作用域对象
解决: 使用完闭包后，要主动释放闭包:
  将引用内层函数的外部变量置为null

鄙视: 画简图:
  1. 找受保护的变量:
      是外层函数的局部变量
      同时, 在内层函数中被使用
  2. 找外层函数都返回了哪些内层函数用于操作受保护的变量: 2种手段:
    1. return function
    2. 可直接给一个全局变量赋值一个function
</code></pre><p>5、 什么是面向对象: 程序中都是用对象结构来描述现实中一个具体事务的属性和功能</p>
<pre><code>为什么: 便于维护
何时: 今后几乎所有大型项目都采用面向对象的思想
如何: 三大特点: 封装，继承，多态
</code></pre><p>6、封装: 用一个对象结构集中保存现实中一个事物的多个属性和功能。</p>
<pre><code>什么是对象: 封装一个事物的属性，并提供操作事物的功能的数据结构。
为什么: 现实中任何一个数据或一项功能都属于一个具体事物。——便于维护
何时: 今后只要使用面向对象的方式，首先都要创建对象。
如何: 3种:
 1. 对象直接量: var obj={
                 属性名:值,
                    ... : ... ,
                   方法:function(){
                     ...this.属性名...
                   }
                    ... : ...
               }
     属性，其实就是保存在对象中的一个普通变量
     方法，其实就是保存在对象中的一个普通函数
     问题: 对象自己的方法，通常要使用对象自己的属性值
       错误: 直接使用属性名当变量
       正确: this: 引用正在调用函数的.前的对象的关键词
         今后，只要对象自己的方法要使用对象自己的属性，必须用this.属性名

访问对象的成员: 成员=属性+方法
  访问属性: 对象.属性名  用法和普通变量完全一样
      特殊: 要访问的属性不存在，不报错！
           返回undefined
  调用方法: 对象.方法名() 用法和普通函数完全一样！
 2. 用new: 2步:
    var obj=new Object(); //先创建一个空对象
    obj.属性名=属性值;//再向空对象中添加属性和方法
    obj.方法名=function(){
      ...this.属性名...
    }
   其实js中的对象可在任何时候添加新属性和方法
   特殊: 要赋值的属性不存在，不报错!
         而是在对象中动态添加该属性
js中对象的本质，就是关联数组。
  其实访问成员: 对象[&quot;属性名&quot;]
                对象[&quot;方法名&quot;]()
  . vs [] : 如果要访问的属性名是固定的，就用.访问
         如果要访问的属性名是动态生成的，就用[]

问题: 只能创建一个单独的对象
      反复创建多个相同结构的对象时，代码重复严重
解决: 构造函数
3. 用构造函数反复创建多个相同结构的对象
什么是构造函数: 描述同一类型的所有对象共同成员结构的函数。
为什么: 代码重用！
何时: 只要反复创建同一类型的多个对象时
如何: 2步:
 1. 定义构造函数:
    function 类型名(属性参数列表){
       this.属性名=参数;
             ... = ... ;
       this.方法名=function(){
         ...this.属性名...
       }
    }
 2. 调用构造函数创建一个对象:
    var obj=new 类型名(属性值列表)
原理: new: 4件事:
  1. 创建新的空对象，将构造函数中的this-&gt;新对象
  2. 让新对象自动继承构造函数的原型对象
  3. 执行构造函数中的语句，向新对象中添加新成员并赋值
  4. 返回新对象地址保存到变量中
</code></pre><p>7、 继承: 父对象的成员，子对象无需重复创建，就可直接使用。</p>
<pre><code>为什么: 代码重用，节约内存
如何:
原型对象: 集中保存同一类型的子对象共有成员的父对象
    创建: 在定义构造函数时，自动创建(买一赠一)
    如何:
      1. 使用构造函数创建子对象时，会自动设置子对象继承构造函数的原型对象
      2. 放在原型对象中的成员，所有子对象共用
    如何访问构造函数的原型对象:
      构造函数.prototype.成员名=值/function(){...}
总结: 今后，只要希望所有子对象共有的成员，都要添加到构造函数的原型对象中。而不应该放在构造函数内。

共有属性和自有属性:
  共有属性: 添加到原型对象中，所有子对象共有的属性
  自有属性: 直接保存在对象本地的属性
  访问: 读取: 两者用法完全相同: 对象.属性
             先在对象本地找，没有，才去父对象中找
        修改: 自有属性: 对象.属性=值
              共有属性: 子对象不允许修改共有属性
                  必须通过构造函数
                  构造函数.prototype.属性=值
  判断属性是否可用/包含:
    &quot;成员&quot;  in 对象
    返回bool
       强调: in不仅判断自有属性，而且判断父对象中的共有属性。

内置对象的原型对象:
内置对象，也有构造函数和原型对象
  构造函数负责创建指定类型的对象
  原型对象负责保存该类型子对象共有的API
  解决新旧浏览器API兼容性问题: 2步:
    1. 判断当前浏览器是否支持API
    2. 如果不支持，就自定义一个API放入该类型的原型对象中

原型链: 由多级父对象逐级继承形成的链式结构
  保存了所有对象的成员(属性和方法)
  定义了成员的使用顺序:
     先用自有成员, 自己没有，才延原型链向父对象查找
  vs 作用域链:
     保存了所有变量(全局/局部)
     定义了变量的使用顺序: 先用局部，没有，才延作用域链先父级作用域查找
总结: 只要不需要对象. 就可直接访问的变量都存在作用域链。
      只要必须用对象.才能访问的对象成员都存在原型链中。
</code></pre><p>8、 多态: 同一个方法，在不同情况下表现出不同的状态。</p>
<pre><code>js中仅支持重写(override)
什么是重写: 如果子对象觉得父对象的成员不好用，可自定义自有成员，覆盖父对象中的成员。
为什么: 从父对象继承来的成员，不一定总是想要的
何时: 只要子对象觉得父对象的成员不好用
</code></pre><p>9、 自定义继承:</p>
<pre><code>1. 仅修改两个对象间的继承关系
   Object.setPrototypeOf(child, father)
    让child继承father( 设置child的__proto__继承father)
   问题: 一次只能修改一个对象的继承关系
   解决:
2. 修改构造函数的原型对象来修改所有子对象的父对象
    构造函数.prototype=新father
   强调: 必须在创建子对象之前更换

3. 两种类型间的继承:
  问题: 如果两种类型间有部分相同的属性结构和方法
  优化: 3步:
    1. 定义抽象父类型:
         父类型构造函数中定义公共的属性结构
         父类型原型对象中定义公共的方法
    2. 在子类型构造函数中借用父类型构造函数
      错误: 直接调用父类型构造函数()
        因为如果一个函数没有用new或任何对象.调用，则this默认-&gt;window
      正确: 用call/apply，将父类型构造中的this临时替换为子类型构造函数中的this
        父类型构造.call(this,参数....)
    3. 设置子类型的原型对象继承父类型的原型对象
</code></pre><p>10、 ES5:</p>
<pre><code>保护对象:
 保护属性:
   命名属性: 可用.直接访问的属性
     数据属性: 实际存储属性值的属性
       如何保护: 每个属性其实由四大特性组成:
         {
          value: 值, //实际存储属性值
          writable: true, //控制是否可修改
          enumerable:true,//控制是否可用for in遍历到
                        //即使不能for in，用.也能访问
          configurable:true,//控制是否可修改其他特性
                         //控制能否删除该属性
                         //改为false后不可逆
         }
       获取一个对象的属性的四大特性:
       Object.getOwnPropertyDescriptor(obj,&quot;属性名&quot;)
       修改一个对象的属性的四大特性:
       Object.defineProperty(obj,&quot;属性名&quot;,{
         特性名:特性值,
            ... : ... ,
       });
       问题: 一次只能修改一个属性
       解决: 同时修改多个属性
       Object.defineProperties(obj,{
         属性名:{
           特性名:特性值,
              ... : ...
         },
         属性名:{
           特性名:特性值,
              ... : ...
         },
       })
       强调: 必须启用严格模式才能报错！
       问题: 只能进行简单的保护，无法自定义保护规则
       解决:
     访问器属性: 不实际存储属性值，仅提供对另一个属性值的保护。
      何时: 只要使用自定义规则保护属性时
      如何定义: 2步:
        1. 必须先定义一个隐藏的属性来实际存储属性值
        2. 定义访问器属性，提过对受保护的属性的读写操作和验证。
        Object.defineProperty(obj,&quot;属性名&quot;,{
          get:function(){
             return //受保护的属性值
          },
          set:function(val){
             //如果val符合规则
               受保护的属性=val
             //否则
               抛出自定义错误
          },
          enumerable:true, configurable:true,
        })
        强调:访问器属性中要使用对象自己的属性，也必须加this.
        如何使用: 访问器属性的用法和普通属性的用法完全一样。
          只不过: 获取访问器属性值时，自动调用get方法，实际获得的是受保护的隐藏属性的值
                  修改访问器属性值时，自动调用set方法，自动将新值传给val，经过验证才，实际保存到受保护的隐藏属性中。
   内部属性: 不可用.访问的属性: __proto__
 防篡改: 防止在对象创建后，修改对象的结构/内容
   3个级别:
   1. 防扩展: 禁止给对象添加任何新属性
     Object.preventExtensions(obj);
   2. 密封: seal 在防扩展基础上，再禁止删除现有属性
     Object.seal(obj)
     相当于将所有属性的configurable特性都改为false
   3. 冻结: 禁止对对象做任何修改(包括结构和值)
     Object.freeze(obj);
     三件事: 1. 禁止扩展
            2. 修改所有属性的configurable为false
            3. 修改所有属性的writable为false
</code></pre><p>11、 数组API: 3组</p>
<pre><code> 1. 判断: 判断数组中的元素是否符合要求:
   every: 判断数组中的元素是否*都*符合要求:
     如何: var bool=arr.every(function(val,i,arr){
            //val, 当前元素值
            //i, 当前位置
            //arr, 当前数组
            return 判断条件
          })
   some: 判断数组中是否*包含*符合要求的元素:
 2. 遍历: 对每个元素执行相同操作
   forEach: 对原数组中每个元素执行相同操作
          直接修改原数组
     arr.forEach(function(val,i,arr){
       arr[i]=新值;
     })
   map: 取出原数组中每个元素，执行相同操作后，放入一个新数组中返回
          不修改原数组，仅返回新数组
     var 新数组=arr.map(function(val,i,arr){
       return 新值;
     });
 3. 过滤和汇总:
   过滤: 筛选出原数组中符合条件的元素组成新数组。
         原数组不变。
     var subArr=arr.filter(function(val,i,arr){
       return 判断条件
     })
   汇总: 将数组中每个元素的值，汇总成一个最终结果
     返回值: 一个汇总结果
     var result=arr.reduce(function(prev,val,i,arr){
       return prev+val;//累加
     },base);
  问题: 仅简化了代码，未提高程序的性能
       所有遍历API中使用的都是for循环遍历每个元素

Object.create方法: 直接用父对象创建子对象，并扩展子对象的自有属性:
  何时: 如果只有父对象，也想创建子对象时
  如何:  var child=Object.create(father,{
           新属性:{四大特性},
              ... : ...
         });
</code></pre><p>12、<em>**</em>call/apply/bind: 替换函数中不想要的this</p>
<pre><code>call/apply : 临时替换函数中的this
 差别: call，要求传入函数的参数必须单独传入
      apply, 要求传入函数的参数必须放入数组中整体传入。apply会将数组打散为单个参数值分别传入
强调: call/apply相当于调用函数，立刻执行。
bind: 永久绑定函数中的this
 3件事: 1. 创建一个和原函数功能完全一样的新函数
        2. 将新函数中的this永久绑定为指定对象
        3. 将新函数中的部分固定参数提前永久绑定
 强调: bind绑定在新函数中的this，无法被call/apply再替换。

总结: 如果临时调用一个函数，立刻执行时——call/apply
      如果创建一个函数提前绑定this时，不一定立刻执行时——bind
</code></pre><p> 13、 严格模式:</p>
<pre><code>1. 禁止给未声明的变量赋值
2. 将静默失败升级为错误
</code></pre><p>14、 ES6:</p>
<pre><code>模板字符串: 简化字符串拼接
  何时: 只要一个字符串需要动态拼接而成时
  如何: 反引号
****let: 解决声明提前的问题
  何时: 今后只要声明一个变量，首选let
  特点: 2个:
    1. let会将变量的作用域，限制在一个块内部
        ——增加了块级作用域
    2. let之前不允许再出现未声明的同名变量
        ——避免了声明提前
***箭头函数: 简化所有回调函数:
  如何:
    1. 去掉function，在()和{}之间加=&gt;
    2. 更简化:
      如果只有一个参数，可省略()
        如果没有参数，必须保留()
      如果函数体只有一句话，可省略{}
        如果函数体只有一句话，且是return，可省了{}和return

  强调: 箭头函数简写后，函数中的this和外部this一致了
    所以: 当回调函数内外的this不相同时，不能使用箭头函数简化。
    反之: 如果希望函数内外公用一个this时，就可用箭头函数简化回调函数。

for...of: 简化普通for循环遍历:
  for(var i=0;i&lt;arr.length;i++){
    arr[i] //当前元素值
  }
  for(var val of arr){
    val //当前元素值
  }
  问题1: 仅适用于读取元素值的情况，不能修改原数组元素。
  问题2: 只能遍历数字下标的索引数组和类数组对象。不能遍历关联数组中的元素值。

***class: 简化: 封装,继承,多态
创建一个类型:
  1. 用class结构包裹构造函数和原型对象方法, 将类型名定义在class后
  2. 构造函数的function 函数名，改为constructor
  3. 所有原型方法省略&quot;类型.prototype&quot;和&quot;=function&quot;
两种类型间的继承:
  1. 不再需要Object.setPrototype
     而是class 子类型 extends 父类型
  2. 借用构造函数不再用call/apply，而用super(...)
     其中super中省略this
</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;1、 错误处理:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;错误bug: 程序执行过程中，导致程序无法正常执行的情况
后果: 程序会强行中断退出
错误处理: 即使程序出现错误，也保证程序不异常中断的机制。
如何: try{//始终执行
       //可能出错的代码
     }ca
    
    </summary>
    
      <category term="学习笔记" scheme="www.wangchengzou.cn/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="javaScript" scheme="www.wangchengzou.cn/tags/javaScript/"/>
    
  </entry>
  
  <entry>
    <title>Angular基础知识</title>
    <link href="www.wangchengzou.cn/2017/07/22/Angular/"/>
    <id>www.wangchengzou.cn/2017/07/22/Angular/</id>
    <published>2017-07-22T15:48:26.000Z</published>
    <updated>2017-07-23T14:29:30.091Z</updated>
    
    <content type="html"><![CDATA[<p>1、设计原则和设计模式</p>
<pre><code>拙劣的设计：
①僵化
②脆弱
③不必要的复杂
④晦涩。。

1、YAGNI（不要写不需要的代码）
you aren&apos;t gonna need it

2、KISS （越简单越好）
keep it simple and stupid
语义化的标记、命名规则、减少嵌套

3、DRY（善于使用封装和重用）
Don&apos;t Repeat Yourself

4、高内聚 低耦合（High cohesion,low coupling）
内聚：一个组件（模块）内部的不同部分的关系
耦合：不同组件（模块）之间的关系

5、SRP 单一责任原则
Single Responsibility Principle
实现功能的时候，尽可能的做到每一个模块实现一个单一的功能

6、OCP原则(对于扩展开放、对于修改关闭)
open close principle

7、LCP（迪米特法则）
Least Knowledge Principle 最少知识法则：封装的功能单位要尽可能的小，尽量做到只与自己相关

常用的设计模式分为3大类：①创建 ②结构 ③行为

常用的设计模式：工厂方法模式、单例模式、组合模式、迭代子模式、适配器。。
先去实现功能，在迭代的过程中优化代码。
</code></pre><p>2、AngularJS</p>
<pre><code>认识新东西最好的方式：
①官网
②维基百科 wikipedia.org
what?--ng(AngularJS)是一个开源的js框架
where？--用来实现SPA应用程序（单一页面应用程序single page application）
Gmail邮箱是由Google退出的前端历史中第一个SPA应用
why？
四大特征：
①采用了MVC的设计模式
Model 模型数据
View  视图
Controller 控制器
</code></pre><p>3、MVC的工作原理：</p>
<pre><code>View视图 接收用户的输入，通过控制器（Controller）当中的方法，完成对于Model的增删改查的操作。
1.数据绑定：将数据和视图绑定起来，一旦数据被修改了，视图就会更新
2.双向数据绑定
    数据-》视图
    视图用户的输入 -》 数据
3.依赖注入
4.模块化设计
</code></pre><p>4、使用ng</p>
<pre><code>1、基本语法
    &lt;any&gt;{{表达式}} &lt;/any&gt;
    直接按照上述方法写，结果是不对的，解决方案：在html标签写上了ng-app

2、常用指令
    ngApp
        ①启动ng
        ②指定作用范围，将指令写在根标签
    快捷键：在webStorm中alt+f2,快速选中要去执行在哪个浏览器。
    ngInit 指令 来完成数据的初始化
    &lt;any ng-init=&quot;num=2&quot;&gt;&lt;/any&gt;
        ①不需要在通过ngInit指令定义数据时候，加上var关键字
        ②ngInit所初始化的变量是可以在整个html去使用变量
</code></pre><p>5、常用指令</p>
<pre><code>ng中指令：由angularJS提供了，可以用在html中作为扩展属性、扩展标签。。

作为扩展属性来使用：
    &lt;div ng-**&gt;&lt;/div&gt;
    ngInit  --&gt; ng-init
    ngApp --&gt; ng-app
作为扩展标签来使用：
    &lt;ngView/&gt;
①ngApp
    启动ng
    指定作用范围，将指令写在根标签
    注意事项：调用一次ngApp
②ngInit
    通过ngInit调用一次，初始化多个变量？？
    &lt;any ng-init=&quot;a=1;b=2&quot;/&gt;
③ngRepeat
    重复实例化模板
    两种语法：
    &lt;any ng-repeat=&quot;临时变量的名称 in 集合的名称&quot;&gt;&lt;/any&gt;
    &lt;any ng-repeat=&quot;（key,value） in 集合的名称&quot;&gt;&lt;/any&gt;

    注意事项：在使用ngRpeat的时候要遍历的集合默认是不允许有重复的数据，
        可以通过 track by $index来指定一个不会重复的值就可以解决报错的问题。

④ngIf、ngShow、ngHide、ngSrc、ngDisabled、ngChecked
    ngIf-》选择是否要显示出来（挂载到DOM，从DOM中删除）
    ngShow/ngHide -&gt;选择是否要显示出来(显示或者隐藏)
    &lt;any ng-if=&quot;表达式&quot;&gt;&lt;/any&gt;
    &lt;any ng-show=&quot;表达式&quot;&gt;&lt;/any&gt;
    &lt;any ng-hide=&quot;表达式&quot;&gt;&lt;/any&gt;
    注意事项：在使用ngSrc去读取变量中值的时候，要记得加上双花括号
    &lt;img ng-src=&quot;img/{{imgUrl}}&quot; /&gt; 如果你写的不是ngSrc而是src，显示是ok的，但是控制台是会报错的，通过ngSrc去指定就搞定了
    &lt;any ng-disabled=&apos;表达式&apos;&gt;&lt;/any&gt;
    &lt;input type=&apos;checkbox&apos; ng-checked=&quot;表达式&quot;/&gt;
</code></pre><p>6、MVC</p>
<pre><code>在ng中：
    Model 模型数据：在ng中定义的一些变量
    View  视图：通过ng指令和表达式增强版的html
    Controller 控制器：负责数据的增删改查的
MVC的好处:在实现大型应用程序，可以通过将视图和数据隔离开，有效的降低代码的复杂度、耦合度
在ng中应该怎么做才能实现一个SPA？
准备工作：
①创建一个模块
    因为在ng中是以模块为基本单位的
    var app = angular.module(&apos;模块的名称&apos;，[&apos;依赖模块1&apos;,&apos;依赖模块2&apos;])
②使用模块
    采用ngApp指令
    &lt;html ng-app=&quot;模块的名称&quot;&gt;&lt;/html&gt;
③创建一个控制器
    app.controller(&apos;控制器的名称&apos;,function(){})
    第二个参数时控制器被调用时，要执行的方法
④调用控制器
    采用ngController指令来调用控制器
    &lt;div ng-controller=&apos;控制器的名称&apos;&gt;&lt;/div&gt;
    实现数据的创建和显示等：
⑤操作数据、显示出来

$scope是一个对象，称之为作用域对象，是一个非常重要的概念，
    建立起控制器中的数据和控制器的所指定的视图的桥梁

绑定事件的时候，在ng的做法： &lt;any ng-eventName=&quot;handle()&quot;&gt;
&lt;button ng-click=&quot;handleClick()&quot;&gt;&lt;/button&gt;

注意事项：
由于ngInit和$scope都可以完成数据的初始化，建议使用$scope,因为ngInit会增加代码的耦合度和复杂度。
</code></pre><p>7、ng是由很多指令的：</p>
<pre><code>ngApp ngRepeat ngIf ngShow ngHide ngChecked ngDisabled ngSrc
ngBind ngClass ngStyle

在webStorm中创建一个文件模板的基本步骤：
①拷贝要使用的代码
②点击左上角的file，选择new
③选择Edit File Templates
④点击弹窗中右上角的+号
⑤修改name和extension为创建的文件模板的名称以及格式，点击ok保存即可
</code></pre><p>8、自定义指令</p>
<pre><code>1、如何自定义？？
    angular.module()
    app.controller()
    //创建指令
    app.directive(&apos;指令的名称&apos;，function(){
        return {}
    })
    指令的命令规则：指令的名称由两部分构成，前缀：一般使我们模块或者项目的名字缩写； 后缀：用来描述指令的功能
    属性：
    template：指定要显示的模板内容
    restrict: &quot;EAC&quot; //E(Element)A(Attribute)C(Class)M(Comment)
    replace: true,替换并显示出来
    scope

2、如何使用自定义的指令？？
    注意事项：指令在命名时是要遵循驼峰式命名规则；在使用时要遵循烤串式用方
    &apos;tsHello&apos; --&gt; ts-hello
    根据配置指令时的restrict属性所对应的值，在合适的场景下使用指令。

3、自定义指令传递参数
    怎么传？
        在调用指令的时候可以传 将参数作为属性对应的值
    怎么接受？
        scope
</code></pre><p>9、双向数据绑定</p>
<pre><code>方向1：从&apos;数据&apos;绑定到&apos;视图&apos;
绑定方式：
①常用指令： ngRepeat/ngIf/ngShow...
②双花括号：{{}}

方向2：从‘视图中用户的输入’绑定到‘数据’
绑定方式：指令：ngModel

如果要监听数据的变化：
$scope.$watch(&apos;txt&apos;,function(){

})

在实现下拉框的过程中，如果数据是动态的，可以通过ngOptions将数据绑定到视图中。
ngOptions语法：
 &lt;select
    ng-model=&quot;city&quot;
    ng-options=&quot;city.cityName for city in cities&quot;&gt;
 &lt;/select&gt;
</code></pre><p>10、过滤器</p>
<pre><code>a.内置的过滤器
    ng中的过滤器为了实现对于表达式结果的筛选、过滤、格式化，达到更好的表现效果。
    过滤器的语法：支持多重过滤和传参
    {{expression | 过滤器名称 : '参数' | 过滤器名称2：‘参数’ }
            | => 管道
            常用的过滤器：
                currency 货币样式的过滤器
                date 日期
                uppercase/lowercase 大小写的处理
                orderBy 对指定的数组进行升序或者降序排列
                number 格式化数字为文本（对有小数点的数据的处理）
                limitTo 限定数组或者字符串要显示的个数
        b.自定义过滤器
            自定义过滤器方式：
            app.filter('过滤器名称',function(){
                return function(input，arg){
                        //input是传递给过滤器的数据
                        //arg 是过滤器本身的参数
                    return '过滤后的结果'
                }
            })
            使用自定义的过滤器:
            和内置的过滤器用法是一样的

11、ng模块内置的方法

        序列化、反序列化
        toJson:将对象或者数组 序列化 为json格式的字符串
        fromJson：相反的过程

12、服务

    服务的本质是一个单例对象，提供数据和对象。
    两大类：
    ①内置服务
        $location、$http、$window、$scope...
        使用内置服务中提供的方法：
            第一步 将需要用到的服务注入进来 function($scope,$location)
            第二步 调用服务中提供的方法 数据。。
    ②自定义的服务
        面试题：$scope与$rootScope之间的关系
        1、不同的控制器之间的数据是彼此隔离的
        2、不同的控制器之间如何共享数据？？
        $scope的id是从2开始依次往上递增，
        id为1的是谁？ $rootScope是根作用域对象，其余的$scope都是子对象
            方式1：借助于$rootScope
                把要共享的数据存在$rootScope,所有的子对象就可以读取该数据
            方式2：借助于控制器之间的嵌套
                在调用控制器的元素 之间的嵌套关系
                @@div ng-controller='myCtrl02'>
                    @@<div ng-controller="myCtrl03"></div>
                @@
            方式3：触发事件传递参数
                绑定事件：
                $scope.$on('事件名称',function(event,data){

                })
        触发事件：
        //从子作用对象 向 父作用域对象 传递事件
        $scope.$emit()
        //从父作用对象 向 子作用域对象 传递事件
        $scope.$broadcaset()

13、服务

        双向数据绑定的工作原理：
        绑定时，ng会自动添加一个监听watcher,当数据发生变化时，会执行更新DOM操作的函数。
        怎么知道数据发生了变化？
        在ng中有一个循环$digest,会不断的对比数据，
        需要手工的触发循环做对比，可以通过：
        $scope.$digest();
        $scope.$apply();//触发$rootScope.$digest();

14、ng内置的服务：

        $location $scope $rootScope $window $interval $timeout
        1、在ng中定时器相关的处理--》$interval $timeout
        2、$http
        $http({method:'',url:''}).success().error()
        $http.get()
        $http.post()
        注意：如果需要发起post请求，需要设置:
         app.run(function ($http) {
                $http.defaults.headers.post =
        {'Content-Type':'application/x-www-form-urlencoded'};})

        在发起post请求时，如果需要对参数进行序列化:
        借助于$httpParamSerializer服务，首先注入进来，$httpParamSerializer（obj）。

15、自定义服务

        服务的目的是为了封装业务逻辑，提高代码的复用率

        自定义指令 app.directive
        自定义过滤器 app.filter
        自定义服务的方法：
        app.factory ('服务名称',function(){//普通方法 return {}})
app.service(&apos;服务名称&apos;,function(){//构造函数})
app.constant(&apos;服务名称&apos;，{})//创建常量服务
app.value(&apos;服务名称&apos;，{})//创建变量服务

注意事项：
自定义的服务 需要用到其它服务中方法
图：两个按钮：开始 结束。
</code></pre><p>16、依赖注入</p>
<pre><code>将代码部署到线上，都会对代码做压缩。
使用YUI-Compressor.jar （有java的运行环境）
①借助于CLI（command line）
    java -jar yui**.jar  c:\demo10.js &gt; c:\demo10.min.js

②IDE（webStorm）
    file-&gt;settings-&gt;tools-&gt;fileWathchers-&gt;+-&gt;选中YUI-Compressor JS，在弹窗中的program选中对应的jar，保存即可
压缩效果：
会删除所有的注释、删除没有语义的空白字符、尽可能的简化变量的名称（混淆），但是数字、字符串、关键字是不会改变的。

解决压缩后的问题方式：
依赖注入：将依赖的服务或者其他，通过参数形式注入进来，背后ng框架会帮助对服务等做实例化的操作，让我们可以去直接使用

注入的方式：
①推断式（猜测）
    这种方式在进行压缩会有问题
    app.controller(&apos;myCtrl&apos;,function($scope){});

②标记式
    由于文件压缩时，关键数据 字符串 关键字等不会被处理的；将所需要用到的服务，存在一个字符串（服务名称）数组。
    注意事项：在数组中服务名称的顺序和创建对应的处理函数参数的顺序是要保持一致的
    实现方式：1、将处理函数单独的存在一个变量中 2、给变量设置$inject，值是一个由字符串构成的数组 3、使用服务即可
③行内式（内联式）
    在构建一个ng对象时，允许将一个字符型数组 作为对象的参数，在数组中可以：服务名称、函数（必须是在数组的最后一个元素）
    app.controller(&apos;myCtrl&apos;,[&apos;$scope&apos;,function($scope){}])
    依赖注入3种方式，官方推荐采用行内式依赖注入。
    依赖注入的背后：$injector 注入器：快速的定位到应用需要用到的各种该服务，整个ng应用的注入对象都是由$injector定位和创建。
    $injector.has(&apos;服务名称&apos;) ==》判断指定的服务是否存在
    $injector.get(&apos;服务名称&apos;) ==》 得到指定的服务对应的实例
</code></pre><p>17、模块化设计</p>
<pre><code>ng有4大特征：
①MVC
②双向数据绑定
③依赖注入
④模块化设计

高内聚低耦合，在ng中有两种：①内置的模块 ②自定义的模块

如何自定义模块？
angular.module();

使用模块？
ng-app=&quot;&quot;
在创建模块时，在第二个参数所对应的数组中写上服务的名称

一个ng的模块都可以包含哪些？
控制器：对应部分业务逻辑的封装
服务：经常用到的重复代码封装
指令：扩展html标签、属性
过滤器：针对数据做一些筛选 过滤 格式化的处理
</code></pre><p>18、ngRoute（路由模块）</p>
<pre><code>ng是主要实现SPA（单一页面应用程序）
SPA的工作原理：
    1、页面url
    http://127.0.0.1/index.html#/路由地址
    例如：http://127.0.0.1/index.html#/start
    2、解析index.html 是一个完整的html页面，再解析路由地址(start)
    3、在路由词典中寻找路由地址(start)所对应的路由信息
    4、在路由信息所对应的对象中找到真实的模板页面地址
    5、（发起异步ajax）加载模板页面到指定的容器中，实现局部刷新

ngRoute（路由模块）可以定义路由词典，自动解析路由地址，查找路由词典，自动发起ajax请求加载页面显示。
    0、在创建自定义模块，在依赖列表中指定ngRoute
    1、指定盛放代码片段的容器
    2、配置路由词典

使用ngRoute的基本步骤：
①创建一个完整的html页面
    记得引入angular.js angular-route.js

②创建模块，并指定依赖于ngRoute模块
    angular.module(&apos;myApp&apos;,[&apos;ng&apos;,&apos;ngRoute&apos;])

③使用指令创建一个盛放代码片段的容器
    调用ngView指令：创建一个容器，代码片段会加载到这里

④创建模板页面

⑤配置路由词典
    $routeProvider
    when是用来添加一条路由信息的(路由地址的字符串是以/开始)
    $routeProvider.when(&apos;/myStart&apos;,{controller:&apos;&apos;,template/templateUrl:&apos;&apos;})
    otherwise是用来指定异常的处理
    $routePriovder.otherwise({redirectTo:&apos;路由地址&apos;})

SPA在ng实现过程，代码片段的跳转：
①直接修改地址栏中的路由地址
    http://localhost:63342/day4/demo03_SPA%E7%BB%83%E4%B9%A0.html#/myLogin
    http://localhost:63342/day4/demo03_SPA%E7%BB%83%E4%B9%A0.html#/myRegister
②通过js的方式
    $location.path(&apos;路由地址&apos;)
③超链接的方式
    a href=&quot;#/myRegister&quot;
    login-&gt;start 10

SPA应用程序通过ngRoute来传递参数：
①搞明白 发送 接收
②配置接收方的路由
    $routeProvider.when(&apos;/myStart/:num&apos;,{
    templateUrl:&apos;tpl/start.html&apos;
    })
③拿到传递过来的参数
    $routeParams.num
④发送
    a href=&apos;#/myStart/10&apos;
    $location.path(&apos;/myStart/10&apos;)

注意事项：配置接收方路由时的冒号后的变量名称要和通过$routeParams解析参数的属性是要保持一致
    myStart/:id $routeParams.id

练习：实现一个SPA
完整的html manager.html
代码片段： checkProduct.html pay.html send.html

要求：能够实现不同页面的跳转以及参数的传递
checkProduct.html 能够a跳转到pay，传递price，在pay接收传递过来的参数显示在pay页面
pay 点击button跳转到send
send button以及a跳转到check.html

优化思路：如果多个控制器需要用到同一个方法或者数据，
    ①将方法和数据封装成一个服务
    ②$rootScope
    ③控制器之间的嵌套
    ④借助于事件

由于不同的代码片段都显示在了body的子元素中：body是所有代码片段的父元素，可以在body指定控制器，
控制器中的方法和数据，代码片段就可以用了。
①发送 接收
    checkProduct --&gt; pay

②配置接收方路由
    .when(&apos;/myPay/:price&apos;,{})

③$routeParams
    $routeParams.price

④发送参数
    href=&apos;#/myPay/20&apos;
    $location.path(&apos;/myPay/20&apos;)

ngInclude 引入多个地方同时需要用到的，比如页头、页尾。。。

要求：给综合练习的3个代码片段加上头信息(显示一个p标签)

注意事项：在使用ngInclude进行赋值的时候，对应的路径字符串要在双引号内 加上一对单引号
</code></pre><p>19、ngAnimate（动画模块）</p>
<pre><code>在angularJS添加动画效果，需要用到ngAnimate模块
基本步骤：
①引入对应的js文件
    angular-animate.js
②指定自定义模块依赖于ngAnimate
    angular.module(&apos;myModule&apos;,[&apos;ng&apos;,&apos;ngRoute&apos;,&apos;ngAnimate&apos;])
③css给ng应用程序添加动画效果：
    ngEnter 准备进入
    ngEnterActive 进入完成
    ngLeave 准备离开
    ngLeaveActive 离开完成
④引入对应的css文件

如果用到其它的模块整体思路：
    ①在ng每一个模块都有自己的js文件，用到哪个模块，把指定模块的js文件引入进来
    ②在创建模块，指定依赖列表
    ③根据模块中所提供的指令、服务。。结合业务需要进行
</code></pre><p>20、表单验证</p>
<pre><code>在ng中，针对表单和空间提供了属性，用于验证控件交互的状态
布尔类型：
$valid
$invalid
$dirty
$pristine
对象：
$error

注意事项：
①给表单以及表单组件 加上name属性
②给需要用到的表单组件 ，加上ngModel
③属性的用法
myForm.t_age.$dirty/$pristine/$valid/$invalid/$error
</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;1、设计原则和设计模式&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;拙劣的设计：
①僵化
②脆弱
③不必要的复杂
④晦涩。。

1、YAGNI（不要写不需要的代码）
you aren&amp;apos;t gonna need it

2、KISS （越简单越好）
keep it simple 
    
    </summary>
    
      <category term="学习笔记" scheme="www.wangchengzou.cn/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Angular" scheme="www.wangchengzou.cn/tags/Angular/"/>
    
  </entry>
  
  <entry>
    <title>CSS3有哪些新特性</title>
    <link href="www.wangchengzou.cn/2017/07/22/CSS3%E6%9C%89%E5%93%AA%E4%BA%9B%E6%96%B0%E7%89%B9%E6%80%A7/"/>
    <id>www.wangchengzou.cn/2017/07/22/CSS3有哪些新特性/</id>
    <published>2017-07-22T15:48:26.000Z</published>
    <updated>2017-07-23T08:01:09.332Z</updated>
    
    <content type="html"><![CDATA[<p>举例：<br>  新增各种CSS选择器  （: not(.input)：所有 class 不是“input”的节点）<br>  圆角           （border-radius:8px）<br>  多列布局        （multi-column layout）<br>  阴影和反射        （Shadow\Reflect）<br>  文字特效      （text-shadow、）<br>  文字渲染      （Text-decoration）<br>  线性渐变      （gradient）<br>  旋转          （transform）<br>  增加了旋转,缩放,定位,倾斜,动画，多背景<br>  transform:\scale(0.85,0.90)\ translate(0px,-30px)\ skew(-9deg,0deg)\Animation:</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;举例：&lt;br&gt;  新增各种CSS选择器  （: not(.input)：所有 class 不是“input”的节点）&lt;br&gt;  圆角           （border-radius:8px）&lt;br&gt;  多列布局        （multi-column layout）&lt;b
    
    </summary>
    
      <category term="面试题目" scheme="www.wangchengzou.cn/categories/%E9%9D%A2%E8%AF%95%E9%A2%98%E7%9B%AE/"/>
    
    
      <category term="html" scheme="www.wangchengzou.cn/tags/html/"/>
    
      <category term="css" scheme="www.wangchengzou.cn/tags/css/"/>
    
  </entry>
  
  <entry>
    <title>Doctype作用？标准模式与兼容模式各有什么区别</title>
    <link href="www.wangchengzou.cn/2017/07/22/20170723/"/>
    <id>www.wangchengzou.cn/2017/07/22/20170723/</id>
    <published>2017-07-22T15:48:26.000Z</published>
    <updated>2017-07-23T02:34:26.037Z</updated>
    
    <content type="html"><![CDATA[<p>（1）、&lt;!DOCTYPE&gt;声明位于位于HTML文档中的第一行，处于 <html> 标签之前。告知浏览器的解析器用什么文档标准解析这个文档。DOCTYPE不存在或格式不正确会导致文档以兼容模式呈现。<br>（2）、标准模式的排版 和JS运作模式都是以该浏览器支持的最高标准运行。在兼容模式中，页面以宽松的向后兼容的方式显示,模拟老式浏览器的行为以防止站点无法工作。</html></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;（1）、&amp;lt;!DOCTYPE&amp;gt;声明位于位于HTML文档中的第一行，处于 &lt;html&gt; 标签之前。告知浏览器的解析器用什么文档标准解析这个文档。DOCTYPE不存在或格式不正确会导致文档以兼容模式呈现。&lt;br&gt;（2）、标准模式的排版 和JS运作模式都是以该浏览器支持
    
    </summary>
    
      <category term="面试题目" scheme="www.wangchengzou.cn/categories/%E9%9D%A2%E8%AF%95%E9%A2%98%E7%9B%AE/"/>
    
    
      <category term="html" scheme="www.wangchengzou.cn/tags/html/"/>
    
      <category term="H5" scheme="www.wangchengzou.cn/tags/H5/"/>
    
  </entry>
  
  <entry>
    <title>CSS3笔记</title>
    <link href="www.wangchengzou.cn/2017/07/22/CSS3%E7%AC%94%E8%AE%B0/"/>
    <id>www.wangchengzou.cn/2017/07/22/CSS3笔记/</id>
    <published>2017-07-22T15:48:26.000Z</published>
    <updated>2017-07-23T10:29:58.932Z</updated>
    
    <content type="html"><![CDATA[<p>1、CSS概述</p>
<pre><code>1、问题
    1、控制页面中所有的文本颜色为 红色
    2、控制页面中所有div的文本颜色 为蓝色
    3、将 所有div 的颜色 变为 黄色

    HTML元素的不足：
        1、要完成相同的效果，使用的是不同的属性
            &lt;body text=&quot;red&quot;&gt;
            &lt;font color=&quot;blue&quot;&gt;
        2、没有提升 html属性的 可重用性和可维护性
            可重用性：重复的操作 不用重复的写

        可以通过 CSS 解决以上两个问题
2、什么是CSS
    CSS (Cascading Style Sheets),层叠样式表，级联样式表，简称：样式表。专门用于定义页面元素的样式的。
    以统一的方式定义页面元素的样式

    CSS实现了内容与表现相分离
    提升了代码的可重用性 和 可维护性
3、CSS 与 HTML之间的关系
    HTML : 专门用于构建网页结构
    CSS : 专门构建HTML网页的样式

    HTML属性效果 与 CSS样式效果相冲突的话：
    优先使用 CSS 定义页面元素的效果
</code></pre><p>2、CSS语法</p>
<pre><code>1、使用CSS样式表
    1、内联方式
        又称为 ：行内样式
        将样式定义在某个html元素中
        语法：
        &lt;ANY style=&quot;样式声明;样式声明;&quot;&gt;&lt;/ANY&gt;
        样式声明：
            由 属性名称 和 属性值 来组成，属性名称和属性值之间用 : 来关联
        ex:
            属性名称          属性值
            color             red,blue,yellow...
            background-color  合法颜色值即可..(同上)
            font-size         以px，pt，为单位的数值

            控制以下 文本颜色为 红色，背景颜色为 黄色，文字大小为 24px
            &lt;p&gt;静夜思&lt;/p&gt;
    2、内部样式表
        将样式定义在网页的一块独立位置处
        在 &lt;head&gt;&lt;/head&gt; 中 增加一对 &lt;style&gt;&lt;/style&gt;元素，在 &lt;style&gt; 元素中 定义元素的样式,具体语法如下：
        &lt;head&gt;
            &lt;title&gt;&lt;/title&gt;
            &lt;style&gt;
                样式规则1
                样式规则2
                ...
                样式规则n
            &lt;/style&gt;
        &lt;/head&gt;
        样式规则，由两部分组成
            1、选择器
                选择(规范)页面中哪些元素能够使用声明好的样式
                比如：元素选择器，由元素名称来充当选择器，控制某标记对应所有页面元素的样式
            2、若干样式声明

            样式规则 语法结构：
            选择器{
                样式声明1;
                样式声明2;
                ...
                样式声明n;
            }
            ex:
            p{
                color:red;
                background-color:yellow;
                font-size:24px;
            }

    3、外部样式表
        将样式定义在外部的&quot;样式表文件(*.css)&quot;中
        1、创建 .css 文件，编写样式规则
        2、在要使用 样式表的 html文件中进行引入
            &lt;head&gt;
                &lt;link rel=&quot;stylesheet&quot; href=&quot;样式表文件url&quot;&gt;
            &lt;/head&gt;
2、CSS样式表特征
    1、继承性
        大部分样式属性是可以被继承
    2、层叠性
        可以为一个元素定义多个样式规则
        如果 属性 不冲突时，多个样式规则可以层叠为一个(即都可以应用到当前元素上)
    3、优先级
        在层叠性基础上，如果 样式定义 冲突的话，那么就会按照不同使用方式的优先级，来选择性应用样式
        低 ：浏览器默认设置
        中 ：外部样式表 和 内部样式表
            就近原则
            后定义优先
        高 ：内联方式
    4、!important 规则
        显示调整样式属性的优先级
        语法：
            属性名:值 !important;
        谨慎使用!
3、选择器(重点)
    1、作用
        选择(规范)页面中哪些元素能够使用声明好的样式
        为了匹配页面的元素
    2、详解
        1、通用选择器
            作用：匹配页面中所有的元素
            语法：*{}
            缺点：效率较低，尽可能少用,可以通过 使用 body 的继承性 来替代 *
        2、元素选择器
            作用：匹配某一标记所对应的页面中所有的元素
            语法：元素/标签 {}
            ex:
            div{/*匹配页面中所有div*/}
            span{/*匹配页面中所有span*/}
            li{/*匹配页面中所有li*/}
        3、类选择器
            作用：事先定义好样式，可以由任意元素通过class属性进行引用
            语法：
                定义：.类名{}
                引用：&lt;ANY class=&quot;类名&quot;&gt;&lt;/ANY&gt;

            多类选择器的引用方式：
            让一个元素引用多个类选择器，中间用 空格 隔开即可

            分类选择器的声明方式：
                将元素选择器和类选择器结合到一起进行声明，实现对某种元素中的不同样式细分控制

                ex:想要控制 class为important的div元素，文字大小为 48px
                语法：元素选择器.类选择器{}
        4、id选择器
            作用：匹配 指定id值的元素的 样式
            ex:
                &lt;div id=&quot;nav&quot;&gt;&lt;/div&gt;

            语法：#ID值{}
        5、群组选择器
            群组选择器的声明以一个以 , 隔开的选择器列表
            语法：
                选择器1,选择器2,...{}
            ex:
                #title,p.redColor,.important,span{
                    color:red;
                }
        6、后代选择器
            后代：
                多于 一级 层级关系的元素，只能叫后代
                只具备 一级 层级关系的 也可以叫后代
            语法：
                选择器1 选择器2{}
                语义：匹配 在选择器1 中的  所有后代元素 选择器2
                ex:
                    #content span{}
        7、子代选择器
            子代：
                只具备 一级 层级关系的 称之为 子代
            语法：
                选择器1&gt;选择器2{}
                语义：匹配 在选择器1 中的 子级元素 选择器2
        8、伪类选择器
            伪类：专门匹配元素不同状态的选择器
            分类：
                1、链接伪类
                2、动态伪类

                3、目标伪类
                4、元素状态伪类
                5、结构伪类
                6、否定伪类
            语法：
                以 :作为开始的选择器

                1、链接伪类
                    1、:link
                        适用于未被访问的超链接
                    2、:visited
                        适用于访问过的超链接
                2、动态伪类
                    1、:hover
                        适用于鼠标悬停在html元素时
                    2、:active
                        适用于html元素被激活时
                    3、:focus
                        适用于html元素获取焦点时
</code></pre><p>3、尺寸与边框</p>
<pre><code>1、CSS单位
    1、尺寸单位
        1、px ：像素
        2、pt ：磅 (1pt=1/72in)
        3、in ：英寸，1in=2.54cm
        4、%  ：百分比，占据 当前元素 或 父元素 对应属性的 占比
        5、em ：倍数，多数用于 文字大小的描述
        6、mm ：毫米
        7、cm ：厘米
        注意：css中尺寸单位是不能省略的。
    2、颜色单位(取值)
        1、rgb(r,g,b)
                r : red , 范围 0-255
                g : green,范围 0-255
                b : blue, 范围 0-255

             ex：
                background-color:rgb(0,0,0);黑色
                background-color:rgb(255,0,0);红色
                background-color:rgb(255,255,255);白色
        2、rgb(r%,g%,b%)
        3、rgba(r,g,b,alpha)
            alpha : 透明度 0-1之间的数字
                0 : 完全透明
                1 : 完全不透明
                0.5 : 半透明
        4、#rrggbb
            通过6位16进制数字表示一个颜色
            每位数字范围：0-9 A-F
            #00ff00 : 绿色
            #ff0000 : 红色
            #1a2b3c : ?
        5、#rgb
            #rrggbb 每两位数字相同时，可以使用#rgb简化
            #00ff00 -&gt; #0f0
            #aabbcc -&gt; #abc
            #accdda -&gt; ×
        6、颜色的英文表示
            red,green,blur,orange,yellow...
2、尺寸属性
    1、作用
        用于设置元素的宽度和高度
        单位一般为 px 或 %(父元素对应属性的占比)
    2、语法
        1、宽度
            width
            min-width : 最小宽度
            max-width : 最大宽度
        2、高度
            height
            min-height : 最小高度
            max-height : 最大高度
        注意：
            页面中所有元素的高度，在不指定的情况全部是自适应(以内容为主)。

            页面中所有块级元素的宽度，默认占据父元素的100%
            页面中所有行内元素的宽度，默认自适应(以内容为主)
    3、页面中允许修改 尺寸 属性的元素
        1、所有块级元素都允许修改
        2、大部分的行内块元素
            所有的表单元素都是行内块元素
            除radio、checkbox之外，其他元素允许修改尺寸
        3、本身html元素就具备width 和 height的
            img，table 可以修改尺寸
        4、行内元素(除具备width和height之外)是不能修改尺寸
            span,b,a,i,s,b ... 不能修改尺寸
    4、溢出
        1、什么是溢出
            使用尺寸属性限制元素大小时，如果内容所需要的空间大于元素本身空间，则会导致内容溢出
        2、溢出处理属性
            属性：
                overflow
                overflow-x : 横向溢出处理
                overflow-y : 纵向溢出处理
            取值：
                1、visible
                    默认值，溢出可见
                2、hidden
                    隐藏
                3、scroll
                    滚动，让元素出现滚动条，溢出时，滚动条可用
                4、auto
                    自动，溢出时显示滚动条并可用，非溢出时，不显示滚动条
3、边框属性
    1、边框
        1、简写方式
            border:width style color;
            作用：设置元素上下左右四个边框的宽度，样式以及颜色
                width:边框的宽度(尺寸)
                style:边框的样式
                    取值：
                        1、solid ：直线
                        2、dotted ：虚线(点状)
                        3、dashed ：虚线(线状)
                color:边框的颜色,可以取值为 transparent(透明)

            ex:
                div{
                    border:1px solid red;
                }
        2、单边定义
            border-方向:width style color;
            方向可以被以下关键字所取代
            top : 上
            right : 右
            bottom : 下
            left:左
            ex:
                border-bottom:2px dashed #00ff00;
        3、单属性定义
            border-属性:值;
            属性可以被以下关键字取代：
            width:宽度
            style:样式
            color:颜色
            ex:
                border-width:5px;
                border-style:solid;
                border-color:#f00f00;
        4、单边单属性定义
            border-方向-属性:值;
            方向：top/right/bottom/left
            属性：width/style/color
            ex:
                border-top-color:yellow;
                border-right-style:dotted;
</code></pre><hr>
<p>1、边框</p>
<pre><code>1、边框
    边框实际上是由四个三角形组成的
2、边框倒角
    属性：border-radius
    取值：
        具体数值(px) 或 %
        最少一个值，最多4个值
    单角定义
        border-top-left-radius:左上角倒角半径
        border-bottom-right-radius:右下角
        ... ...
3、边框阴影
    属性：box-shadow
    取值：h-shadow v-shadow blur spread color inset;
        h-shadow:(必须)
            阴影的水平偏移距离
            取值为正，右偏移
            取值为负，左偏移
        v-shadow:(必须)
            阴影的垂直偏移距离
            取值为正，下偏移
            取值为负，上偏移
        blur : 模糊距离,取值为数值
        spread : 阴影的大小
        color : 颜色
        inset : 值，将默认的外阴影改为内阴影
4、轮廓
    1、什么是轮廓
        位于元素外围的一条线,位于边框之外的
    2、属性
        outline:width style color;
        outline-width:宽度;
        outline-style:样式;
        outline-color:颜色;

        常用：
            outline:none;
            或
            outline:0;
    练习：作业基础上
        1、为每幅图像增加四个角的倒角(5px)
        2、鼠标移入的时候，为每幅图像增加阴影
            右下偏移，大小不限，颜色不限
</code></pre><p>2、框模型(重难点)</p>
<pre><code>1、框 &amp; 框模型
    框：页面元素皆为框
    框模型：Box Model ,定义了元素框处理元素内容尺寸，内边距，边框和外边距的一种方式

    元素一旦增加框模型对应属性的属性，那么实际的占地区域会发生改变

    元素的实际宽度=左右外边距 + 左右边框 + 左右内边距 + width;

    元素的实际高度=上下外边距 + 上下边框 + 上下内边距 + height;
2、外边距
    1 、外边距
        围绕在元素边缘周围的空白区域
        默认不能被其他元素所占据
        作用：拉伸两个元素间的距离
    2、语法
        属性：
            margin:值;
            单边设置：
            margin-方向:值;
                方向：top/right/bottom/left
        取值：
            1、具体数值 px
            2、%
            3、负值
                左外边距取负值 ：左移动
                左外边距取正值 ：右移动
                上外边距取负值 ：上移动
                上外边距取正值 ：下移动
            4、auto
                自动，由浏览器计算外边距的值应该是多少
                注意：默认情况下，auto只对左右有效，上下无效。

                为块级元素设置宽度后，再设置其左右外边距为 auto，该元素能水平居中显示
        margin的简洁写法：
            margin:value; 四个方向外边距的值
                margin:5px;
            margin:v1 v2; v1 上下外边距 v2 左右外边距
                margin:5px 10px;
            margin:v1 v2 v3;v1 上外边距 v2 左右外边距 v3 下外边距
                margin:5px 15px 3px;
            margin:v1 v2 v3 v4;上 右 下 左
    3、页面中具备默认外边距的元素
    4、特殊注意
        1、外边距合并
            当两个垂直外边距相遇时，将合并成一个
        2、外边距的溢出
            特殊场合下，为子元素设置外边距(上下)会作用到父元素上
            特殊场合：
                1、父元素没有边框(上下)
                2、为第一个(最后一个)子元素设置外边距
            解决方案：
                1、为父元素增加边框(透明的)
                    弊端：父元素会变高
                2、可以为父元素设置上内边距来取代子元素上外边距
                    弊端：父元素高度会变高
                3、为父元素增加一个空子元素
                    &lt;table&gt;&lt;/table&gt;
                    弊端：多一个子元素
                4、后续讲解...(CSS3高级)
        3、为行内元素和行内块元素设置垂直外边距
            1、大部分行内元素垂直外边距无效
                img允许设置
            2、行内块元素设置垂直外边距，该行的所有元素都跟着变
3、内边距
    1、什么是内边距
        内容区域 和 边框(边缘)之间的距离
        注意：内边距会扩大边框所占用的区域
    2、语法
        属性：
            padding:值;
            padding-方向:值;
                方向：top/right/bottom/left
            取值：
                1、px
                2、%
                3、auto
        简写方式：
            padding:value; 上下左右
            padding:v1 v2; 上下  左右
            padding:v1 v2 v3;上  左右  下
            padding:v1 v2 v3 v4;上 右 下 左
    3、特殊注意
        1、为行内元素增加上下内边距时
            只影响自己，并不影响其他元素
4、box-sizing
    1、作用
        重新指定元素尺寸计算模式
        占地宽度 = margin+border+padding+width
        可见宽度 = border+padding+width
    2、语法
        属性：box-sizing
        取值：
            1、content-box
                默认值，width只表示内容区域的宽度，border和padding额外进行计算
                可见宽度=border+padding+width
            2、border-box
                width包含边框内所有的距离(padding,border)
                可见宽度=width(border+padding+宽度);
</code></pre><p>3、背景</p>
<pre><code>1、背景颜色
    属性：background-color
    取值：颜色值 或 transparent
    注意：背景颜色从边框位置处开始绘制
2、背景图像
    属性：background-image
    取值：url(背景图url)
3、背景重复
    属性：background-repeat
    取值：
        1、repeat
            默认值，即横向又纵向平铺
        2、repeat-x
            只在横向平铺
        3、repeat-y
            只在纵向平铺
        4、no-repeat
            不平铺
4、背景图片尺寸
    属性：background-size
    取值：
        1、value1 value2
            指定背景图像宽度 和 高度
        2、value1% value2%
            采用当前元素宽和高的占比，来作为背景图大小
        3、cover
            覆盖，会将背景图像等比放大，直到背景图完全覆盖到元素为止
        4、contain
            包含，会将背景图像等比放大，直到右边或下边碰到元素边缘为止
5、背景图片固定
    属性：background-attachment
    取值：
        1、scroll
            滚动，默认值
        2、fixed
            固定，让背景图一直在可视化区域中
6、背景图片定位
    改变背景图在元素中的位置
    属性：background-position
    取值：
        1、x y
            指定背景图水平 和 垂直偏移距离
            x : 水平偏移距离
                取值为正，背景图右偏移
                取值为负，背景图左偏移
            y : 垂直偏移距离
                取值为正，背景图下偏移
                取值为负，背景图上偏移
        2、x% y%
            0% 0% : 背景图在左上
            0% 100% : 背景图在左下
            100% 100% : 背景图在右下
        3、关键字
            x : left / center / right
            y : top / center/ bottom
7、背景属性
    在一个 background 属性中声明所有的北京属性值

    属性：background
    取值：color url repeat attachment position;

    ex:
        background:red;
        background:url(a.jpg) no-repeat;
8、特殊使用
    CSS Sprites(精灵图/雪碧图)
</code></pre><p>1、渐变</p>
<pre><code>1、什么是渐变
    多种颜色之间平缓过度的显示效果
2、渐变分类
    1、线性渐变(linear-gradient)
        按照直线的方式填充渐变颜色和方向
    2、径向渐变(radial-gradient)
        以圆的方式填充渐变效果(圆心位置，半径)
    3、重复渐变
        1、重复线性渐变
            repeating-linear-gradient
        2、重复径向渐变
            repeating-radial-gradient
3、渐变中的重要信息
    1、色标
        由 颜色 及其 出现的位置 来组成的
4、渐变的语法
    1、属性
        background-image
    2、取值
        1、linear-gradient()
            linear-gradient(angle,color-point1,color-point2);
            1、angle
                填充的方向或角度
                1、关键字
                    1、to top ：从下向上填充
                    2、to right ：从左向右填充
                    3、to bottom ：从上向下填充
                    4、to left ：从右向左填充
                2、角度
                    0deg ~ 360deg

                    0deg : to top
                    90deg : to right
                    180deg : to bottom
                    270deg : to left
            2、color-point
                渐变中的色标,由 颜色 及其 出现的位置组成
                ex:
                    1、red 0px
                        该色标颜色为 red ，位置为填充方向的 0px 处
                    2、green 50px
                        该色标颜色为 green,位置为填充方向的 50px 处
                    3、blue 50%
                        该色标颜色为 blue，位置为填充方向的 50% 处
                    4、
                        linear-gradient(to top,red,blue,green);
                        自动分配位置
        2、radial-gradient()
            radial-gradient([size at position,]color-point,color-point)

            1、[size at position,] : 允许被省略
                size:圆的半径
                at : 关键字
                position:圆心的位置
                    1、x y
                        以px为单位的具体数值
                    2、x% y%
                    3、关键字
                        x : left , center , right
                        y : top , center, bottom
        3、repeating-linear-gradient()
        4、repeating-radial-gradient()
5、浏览器兼容性问题
    主流浏览器都支持渐变
    对于不支持的浏览器，需要添加浏览器前缀的方式实现兼容性
        浏览器前缀：
            1、Firefox ：-moz-
            2、Chrome 和 Safari ：-webkit-
            3、Opear ：-o-
            4、Microsoft IE ：-ms-
        如果浏览器不支持属性的话，则将前缀添加到属性名称前
            ex:
                animation:值;
                -moz-aniamtion:值;
                -webkit-aniamtion:值;
                -o-aniamtion:值;
                -ms-animation:值;
        如果浏览器支持属性，但不支持属性值的话，则将前缀添加到属性值前
            ex:
                background-image:linear-gradient();
                background-image:-moz-linear-gradient();
                background-image:-webkit-linear-gradient();
                background-image:-o-linear-gradient();
                background-image:-ms-linear-gradient();
</code></pre><p>2、文本格式化</p>
<pre><code>1、字体属性
    1、指定字体
        属性：font-family
        取值：字体1,字体2,字体3;
        注意：字体中包含中文或特殊字符的话，尽量使用 &quot;&quot; 引起来
        ex:
            font-family:&quot;微软雅黑&quot;,Arial;
    2、字体大小
        属性：font-size
        取值：px 或 pt 为单位的数值
    3、字体加粗
        属性：font-weight
        取值：
            1、normal
                非加粗显示，正常体
            2、bold
                加粗显示 &lt;b&gt;&lt;/b&gt;
            3、400 ~ 900
                400 ：normal
                900 ：bold
    4、字体样式
        属性：font-style
        取值：
            1、normal
                正常体
            2、italic
                斜体 &lt;i&gt;&lt;/i&gt;
    5、小型大写字符
        效果：将小写英文字符变成大写，但是大小和小写字符一样
        属性：font-variant
        取值：
            1、normal
                正常，默认值
            2、small-caps
                小型大写字符
    6、字体属性
        属性：font
        取值：style variant weight size family;
        注意：该简写属性中，必须包含 family 的值
2、文本属性
    1、文本颜色
        属性：color
        取值：~
    2、文本排列
        作用：控制内容的的水平对齐方式
        属性：text-align
        取值：left/center/right/justify(两端对齐)
    3、文本修饰
        线条修饰
        属性：text-decoration
        取值：
            1、none
                无线条修饰
            2、underline
                显示下划线
            3、line-through
                显示删除线 &lt;s&gt;&lt;/s&gt;
            4、overline
                显示上划线
    4、行高
        作用：一行数据的高度
        属性：line-height
        取值：以px为单位 或 当前字体大小的倍数
            line-height:50px;
            line-height:1.5;
        注意：文字将在指定行高的范围内垂直居中显示
        场合：
            1、文字垂直居中
            2、行间距的设置
    5、文本阴影
        属性：text-shadow
        取值：h-shadow v-shadow blur color;
</code></pre><p>3、表格</p>
<pre><code>1、表格常用属性
    1、边距属性
        padding，margin(不能为td设置margin)
    2、尺寸属性
        width,height
    3、文本格式化属性
        font-*,text-*,line-height,color,... ...
    4、背景属性
        颜色，图片，渐变
    5、border属性
    6、垂直方向对齐
        属性：vertical-align
        取值：top / middle / bottom
2、表格特有属性
    1、边框合并属性
        属性：border-collapse
        取值：
            1、separate
                默认值
            2、collapse
                合并
    2、边框边距
        类似于 cellspacing
        属性：border-spacing
        取值：
            1、指定1个值
                每个单元格的水平和垂直间距相同
            2、指定2个值
                第一个值，表示水平间距
                第二个值，表示垂直间距
        注意：
            必须保证border-collapse是separate时才有效
    3、标题位置
        默认情况下，标题表格上方，水平居中
        属性：caption-side
        取值：
            1、top
                默认值
            2、bottom
                底部
    4、显示规则
        作用：指定浏览器如何来布局一张表格(指定行和列的尺寸的计算模式)
        属性：table-layout
        取值：
            1、auto
                自动，即自动表格布局，默认值
                列的宽度高度实际上是由内容来决定的
            2、fixed
                固定，即固定表格布局。
                列的宽度和高度由设定的值决定
        自动表格布局 VS 固定表格布局
            1、自动表格布局
                1、单元格的大小会适应内容
                2、表格复杂时，加载速度较慢(缺点)
                3、适用于不确定每列大小时使用
                4、特别灵活(优点)
            2、固定表格布局
                1、尺寸取决于设定的值，与单元格内容无关
                2、任何情况下，都会加速显示表格(优点)
                3、不够灵活(缺点)
        推荐：
            复杂的布局不能使用table
            简单，显示数据的布局，可以使用table
</code></pre><p>4、浮动</p>
<pre><code>1、定位
    改变元素在网页中的默认位置
2、定位的分类
    按照定位效果，可以分为以下几种方式：
    1、普通流定位/文档流定位
    2、浮动定位
    3、相对定位
    4、绝对定位
    5、固定定位
3、定位-普通流定位
    普通流定位，又称为 文档流定位，网页元素默认定位方式
    1、页面中所有元素都有自己的位置
    2、按照从左到右，从上到下的方式排列
    3、块级元素 - 从上到下排列
    4、行内/行内块 - 从左到右排列

    问题：让多个块级元素在一行内显示?
4、定位 - 浮动定位
    1、浮动定位特点
        将元素设置为浮动定位，将具备以下特征
        1、会排除在文档流之外即&quot;脱离文档流&quot;，不再占据页面空间，后续元素则上前补位
        2、浮动元素只在当前行内浮动
        3、浮动元素会停靠在父元素的左边或右边或其他已浮动元素的边缘上
        4、浮动元素依然位于父元素之内
        5、解决问题-多个块级元素在一行内的显示问题
    2、语法
        属性：float
        取值：
            1、none
                默认值，即无任何浮动
            2、left
                元素左浮动
                停靠在父元素的左边 或 其他已浮动元素的右边上
            3、right
                元素右浮动
                停靠在父元素的右边 或 其他已浮动元素的左边上
    3、浮动引发的特殊效果
        1、当父元素容纳不下所有已浮动子元素，最后一个将换行显示(有可能被卡住)
        2、元素一旦浮动起来后，宽度将变成自适应(非手动指定情况下)
        3、元素一旦浮动起来后，都将变成块级元素
            块级：允许修改尺寸，允许设置上下margin
            行内元素：不能改尺寸，不能设置上下margin
        4、行内元素，行内块元素，文本 采用的是环绕的排列方式，无法被浮动元素压在底下
</code></pre><p>1、浮动定位</p>
<pre><code>1、清除浮动
    1、什么是清除浮动
        清除当前元素前面的元素浮动所带来的影响
        清除浮动影响后，当前元素不会上前占位
    2、属性
        属性：clear
        取值：
            1、none
                默认值，无清除效果
            2、left
                清除当前元素前面元素左浮动带来的影响
            3、right
                清除当前元素前面元素右浮动带来的影响
            4、both
                清除当前元素前面元素任何一种浮动方向所带来的影响
    3、浮动元素为父元素高度带来的影响
        父元素的高度是以未浮动的子元素高度为准
        如果一个元素中所有的子元素全部都是浮动的，那么该父元素的高度为 0
        解决父元素的高度问题方案：
        1、直接设置父元素高度
            弊端：必须知道父元素的高度
        2、让父元素也浮动
            弊端：对后续元素会产生影响
        3、为父元素增加溢出处理属性
            属性：overflow
            取值：hidden 或 auto
            弊端：要溢出显示的内容，也一同被隐藏
        4、在父元素中，增加空子元素到最后一个位置处,并且设置其clear属性为both
            弊端：多一个子元素在页面上
</code></pre><p>2、显示</p>
<pre><code>1、显示方式
    属性：display
    取值：
        1、none
            让指定的元素不显示 并且 不占据页面空间
            (脱离文档流)
        2、block
            将指定的元素显示为块级
        3、inline
            将指定的元素显示为行内
        4、inline-block
            将指定的元素显示为行内块
            行内块特点：
                1、多个元素能够在一行内显示
                2、允许修改尺寸
        5、table
            将指定的元素显示为 table
2、显示效果
    1、visibility 属性
        作用：规范元素可见性
        取值：
            1、visible
                默认值，元素可见
            2、hidden
                元素不可见，但是占据页面空间
            3、collapse
                用在表格元素上，删除一行或一列时，不影响表格整体布局
        面试：
            display:none 和 visibility:hidden 区别
            1、display:none; 脱离文档流，所以不占据页面空间
            2、visibility:hidden; 只是改变可见性，并不脱离文档流，空间依然占据
    2、opacity 属性
        作用：改变元素的透明度
        取值：从0.0(完全透明) ~ 1.0(完全不透明) 之间的数字
    3、vertical-align 属性
        1、在 td 中，设置文本的垂直对齐方式
        2、设置行内块元素两边文本的垂直对齐方式
        3、设置图片两端文本垂直对齐方式

        语法：
            属性：vertical-align
            取值：
                1、top
                2、middle
                3、bottom
                4、baseline
                    基线对齐
3、光标
    改变鼠标在页面(元素)中的状态
    属性：cursor
    取值：
        1、default
        2、pointer
            小手
        3、crosshair
            +
        4、text
            文本状态 I
        5、wait
            等待
        6、help
            帮助
</code></pre><p>3、列表</p>
<pre><code>1、列表项标识
    属性：list-style-type
    取值：
        1、none
        2、disc ：实心圆
        ... ...
2、列表项图像
    属性：list-style-image
    取值：url()
3、列表项标识位置
    列表项标识的默认位置是在内容区域之外
    属性：list-style-position
    取值：
        1、outside
            默认值
        2、inside
            将列表项标识的位置改为内容区域之内
4、列表属性
    属性：list-style
    取值：type url position;
    常用方式：list-style:none;
5、CSS重写
    CSS Reset，修改元素的默认样式
    body,p,h1,h2,h3,h4,h5,h6,pre,ul,ol,dl,dd{
        margin:0;
        padding:0;
        list-style:none;
    }
</code></pre><p>4、定位(相对，绝对，固定)</p>
<pre><code>1、定位属性
    1、定位属性
        属性：position
        作用：改变元素定位方式
        取值：
            1、static
                静态的，默认值
            2、relative
                相对的
            3、absolute
                绝对的
            4、fixed
                固定定位
        注意：relative，absolute，fixed被称之为 &quot;已定位元素&quot;
    2、偏移属性
        作用：改变元素在页面中的位置
        属性：
            1、top
            2、bottom
            3、left
            4、right
        取值：偏移距离(px)
    3、堆叠顺序
        作用：在已定位元素中调整堆叠顺序
        属性：z-index
        取值：无单位的数字
2、定位 - 相对定位
    1、什么是相对定位
        元素会相对于它原来的位置偏移某个距离
        元素原来所占的空间会被保留
    2、语法
        position:relative;
        配合 top/right/bottom/left 偏移属性实现位置的微调
    3、使用场合
        1、元素位置微调
3、定位 - 绝对定位
    1、什么是绝对定位 &amp; 特点
        1、绝对定位的元素会脱离文档流即不占据页面空间
        2、绝对定位的元素会相对于离它最近的已定位的祖先元素去实现定位
        3、如果没有已定位的祖先元素，那么就会相对于最初的包含块去实现定位比如body或html
    2、语法
        position:absolute;
        配合着 top/right/bottom/left 实现位置定位
    3、特点
        1、绝对定位元素会变成块级元素
        2、绝对定位元素的margin可以使用，默认情况下，auto会失效
        &lt;div id=&quot;d1&quot;&gt;(无定位)
            &lt;div id=&quot;d2&quot;&gt;(无定位)
                &lt;p id=&quot;p1&quot;&gt;(无定位)
                    &lt;span&gt;这是一个span&lt;/span&gt;
                &lt;/p&gt;
            &lt;/div&gt;
        &lt;/div&gt;
4、堆叠顺序
    属性：z-index
    取值：无单位的数值
        数值越大，越靠前，默认是0
        可以取负值，当前元素在页面所有内容之下
    注意：
        1、只有已定位元素才能设置z-index
        2、默认的堆叠顺序是 后来者居上
        3、父子元素中，永远都是子压在父上,是不受z-index影响的
</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;1、CSS概述&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;1、问题
    1、控制页面中所有的文本颜色为 红色
    2、控制页面中所有div的文本颜色 为蓝色
    3、将 所有div 的颜色 变为 黄色

    HTML元素的不足：
        1、要完成相同的效果，使
    
    </summary>
    
      <category term="学习笔记" scheme="www.wangchengzou.cn/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="CSS" scheme="www.wangchengzou.cn/tags/CSS/"/>
    
      <category term="CSS3" scheme="www.wangchengzou.cn/tags/CSS3/"/>
    
  </entry>
  
  <entry>
    <title>CSS优先级算法如何计算</title>
    <link href="www.wangchengzou.cn/2017/07/22/CSS%E4%BC%98%E5%85%88%E7%BA%A7%E7%AE%97%E6%B3%95%E5%A6%82%E4%BD%95%E8%AE%A1%E7%AE%97/"/>
    <id>www.wangchengzou.cn/2017/07/22/CSS优先级算法如何计算/</id>
    <published>2017-07-22T15:48:26.000Z</published>
    <updated>2017-07-23T07:53:48.776Z</updated>
    
    <content type="html"><![CDATA[<ul>
<li>优先级就近原则，同权重情况下样式定义最近者为准;</li>
<li>载入样式以最后载入的定位为准;<br>优先级为:    !important &gt;  id &gt; class &gt; tag<br>important 比 内联优先级高</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;优先级就近原则，同权重情况下样式定义最近者为准;&lt;/li&gt;
&lt;li&gt;载入样式以最后载入的定位为准;&lt;br&gt;优先级为:    !important &amp;gt;  id &amp;gt; class &amp;gt; tag&lt;br&gt;important 比 内联优先级高&lt;/li&gt;
&lt;/
    
    </summary>
    
      <category term="面试题目" scheme="www.wangchengzou.cn/categories/%E9%9D%A2%E8%AF%95%E9%A2%98%E7%9B%AE/"/>
    
    
      <category term="html" scheme="www.wangchengzou.cn/tags/html/"/>
    
      <category term="css" scheme="www.wangchengzou.cn/tags/css/"/>
    
  </entry>
  
  <entry>
    <title>CSS3高级笔记</title>
    <link href="www.wangchengzou.cn/2017/07/22/CSS3%E9%AB%98%E7%BA%A7/"/>
    <id>www.wangchengzou.cn/2017/07/22/CSS3高级/</id>
    <published>2017-07-22T15:48:26.000Z</published>
    <updated>2017-07-23T10:33:13.367Z</updated>
    
    <content type="html"><![CDATA[<p>1、复杂选择器</p>
<pre><code>1、兄弟选择器
    通过兄弟级别的位置关系来匹配页面元素
    注意，兄弟选择器，只能向后找，不能向前找
    语法：
        相邻兄弟选择器：通过相邻（紧紧挨着的）位置关系匹配元素
        选择器1+选择器2
        如：div+p   #top+.important
                通用兄弟选择器：用于匹配某元素后面所有的兄弟元素
        选择器1~选择器2
        如#d1~div
2、属性选择器
    通过元素所附带的属性及其值来匹配页面中的元素
    语法：
        基础属性选择器  [attr]
            匹配页面中的有附带attr属性的元素
        elem[attr]
            elem:表示任意元素名称
            attr:表示任意属性名称
            匹配页面中附带attr属性的elem元素
            如：div[id]:匹配页面中所有附带id属性的div元素
        [attr1][attr2][attr3]
            匹配页面中同时附带attr1和attr2属性的所有元素
            如 input[name][hype]
        [attr=value]
            匹配页面中所有attr属性的值为value的元素
            如input[type=text]
        [class~=value]
            主要使用在多类选择器上，匹配页面中class属性值中包含value选择器的元素
        [attr^=value]
            匹配以value值作为开始的attr属性的元素
        [attr$=value]
            匹配以value值作为结束的attr属性的元素
        [attr*=value]
            匹配attr属性值中包含value字符的所有元素
3、伪类选择器
    目标伪类
        突出显示活动的HTML锚元素
        语法： ：target
    结构伪类
        通过元素之间的结构关系来匹配元素
        ：first-child     获取属于其父元素中的首个子元素
        ：last-child     获取属于其父元素中的尾（最后）子元素
        :nth-child(N)  获取属于其父元素中的第N个子元素
        ：empty   空的，匹配没有子元素的元素，包含文本
        ：only-child   匹配属于其父元素中的唯一子元素
    否定伪类
        把匹配某选择器元素排除出去
        ：not(选择器 )
4、伪元素选择器
    伪类与伪元素
        伪类：匹配元素不同的状态
        伪元素：是匹配元素中的内容
    语法：
        ：first-letter
        ::first-letter  匹配某元素的首字符
        ：first-line    匹配某元素的首行字符
        ：：selection 匹配用户选取的内容部分
    ：和：：区别
        在CSS2.1中，伪类选择器和仿元素选择器都是用：来表示
        在CSS3中，所有伪类选择器用：表示，所有的伪元素选择器用：：表示
</code></pre><p>2、内容生成</p>
<pre><code>通过CSS动态的向某个元素的内容区域之前、之后增加一部分内容
伪元素选择器
    ：before   定位到元素内容区域之前
    ：after    定位到元素内容区域之后
语法：
    属性：content
    取值：普通文本
         图像，url(...)
         计数器
问题处理：
    外边距溢出问题
        为父元素添加边框
        使用父元素的内边距取代子元素的外边距
        在父元素的第一个或最后一个子元素位置处增加一个空的table
    浮动元素父元素的高度问题
</code></pre><p>3、弹性布局</p>
<pre><code>flexible box,可伸缩布局，为普通布局带来更大的灵活性
基本概念‘
    flex容器：简称容器，将元素设置为flex容器后，其子元素允许实现灵活的位置摆放
    flex项目：简称项目，存放在flex容器中的内容

语法：
    容器：display
        取值：flex 将块级元素变为flex容器
              inline-flex  将行内元素变为flex容器
        注意：将元素设置为flex布局后，子元素的float,clear,vertical-align属性将失去作用
    容器属性;
        该组属性要添加在容器元素上，控制子元素的位置
        flex-direction  决定主轴的方向（main-axsis）
            取值：
                row  主轴为水平方向的轴，起点在容器左端，默认值
                row-reverse 主轴为水平方向的轴，起点在容器右端
                column  主轴为交叉轴，起点在容器的顶端
                column-reverse 主轴为交叉轴，起点在容器的底端
        flex-wrap   当一条轴线（一行）排列不下时，子元素将如何换行
            取值：
                nowrap     默认值，不换行
                wrap        换行
                wrap-reverse  反方向换行
        flex-flow   dirextion和wrap的缩写方式
            取值：
                row nowrap 默认值
                direction wrap
        justify-content   定义项目在主轴上的对齐方式
            取值：
                flex-start   主轴起点对齐
                flex-end   主轴终点对齐
                center    居中对齐
                space-between  两端对齐，项目之间的距离是相等的
                space-around  每个项目两侧间距是相等的 项目与项目之间的间距，要比项目与父元素之间的间距大一倍
        align-items  定义项目在交叉轴的对齐方式（单行项目有效）
            取值：
                flex-start  交叉轴起点对齐
                flex-end   交叉轴终点对齐
                center     交叉轴中间对齐
                baseline   基线对齐，以所有项目中的第一行文本为准
                stretch    默认值，如果项目不设置高度或为auto时，那么项目将占满整个容器的高度
        align-content  定义了多跟轴线的对齐方式，如果项目只一根轴线，该属性无效
            取值：
                flex-start   交叉轴顶端对齐
                flex-end    交叉轴底端对齐
                center      交叉轴中间对齐
                space-between  与交叉轴两端对齐
                space-around     项目与项目间对齐
    项目属性：
        该组属性主要设置于项目中
        order  定义项目在排列顺序，值越小，越靠前，默认为0
        flex-grow  指定项目的放大比例，默认为0，即不放大
        flex-shrink 指定项目的缩小比例，默认为1，即空间不足时，等比缩小，为0时不缩小
        flex-basis  指定项目占据主轴的剩余空间大小 auto 默认值，项目本身大小
        flex  是flex-grow,flex-shrink,flex-basis 的简写模式
            取值，auto  相当于1  1   auto
                 none  相当于0 0  auto
                 flex-grow【,flex-shrink,flex-basis】
        align-self  允许定义当个项目与其他项目不一样的交叉轴对齐方式（类似于align-items）,能够覆盖align-items的效果
            取值： auto 默认值，使用
                  flex-start   主轴起点对齐
                flex-end   主轴终点对齐
                center    居中对齐
                base-line
                stretch
</code></pre><p>4、CSS Hack 兼容性</p>
<pre><code>标准模式和混杂模式和准标准模式
IE6之前，没有兼容性说法
IE6之后，各个浏览器追求标准统一，开始支持标准，IE的其它浏览器要向前兼容，所以出现各种模式
    混杂模式  无标准可言
        编写代码时，不写&lt;!doctylpe&gt;就是混杂模式，采用的是IE5.5的内核进行渲染
    标准模式  安全支持
    准标准模式，即支持标准，也同时向前兼容非标准代码
如何根据不同的浏览器编写不同的css
    css类内部Hack
        在属性名称前和值添加前后缀以便识别不同的浏览器
    选择器Hack
        在选择器前添加特殊标识以便识别不同的浏览器
    头部引用hack
        通过html的条件注释来判断浏览器版本，去执行不同的CSS
        条件注释
            条件：
                gt:判断当前浏览器是否大于指定定版本
                gte：判断当前浏览器是否大于等于指定定版本
                it:   判断当前浏览器是否小于指定版本
                ite： 判断当前浏览器是否小于等于指定版本
                !：   判断当前浏览器是否为非指定版本
                    &lt;!--[if !IE 8]&gt;
                        该段内容在除IE8以外浏览器中显示
                    &lt;![endif]--&gt;
</code></pre><p>5、转换</p>
<pre><code>说明：改变元素在页面中的形状，角度 大小 位置的一种效果
    允许进行2D和3D方向的转换
    2D转换：在平面中进行的操作
    3D转换：在空间中进行的操作
转换属性：
    rtansform:为元素应用2D或3D转换效果
        取值：none;  没有效果

            transform-functions:一组转换函数
                位移转换函数：translate()
                改变形状函数：skew()
                注意：如果指定多个转换函数的话中间用空格隔开
    转换原点：
        属性：transform-origin
        默认：转换原点在元素中心处
        取值：轴线给值
            两个轴线值：X Y
            三个轴线值：X Y Z
2D转换
    位移：改变元素在页面中的位置
        语法：transform
            fransform(x)  改变元素在X轴的位置
            fransform(X ,Y)  改变元素在两轴的位置
            fransformX(X) 只在X轴上位置移动
            fransformY(Y)  只在Y轴上位置移动
    缩放： 改变元素在页面中的大小】
        语法：transform
            scale(value)  表示两轴等比缩放
                取值：默认  为1
                    放大   为大于1的数值
                    缩小   为0~1之间小数
                    返转   负数
            sacle(X,Y)
            saclex(y)
            sacley(y)
    旋转：改变元素在页面上的角度，要根据原点实现转换效果
        语法：transform
            rotate(ndeg)
                n 取值正，顺时针旋转
                n 取值负，逆时针旋转
                deg 为角度
                0~360范围
        注意：转换原点问题
            元素坐标轴也跟着旋转
    倾斜：改变元素在页面中形状
        语法：transform
            skew(xdeg)  横向倾斜指定度数
                x 取值正，y轴逆时针倾斜一定角度
                  取值负，Y轴顺时针倾斜一定角度
            skew(xdeg,ydeg)
            skewx(xdeg)
            skewy(ydeg)
3D转换
    感觉空间
    属性：perspetive 假定人眼到投射平面的距离
    注意：该属性要放在3D转换元素的父元素上
        兼容性chrome和safari需要加前缀
            -wedkit-perspective:500px;
    旋转：以X轴中心轴旋转
            rotatex(xdeg)
          以Y轴中心轴旋转
            rotatey(ydeg)
          以Z轴中心轴旋转
            rotatez(zdeg)
        取值：正  顺时针
            负   逆时针
        以多个轴同时进行旋转
            rotate3d(x ,y, z ,ndeg)
                x y z 取值为1，该轴参与旋转
                x y z  取值为0 ，该轴不参与旋转
    位移：改变元素在Z轴上的位置
        语法：transform
            translatez(z)

            transform-style
                取值：flat  默认值，子元素不保留3D位置
                     preserve-3D  子元素保留3D位置
</code></pre><p>6、过渡</p>
<pre><code>作用效果：使得css属性值在一段时间内平缓变化的效果
要素与属性：
    指定过渡属性：指定哪个属性值在变化时使用过渡效果展示
        transition-property: 属性名称（width）
                      all   全部属性
                      none
        允许设置过渡效果的属性：
            颜色属性
            渐变属性
            取值为数字属性
            转换属性 transition-property:transform;
            visibility属性
            阴影属性
    指定过渡时长
        transition-duration: 以S、MS为单位数值
    指定过渡时速曲线函数  可选
        transition-timing-function
            取值：ease  默认值，慢速开始，快速变快，慢速结束
                 linear  匀速进行
                 ease-in   慢速开始，快速结束
                 ease-out  快速开始，慢速结束
                 ease-in-out  慢速开始和结束，先加速后减速
    指定过渡的延迟时间   可选
        transition-delay
            取值：以S或MS做为单位
    简写属性：transition:prop duration  timing-fun delay;
        多个过渡效果
            transition:prop1 duration1 timing-fun1 delay1,prop2 duration2 timing-fun2 delay2........;
触发过渡条件
    将过渡编写在元素声明的样式中，由:hover,:active等，进行触发,
    将过渡编写在:hover,:active伪类中
</code></pre><p>7、动画</p>
<pre><code>使元素从一种样式逐渐变化为另一种样式的过程，与动画相关的属性，增加浏览器前缀
动画使用步骤
    声明动画
        指定动画名称
        指定动画中的关键帧（keyframes）
            时间点（以百分比描述时间）
            元素状态（CSS样式）
    为元素调用动画
        指定调用动画的名称以及执行时长
语法：
    声明动画     注意前缀，兼容性问题
        &lt;style&gt;
            @keyframes 名称{
                0%{   动画开始时，元素的状态   }
                。。。。
                100%{  动画结束时，元素的状态  }
            }
        &lt;/style&gt;
    调用动画(animation)
        animation-name  指定调用动画名称
        animation-duration   指定动画周期时长，以S或MS为单位
        animation-timing-function  指定动画的速度时间出线函数
            取值：ease  默认值，慢速开始，快速变快，慢速结束
                 linear  匀速进行
                 ease-in   慢速开始，快速结束
                 ease-out  快速开始，慢速结束
                 ease-in-out  慢速开始和结束，先加速后减速
        animation-delay  指定动画延迟时间
        animation-iteration-count  指定动画播放次数
            取值：默认1次，具体数值
                infinite:无限次播放
        animation-direction  指定动画的播放方向
            取值：normal  从0%~100%
                reverse  从100%~0%
                alternate  轮流来回播放 奇数 0%~100%
                                 偶数 100%~0%
        animation  简写方式
            取值：name  duration  timing-fun delay  iteration-count direction;
        animation-fill-mode  指定动画播放之前、之后的填充模式
            取值：none  默认值
                 forwards  动画播放完成后，保持在最后一帧的位置
                 backwards 动画播放前，延迟时间内，动画保持在开始第一帧上的位置
                 both 同时应用在开始和最后的位置帧上
        animation-play-state  动画播放状态
            取值：paused 暂停
                 running 播放
</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;1、复杂选择器&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;1、兄弟选择器
    通过兄弟级别的位置关系来匹配页面元素
    注意，兄弟选择器，只能向后找，不能向前找
    语法：
        相邻兄弟选择器：通过相邻（紧紧挨着的）位置关系匹配元素
        选择器1+选
    
    </summary>
    
      <category term="学习笔记" scheme="www.wangchengzou.cn/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="CSS" scheme="www.wangchengzou.cn/tags/CSS/"/>
    
      <category term="CSS3" scheme="www.wangchengzou.cn/tags/CSS3/"/>
    
  </entry>
  
  <entry>
    <title>HTML5的form如何关闭自动完成功能</title>
    <link href="www.wangchengzou.cn/2017/07/22/HTML5%E7%9A%84form%E5%A6%82%E4%BD%95%E5%85%B3%E9%97%AD%E8%87%AA%E5%8A%A8%E5%AE%8C%E6%88%90%E5%8A%9F%E8%83%BD/"/>
    <id>www.wangchengzou.cn/2017/07/22/HTML5的form如何关闭自动完成功能/</id>
    <published>2017-07-22T15:48:26.000Z</published>
    <updated>2017-07-23T07:45:05.164Z</updated>
    
    <content type="html"><![CDATA[<p>给不想要提示的 form 或某个 input 设置为 autocomplete=off</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;给不想要提示的 form 或某个 input 设置为 autocomplete=off&lt;/p&gt;

    
    </summary>
    
      <category term="面试题目" scheme="www.wangchengzou.cn/categories/%E9%9D%A2%E8%AF%95%E9%A2%98%E7%9B%AE/"/>
    
    
      <category term="html" scheme="www.wangchengzou.cn/tags/html/"/>
    
      <category term="H5" scheme="www.wangchengzou.cn/tags/H5/"/>
    
  </entry>
  
  <entry>
    <title>DOM_BOM笔记</title>
    <link href="www.wangchengzou.cn/2017/07/22/DOM_BOM%E7%AC%94%E8%AE%B0/"/>
    <id>www.wangchengzou.cn/2017/07/22/DOM_BOM笔记/</id>
    <published>2017-07-22T15:48:26.000Z</published>
    <updated>2017-07-23T10:57:34.367Z</updated>
    
    <content type="html"><![CDATA[<ol>
<li><p>DOM: Document Object Model</p>
<p> DOM是专门操作网页内容的API标准<br> 为什么: 早起js操作不同浏览器的API没有标准，有严重兼容性问题<br> 所以，W3C制定了统一的操作网页内容的API标准,所有浏览器厂商都遵照执行。<br> 结果，使用DOM API操作网页内容，几乎100%兼容所有浏览器<br> 何时: 只要操作网页内容，就用DOM API查找, 修改(内容,属性,样式), 添加, 删除.</p>
</li>
</ol>
<p>DOM Tree:</p>
<pre><code>什么是: 网页中一切内容在内存中都是以树形结构存储的
       网页中每一项内容都是树上的一个节点对象
       包括: 元素, 文字, 属性...
       树只有一个根节点: document, 包含了所有网页内容
Node: 每个节点都是一个node类型的对象
      node是所有节点的父类型
</code></pre><p>三大公共: nodeType  nodeName  nodeValue</p>
<pre><code>nodeType: 节点的类型
  值: document   9
     element     1
     attribute     2
     text         3
  何时: 只要判断节点类型，就用nodeType
        因为不同类型的节点，能执行的操作是不一样的
  问题: 不能进一步区分元素的名称
  解决:
nodeName: 节点的名称
  值: document   #document
     element    全大写的标签名
     attribute    属性名
     text        #text
  何时: 只要细致鉴别元素的标签名时
    强调: nodeName返回的是全大写的标签名
nodeValue: 节点值:
  值: document   null
     element     null
     attribute     属性值
     text         文本内容
</code></pre><p>2、查找: 4种:</p>
<pre><code>  a. 不需要查找，可直接获得的元素
        html   document.documentElement
        head   document.head
        body   document.body
  b. 按节点间关系查找:
节点树: 包含所有节点: 元素和文本
  1. 父子: elem.parentNode  找elem的父节点
        elem.childNodes  找elem的所有*直接*子节点
            返回，所有直接子节点组成的集合(类数组)
        elem.firstChild   找elem的第一个*直接*子节点
        elem.lastChild   找elem的最后一个*直接*子节点
  2. 兄弟: elem.previousSibling 找elem的前一个兄弟
        elem.nextSibling   找elem的下一个兄弟
 何时: 前提: 已经获得了一个节点
      要找周围临近的节点时
 问题: 连看不见的空字符，也算文本节点——干扰
 解决:
元素树: 仅包含元素节点的树结构
       不是一棵新树，仅是节点树的子集
 1. 父子: elem.parentElement  找elem的父元素
        elem.children  找elem的所有*直接*子元素
            返回，所有直接子元素组成的集合(类数组)
        elem.firstElementChild   第一个*直接*子元素
        elem.lastElementChild   最后一个*直接*子元素
 2. 兄弟:
   elem.previousElementSibling 找elem的前一个兄弟元素
   elem.nextElementSibling   找elem的下一个兄弟元素
 何时: 只要仅关心元素节点，不关心文本节点时
 问题: IE9+
 强调: childNodes和children返回的都是动态集合！
   凡是遍历动态集合，都要先缓存元素个数，再遍历
   for(var i=0,len= childNodes.length;i&lt;len;i++)
     不会导致反复查找DOM树
</code></pre><p>3、 按HTML查找:</p>
<pre><code>    优: 范围可大可小,可设置条件
a、按id查找: var elem=document.getElementById(&quot;id&quot;)
  强调: 1. 只能在document对象上调用
       2. 返回一个元素对象
b、按标签名查找:
    var elems=parent.getElementsByTagName(&quot;标签名&quot;);
  强调: 1. 可在任意父元素上
       2. 返回多个元素组成的集合
       3. 不但查找直接子元素，还查找所有后代元素
c、按name属性查找: 了解
   专门找表单中有name属性的表单元素
    var elems=document.getElementsByName(&quot;name&quot;)
    强调: 1. 只能在document上调用
         2. 返回多个元素组成的集合
d、按class属性查找:
    var elems=parent.getElementsByClassName(&quot;class&quot;)
    强调: 1. 可在任意父元素上调用
         2. 返回多个元素组成的集合
         3. 不要求完整匹配，只要包含即可！
缺: 每次只能按一个条件查找
   如果条件复杂，就无法一句话获得想要的元素
</code></pre><p>4、 按选择器查找:</p>
<pre><code>a. 只找一个元素:
  var elem=parent.querySelector(&quot;selector&quot;);
b. 找多个元素
  var elems=parent.querySelectorAll(&quot;selector&quot;);
</code></pre><p>5、 总结:</p>
<pre><code> A首次查找:
    1. 如果条件简单: 按HTML查找: id, 标签, className
    2. 如果条件复杂: 按选择器查找:
 B已经获得一个元素，找周围相邻: 按节点间关系
鄙视: 按HTML查找 vs 按选择器查找
 1.使用的难易程度: 当条件复杂时:
    按选择器查找——简单, 按HTML查找——繁琐
 2.返回值:
    getElementsByTagName() 返回多个元素的*动态*集合
      什么是动态集合: 不实际存储对象的属性值，每次访问，都要重新查找DOM树
    querySelectorAll()  返回多个元素的*非动态*集合
      什么是非动态集合: 实际存储对象的所有属性值，即使反复访问集合，也不会导致反复查找DOM树
 3.单次效率:
    按HTML查找——效率高!
    按选择器查找——效率低
</code></pre><p>3、 修改: (内容, 属性, 样式)</p>
<pre><code>1. 修改:
标准属性: 2种:
  1. 核心DOM: 操作一切结构化文档的API(HTML，XML)
    elem.attributes集合: 保存了当前元素的所有属性节点
    获取属性值: elem.getAttribute(&quot;属性名&quot;)
    修改属性值: elem.setAttribute(&quot;属性名&quot;,&quot;值&quot;)
    判断是否包含属性: elem.hasAttribute(&quot;属性名&quot;)
    移除属性: elem.removeAttribute(&quot;属性名&quot;)
  2. HTML DOM: 对部分常用DOM API的简化版本
     HTML DOM将标准属性都预定义在元素对象中
    获取属性值: elem.属性名
    修改属性值: elem.属性名=&quot;值&quot;;
    判断是否包含属性: elem.属性名===&quot;&quot; 不包含
    移除属性: elem.属性名=&quot;&quot;
    特例: class属性和ES标准中的class重名
          -&gt; DOM -&gt; className
    自定义属性: 比如: data-toggle=&quot;dropdown&quot;
      HTML DOM不能操作自定义属性
      暂时只能用核心DOM操作:
    三大状态: disabled  selected   checked
      核心DOM无法操作三大状态属性
      HTMLDOM: elem.disabled elem.selected  elem.checked
            值都是bool类型true/false
</code></pre><p>3.1、修改css样式:</p>
<pre><code>1. 仅获取/修改内联样式:  elem.style.css属性名
  问题1: css属性名有的带-
  解决: 所有css属性名都要去横线变驼峰
     比如: background-color: backgroundColor
          list-style-type: listStyleType
  问题2: 所有数值类型的属性值都是带单位的字符串
  解决: 获取时: 都要去单位，转数值
        修改时: 将单位拼回数值
  问题3: 仅能获得内联样式, 无法获得样式表中的样式
  解决: 计算后的样式: 最终应用到元素上的完整样式
    何时: 只要希望获得元素完整的样式时
    如何: 2步:
      1. 获得完整样式对象style
        var style=getComputedStyle(elem)
      2. 获得style对象中的css属性
        style.css属性名
     强调: style对象中的样式都是只读
结论: 1. 获取样式: getComputedStyle
     2. 修改样式: elem.style.css属性名
2. 运行时修改样式表中的样式:
  Step1: 获得样式表对象:
   var sheet=document.styleSheets[i]
  Step2: 获得样式表对象中某个CSSRule(一个选择器{})
   var rule=sheet.cssRules[i]
  Step3: 修改rule.style.css属性名=值
</code></pre><p>4、 添加和删除:</p>
<pre><code>添加: 3步:
 Step1: 创建空元素:
  var a=document.createElement(&quot;a&quot;);
  &lt;a&gt;&lt;/a&gt;
 Step2: 设置关键属性:
     a.href=&quot;http://tmooc.cn&quot;
     a.innerHTML=&quot;go to tmooc&quot;;
  &lt;a href=&quot;http://tmooc.cn&quot;&gt;go to tmooc&lt;/a&gt;
 Step3: 将元素添加到DOM树: 3种:
   1. 末尾追加: parent.appendChild(child)
   2. 中间插入: parent.insertBefore(child, oldChild)
   3. 替换: parent.replaceChild(child, oldChild)
</code></pre><p>优化: 尽量少的修改DOM树</p>
<pre><code>原因: 页面加载过程:
  html -&gt; DOM Tree(松树)
           ↓
        render Tree(圣诞树)-&gt; layout(计算绝对布局)-&gt;paint
           ↑                 最耗时
  css  -&gt; cssRules(装饰品)
  每次修改DOM树，都会导致重新layout，耗时。
如何: 2种:
 1. 如果同时添加父元素和子元素时，应该先在内存将子元素都添加到父元素中，再将父元素一次性整体添加到DOM树
    结果: 只触发一次layout
</code></pre><p>1、 HTML DOM 常用对象: 对常用HTML元素操作的简化</p>
<pre><code>Select: 代表页面上的一个select元素
 属性: select.value 当前选中项的value
                 没有value，就返回选中项的内容
      select.options 保存select下所有option元素对象
        相当于: select.getElementsByTagName(&quot;option&quot;)
        select.options.length 保存select下option的个数
        清空select下所有option: select.options.length=0;
      select.length 等效于select.options.length
        清空select下所有option: select.length=0;
                               select.innerHTML=&quot;&quot;;
      select.selectedIndex 当前选中项的下标
  事件: onchange 当选中项发生改变时
  方法: select.add(option) 向select中添加一个option
         相当于: select.appendChild(option)
         不支持文档片段
       select.remove(i) 移除select中i位置的一个option
Option: 代表页面上的一个option元素
  创建: var opt=new Option(text,value);
     创建一个option对象，同时设置opt的内容为text，设置opt的值为value
     相当于: var opt=document.createElement(&quot;option&quot;);
            opt.innerHTML=text;
            opt.value=value;
  属性: .text 代替.innerHTML
       .index  表示当前option在select下的下标位置
</code></pre><p>Table: 代表网页中一个table元素</p>
<pre><code> 管着行分组：
   添加行分组: var 行分组=table.createTHead|TBody|TFoot();
       强调: 即创建，同时又将行分组添加到table
   删除行分组: table.deleteTHead|TFoot()
   获取行分组: table.tHead|tFoot
              table.tBodies[i]
行分组: THead TBody TFoot
  管着行:
   添加行: var tr=行分组.insertRow(i)
       在行分组中i位置插入一个新行
       强调: 中间插入行，原i位置的行向后顺移
       固定套路: 1. 末尾追加一个新行: 行分组.insertRow()
                2. 开头插入: 行分组.insertRow(0)
   删除行: 行分组.deleteRow(i)
       删除行分组中第i行
       强调: i是当前行在行分组内的相对下标位置
   获取行: 行分组.rows

行: tr
  管着td:
    添加td: var td=tr.insertCell(i);
        省略i表示右侧末尾追加
        insertCell不支持添加th，只能添加td
    删除td: tr.deleteCell(i);
    获取td: tr.cells

删除行:
 tr上都有一个属性: tr.rowIndex 行在整个表的绝对下标
 问题：行分组，无法使用tr.rowIndex删除行。
 解决: table.deleteRow(tr.rowIndex)
 总结: 今后，删除行都用table.deleteRow(tr.rowIndex)
</code></pre><p>form: 代表页面上一个表单元素</p>
<pre><code> 获取: var form=document.forms[i/id]
 属性: form.elements 保存了表单中所有表单元素的数组
        包括: input   select   textarea  button
      form.elements.length 获得表单中表单元素的个数
      form.length =&gt; form.elements.length
 方法: form.submit();  用于手动提交表单
 事件: form.onsubmit  以任何方式提交表单之前自动触发
          常用于在提交之前，验证所有表单元素的内容
表单元素:
 获取: var elem=form.elements[i/id/name]
        简写: 如果表单元素有name属性: form.name
 方法: elem.focus() 让elem获得焦点
      elem.blur()  让elem失去焦点

Image: 代表页面上一个img元素
  创建: var img=new Image();
</code></pre><p>DOM总结: 查找-&gt;绑定事件-&gt;查找-&gt;修改/添加/删除</p>
<pre><code>查找: 4种:
  1. 不需要查找可直接获得: html  head  body  form
  2. 节点间关系: 节点树/元素树
      鄙视: 递归遍历
  3. 按HTML: 4种: ById, ByTagName, ByName, ByClassName
  4. 按选择器: 2种:
      只找一个: querySelector()
      找多个: querySelectorAll()
修改:
  内容: .innerHTML  .textContent/.innerText  .value
  属性:
    1. 标准属性: 1. 核心DOM; 2. HTML DOM
    2. 自定义属性: 核心DOM
    3. 状态属性: HTML DOM
  样式:
    修改: elem.style.css属性=值
    获取: var style=getComputedStyle(elem)
         style.css属性 ——只读
    可通过修改class属性批量应用修改多个css属性
添加: 3步:
   1. createElement,
   2.设置关键属性,
   3. appendChild/insertBefore/replaceChild
  优化: 尽量少的操作DOM树
  如何: 2种:
   1. 同时添加父子元素: 先将子元素加入父元素，再将父元素整体添加到页面
   2. 同时添加多个平级子元素: fragment
删除: parent.removeChild(child)
HTML DOM: Select/Option  Table/...  From/Element  Image
过渡动画: 2步:
  css中: 添加transition
  js中: 修改css属性值
   不支持transition: display  zIndex
   支持: width  height  opacity   bottom/top/left/right ...
</code></pre><p>2、BOM: Browser Object Model</p>
<pre><code>什么是: 专门操作浏览器窗口的API
比如: alert prompt confirm
问题: 1. 没有标准——兼容性问题;
     2. 不可定制
window对象: 2个角色:
  1. 代替ES中的Global充当全局作用域对象
  2. 封装所有BOM和DOM的API

打开超链接: 4种:
  1. 在当前窗口打开，可后退
    html: &lt;a href=&quot;url&quot; target=&quot;_self&quot;&gt;&lt;/a&gt;
    js: /*window.*/open(&quot;url&quot;,&quot;_self&quot;)
  2. 在当前窗口打开，不可后退
    js: location.replace(&quot;url&quot;);
       用新url代替history中当前url，结果: 无法后退
  3. 在新窗口打开，可打开多个
    html: &lt;a href=&quot;url&quot; target=&quot;_blank&quot;&gt;&lt;/a&gt;
    js: open(&quot;url&quot;,&quot;_blank&quot;)
  4. 在新窗口打开，只能打开一个
    html: &lt;a href=&quot;url&quot; target=&quot;自定义name属性值&quot;&gt;&lt;/a&gt;
    js: open(&quot;url&quot;,&quot;自定义name属性值&quot;)
    原理: 内存中每个窗口都有一个唯一的name属性来唯一标示一个窗口
      浏览器规定，相同name属性的窗口只能打开一个
    其实: html中的target属性就是在设置新窗口的name属性值。
    如果target中使用自定义的窗口名，则只能打开一个
    预定义:
      _self: 默认使用当前窗口自己的name属性
           结果，新窗口覆盖当前窗口
      _blank: 意为不指定窗口名, 浏览器会随机生成不同的窗口名。
           结果: 每次打开新窗口都随机生成不同的name
                 结果: 可打开任意多个
</code></pre><p>定时器: 2种:</p>
<pre><code>1. 周期性定时器:
  什么是: 让程序按照指定时间间隔，反复执行一项任务
  何时: 只要让程序按照指定时间间隔，反复执行一项任务
  如何: 3件事:
    1. 任务函数: 让定时器反复调用的函数
    2. 启动定时器:
     var timer=setInterval(任务函数, 间隔的毫秒数)
    3. 停止定时器: clearInterval(timer)
        问题: timer中的序号会残留在timer变量中
        解决: 停止定时器后，主动清空timer
             timer=null
  停止定时器: 2种:
    1. 用户手动停止定时器: 用按钮调用clearInterval
    2. 自动停止定时器: 在任务函数中:
       1. 设定临界条件
       2. 如果达到临界条件就自动调用clearInterval

2. 一次性定时器:
 什么是: 让程序先等待一段时间，再自动执行一次任务
         执行一次后，定时器自动停止
 何时: 只要先等待，再执行一次任务
 如何: 三件事
   1. 任务函数
   2. 启动: var timer=setTimeout(任务函数, 等待的毫秒数)
   3. 停止: clearTimeout(timer)
</code></pre><p>鄙视: 定时器中的函数，只能在主程序所有程序执行后才能执行</p>
<pre><code>for(var i=0;i&lt;3;i++){
  setTimeout(function(){
    console.log(i);
  },0);
}//结果: 3 3 3
//alert(&quot;Hello&quot;) 如果不点确定，则永远不输出333
</code></pre><p>window:<br> history，location，document，navigator，screen，event</p>
<pre><code>history: 保存当前窗口打开后，成功访问过的历史记录的栈
  history封装的非常严密
  只能前进，后退，刷新: history.go(n)
   前进: go(1)  后退:go(-1)  刷新:go(0)

location: 专门保存当前窗口正在打开的url的对象
 属性: location.href 保存了完整的url
        在当前窗口打开: location.href=新url
      location.protocol: 协议
            .host: 主机名+端口号
            .hostname: 主机名
            .port: 端口号
      location.pathname: 相对路径
            .hash: 锚点地址#xxx
            .search: 表单提交后地址栏中的查询字符串
                   ?变量名=值&amp;变量名=值&amp;...
 方法:
   1. 替换history中当前url,实现进制后退:
     location.replace(&quot;新url&quot;)
   2. 在当前页面打开，可后退:
     location.assign(&quot;新url&quot;)
       =&gt; location.href=&quot;新url&quot;
        =&gt; location=&quot;新url&quot;
   3. 刷新页面:  location.reload(false/true);
     鄙视: false/true的差别
       浏览器本地是有缓存的
         浏览器的缓存中会保存css，图片等静态资源
       每次请求时，首先查看缓存中是否有想要文件
         没有想要文件，或文件过期，才去服务器下载新文件
       reload(false) 优先使用本地缓存的文件
       reload(true) 强制去服务器下载新文件
     查 浏览器缓存的原理！
</code></pre><p>1、event</p>
<pre><code>绑定事件: 2种:
 1. 在HTML中绑定: &lt;ANY on事件名=&quot;js语句&quot;
    问题: 不符合内容与行为分离的原则——不便于维护
 2. 在js中动态绑定: 2种:
    1. 一个事件只绑定一个处理函数:
       elem.on事件名=function(){
         //this-&gt;elem
       }
       解除绑定: elem.on事件名=null;
       问题: 每个事件只能绑定一个处理函数
       解决:
    2. 一个事件可同时绑定多个处理函数:
       elem.addEventListener(&quot;事件名&quot;,function(){
         //this-&gt;elem
       })
       解除绑定:
        elem.removeEventListener(&quot;事件名&quot;,&quot;函数名&quot;);
        强调: 如果一个事件处理函数可能被动态移除，则绑定时，不能使用匿名函数，必须使用有名称的函数

    事件模型: DOM标准: 3个阶段
      1. 捕获: 由外向内，记录各级父元素绑定的事件处理函数
      2. 目标触发: 首先执行目标元素上的事件处理函数
      3. 冒泡: 由内向外，反向执行捕获阶段记录的处理函数

    事件对象: 事件发生时自动创建的
             封装事件信息
             提供操作事件的API 的对象
      何时: 只要希望获得事件信息或修改事件的默认行为
      如何: 事件对象，在事件发生时，通常作为事件处理函数的第一个参数，默认自动传入！
          .on事件名=function(e){
             //e会自动获得事件对象
          }
    阻止蔓延/冒泡: e.stopPropagation();
    利用冒泡:
      优化: 尽量少的添加事件监听
      原理: 因为浏览器触发事件监听，是采用遍历查找的方式。添加的监听越多，遍历的速度越慢
      如何: 如果多个子元素都要绑定相同的事件
          只要在父元素绑定一次，所有子元素即可共用
      难题:
         1. 获得目标元素:
            不能用this, 因为this指父元素
            应该用e.target，保存实际点击的目标元素
         2. 鉴别目标元素:
            先判断目标元素的nodeName或className...
            只有目标元素符合要求时，才执行事件操作
    取消事件/阻止默认行为: e.preventDefault();
    事件坐标: 3对儿:
      1. 相对于整个屏幕左上角的坐标: e.screenX|screenY
      2. 相对于文档显示区左上角的坐标: e.clientX|clientY
      3. 相对于当前元素左上角的坐标: e.offsetX|offsetY

    页面滚动:
      事件: window.onscroll
      获得页面滚动位置: document.body.scrollTop
          页面超出文档显示区顶部的距离
</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;ol&gt;
&lt;li&gt;&lt;p&gt;DOM: Document Object Model&lt;/p&gt;
&lt;p&gt; DOM是专门操作网页内容的API标准&lt;br&gt; 为什么: 早起js操作不同浏览器的API没有标准，有严重兼容性问题&lt;br&gt; 所以，W3C制定了统一的操作网页内容的API标准,所有浏览器厂商
    
    </summary>
    
      <category term="学习笔记" scheme="www.wangchengzou.cn/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="javaScript" scheme="www.wangchengzou.cn/tags/javaScript/"/>
    
      <category term="DOM" scheme="www.wangchengzou.cn/tags/DOM/"/>
    
      <category term="BOM" scheme="www.wangchengzou.cn/tags/BOM/"/>
    
  </entry>
  
  <entry>
    <title>html知识点</title>
    <link href="www.wangchengzou.cn/2017/07/22/HTML%E7%AC%94%E8%AE%B0/"/>
    <id>www.wangchengzou.cn/2017/07/22/HTML笔记/</id>
    <published>2017-07-22T15:48:26.000Z</published>
    <updated>2017-07-23T10:22:26.610Z</updated>
    
    <content type="html"><![CDATA[<p>1、Web基础知识</p>
<pre><code>1、Internet
    1、简介
        Internet 实际上就是由计算机所组成的网络结构
        服务：
            1、Telnet
                远程登录
            2、Email
                电子邮件
            3、WWW
                万维网服务，World Wide Web
            4、BBS
                电子公告板 (论坛)
                百度贴吧，天涯论坛，... ...
                CSDN ... ...
            5、FTP
                文件传输协议
        基本实现技术：
            1、分组交换原理
                将传递的数据 拆分成若干数据包
            2、TCP/IP协议
2、Web
    Web ：运行在Internet上的最流行的应用
        WWW : World Wide Web
        W3C : World Wide Web Consortium(万维网联盟)

        将 各类信息 以及 服务 进行无缝连接：
            信息：文字，图像，音频，视频，文件
            服务：BBS，Telnet，Email
3、Web的工作原理
    WEB是 基于 浏览器 / 服务器 模式的程序(B/S)
        B : Browser 浏览器
        S : Server 服务器

    基于 客户端 / 服务器 模式的程序(C/S)
        C : Client 客户端
        S : Server 服务器
        必须通过指定的客户端才能访问服务器数据的一种模式
    由Web服务器，浏览器 以及 通信协议 来组成
        服务器：提供服务的机器
        浏览器：工具
        通信协议：web中使用的时http通信协议
            http: Hyper Text Transfer Protocol
                    超级  文本 传输     协议
            规范了
                数据是如何打包的
                数据是如何传递的
    1、Web服务器
        功能：
            1、存储Web上内容信息
            2、接收客户端请求，并给出响应
            3、具备一定的安全功能
        产品：
            1、Tomcat
            2、Apache
            3、IIS
            ... ...
    2、WEB浏览器
        功能:
            1、代替用户提交请求(User Agent)
            2、作为HTML/CSS/Javascript 的解析器
            3、以图像化的方式显示网页文档
        产品:
            1、Microsoft IE
            2、Mozilla FireFox
            3、Google Chrome
            4、Apple Safari
            5、Opera
4、Web相关技术
    1、服务器端技术
        运行于服务器端，具备访问数据库的能力

        1、PHP
        2、JSP
        3、ASP
        4、ASP.NET
        5、Python
        6、NodeJS
    2、浏览器端技术(客户端)
        运行在客户端，由浏览器负责解释
        1、HTML
        2、CSS
        3、JavaScript(JS)
</code></pre><p>2、HTML入门</p>
<pre><code>1、HTML概述
    Web : 一种应用
    HTML是开发Web网页程序的一种语言

    1、什么是HTML
        HTML：Hyper Text Markup Language
                  超级  文本 标签   语言
            超级文本：具备超能力的文本
                字符 a ：首字符
                超文本 a ：链接
            标签/标记：超文本的组成形式
            语言：具备不同的语法规范
        由HTML编写的文本最终是以 .html 或 .htm作为结尾的文件 , 并且由浏览器解释运行
2、HTML语法规范(重点)
    1、标记
        在HTML中，用于描述功能的符号称之为 &quot;标记&quot;

        语法：
            标记在书写时，必须用 尖括号 括起来(&lt;&gt;)
            标记分成 封闭类型的标记 和 非封闭类型的标记
            1、封闭类型标记
                必须成对出现
                &lt;标记&gt; 内容 &lt;/标记&gt;
                注意：
                    1、封闭类型标记必须成对出现
                    2、标记必须要完整,否则会有意想不到的效果

            2、非封闭类型标记
                又称为 单标记 或 空标记
                &lt;标记&gt; 或 &lt;标记/&gt;
                ex :
                    &lt;br&gt; : 换行
                    &lt;hr/&gt;: 水平线
    2、元素
        元素 即 标记
        ex:
            &lt;a&gt;百度&lt;/a&gt;

        1、元素的嵌套
            元素之间可以相互嵌套，形成更为复杂的页面结构
            语法：
                &lt;标记&gt;&lt;标记1&gt;&lt;/标记1&gt;&lt;/标记&gt;
            注意：
                1、注意嵌套顺序
                2、必须完整嵌套
                3、格式问题
                    被嵌套的内容要通过缩进(Tab)表示层级关系
                ex:
                    &lt;a&gt;&lt;b&gt;&lt;span&gt;&lt;i&gt;&lt;u&gt;Hello World&lt;/u&gt;&lt;/i&gt;&lt;/span&gt;&lt;/b&gt;&lt;/a&gt;
                    推荐的格式：
                    &lt;a&gt;
                        &lt;b&gt;
                            &lt;span&gt;
                                &lt;i&gt;
                                    &lt;u&gt;
                                        Hello World
                                    &lt;/u&gt;
                                &lt;/i&gt;
                            &lt;/span&gt;
                        &lt;/b&gt;
                    &lt;/a&gt;
        2、属性 和 值
            属性 是用来修饰 元素的
            语法：
                1、属性的声明必须位于开始标记中
                2、属性名称与标记名称之间用空格隔开
                    &lt;标记 属性&gt;&lt;/标记&gt;
                    &lt;标记 属性/&gt;
                3、属性值 与 属性之间 用 &quot;=&quot; 来连接
                     属性值要用 &quot;&quot; 或 &apos;&apos; 引起来
                    &lt;标记 属性=&quot;值&quot;&gt;
                4、一个元素允许有多属性，多属性之间排名不分先后，中间用 空格 隔开
                    &lt;标记 属性1=&quot;值&quot; 属性2=&quot;值&quot;&gt;

                    ex:
                        &lt;p align=&quot;center&quot; id=&quot;p1&quot;&gt;&lt;/p&gt;

            通用属性：大部分元素都会具备的属性
                1、id
                    定义元素在页面中独一无二的名称
                2、title
                    鼠标移入到元素上时所提示的信息
                3、class
                    指定元素所引用的类选择器(CSS中使用)
                4、style
                    定义元素的内联样式(css中使用)
        3、注释
            要编写在源文档中，但不想被浏览器解释运行的内容
            &lt;!--  注释  --&gt;
            注意：
                1、注释不能嵌套
                    &lt;!--
                        这是一段注释
                        &lt;!--
                            这是另一段注释
                        --&gt;
                    --&gt;
                    以上结构是错的
                2、注释不能出现在标记(&lt;&gt;)里
                    &lt;a &lt;!-- 这是一个a --&gt;&gt;&lt;/a&gt;
                    以上的写法是错误的
        4、文档结构
            1、两部分组成
                1、文档类型声明
                    指定当前html文档用的时哪个版本
                    语法：
                        文档中的第一句话位置处
                        &lt;!doctype html&gt;
                2、html页面
                    网页要表示的信息的开始与结束
                    语法：
                        &lt;html&gt;&lt;/html&gt;
                        属性：
                            1、lang
                                取值：zh-cn
                    子级内容：
                        1、网页头部信息
                            作用：用于定义网页的全局信息
                            语法：
                                &lt;head&gt;&lt;/head&gt;
                            子级：
                                1、网页标题
                                    &lt;title&gt;标题内容&lt;/title&gt;
                                2、网页元数据
                                    指定网页编码格式
                                    &lt;meta charset=&quot;utf-8&quot;&gt;
                                    注意：
                                        必须保证网页文档的编码格式也是 utf-8 的
                        2、网页主体信息
                            包含要显示给用户去看的所有内容
                            &lt;body&gt;&lt;/body&gt;
                            属性：
                                1、text
                                    作用：控制当前文档的文本颜色
                                    取值：颜色的英文表示方式
                                2、bgcolor
                                    作用：控制当前文档的背景颜色
                                    取值：同上
    3、文本
        1、作用
            以不同的形式展现文字
        2、特殊字符
            默认下，任意多个 回车 和 空格 最后都会被折叠成一个空格
            通过转义字符表示特殊字符：
            1、&amp;nbsp;
                一个空格
            2、&amp;gt;
                &gt;
            3、&amp;lt;
                &lt;
            4、&amp;copy;
                ©
            5、&amp;yen;
                ￥
        3、文本标记
            1、文本样式
                &lt;i&gt;内容&lt;/i&gt; 斜体显示文本
                &lt;u&gt;内容&lt;/u&gt; 下划线的文本
                &lt;s&gt;内容&lt;/s&gt; 删除线的文本
                &lt;b&gt;内容&lt;/b&gt; 加粗显示文本
                &lt;sub&gt;&lt;/sub&gt; 下标
                &lt;sup&gt;&lt;/sup&gt; 上标

                特点：
                    所有的内容会在一行内显示
            2、标题元素
                作用：以标题的方式显示文本(突出显示)
                语法：
                    &lt;hn&gt;&lt;/hn&gt;
                        n : 1~6
                        &lt;h1&gt;&lt;/h1&gt;
                        ...
                        &lt;h6&gt;&lt;/h6&gt;
                属性：
                    1、align ：文本的水平排列方式
                        取值：left / center / right
                特点：
                    1、独自成行
                    2、加粗显示文本
                    3、上下会有垂直的空白
            3、段落元素
                语法：
                    &lt;p&gt;&lt;/p&gt;
                属性：
                    align
                特点：
                    1、垂直空白
                    2、独占一行
            4、换行元素
                语法：&lt;br&gt; 或 &lt;br/&gt;
            5、分割线元素
                语法：&lt;hr&gt; 或 &lt;hr/&gt;
                属性：
                    1、size
                        尺寸，以px或%为单位(省略单位的话是px)
                    2、width
                        宽度，以px或%为单位
                    3、align
                        水平对齐方式
                    4、color
                        颜色
            6、行分区元素
                语法：&lt;span&gt;&lt;/span&gt;
                作用：包裹文本并且设置不同的样式
            7、块分区元素
                语法：&lt;div&gt;&lt;/div&gt;
                作用：布局
            8、预格式化
                作用：保留标记内的格式(回车 和 空格)
                语法：&lt;pre&gt;&lt;/pre&gt;
            9、块级元素和行内元素
                1、块级元素
                    每一个块级元素独占一行
                    块级元素的主要作用：布局
                2、行内元素
                    多个元素会在一行内显示，显示不下自动换行
                    span,i,b,s,u,sub,sup
                    作用：设置文本样式
</code></pre><p>  图像和链接</p>
<pre><code>URL 表示地址
    目录    WEB站点中保存文件的文件夹
    目录结构
    URL:Uniform Resource Locator 即统一资源定位器，俗称路径
                                 是描述资源文件位置的信息
        a.html 中想使用 b.html
        a.html 当前文件
        b.html 资源文件
    URL：表达三种方式
            绝对路径：从资源文件所在的最高级目录下开始的完整路径表示
                        获取网络资源文件《只能是绝对路径》
                            由通信协议“http/https”、主机名(域名、IP地址)、目录路径、文件名组成
                        获取本机资源文件
                            从盘符开始到资源文件名结尾
            相对路径：从当前文件位置处开始开始，去查找资源文件所经过的路径
            根相对路径  从WEB站点所在的服务器根目录上开始查找的
                        以/作为开始
图像  语法
      标记：&lt;img&gt;或&lt;img/&gt;
      属性：src(全称：source 源)
            &lt;img src=&quot;ur1&quot;&gt;
            &lt;img src=&quot;a.jpg&quot;&gt;
            &lt;img src=&quot;images/a.jpg&quot;&gt;
            注意：URL严格区分大小写
            width
            height
            注意：如果width 和height只设置其中一个属性的话，那么另外一个将等比缩放
链接 （超链接）
        语法：由&lt;a&gt;内容&lt;/a&gt;
              注意：默认情况下，A是不能被点击的
        属性：href 链接的URL 只有设置href属性后，才允许被点击
              target  目标，打开新网页的方式
                      取值：_self 默认值，在自身标签页中，打开新网页
                            _blank 在新标签页中，打开新网页
        链接表现形式： 资源下载
                        链接地址为**.zip/**.rar
                       电子邮件链接 &lt;a href=&quot;mailto:zhaoxu@tedu.cn&quot;&gt;发送邮件&lt;/a&gt;
                       返回页面顶部的空链接&lt;a href=&quot;#&quot;&gt;返回顶部&lt;/a&gt;
                       链接到Javascript &lt;a href=&quot;javascript:js代码&quot;&gt;&lt;/a&gt;
        锚点：anchor   在html文档的某行位置做一个记号，允许通过超链接跳转到该记号位置
                定义锚点（做记号）
                    通过A标记的name属性 &lt;a name=&quot;名称&quot;&gt;&lt;/a&gt;
                    通过任意标记的ID属性&lt;标记 ID=&quot;标记名称&quot;&gt;&lt;/标记&gt;
                链接到锚点（跳转到锚点）&lt;a href=&quot;#锚点名称&quot;&gt;&lt;/a&gt;
                                        &lt;a href=&quot;页面URL#锚点名称&quot;&gt;&lt;/a&gt;
</code></pre><p>表格:表格的作用</p>
<pre><code>表格，是由一些称为单元格的东西按照从左到右，从上到下的顺序排列而成的
    语法：&lt;table&gt;&lt;/table&gt;  定义表格
          &lt;tr&gt;&lt;/tr&gt;        定义表行
          &lt;td&gt;&lt;/td&gt;           定义单元格
         尽量保证默认情况下，每行中的单元格数量是相同的
    表格属性：width   宽度
          height  高度
          align   对齐方式
          border  边框
          cellpadding  设置单元格内边距
          cellspacing  设置单元格外边距
          bgcolor  背景颜色
    表行属性：align   水平对齐
              valign  取值top/middle/bottom    垂直对齐方法
              bgcolor 背景颜色
          单元格属性：align
              valign
              width
              height
              bgcolor
              colspan    设置单元格跨列
              rowspan    设置单元格跨行
    单元格特点
            某一行单元格的高度，以最高的单元格高度为准
            某一列单元格的宽度，以最宽的单元格宽度为主
table的子元素：表格标题&lt;caption&gt;标题文本&lt;/caption&gt;
                注意：一个表格最多只能有一个标题
                     caption 必须位于&lt;table&gt;下的第一句话
               td允许被 th替换  加粗。居中
表格的复杂应用：行分组 表头行分组 &lt;thead&gt;&lt;/thead&gt; 允许包含一行或多行tr
                       表主体行分组&lt;tbody&gt;&lt;/tbody&gt; 允许包含任意多的连续tr
                       表尾行分组&lt;tfoot&gt;&lt;/tfoot&gt; 允许包含一行或多行tr
                    注意：如果不对table中的数据进行显示分组的话，默认都在tbody中
                不规则表格  通td的 colspan和 rowspan属性来完成
                            colspan 跨列，在一行中，从指定单元格位置处开始，横向向右合并几个单元格
                                    被合并的单元格，要删除
                            rowspan 跨行。在一列中，从指定单元格位置处开始，纵向向下合并几个单元格
                                    被合并的单元格，要删除
                表格的嵌套  允许在单元格中在放入一个表格
                            &lt;table&gt;
                                &lt;tr&gt;
                                    &lt;td&gt;
                                        &lt;table&gt;
                                            &lt;tr&gt;
                                                &lt;td&gt;
                                                &lt;/td&gt;
                                            &lt;/tr&gt;
                                        &lt;/table&gt;
                                    &lt;/td&gt;
                                &lt;/tr&gt;
                            &lt;/table&gt;
</code></pre><p>  列表</p>
<pre><code>列表语法
    组成  列表的类型：有序列表：&lt;ol&gt;&lt;/ol&gt;
                      无序列表：&lt;ul&gt;&lt;/ul&gt;
             列 表项：显示在列表中的内容 &lt;li&gt;&lt;/li&gt;
    属性  有序列表（ol）的属性 type 取值 1   a   A   i   I
                               start  起始编号是多少 具体为数字
          无序列表（ul）的属性 type 取值 disc 实心圆点
                                         circle 空心圆
                                         none 不显示标识
                                         square  方块
列表的嵌套： 允许在一个列表中出现另一个列表被嵌套的列表必须放在&lt;li&gt;中
定义列表：作用，往往用于给出一类事物的定义情形，如名词解释
          语法，&lt;dl&gt;&lt;/dl&gt;  表示定义列表
                    &lt;dt&gt;&lt;/dt&gt; 定义列表中标题
                    &lt;dd&gt;&lt;/dd&gt; 对标题解释说明的内容
        使用场合：图文混排时使用
</code></pre><p>  结构标记</p>
<pre><code>网页结构布局：为了取代做布局的Div，从而体现出布局标记的语义性
    块级元素做布局，Div
    常用结构标记
        header 用来表示页面或某部分内容的顶部信息
               &lt;header&gt;&lt;/header&gt;
         nav   用来表示页面的主导航信息
                &lt;nav&gt;&lt;/nav&gt;
        section  表示页面中的小节，也可以用来表示页面的主体内容
                 &lt;section&gt;&lt;/section&gt;
        article  表示页面中的文章信息或是文字居多的部分，比如博客信息，微博的条目，论坛中的主贴和回帖
                  &lt;article&gt;&lt;/article&gt;
        footer   表示页面中底部信息，一般用户关注度较低
                 &lt;footer&gt;&lt;/footer&gt;
        aside  表示页面中的边档信息
                &lt;aside&gt;&lt;/aside&gt;
</code></pre><p>  表单</p>
<pre><code>表单概述：表单用于显示，收集用户信息，并提交给服务器
 完整表单由两部分组成：实现表单以及可交互的界面元素（前端）
      表单元素：用于定义表单的提交信息如：提交地址，提交方式
      表单控件：能够与用户交互的界面无素如：文本框，密码框
              表单提交后的处理（服务器端）
          表单元素：语法 &lt;form&gt;&lt;/form&gt;
              注意：只有出现在form中的表单控件的数据才会被提交
                    form在页面中没有显示效果，只有功能
          属性：action :指定提交给服务器处理程序的地址，该地址要与服务器端人员商量
                  注意：如果省略不写，默认提交给本页
               method ：指定提交数据的方法（模式）
                   取值：get 获取（默认方式）
                          以明文的方式提交数据到服务器（数据会显示在地址栏上），安全性低
                          最大提交2KB数据
                          向服务器要数据时用get方式
                        post  邮寄
                             以隐式的方式提交数据到服务器不会显示，安全性高
                             无提交数据大小限制
                             让服务器处理数据时使用post
                        put
                        delete
               enctype ：指定表单数据的编码方式（什么样的数据允许提交）
                   取值：application/x-www-form-urlencoded
                         默认值，可以将所有的数据提交给服务器（文件除外）
                        multipart/form-data
                            允许将文件（图像，音频，视频，文档）提交给服务器
                        text/plain
                            允许将普通字符提交给服务器，特殊字符无法提交（=，&amp;，？）
                        name ：定义表单名称
                         id： 定义表达独一的标识
          表单控件：都是与用户进行交互的元素
              语法:input     收集用户信息
                  属性：type  根据不同的type值创建不同的输入控件
                       name  定义控件的名称提供给服务器端使用，采用匈牙利命名法，控件缩写+功能
                       value  定义控件的值，提供给服务器端使用
                       disabled 禁用控件（无法操作，无法提交），该属性无值
                       说明：文本框和密码框
                            文本框：type=“text”
                            密码框：type=“password”
                            属性：maxlength 限制输入的字符数，超出不显示
                                 readonly  只读（只能看，不能改，但允许被提交） 无值属性
                                 name 缩写txt+功能 如 name=“txtpassword”
                            单选按钮和复选框
                                单选按钮 ：type=“‘radio’”   radio缩写rdo
                                复选框 ：type=“checkbox”    checkbox缩写chk
                                 属性：：name 定义控件的名称
                                              为控件分组
                                         value 值
                                         checked 预选中
                             按钮：提交按钮
                                  type=“submit” 必须放入表单中进行
                                  重置按钮
                                   type=“reset”
                                  普通按钮
                                     type=“button”
                                      属性：name  缩写btn
                                           value  按钮上的文字
                                  其它按钮：图片按钮
                                      &lt;input type=&quot;image&quot;&gt;
                                        属性：src
                                            按钮《提交》可以放图
                                       &lt;button&gt;内容&lt;/button&gt;
          隐藏域和文件选择框
               隐藏域：type=“hidden”  想提交给服务器，但不想被用户看见的数据放在隐藏域中
                 属性：name
                      value
               文件选择框：type=“file”
                    注意，要求form的methods属性必须为post
                         form的enctype属性为multipart/form-data
          textarea  多行文本域 允许 录入多行数据
               语法：&lt;textarea&gt;&lt;/textarea&gt;
               属性：name缩写 txt
                     cols  指定文本区域列数
                     rows  指定文本区域行数
                     readonly  只读
          select  选择框下拉框
               语法：&lt;select&gt;&lt;/select&gt;
               属性 name 缩写sel
                    size 默认显示的数量，如果大于1的话，则为滚动列表
                    multiple 设置多选，同时变以滚动列表配合ctrl或shift实现多选
                选项
                     &lt;option&gt;/&lt;option&gt;
                 属性  value 值
                       selected 默认预选中，无值
          其它
               label  关联文本与控件
                     &lt;label&gt;&lt;/label&gt;
                属性  for 表示与该元素关联的控件的ID值
                      控件分组控件
                         &lt;fieldset&gt;&lt;/fieldset&gt;  分组
                         &lt;legend&gt;&lt;/legend&gt;    分组标题
               浮动框架
                   可以在一个浏览器窗口中同时显示多个页面文档的内容，在一个页面中引入另一个页面
                   语法  &lt;iframe&gt;文字&lt;/iframe&gt;
                    属性 src 浮动框架中要引入的页面URL
                          width
                          height
                          frameborder 浮动框架边框 默认有边框，无需边框设置为0
</code></pre><p>新表单元素（HTML5新标记）</p>
<pre><code>统一属性：name缩写txt
    required  非空限制，必须填入内容
电子邮件类型：&lt;input type=&quot;email&quot;&gt; 缩写txt
搜索类型：&lt;input type=&quot;search&quot;&gt;
URL类型：&lt;input type=&quot;url&quot;&gt;  数据必须符合URL规范
电话号码类型：&lt;input type=&quot;tel&quot;&gt;    移动终端：弹出数字键盘
数字类型：&lt;input type=&quot;number&quot;&gt;
    属性：min 控件接受的最小值
        max 控件接受的最大值
        step 控件递增的步长，默认为1
范围类型：允许选择指定范围内的一个值（左右滑块类型）
    &lt;input type=&quot;range&quot;&gt;
    属性：min 指定范围最小值
        max 指定范围最大值
        step 指定值变化步长
        value 设置初始值
颜色类型：颜色拾取控件
        &lt;input type=&quot;color&quot;&gt;
日期类型：允许用户选择日期
        &lt;input type=&quot;date&quot;&gt;
周类型：与date类似，但只能选择周
        &lt;input type=&quot;week&quot;&gt;
月类型：与date类似，但只能选择月份
        &lt;input type=&quot;month&quot;&gt;
</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;1、Web基础知识&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;1、Internet
    1、简介
        Internet 实际上就是由计算机所组成的网络结构
        服务：
            1、Telnet
                远程登录
   
    
    </summary>
    
      <category term="学习笔记" scheme="www.wangchengzou.cn/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="笔记" scheme="www.wangchengzou.cn/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>JQuery基础知识</title>
    <link href="www.wangchengzou.cn/2017/07/22/JQuery/"/>
    <id>www.wangchengzou.cn/2017/07/22/JQuery/</id>
    <published>2017-07-22T15:48:26.000Z</published>
    <updated>2017-07-23T13:47:56.493Z</updated>
    
    <content type="html"><![CDATA[<p>1、 DOM分为三部分：</p>
<pre><code>(1)核心DOM：操作任意标签树
(2)HTML DOM：操作HTML标签树
(3)XML DOM：操作XML标签树
</code></pre><p>2、常用的核心DOM操作</p>
<pre><code>(1)查找元素的方法
    document.getElementById(&apos;p1&apos;)
    document.getElementsByName(&apos;uname&apos;)
    document.getElementsByTagName(&apos;div&apos;)
    document.getElementsByClassName(&apos;btn&apos;)
    document.querySelector(&apos;选择器&apos;)
    document.querySelectorAll(&apos;选择器&apos;)
    遍历DOM节点：
    node.parentNode
    parent.childNodes、parent.children
    node.nextSibling、node.previousSibling
(2)修改元素的属性
    node.setAttribute(&apos;title&apos;,&apos;值&apos;)
    node.getAttribute(&apos;title&apos;)
(3)修改元素的内容
    element.innerHTML
    element.textContent/innerText
(4)修改元素的样式
    element.style.color = &apos;red&apos;;
    element.className = &apos;btn btn-danger&apos;
(5)修改元素的值
    inputElement.value
(6)添加新元素
    var newElement = document.createElement(&apos;div&apos;);
    parent.appendChild(newElement)
(7)删除已有元素
    parent.removeChild(node)
(8)替换旧元素
    parent.replaceChild(oldChild, newChild)
(9)元素克隆
    element.cloneNode()

总结：核心DOM操作的问题
  · 方法名普遍比较长
  · 操作比较僵硬
  · 方法存在浏览器兼容性
</code></pre><p>3、jQuery 概述</p>
<pre><code>jQuery是一个DOM操作的函数库，简化了常用的DOM操作。
理念：Write Less，Do More
jQuery提供了四类函数：
  (1)DOM操作 —— 重点
  (2)事件处理
  (3)动画函数
  (4)AJAX
</code></pre><p>4、 jQuery的版本问题：</p>
<pre><code>(1)jQuery 1.x：比较大、功能偏弱、兼容老IE
(2)jQuery 2.x：比较小、功能强大、不兼容老IE
(3)jQuery 3.x：比较小、功能更强大、不兼容老IE
面试题：jQuery3的新特性有哪些？
HTML中使用jQuery，只需要使用SCRIPT标签引入jquery-*.js即可，会为window添加两个新的成员：
    window.$
    window.jQuery
</code></pre><p>5、jQuery函数的特点</p>
<pre><code>(1) $或者jQuery是一个函数，返回值是一个jQuery类数组对象
(2)即使没有查找到需要的元素，jQuery类数组对象也不会是null/undefined，调用jQuery函数不会报错！
(3)jQuery类数组对象提供的函数都自带for循环遍历每个查找到的元素
(4)jQuery函数底层都是DOM操作，所以可和原生的DOM操作组合使用
(5)原生DOM对象不能调用jQuery提供的函数；jQuery函数返回的类数组对象也不能调用核心DOM成员
(6)原生DOM对象和jQuery对象间如何转换：
  原生DOM对象封装到一个jQuery类数组对象
      $(domObject)
  jQuery类数组中取出封装的DOM对象：
      $(&apos;button&apos;)[index]
(7)jQuery对象方法的返回值一般还是当前选定的类数组对象，可以实现“链式调用”
</code></pre><p>6、jQuery函数第一部分：DOM操作函数 —— 查找元素</p>
<pre><code>$( &apos;选择器&apos; )
jQuery的选择器语法支持所有的CSS选择器语法！并屏蔽了浏览器兼容性；同时还扩展了一些新的选择器语法。
面试题：jQuery中的哪些选择器是CSS中没有的？ —— 执行效率较低
</code></pre><p>7、 第一组：基本选择器   —— 重点</p>
<pre><code>(1)#id
  练习：点击一个button#bt1，让下方的一个p#p1隐藏起来
  提示：jQuery类数组对象提供的.hide()函数可以隐藏一个元素
(2).className
  练习：点击一个button#bt2，让下方所有的span.badge字体变大为2em
  提示：jQuery类数组对象提供的.css(&apos;color&apos;, &apos;red&apos;)函数可以修改当前选定元素的指定样式
(3)标签名
  练习：li元素上发生鼠标进入事件时，当前li显示出下边框
  提示：使用.on(&apos;mouseover&apos;, fn)监听鼠标进入事件
(4)*
  练习：单击button#bt3后，让所有的元素的box-sizing变为border-box，所有元素的margin变为0
(5)div, p, #c3
  练习：页面加载完成后，为所有的button、.btn、role=&quot;button&quot;的元素，添加事件监听，点击后打印出当前系统时间
</code></pre><p>8、第二组：层级选择器       —— 重点</p>
<pre><code>(6) ancestor descendant   后代选择器
  练习：为所有#alert1中的.btn添加事件监听，单击后，隐藏#alert1
(7) parent &gt; child     直接子代选择器
  练习：为所有#alert2中的直接子元素.btn添加事件监听，单击后，隐藏#alert2
(8) prev + next      下一个相邻兄弟选择器
  练习：为UL中的LI添加上边框，实现如下效果：
  $(&apos;li + li&apos;).....
  $(&apos;li:not(:first-child)&apos;)....
(9) prev ~ siblings    后续的所有兄弟选择器
</code></pre><p>9、第三组：基本过滤选择器       —— 重点</p>
<pre><code>注意：基本过滤选择器把所有满足选中的元素放在一个大集合中进行排序，不论是否在同一个父元素中与否。下标从0开始！
(10) :first
  练习：把所有列表中的第一个LI字体加粗显示
(11) :last:
  练习：把所有列表中的最后一个LI字体斜体显示
(12) :eq(index)
  练习：把所有列表中的第index个LI添加有边框
(13) :gt(index)
  练习：把所有列表中的下标大于index的LI添加删除线
(14) :lt(index)
  练习：把所有列表中的下标小于index的LI添加下划线
(15) :odd
  练习：把所有列表中的下标为奇数的LI背景颜色变为淡黄色
(16) :even
  练习：把所有列表中的下标为偶数的LI背景颜色变为淡蓝色
(17) :not(selector)
</code></pre><p>10、第四组：子元素过滤选择器       —— 重点</p>
<pre><code>注意：在每个父元素中进行分组，查找指定的子元素。下标从1开始。
(18) :first-child
  $(&apos;li:first-child&apos;);
  练习：把每个列表中的第一个子LI字体变浅蓝
(19) :last-child
  练习：把每个列表中的第最后一个子LI字体变红色
(20) :nth-child(index)
  练习：把每个列表中的第2个子LI字体添加绿色背景
  $(&apos;li:nth-child(2)&apos;)...
  $(&apos;li:nth-child(odd)&apos;)       $(&apos;li:nth-child(2n+2)&apos;)
  $(&apos;li:nth-child(even)&apos;)    $(&apos;li:nth-child(2n)&apos;)
(21) :only-child
  $(&apos;li:only-child&apos;)
</code></pre><p>11、第五组：属性选择器</p>
<pre><code>(22) [attribute]
  选中所有具备title属性的a元素： $(&apos;a[title]&apos;)...
(23) [attribute=value]
  选中所有具备data-toggle属性且值为dropddown的元素：
  $(&apos;[data-toggle=&quot;dropdown&quot;]&apos;)....
(24) [attribute!=value]
(25) [attribute^=value]
(26) [attribute$=value]
(27) [attribute*=value]    具备指定的属性，且值中包含指定字符
</code></pre><p>12、第六组：可见性选择器</p>
<pre><code>(28) :visible         $(&apos;:visible&apos;)选中所有可见元素
(29) :hidden        $(&apos;:hidden&apos;)选中所有隐藏元素
测试：哪些是:hidden可以选中的？
      · display: none            可以
      · visibility: hidden        不可以
      · opacity: 0            不可以
      · input[type=&quot;hidden&quot;]    可以
</code></pre><p>13、第七组：内容过滤选择器</p>
<pre><code>  (30) :contains(txt)
    练习：选中文本中包含“提交”字的button元素，让它们变为绿色按钮
  (31) :has(selector)
    练习：选中包含.close按钮的.alert元素，让它们变为红色的警告框；
选中不包含.close按钮的.alert元素，让它们变为红色的警告框
  (32) :empty
    练习：选中内容为空的警告框    $(&apos;.alert:empty&apos;).....
  (33) :parent
    练习：选中内容不为空的警告框，即包含子元素或文本内容
    $(&apos;.alert:parent&apos;).....
</code></pre><p>14、第八组：表单元素选择器</p>
<pre><code>: input         :text         :password     :radio
:checkbox     :submit         :image         :reset
:button     :file             :hidden

:enabled     :disabled     :checked         :selected
  &lt;input type=&quot;image&quot; src=&quot;img/1.jpg&quot;&gt;
</code></pre><p>15、 W3C DOM把HTML文档看做树型结构，并提供操作节点方法；–总结</p>
<pre><code>jQuery是一个函数库，用于简化DOM操作，屏蔽了浏览器兼容性问题。函数分为四类：
  (1)DOM操作
  (2)事件处理
  (3)动画
  (4)AJAX
jQueryDOM操作——查找节点
  jQuery(&apos;选择器&apos;)    =》  类数组对象
基本选择器：
    #id、.class、div、*、button,.btn
层级选择器：
    parent  child
    parent &gt; child
    prev + next
    prev ~ siblings
基本过滤选择器：
    :first        :last        :eq(i)    :gt(i)        :lt(i)
    :odd        :even    :not(selector)
子代过滤选择器：
    :first-child    :last-child        :nth-child(i)
    :nth-child(odd)   :nth-child(even)
属性选择器：
    [attr=&quot;value&quot;]
可见性选择器：
    :visible        :hidden
内容选择器：
    :contains(txt)        :has(selector)
    :empty            :parent
表单元素选择器：
    :text        :radio    :submit
    :disabled    :enabled     :checked    :selected
</code></pre><p>16、操作元素的属性</p>
<pre><code>&lt;a  href=&quot;&quot; title=&quot;&quot;  data-toggle=&quot;dropdown&quot;&gt;
核心DOM：
  element.getAttribute(&apos;title&apos;)
  element.setAttribute(&apos;title&apos;, &apos;abc&apos;)
jQuery：
  var value  = $(..).attr(&apos;title&apos;)        //读取属性的值
  $(..).attr(&apos;title&apos;, &apos;abc&apos;)            //设置属性的值
提示：读取和设置元素的data-*扩展属性，可以使用attr()方法，也可以使用data()方法，如： &lt;a data-my-target=&quot;1.jpg&quot;&gt;
  var v = $(...).data(&apos;my-target&apos;)        //读取
  $(...).data(&apos;my-target&apos;, &apos;2.jpg&apos;)        //设置

练习：点击某个小图，下方就显示出对应的大图
  &lt;img src=&quot;img/4.jpg&quot; data-target=&quot;img/Koala.jpg&quot;&gt;
</code></pre><p>17、操作元素的内容</p>
<pre><code>核心DOM：
  var h = element.innerHTML;
  element.innerHTML = h;
  var t = element.innerText/textContent;
  element.innerText/textContext = t;
jQuery：
  $(..).html( )        //读取innerHTML
  $(..).html( &apos;html&apos; )    //设置innerHTML
  $(..).text( )        //读取innerText
  $(..).text( &apos;txt&apos; )        //设置innerText
练习：点击一个Button，上方显示出已点击的次数
练习：&lt;a href=&quot;#&quot;&gt;再次点击即显示下一张图片&lt;/a&gt;
  1再次点击即显示下一张图片
  2&lt;img src=&quot;1.jpg&quot;&gt;
  3再次点击即显示下一张图片
  4&lt;img src=&quot;2.jpg&quot;&gt;
  5再次点击即显示下一张图片
  6 ....
</code></pre><p>18、操作元素的样式</p>
<pre><code>核心DOM：
  var c = element.style.color        //读取行内样式
  element.style.color = &apos;red&apos;        //设置行内样式
  var n = element.className        //读取ClassName
  element.className = n            //设置ClassName
jQuery：
  $(..).css(&apos;color&apos;)        //读取指定样式的值
  $(..).css(&apos;color&apos;, &apos;red&apos;)    //设置行内样式
  $(..).addClass(&apos;alert&apos;)    //添加一个class
  $(..).removeClass(&apos;alert&apos;)    //删除一个class
  $(..).hasClass(&apos;alert&apos;)    //判断选定元素是否具有指定class
练习：实现一个“双态按钮”，点击一次变为深色，再点击变为浅色
  .up {  }            .down {  }
</code></pre><p>19、操作表单元素的值</p>
<pre><code>核心DOM：
    var v = input.value        //读取值
    input.value = &apos;v&apos;        //设置值
jQuery：
    $(...).val( )            //读取值
    $(...).val(&apos;value&apos;)    //设置值
练习：“用户名”和“密码”输入框，点击“提交注册信息”按钮后，读取用户的两个输入，打印出来，在输入框中清除用户的输入

面试题：在操作元素的相关属性时，使用attr()、val()、prop()、data()有何区别？
attr()一般只用于操作元素的HTML字面属性，如src、href、name...
val()操作的是HTML元素对应的JS对象的value属性
prop()操作的是HTML元素对应的JS对象的disabled、readyonly、selected、checked等Boolean类型属性
data()操作的是HTML元素对应的JS对象的扩展数据属性（对象缓存数据），而attr(&apos;data-xx&apos;)读取/修改的HTML元素字面属性
</code></pre><p>20、遍历DOM树上的节点</p>
<pre><code>核心DOM：
  element.parentNode            //寻找父节点
  element.childNodes/children        //获取子节点
  elemnet.nextSibling            //获取下一个兄弟
  element.previousSibling            //获取上一个兄弟
jQuery：
  $(..).parent()            //返回选定元素的父节点
  $(..).children()            //返回所有子节点
  $(..).next()            //返回下一个兄弟
  $(..).prev()            //返回上一个兄弟
  $(..).siblings()            //返回所有的同辈兄弟
练习：实现一个自己的页签组件

  &lt;ul class=&quot;tabs&quot;&gt;
      &lt;li&gt;&lt;a&gt;十元套餐&lt;/a&gt;&lt;/li&gt;
      &lt;li class=&quot;active&quot;&gt;&lt;a&gt;二十元套餐&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a&gt;三十元套餐&lt;/a&gt;&lt;/li&gt;
  &lt;/ul&gt;
</code></pre><p>21、添加新的元素</p>
<pre><code>核心DOM：
  var li = document.createElement(&apos;li&apos;)    //创建子节点
  //修改li的属性....                    //设置其属性
  ul.appendChild( li );                    //添加到父节点
jQuery：
  var li = $(&apos;&lt;li class=&quot;item&quot;&gt;内容&lt;/li&gt;&apos;)    //创建子节点
  //li.click(fn)
  $(&apos;ul&apos;).append( li );                //在父节点最后追加子节点
  $(li).appendTo( &apos;ul&apos; )            //子节点追加到父节点最后
   -------可以简写为------------------------------
  $(&apos;ul&apos;).append( &apos;&lt;li class=&quot;item&quot;&gt;内容&lt;/li&gt;&apos; )
练习：添加和删除小盒子

  function rc(){            //Random Color:  返回一个随机的颜色
      var r = Math.floor(Math.random()*256)
      var g = Math.floor(Math.random()*256)
      var b = Math.floor(Math.random()*256)
      return `rgb(  ,  ,  )`;
  }
</code></pre><p>22、删除已有的元素</p>
<pre><code>核心DOM：
  ul.removeChild( li )            //由父元素删除孩子
jQuery：
  $(&apos;li&apos;).remove()                //删除当前选定元素
</code></pre><p>23、替换已有元素</p>
<pre><code>核心DOM：
  parent.replaceChild(oldChild,  newChild);
jQuery：
  $(&apos;oldChild&apos;).replaceWith( newChild )    //已有节点用新节点替换，返回被删除的旧节点
  $(&apos;newChild&apos;).replaceAll( oldChild )    //新节点替换所有的旧节点，返回新节点
练习：实现英雄选择效果    div#chosen        div#list
</code></pre><p>24克隆节点</p>
<pre><code>核心DOM：
  var copy = element.cloneNode( )
jQuery：
  var copy = $(..).clone()        //返回选定元素的副本
  var copy = $(..).clone(copyListener)   //参数指示是否复制选定元素绑定的监听函数，默认为false，不复制监听函数
练习：改进“英雄选择”应用，要求点击某个小飞机后，下方仍然有该飞机，上方选中区域出现当前飞机的一个副本
</code></pre><p>25、jQuery函数第二部分：事件处理函数</p>
<pre><code>jQuery的历史上先后出现了若干事件处理函数：
(1)bind() / unbind()            已废弃
(2)one(事件名称, fn)    仅对指定事件监听一次
(3)live() / die()                已废弃
(4)delegate() / undelegate()    已废弃
(5)on() / off()
(6)click() / mouseover() / mouseout() / keyup() ...
  $(..).click(fn)  &lt;=&gt;  $(..).on(&apos;click&apos;, fn)

  on()函数的第一种使用方法——直接绑定在事件源上：
      $(&apos;事件源&apos;).on(&apos;事件名称&apos;, fn)    //绑定监听函数
      $(&apos;事件源&apos;).off(&apos;事件名称&apos;)        //取消所有监听函数
  练习：点击“开始抽奖”按钮，命令行中输出“抽奖中”，按钮上的文字也变为“抽奖中”；要求此后此按钮再被点击无任何处理函数了。
  on()的第一种用法有两个限制：
      (1)若选中元素很多，每个都会有一个监听函数
      (2)无法为后添加的元素执行绑定
  on()函数的第二种使用方法——委托给父元素进行事件代理：
      $(&apos;parent&apos;).on(&apos;事件名称&apos;, &apos;子元素选择器&apos;, fn)
</code></pre><p>26、 DOM中为元素绑定监听函数：</p>
<pre><code>btn.onclick = function(){  }
btn.addEventListener(&apos;click&apos;, function(){  })
jQuery中的on()函数底层是addEventListener
</code></pre><p>27、DOM操作——增删改查</p>
<pre><code>(1)查找元素：  $(&apos;选择器&apos;)   jQuery(&apos;选择器&apos;)
(2)操作元素的属性： $(..).attr()
(3)操作元素的内容： $(..).html()  $(..).text()
(4)操作元素的样式： $(..).css()
    $(..).addClass()   $(..)removeClass()
    $(..).hasClass()  $(..).toggleClass(&apos;.btn&apos;)
 (5)操作元素的值：  $(..).val()
 (6)遍历元素：
    $(..).parent()
    $(..).children()-直接子代
    $(..).find()-所有子元素
    $(..).next()        $(..).nextAll()
    $(..).prev()        $(..).prevAll()
    $(..).siblings()
(7)插入节点：  $(..).append()   $(..).prepend()
(8)删除节点：  $(..).remove()   $(..).empty()
(9)替换节点：  $(..).replaceWith()  $(..).replaceAll()
(10)克隆节点： $(..).clone()
</code></pre><p>28、事件处理函数：</p>
<pre><code>(1)$(&apos;.btn&apos;).one(&apos;click&apos;, fn)
(2)$(&apos;.btn&apos;).click(fn) ....
(3)$(&apos;.btn&apos;).on(&apos;click&apos;, fn)        off(..)
  $(&apos;.container&apos;).on(&apos;click&apos;, &apos;.btn&apos;, fn)  off(..)

  让jQuery放弃使用 $ ：
  jQuery.noConflict()
</code></pre><p>29、面试题：window.onload和$(document).ready()的异同？</p>
<pre><code>window.onload是核心DOM的写法：
  window.onload = function(){ ... }
  只能为绑定一次；
  只有全部的网页内容(html/css/js/图片....)加载完成才能触发。

$(document).ready()是jQuery的写法：
  $(document).ready(function(){ ... })
  底层是addEventListener(&apos;DOMContentLoaded&apos;, fn)，可以先后绑定多次；
  只要“DOM内容(只包括html/js)加载完成”即可触发。
</code></pre><p>30、补充：jQuery中的hover()函数</p>
<pre><code>jQuery监听“鼠标进入+鼠标离开”有如下三种方法：
(1) $(..).mouseover(fn)   +  $(..).mouseout(fn)
(2) $(..).mouseenter(fn)   +   $(..).mouseleave(fn)
(3) $(..).hover( fn, fn )
注意：方法3等同于方法2
</code></pre><p>31、补充：jQuery中的trigger()函数</p>
<pre><code>使用JS代码代替用户触发指定的事件，调用之前绑定的监听函数。
$(&apos;.btn&apos;).trigger( &apos;click&apos; )
可以简写为：
$(&apos;.btn&apos;).click( )
</code></pre><p>32、jQuery中的函数第三部分：动画函数 —— 隐藏和显示动画</p>
<pre><code>隐藏和显示函数通过使用定时器修改目标元素的width / height / opcaity三个样式的值来实现动画：
$(..).show()      $(..).show(&apos;slow/normal/fast&apos;)  $(..).show(3000)
$(..).hide()    $(..).hide(&apos;slow/normal/fast&apos;)  $(..).hide(3000)
$(..).toggle()     ...  在隐藏和显示之间切换
</code></pre><p>33、jQuery中的函数第三部分：动画函数 —— 折叠展开/收起动画</p>
<pre><code>折叠展开/收起动画函数通过使用定时器修改目标元素的height一个样式的值来实现动画：
$(..).slideUp( )    $(..).slideUp( &apos;slow/normal/fast&apos; )   $(..).slideUp( 300 )
$(..).slideDown( )  ....
$(..).slideToggle( )   ....

练习：仿写Bootstrap中的响应式导航条在手机中的效果
&lt;div class=&quot;navbar&quot;&gt;
  &lt;div class=&quot;navbar-header&quot;&gt;
      &lt;a class=&quot;navbar-brand&quot;&gt;TARENA&lt;/a&gt;
      &lt;a class=&quot;navbar-toggle&quot;&gt;三&lt;/a&gt;
  &lt;/div&gt;
  &lt;div class=&quot;navbar-collapse&quot;&gt;
      ul&gt;li&gt;a
  &lt;/div&gt;
&lt;/div&gt;
</code></pre><p>34、jQuery中的函数第三部分：动画函数 —— 淡入/淡出动画</p>
<pre><code>淡入/淡出动画函数通过使用定时器修改目标元素的opacity一个样式的值来实现动画：
$(..).fadeIn( )  $(..).fadeIn(&apos;slow/normal/fast&apos;)  $(..).fadeIn(300)
$(..).fadeOut( )
$(..).fadeToggle( )
提示：上述六个动画函数都可以在最后接收一个参数——函数
  $(..).fadeOut( 300,  function(){ //在动画结束时的回调函数 })
练习：点击小星星后，闪动3次，最后消失
</code></pre><p>35、jQuery中的函数第三部分：动画函数 —— animate()</p>
<pre><code>$(..).animate({
  属性1: 值1;
  ...
}, 300, fn)
动画排队：执行完一个动画后，再执行另一个
动画并发：同时执行多个属性的动画效果

animate({})可以对哪些CSS属性执行动画？
(1)width、height、opacity、fontSize....等等有可渐变属性值（数值型）的样式可以执行动画
(2)display、fontFamily、transform、颜色类属性等没有渐变属性值的样式不能执行动画
</code></pre><p>36、Web应用中可用的动画技术：</p>
<pre><code>(1)CSS3 Transition
(2)CSS3 Keyframes
(3)定时器 + 属性修改            jQuery1/2动画函数
(4)requestAnimationFrame       jQuery3
</code></pre><p>37、jQuery类数组对象的操作</p>
<pre><code>  window.$  &lt;=&gt; window.jQuery
$()函数或jQuery()返回值是一个“类数组对象”—— 有点像数组，但不是Array类型的实例，其中封装着查找到的所有DOM元素。该对象称为“jQuery对象”，其类数组相关操作：
  $(..).length        获取类数组中封装的DOM对象的数量
  $(..)[index]        获取类数组中封装的第index个DOM对象
  $(..).get(index)        获取类数组中封装的第index个DOM对象
  $(..).each(fn)        遍历类数组中封装的每一个DOM对象，针对每个DOM元素执行一次指定的回调函数
  $(..).index(domObj)    返回指定的DOM元素在当前类数组中的下标
</code></pre><p>38、补充：页面DOM内容加载完成后执行指定的函数</p>
<pre><code>$(document).ready(fn)
$().ready(fn)
$(fn)
</code></pre><p>39、jQuery中的插件函数</p>
<pre><code> Plugin：插件，在现有的功能基础上添加更多的功能，扩展整体的应用。
jQuery中的插件（即函数）分为两类：
 1.jQuery全局插件函数
   原本要声明的工具函数（如max()/min()）如果声明为全局函数，会造成“全局对象(window)的污染；
   为了避免污染全局对象，可以把这些函数纳入到 jQuery对象的名下——与jQuery没有必然的关系：
   声明方式：    jQuery.max = function(arr){  }
               jQuery.extend({ max: fn,  min: fn})
   调用方式：    jQuery.max([10,38,50])
 2.jQuery对象插件函数
   jQuery对象插件函数就是为所有的jQuery对象（$()函数的返回值）添加的公共函数，用于操作当前选定的DOM元素。
   声明方式：    jQuery.fn.max = function( ){  }
               jQuery.fn.extend({ max: fn,   min: fn})
   调用方式：    $(&apos;li&apos;).max( )

   jQuery(..) 或 $(..) 的返回值是一个类数组对象——“jQuery对象”，所有的jQuery对象的原型： jQuery.fn;
   若想给所有的jQuery对象都添加一个扩展函数，只需要加给jQuery.fn即可

  3.复杂插件的编写：轮播广告
       $(&apos;..&apos;).carousel( );

  4.复杂插件的编写：滚动监听
       $(&apos;..&apos;).scrollspy( );
</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;1、 DOM分为三部分：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;(1)核心DOM：操作任意标签树
(2)HTML DOM：操作HTML标签树
(3)XML DOM：操作XML标签树
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;2、常用的核心DOM操作&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;(1)查找元
    
    </summary>
    
      <category term="学习笔记" scheme="www.wangchengzou.cn/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="javaScript" scheme="www.wangchengzou.cn/tags/javaScript/"/>
    
      <category term="JQuery" scheme="www.wangchengzou.cn/tags/JQuery/"/>
    
  </entry>
  
  <entry>
    <title>CSS选择符有哪些？哪些属性可以继承</title>
    <link href="www.wangchengzou.cn/2017/07/22/CSS%E9%80%89%E6%8B%A9%E7%AC%A6%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F%E5%93%AA%E4%BA%9B%E5%B1%9E%E6%80%A7%E5%8F%AF%E4%BB%A5%E7%BB%A7%E6%89%BF/"/>
    <id>www.wangchengzou.cn/2017/07/22/CSS选择符有哪些？哪些属性可以继承/</id>
    <published>2017-07-22T15:48:26.000Z</published>
    <updated>2017-07-23T07:53:18.490Z</updated>
    
    <content type="html"><![CDATA[<p> 1.id选择器（ # myid）<br> 2.类选择器（.myclassname）<br> 3.标签选择器（div, h1, p）<br> 4.相邻选择器（h1 + p）<br> 5.子选择器（ul &gt; li）<br> 6.后代选择器（li a）<br> 7.通配符选择器（ * ）<br> 8.属性选择器（a[rel = “external”]）<br> 9.伪类选择器（a:hover, li:nth-child）</p>
<ul>
<li>可继承的样式： font-size font-family color, UL LI DL DD DT;</li>
<li>不可继承的样式：border padding margin width height ;</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt; 1.id选择器（ # myid）&lt;br&gt; 2.类选择器（.myclassname）&lt;br&gt; 3.标签选择器（div, h1, p）&lt;br&gt; 4.相邻选择器（h1 + p）&lt;br&gt; 5.子选择器（ul &amp;gt; li）&lt;br&gt; 6.后代选择器（li a）&lt;br&gt; 7.通配符
    
    </summary>
    
      <category term="面试题目" scheme="www.wangchengzou.cn/categories/%E9%9D%A2%E8%AF%95%E9%A2%98%E7%9B%AE/"/>
    
    
      <category term="html" scheme="www.wangchengzou.cn/tags/html/"/>
    
      <category term="css" scheme="www.wangchengzou.cn/tags/css/"/>
    
  </entry>
  
  <entry>
    <title>Javascript如何实现继承</title>
    <link href="www.wangchengzou.cn/2017/07/22/Javascript%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E7%BB%A7%E6%89%BF/"/>
    <id>www.wangchengzou.cn/2017/07/22/Javascript如何实现继承/</id>
    <published>2017-07-22T15:48:26.000Z</published>
    <updated>2017-07-23T08:23:34.884Z</updated>
    
    <content type="html"><![CDATA[<p>1、构造继承<br>2、原型继承<br>3、实例继承<br>4、拷贝继承<br>原型prototype机制或apply和call方法去实现较简单，建议使用构造函数与原型混合方式。<br>function Parent(){  this.name = ‘wang’;   }<br>function Child(){   this.age = 28;    }<br>Child.prototype = new Parent();//继承了Parent，通过原型<br>var demo = new Child();<br>alert(demo.age);<br>alert(demo.name);//得到被继承的属性   }</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;1、构造继承&lt;br&gt;2、原型继承&lt;br&gt;3、实例继承&lt;br&gt;4、拷贝继承&lt;br&gt;原型prototype机制或apply和call方法去实现较简单，建议使用构造函数与原型混合方式。&lt;br&gt;function Parent(){  this.name = ‘wang’;   }&lt;
    
    </summary>
    
      <category term="面试题目" scheme="www.wangchengzou.cn/categories/%E9%9D%A2%E8%AF%95%E9%A2%98%E7%9B%AE/"/>
    
    
      <category term="javaScript" scheme="www.wangchengzou.cn/tags/javaScript/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript原型，原型链，有什么特点</title>
    <link href="www.wangchengzou.cn/2017/07/22/JavaScript%E5%8E%9F%E5%9E%8B%EF%BC%8C%E5%8E%9F%E5%9E%8B%E9%93%BE%EF%BC%8C%E6%9C%89%E4%BB%80%E4%B9%88%E7%89%B9%E7%82%B9/"/>
    <id>www.wangchengzou.cn/2017/07/22/JavaScript原型，原型链，有什么特点/</id>
    <published>2017-07-22T15:48:26.000Z</published>
    <updated>2017-07-23T08:22:28.232Z</updated>
    
    <content type="html"><![CDATA[<p>每个对象都会在其内部初始化一个属性，就是prototype(原型)，当我们访问一个对象的属性时，如果这个对象内部不存在这个属性，那么他就会去prototype里找这个属性，这个prototype又会有自己的prototype，于是就这样一直找下去，也就是我们平时所说的原型链的概念。<br>关系：instance.constructor.prototype = instance.<strong>proto</strong><br>特点：JavaScript对象是通过引用来传递的，我们创建的每个新对象实体中并没有一份属于自己的原型副本。当我们修改原型时，与之相关的对象也会继承这一改变。<br>当我们需要一个属性的时，Javascript引擎会先看当前对象中是否有这个属性， 如果没有的话，  就会查找他的Prototype对象是否有这个属性，如此递推下去，一直检索到 Object 内建对象。<br> function Func(){}<br> Func.prototype.name = “Sean”;<br> Func.prototype.getInfo = function() {return this.name;}<br> var person = new Func();//现在可以参考var person = Object.create(oldObject);<br> console.log(person.getInfo());//它拥有了Func的属性和方法<br> //“Sean”<br> console.log(Func.prototype);<br> // Func { name=”Sean”, getInfo=function()}</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;每个对象都会在其内部初始化一个属性，就是prototype(原型)，当我们访问一个对象的属性时，如果这个对象内部不存在这个属性，那么他就会去prototype里找这个属性，这个prototype又会有自己的prototype，于是就这样一直找下去，也就是我们平时所说的原型链
    
    </summary>
    
      <category term="面试题目" scheme="www.wangchengzou.cn/categories/%E9%9D%A2%E8%AF%95%E9%A2%98%E7%9B%AE/"/>
    
    
      <category term="javaScript" scheme="www.wangchengzou.cn/tags/javaScript/"/>
    
  </entry>
  
  <entry>
    <title>Javascript作用链域?</title>
    <link href="www.wangchengzou.cn/2017/07/22/Javascript%E4%BD%9C%E7%94%A8%E9%93%BE%E5%9F%9F/"/>
    <id>www.wangchengzou.cn/2017/07/22/Javascript作用链域/</id>
    <published>2017-07-22T15:48:26.000Z</published>
    <updated>2017-07-23T08:27:58.046Z</updated>
    
    <content type="html"><![CDATA[<p>全局函数无法查看局部函数的内部细节，但局部函数可以查看其上层的函数细节，直至全局细节。<br>当需要从局部函数查找某一属性或方法时，如果当前作用域没有找到，就会上溯到上层作用域查找，直至全局函数，这种组织形式就是作用域链。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;全局函数无法查看局部函数的内部细节，但局部函数可以查看其上层的函数细节，直至全局细节。&lt;br&gt;当需要从局部函数查找某一属性或方法时，如果当前作用域没有找到，就会上溯到上层作用域查找，直至全局函数，这种组织形式就是作用域链。&lt;/p&gt;

    
    </summary>
    
      <category term="面试题目" scheme="www.wangchengzou.cn/categories/%E9%9D%A2%E8%AF%95%E9%A2%98%E7%9B%AE/"/>
    
    
      <category term="javaScript" scheme="www.wangchengzou.cn/tags/javaScript/"/>
    
  </entry>
  
  <entry>
    <title>JSON 的了解</title>
    <link href="www.wangchengzou.cn/2017/07/22/JSON%20%E7%9A%84%E4%BA%86%E8%A7%A3/"/>
    <id>www.wangchengzou.cn/2017/07/22/JSON 的了解/</id>
    <published>2017-07-22T15:48:26.000Z</published>
    <updated>2017-07-23T08:39:00.433Z</updated>
    
    <content type="html"><![CDATA[<p>JSON(JavaScript Object Notation) 是一种轻量级的数据交换格式。它是基于JavaScript的一个子集。数据格式简单, 易于读写, 占用带宽小如：{“age”:”12”, “name”:”back”}<br>JSON字符串转换为JSON对象:<br>var obj =eval(‘(‘+ str +’)’);<br>var obj = str.parseJSON();<br>var obj = JSON.parse(str);</p>
<p>JSON对象转换为JSON字符串：<br>var last=obj.toJSONString();<br>var last=JSON.stringify(obj);</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;JSON(JavaScript Object Notation) 是一种轻量级的数据交换格式。它是基于JavaScript的一个子集。数据格式简单, 易于读写, 占用带宽小如：{“age”:”12”, “name”:”back”}&lt;br&gt;JSON字符串转换为JSON对象:&lt;
    
    </summary>
    
      <category term="面试题目" scheme="www.wangchengzou.cn/categories/%E9%9D%A2%E8%AF%95%E9%A2%98%E7%9B%AE/"/>
    
    
      <category term="javaScript" scheme="www.wangchengzou.cn/tags/javaScript/"/>
    
  </entry>
  
  <entry>
    <title>Label的作用是什么？是怎么用的</title>
    <link href="www.wangchengzou.cn/2017/07/22/Label%E7%9A%84%E4%BD%9C%E7%94%A8%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F%E6%98%AF%E6%80%8E%E4%B9%88%E7%94%A8%E7%9A%84/"/>
    <id>www.wangchengzou.cn/2017/07/22/Label的作用是什么？是怎么用的/</id>
    <published>2017-07-22T15:48:26.000Z</published>
    <updated>2017-07-23T07:44:14.531Z</updated>
    
    <content type="html"><![CDATA[<p>label标签来定义表单控制间的关系,当用户选择该标签时，浏览器会自动将焦点转到和标签相关的表单控件上。</p>
<label for="Name">Number:</label><input type="“text“name="Name"" id="Name"><br><br><br><label>Date:<input type="text" name="B"></label>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;label标签来定义表单控制间的关系,当用户选择该标签时，浏览器会自动将焦点转到和标签相关的表单控件上。&lt;/p&gt;
&lt;label for=&quot;Name&quot;&gt;Number:&lt;/label&gt;&lt;input type=&quot;“text“name=&quot;Name&quot;&quot; id=&quot;Name&quot;&gt;&lt;br&gt;&lt;
    
    </summary>
    
      <category term="面试题目" scheme="www.wangchengzou.cn/categories/%E9%9D%A2%E8%AF%95%E9%A2%98%E7%9B%AE/"/>
    
    
      <category term="html" scheme="www.wangchengzou.cn/tags/html/"/>
    
      <category term="H5" scheme="www.wangchengzou.cn/tags/H5/"/>
    
  </entry>
  
  <entry>
    <title>谈谈This对象的理解</title>
    <link href="www.wangchengzou.cn/2017/07/22/This%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%90%86%E8%A7%A3/"/>
    <id>www.wangchengzou.cn/2017/07/22/This对象的理解/</id>
    <published>2017-07-22T15:48:26.000Z</published>
    <updated>2017-07-23T08:29:44.417Z</updated>
    
    <content type="html"><![CDATA[<p>this总是指向函数的直接调用者（而非间接调用者）；<br>如果有new关键字，this指向new出来的那个对象；<br>在事件中，this指向触发这个事件的对象，特殊的是，IE中的attachEvent中的this总是指向全局对象Window；</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;this总是指向函数的直接调用者（而非间接调用者）；&lt;br&gt;如果有new关键字，this指向new出来的那个对象；&lt;br&gt;在事件中，this指向触发这个事件的对象，特殊的是，IE中的attachEvent中的this总是指向全局对象Window；&lt;/p&gt;

    
    </summary>
    
      <category term="面试题目" scheme="www.wangchengzou.cn/categories/%E9%9D%A2%E8%AF%95%E9%A2%98%E7%9B%AE/"/>
    
    
      <category term="javaScript" scheme="www.wangchengzou.cn/tags/javaScript/"/>
    
  </entry>
  
</feed>
