<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>~~博客园~~</title>
  <subtitle>千帆渡</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="www.wangchengzou.cn/"/>
  <updated>2017-10-09T15:12:46.747Z</updated>
  <id>www.wangchengzou.cn/</id>
  
  <author>
    <name>汪成邹</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>canvas基础知识和使用方法</title>
    <link href="www.wangchengzou.cn/2017/10/09/canvas/"/>
    <id>www.wangchengzou.cn/2017/10/09/canvas/</id>
    <published>2017-10-09T15:48:26.000Z</published>
    <updated>2017-10-09T15:12:46.747Z</updated>
    
    <content type="html"><![CDATA[<p>canvas 绘图<br>    上下文对象画笔     getContext(‘2d’)<br>    填充矩形          ctx.fillRect(x,y,w,h)<br>    描边矩形          ctx.strokeRect(x,y,w,h)<br>    画笔颜色          ctx.fillstyle=’#fff’<br>    画笔宽度          ctx.lineWidth=20<br>    清除画布          ctx.clearRect(x,y,w,h)<br>    基线文字          ctx.textBaseLine<br>    文字类型          ctx.font=’30px yaHei’<br>    填充字体          ctx.fillText(str,x,y)<br>    字体长度          ctx.measureText(str).width<br>    描边字体          ctx.strokeText(str,x,y)</p>
<pre><code>直线路径          ctx.beginPath()//开始
                 ctx.moveTo()
                 ctx.lineTo()
                 ctx.closePath()//结束
                 ctx.stroke//填充
                 ctx.fill//描边

连接处样式        ctx.lineJoin=&apos;miter&apos;//尖角
连接处样式        ctx.lineJoin=&apos;round&apos;//圆角
连接处样式        ctx.lineJoin=&apos;bevel&apos;//方角

绘圆方法          ctx.arc(x,y,半径,-90*Math.PI/180,180*Math.PI/180)
保存状态          save()
恢复状态          restore()
平移              translate
缩放              slale
旋转              rotate
变换矩阵方法
[                             [
     a c e                         x缩放 x倾斜  x平移
     b d f          ==             y倾斜 y缩放  y平移
     0 0 1                           0    0      1
]                              ]
例子 ctx.transform（2，0，0，2，150，150）

图像加载          ctx.drawImage(img,x,y)
</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;canvas 绘图&lt;br&gt;    上下文对象画笔     getContext(‘2d’)&lt;br&gt;    填充矩形          ctx.fillRect(x,y,w,h)&lt;br&gt;    描边矩形          ctx.strokeRect(x,y,w,h)&lt;br&gt;
    
    </summary>
    
      <category term="学习笔记" scheme="www.wangchengzou.cn/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="canvas" scheme="www.wangchengzou.cn/tags/canvas/"/>
    
      <category term="javascript" scheme="www.wangchengzou.cn/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>前端常见跨域解决方案</title>
    <link href="www.wangchengzou.cn/2017/09/23/%E8%B7%A8%E5%93%89/"/>
    <id>www.wangchengzou.cn/2017/09/23/跨哉/</id>
    <published>2017-09-23T07:48:26.000Z</published>
    <updated>2017-09-23T07:13:47.998Z</updated>
    
    <content type="html"><![CDATA[<p>什么是跨域？</p>
<pre><code>跨域是指一个域下的文档或脚本试图去请求另一个域下的资源，这里跨域是广义的。
</code></pre><p>广义的跨域：</p>
<pre><code>1.) 资源跳转： A链接、重定向、表单提交
2.) 资源嵌入：&lt;link&gt;、&lt;script&gt;、&lt;img&gt;、&lt;frame&gt;等dom标签，
    还有样式中background:url()、@font-face()等文件外链
3.) 脚本请求： js发起的ajax请求、dom和js对象的跨域操作等
其实我们通常所说的跨域是狭义的，是由浏览器同源策略限制的一类请求场景。
</code></pre><p>什么是同源策略？</p>
<pre><code>同源策略/SOP（Same origin policy）是一种约定，由Netscape公司1995年引入浏览器，
它是浏览器最核心也最基本的安全功能，如果缺少了同源策略，浏览器很容易受到XSS、CSFR等攻击。
所谓同源是指”协议+域名+端口”三者相同，即便两个不同的域名指向同一个ip地址，也非同源。
</code></pre><p>同源策略限制以下几种行为：</p>
<pre><code>1.) Cookie、LocalStorage 和 IndexDB 无法读取
2.) DOM 和 Js对象无法获得
3.) AJAX 请求不能发送
</code></pre><p>常见跨域场景</p>
<pre><code>URL                                      说明                    是否允许通信
http://www.domain.com/a.js
http://www.domain.com/b.js         同一域名，不同文件或路径           允许
http://www.domain.com/lab/c.js

http://www.domain.com:8000/a.js
http://www.domain.com/b.js         同一域名，不同端口                不允许
http://www.domain.com/a.js
https://www.domain.com/b.js        同一域名，不同协议                不允许
http://www.domain.com/a.js
http://192.168.4.12/b.js           域名和域名对应相同ip              不允许
http://www.domain.com/a.js
http://x.domain.com/b.js           主域相同，子域不同                不允许
http://domain.com/c.js
http://www.domain1.com/a.js
http://www.domain2.com/b.js        不同域名                         不允许
</code></pre><p>跨域解决方案</p>
<pre><code>1、 通过jsonp跨域
2、 document.domain + iframe跨域
3、 location.hash + iframe
4、 window.name + iframe跨域
5、 postMessage跨域
6、 跨域资源共享（CORS）
7、 nginx代理跨域
8、 nodejs中间件代理跨域
9、 WebSocket协议跨域
</code></pre><p>一、 通过jsonp跨域</p>
<pre><code>通常为了减轻web服务器的负载，我们把js、css，img等静态资源分离到另一台独立域名的服务器上，
在html页面中再通过相应的标签从不同域名下加载静态资源，而被浏览器允许，基于此原理，
我们可以通过动态创建script，再请求一个带参网址实现跨域通信。

1.）原生实现：
&lt;script&gt;
    var script = document.createElement(&apos;script&apos;);
    script.type = &apos;text/javascript&apos;;

    // 传参并指定回调执行函数为onBack
    script.src = &apos;http://www.domain2.com:8080/login?user=admin&amp;callback=onBack&apos;;
    document.head.appendChild(script);

    // 回调执行函数
    function onBack(res) {
        alert(JSON.stringify(res));
    }
&lt;/script&gt;

服务端返回如下（返回时即执行全局函数）：
onBack({&quot;status&quot;: true, &quot;user&quot;: &quot;admin&quot;})

2.）jquery ajax：
$.ajax({
    url: &apos;http://www.domain2.com:8080/login&apos;,
    type: &apos;get&apos;,
    dataType: &apos;jsonp&apos;,  // 请求方式为jsonp
    jsonpCallback: &quot;onBack&quot;,    // 自定义回调函数名
    data: {}
});

3.）vue.js：
this.$http.jsonp(&apos;http://www.domain2.com:8080/login&apos;, {
    params: {},
    jsonp: &apos;onBack&apos;
}).then((res) =&gt; {
    console.log(res);
})

后端node.js代码示例：
var querystring = require(&apos;querystring&apos;);
var http = require(&apos;http&apos;);
var server = http.createServer();

server.on(&apos;request&apos;, function(req, res) {
    var params = qs.parse(req.url.split(&apos;?&apos;)[1]);
    var fn = params.callback;

    // jsonp返回设置
    res.writeHead(200, { &apos;Content-Type&apos;: &apos;text/javascript&apos; });
    res.write(fn + &apos;(&apos; + JSON.stringify(params) + &apos;)&apos;);

    res.end();
});
server.listen(&apos;8080&apos;);
console.log(&apos;Server is running at port 8080...&apos;);

jsonp缺点：只能实现get一种请求。
</code></pre><p>二、 document.domain + iframe跨域</p>
<pre><code>此方案仅限主域相同，子域不同的跨域应用场景。
实现原理：两个页面都通过js强制设置document.domain为基础主域，就实现了同域。

1.）父窗口：(http://www.domain.com/a.html)
&lt;iframe id=&quot;iframe&quot; src=&quot;http://child.domain.com/b.html&quot;&gt;&lt;/iframe&gt;
&lt;script&gt;
    document.domain = &apos;domain.com&apos;;
    var user = &apos;admin&apos;;
&lt;/script&gt;

2.）子窗口：(http://child.domain.com/b.html)
&lt;script&gt;
    document.domain = &apos;domain.com&apos;;
    // 获取父窗口中变量
    alert(&apos;get js data from parent ---&gt; &apos; + window.parent.user);
&lt;/script&gt;
</code></pre><p>三、 location.hash + iframe跨域</p>
<pre><code>实现原理：a欲与b跨域相互通信，通过中间页c来实现。
 三个页面，不同域之间利用iframe的location.hash传值，相同域之间直接js访问来通信。

具体实现：A域：a.html -&gt; B域：b.html -&gt; A域：c.html，
a与b不同域只能通过hash值单向通信，b与c也不同域也只能单向通信，
但c与a同域，所以c可通过parent.parent访问a页面所有对象。

1.）a.html：(http://www.domain1.com/a.html)
&lt;iframe id=&quot;iframe&quot; src=&quot;http://www.domain2.com/b.html&quot; style=&quot;display:none;&quot;&gt;&lt;/iframe&amp;gt
&lt;script&gt;
    var iframe = document.getElementById(&apos;iframe&apos;);

    // 向b.html传hash值
    setTimeout(function() {
        iframe.src = iframe.src + &apos;#user=admin&apos;;
    }, 1000);

    // 开放给同域c.html的回调方法
    function onCallback(res) {
        alert(&apos;data from c.html ---&gt; &apos; + res);
    }
&lt;/script&gt;

2.）b.html：(http://www.domain2.com/b.html)
&lt;iframe id=&quot;iframe&quot; src=&quot;http://www.domain1.com/c.html&quot; style=&quot;display:none;&quot;&gt;&lt;/iframe&gt;
&lt;script&gt;
    var iframe = document.getElementById(&apos;iframe&apos;);

    // 监听a.html传来的hash值，再传给c.html
    window.onhashchange = function () {
        iframe.src = iframe.src + location.hash;
    };
&lt;/script&gt;

3.）c.html：(http://www.domain1.com/c.html)
&lt;script&gt;
    // 监听b.html传来的hash值
    window.onhashchange = function () {
        // 再通过操作同域a.html的js回调，将结果传回
        window.parent.parent.onCallback(&apos;hello: &apos; + location.hash.replace(&apos;#user=&apos;, &apos;&apos;));
    };
&lt;/script&gt;
</code></pre><p>四、 window.name + iframe跨域</p>
<pre><code>window.name属性的独特之处：name值在不同的页面（甚至不同域名）加载后依旧存在，
并且可以支持非常长的 name 值（2MB）。
1.）a.html：(http://www.domain1.com/a.html)
var proxy = function(url, callback) {
    var state = 0;
    var iframe = document.createElement(&apos;iframe&apos;);

    // 加载跨域页面
    iframe.src = url;

    // onload事件会触发2次，第1次加载跨域页，并留存数据于window.name
    iframe.onload = function() {
        if (state === 1) {
            // 第2次onload(同域proxy页)成功后，读取同域window.name中数据
            callback(iframe.contentWindow.name);
            destoryFrame();

        } else if (state === 0) {
            // 第1次onload(跨域页)成功后，切换到同域代理页面
            iframe.contentWindow.location = &apos;http://www.domain1.com/proxy.html&apos;;
            state = 1;
        }
    };

    document.body.appendChild(iframe);

    // 获取数据以后销毁这个iframe，释放内存；这也保证了安全（不被其他域frame js访问）
    function destoryFrame() {
        iframe.contentWindow.document.write(&apos;&apos;);
        iframe.contentWindow.close();
        document.body.removeChild(iframe);
    }
};

// 请求跨域b页面数据
proxy(&apos;http://www.domain2.com/b.html&apos;, function(data){
    alert(data);
});

2.）proxy.html：(http://www.domain1.com/proxy….
中间代理页，与a.html同域，内容为空即可。

3.）b.html：(http://www.domain2.com/b.html)
&lt;script&gt;
    window.name = &apos;This is domain2 data!&apos;;
&lt;/script&gt;

总结：通过iframe的src属性由外域转向本地域，跨域数据即由iframe的window.name
从外域传递到本地域。这个就巧妙地绕过了浏览器的跨域访问限制，但同时它又是安全操作。
</code></pre><p>五、 postMessage跨域</p>
<pre><code>postMessage是HTML5 XMLHttpRequest Level 2中的API，
且是为数不多可以跨域操作的window属性之一，它可用于解决以下方面的问题：
a.） 页面和其打开的新窗口的数据传递
b.） 多窗口之间消息传递
c.） 页面与嵌套的iframe消息传递
d.） 上面三个场景的跨域数据传递

用法：postMessage(data,origin)方法接受两个参数
data： html5规范支持任意基本类型或可复制的对象，但部分浏览器只支持字符串，
    所以传参时最好用JSON.stringify()序列化。
origin： 协议+主机+端口号，也可以设置为”*”，表示可以传递给任意窗口，
    如果要指定和当前窗口同源的话设置为”/”。

1.）a.html：(http://www.domain1.com/a.html)
&lt;iframe id=&quot;iframe&quot; src=&quot;http://www.domain2.com/b.html&quot; style=&quot;display:none;&quot;&gt;&lt;/iframe&gt;
&lt;script&gt;
    var iframe = document.getElementById(&apos;iframe&apos;);
    iframe.onload = function() {
        var data = {
            name: &apos;aym&apos;
        };
        // 向domain2传送跨域数据
        iframe.contentWindow.postMessage(JSON.stringify(data), &apos;http://www.domain2.com&apos;);
    };

    // 接受domain2返回数据
    window.addEventListener(&apos;message&apos;, function(e) {
        alert(&apos;data from domain2 ---&gt; &apos; + e.data);
    }, false);
&lt;/script&gt;

2.）b.html：(http://www.domain2.com/b.html)
&lt;script&gt;
    // 接收domain1的数据
    window.addEventListener(&apos;message&apos;, function(e) {
        alert(&apos;data from domain1 ---&gt; &apos; + e.data);

        var data = JSON.parse(e.data);
        if (data) {
            data.number = 16;

            // 处理后再发回domain1
            window.parent.postMessage(JSON.stringify(data), &apos;http://www.domain1.com&apos;);
        }
    }, false);
&lt;/script&gt;
</code></pre><p>六、 跨域资源共享（CORS）</p>
<pre><code>普通跨域请求：只服务端设置Access-Control-Allow-Origin即可，前端无须设置。
带cookie请求：前后端都需要设置字段，另外需注意：所带cookie为跨域请求接口所在域的cookie，而非当前页。
目前，所有浏览器都支持该功能(IE8+：IE8/9需要使用XDomainRequest对象来支持CORS）)，
CORS也已经成为主流的跨域解决方案。

1、 前端设置：
    1.）原生ajax
    // 前端设置是否带cookie
    xhr.withCredentials = true;
    示例代码：
    var xhr = new XMLHttpRequest(); // IE8/9需用window.XDomainRequest兼容
    // 前端设置是否带cookie
    xhr.withCredentials = true;
    xhr.open(&apos;post&apos;, &apos;http://www.domain2.com:8080/login&apos;, true);
    xhr.setRequestHeader(&apos;Content-Type&apos;, &apos;application/x-www-form-urlencoded&apos;);
    xhr.send(&apos;user=admin&apos;);
    xhr.onreadystatechange = function() {
        if (xhr.readyState == 4 &amp;&amp; xhr.status == 200) {
            alert(xhr.responseText);
        }
    };

    2.）jQuery ajax
    $.ajax({
        ...
       xhrFields: {
           withCredentials: true    // 前端设置是否带cookie
       },
       crossDomain: true,   // 会让请求头中包含跨域的额外信息，但不会含cookie
        ...
    });

    3.）vue框架
    在vue-resource封装的ajax组件中加入以下代码：
    Vue.http.options.credentials = true

2、 服务端设置：

    若后端设置成功，前端浏览器控制台则不会出现跨域报错信息，反之，说明没设成功。
    1.）Java后台：
    /*
    * 导入包：import javax.servlet.http.HttpServletResponse;
    * 接口参数中定义：HttpServletResponse response
    */
    response.setHeader(&quot;Access-Control-Allow-Origin&quot;, &quot;http://www.domain1.com&quot;);
      // 若有端口需写全（协议+域名+端口）
    response.setHeader(&quot;Access-Control-Allow-Credentials&quot;, &quot;true&quot;);

    2.）Nodejs后台示例：
    var http = require(&apos;http&apos;);
    var server = http.createServer();
    var qs = require(&apos;querystring&apos;);
    server.on(&apos;request&apos;, function(req, res) {
        var postData = &apos;&apos;;
        // 数据块接收中
        req.addListener(&apos;data&apos;, function(chunk) {
            postData += chunk;
        });
        // 数据接收完毕
        req.addListener(&apos;end&apos;, function() {
            postData = qs.parse(postData);
            // 跨域后台设置
            res.writeHead(200, {
                &apos;Access-Control-Allow-Credentials&apos;: &apos;true&apos;,
                     // 后端允许发送Cookie
                &apos;Access-Control-Allow-Origin&apos;: &apos;http://www.domain1.com&apos;,
                    // 允许访问的域（协议+域名+端口）
                &apos;Set-Cookie&apos;: &apos;l=a123456;Path=/;Domain=www.domain2.com;HttpOnly&apos;
                   // HttpOnly:脚本无法读取cookie
            });
            res.write(JSON.stringify(postData));
            res.end();
        });
    });
    server.listen(&apos;8080&apos;);
    console.log(&apos;Server is running at port 8080...&apos;);
</code></pre><p>七、 nginx代理跨域</p>
<pre><code>1、 nginx配置解决iconfont跨域
浏览器跨域访问js、css、img等常规静态资源被同源策略许可，
但iconfont字体文件(eot|otf|ttf|woff|svg)
例外，此时可在nginx的静态资源服务器中加入以下配置。
location / {
  add_header Access-Control-Allow-Origin *;
}

2、 nginx反向代理接口跨域
跨域原理： 同源策略是浏览器的安全策略，不是HTTP协议的一部分。
服务器端调用HTTP接口只是使用HTTP协议，不会执行JS脚本，不需要同源策略，
也就不存在跨越问题。

实现思路：通过nginx配置一个代理服务器（域名与domain1相同，端口不同）做跳板机，
反向代理访问domain2接口，并且可以顺便修改cookie中domain信息，方便当前域cookie写入，实现跨域登录。

nginx具体配置：
#proxy服务器
server {
    listen       81;
    server_name  www.domain1.com;
    location / {
        proxy_pass   http://www.domain2.com:8080;
         #反向代理
        proxy_cookie_domain www.domain2.com www.domain1.com;
         #修改cookie里域名
        index  index.html index.htm;
        # 当用webpack-dev-server等中间件代理接口访问nignx时，此时无浏览器参与，
        故没有同源限制，下面的跨域配置可不启用
        add_header Access-Control-Allow-Origin http://www.domain1.com;
         #当前端只跨域不带cookie时，可为*
        add_header Access-Control-Allow-Credentials true;
    }
}

1.)前端代码示例：
var xhr = new XMLHttpRequest();
// 前端开关：浏览器是否读写cookie
xhr.withCredentials = true;
// 访问nginx中的代理服务器
xhr.open(&apos;get&apos;, &apos;http://www.domain1.com:81/?user=admin&apos;, true);
xhr.send();
2.) Nodejs后台示例：
var http = require(&apos;http&apos;);
var server = http.createServer();
var qs = require(&apos;querystring&apos;);
server.on(&apos;request&apos;, function(req, res) {
    var params = qs.parse(req.url.substring(2));
    // 向前台写cookie
    res.writeHead(200, {
        &apos;Set-Cookie&apos;: &apos;l=a123456;Path=/;Domain=www.domain2.com;HttpOnly&apos;   // HttpOnly:脚本无法读取
    });
    res.write(JSON.stringify(params));
    res.end();
});
server.listen(&apos;8080&apos;);
console.log(&apos;Server is running at port 8080...&apos;);
</code></pre><p>八、 Nodejs中间件代理跨域</p>
<pre><code>node中间件实现跨域代理，原理大致与nginx相同，都是通过启一个代理服务器，实现数据的转发。

1、 非vue框架的跨域（2次跨域）
利用node + express + http-proxy-middleware搭建一个proxy服务器。

1.）前端代码示例：
var xhr = new XMLHttpRequest();
// 前端开关：浏览器是否读写cookie
xhr.withCredentials = true;
// 访问http-proxy-middleware代理服务器
xhr.open(&apos;get&apos;, &apos;http://www.domain1.com:3000/login?user=admin&apos;, true);
xhr.send();

2.）中间件服务器：
var express = require(&apos;express&apos;);
var proxy = require(&apos;http-proxy-middleware&apos;);
var app = express();
app.use(&apos;/&apos;, proxy({
    // 代理跨域目标接口
    target: &apos;http://www.domain2.com:8080&apos;,
    changeOrigin: true,
    // 修改响应头信息，实现跨域并允许带cookie
    onProxyRes: function(proxyRes, req, res) {
        res.header(&apos;Access-Control-Allow-Origin&apos;, &apos;http://www.domain1.com&apos;);
        res.header(&apos;Access-Control-Allow-Credentials&apos;, &apos;true&apos;);
    },
    // 修改响应信息中的cookie域名
    cookieDomainRewrite: &apos;www.domain1.com&apos;  // 可以为false，表示不修改
}));
app.listen(3000);
console.log(&apos;Proxy server is listen at port 3000...&apos;);

3.）Nodejs后台同（六：nginx）

2、 vue框架的跨域（1次跨域）
利用node + webpack + webpack-dev-server代理接口跨域。
在开发环境下，由于vue渲染服务和接口代理服务都是webpack-dev-server同一个，
所以页面与代理接口之间不再跨域，无须设置headers跨域信息了。

webpack.config.js部分配置：
module.exports = {
    entry: {},
    module: {},
    ...
    devServer: {
        historyApiFallback: true,
        proxy: [{
            context: &apos;/login&apos;,
            target: &apos;http://www.domain2.com:8080&apos;,  // 代理跨域目标接口
            changeOrigin: true,
            cookieDomainRewrite: &apos;www.domain1.com&apos;  // 可以为false，表示不修改
        }],
        noInfo: true
    }
}
</code></pre><p>九、 WebSocket协议跨域</p>
<pre><code>WebSocket protocol是HTML5一种新的协议。它实现了浏览器与服务器全双工通信，
同时允许跨域通讯，是server push技术的一种很好的实现。
原生WebSocket API使用起来不太方便，我们使用Socket.io，它很好地封装了webSocket接口，
提供了更简单、灵活的接口，也对不支持webSocket的浏览器提供了向下兼容。

1.）前端代码：
&lt;div&gt;user input：&lt;input type=&quot;text&quot;&gt;&lt;/div&gt;
&lt;script src=&quot;./socket.io.js&quot;&gt;&lt;/script&gt;
&lt;script&gt;
var socket = io(&apos;http://www.domain2.com:8080&apos;);
// 连接成功处理
socket.on(&apos;connect&apos;, function() {
    // 监听服务端消息
    socket.on(&apos;message&apos;, function(msg) {
        console.log(&apos;data from server: ---&gt; &apos; + msg);
    });
    // 监听服务端关闭
    socket.on(&apos;disconnect&apos;, function() {
        console.log(&apos;Server socket has closed.&apos;);
    });
});
document.getElementsByTagName(&apos;input&apos;)[0].onblur = function() {
    socket.send(this.value);
};
&lt;/script&gt;

2.）Nodejs socket后台：
var http = require(&apos;http&apos;);
var socket = require(&apos;socket.io&apos;);
// 启http服务
var server = http.createServer(function(req, res) {
    res.writeHead(200, {
        &apos;Content-type&apos;: &apos;text/html&apos;
    });
    res.end();
});
server.listen(&apos;8080&apos;);
console.log(&apos;Server is running at port 8080...&apos;);

// 监听socket连接
socket.listen(server).on(&apos;connection&apos;, function(client) {
    // 接收信息
    client.on(&apos;message&apos;, function(msg) {
        client.send(&apos;hello：&apos; + msg);
        console.log(&apos;data from client: ---&gt; &apos; + msg);
    });
    // 断开处理
    client.on(&apos;disconnect&apos;, function() {
        console.log(&apos;Client socket has closed.&apos;);
    });
});
</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;什么是跨域？&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;跨域是指一个域下的文档或脚本试图去请求另一个域下的资源，这里跨域是广义的。
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;广义的跨域：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;1.) 资源跳转： A链接、重定向、表单提交
2.) 资源嵌入：&amp;lt;lin
    
    </summary>
    
      <category term="学习笔记" scheme="www.wangchengzou.cn/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="跨域解决方案， javaScript" scheme="www.wangchengzou.cn/tags/%E8%B7%A8%E5%9F%9F%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%EF%BC%8C-javaScript/"/>
    
  </entry>
  
  <entry>
    <title>ES6 精简语法</title>
    <link href="www.wangchengzou.cn/2017/09/20/es6%E7%B2%BE%E7%AE%80%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95/"/>
    <id>www.wangchengzou.cn/2017/09/20/es6精简学习方法/</id>
    <published>2017-09-20T12:48:26.000Z</published>
    <updated>2017-09-20T12:52:30.359Z</updated>
    
    <content type="html"><![CDATA[<p>ES6语法精简总结</p>
<p>1、块级作用域，和常量声明</p>
<pre><code>let  const
</code></pre><p> 2、解构赋值</p>
<pre><code>1，基本类型
    [a,b]=[1,2]
    [a,...b]=[1,2,3,4,5]//“...”表示其对应的参数集合数组
2.变量交换
    [a,b]=[b,a]
3，选择性接收数据--采用空格的形式分开
4，在不确定元素时，采用“...”
5，对象解构定义两个对象，属性名相同，定义值为所赋值
</code></pre><p>3、正则扩展</p>
<pre><code>1，修饰符和表达式可以分开写，定义时第一个参数为表达式，第二个参数为修饰符
2，字符串对正则使用的四大方法
    str.search(&apos;表达式&apos;)//匹配结果的起始位置
    srt.replace(&quot;表达式&quot;)//匹配结果替换
    str.match(&quot;表达式&quot;)//匹配结果输出组成数组
    str.split(&quot;表达式&quot;)//匹配结果拆分成数组
3，修饰符
        y修饰符-- 从头部位置开始匹配
        u修饰符---用于处理两字节数据
        r.sticky--判断是否设置了y修饰符
        r.flags---返回正则表达式的所有修饰符
</code></pre><p>4、字符串的扩展</p>
<pre><code>1，对于两个字节的表示数据，用“｛｝”包起来
2，code编码格式api
        str.length
        str.charAt()
        str.charCodeAt()
        str.charPointAt()----处理两字节数据编码
        String.fromCodePoint()---反编码两字节数据
3，针对两字节的遍历方法使用for---of
        for(let code of str){}
4，判断字符串结构
        str.includes(&quot;str&quot;) ---是否包含“str”
        str.statrsWith(&quot;str&quot;)--- 是否以str开头
        str.endsWith(&quot;str)---是否以str结尾
5，字符串复制
        str.repeat(2)---复制两次
6，补全功能
        padStart(2,&quot;0&quot;)---向前补全
        padEnd(2 ,&quot;0&quot;)---向后补全
7，转义字符失效
        String.raw(&quot;表达式&quot;)
</code></pre><p>5、数值扩展</p>
<pre><code>console.log(Number.isFinite(15))//是不是有尽值
console.log(Number.isFinite(NaN))
console.log(Number.isFinite(1/0))
console.log(Number.isNaN(NaN));//判断是不是数
console.log(Number.isInteger(25))//判断是不是整数
console.log(Number.isInteger(25.0))//判断是不是整数
console.log(Number.isInteger(25.2))//判断是不是整数
console.log(Number.isInteger(&apos;21432&apos;))//判断是不是整数
console.log(Number.MAX_SAFE_INTEGER)
console.log(Number.MIN_SAFE_INTEGER)//表示数值的上下限
console.log(Number.isSafeInteger(67))//表示数值在不在这个范围内
console.log(4.1,Math.trunc(4.1))//4
console.log(4.9,Math.trunc(4.9))//4
console.log(Math.sign(-5))//-1
console.log(Math.sign(0))//0
console.log(Math.sign(5))//判断正负还是零 1
console.log(Math.cbrt(-1))//-1
console.log(Math.cbrt(8))//立方根 2
</code></pre><p>6、数组扩展</p>
<pre><code>Array.of(3,4,5)---将参数转换成对应类型
Array.from(obj)---将类数组转换成真正数组

arr.fill(7)        替换，将所有数据替换成7
arr.fill(7,1,3)  将位置1到3位置结束替换成7

for(let index of arr.keys()){}--遍历出键名
for(let value of arr.values()){}--遍历出键值
for(let [index,value] of arr.entries()){}--遍历出所有数据

arr.copyWithin(x,y,z)--将y和z范围内的值替换到x位置上
===》[1,2,3,4,5].copywithin(0,3,4)----[4,2,3,4,5]

arr.find()---匹配值返回
arr,findIndex()---匹配值的下标返回

arr.includes(x)----数组中是否包含x
</code></pre><p>7、函数扩展</p>
<pre><code>1，处理默认参数
    function test(x,y=&quot;text&quot;){}
2，箭头函数使用  （）=&gt;{}
</code></pre><p>8、对象扩展</p>
<pre><code>1，属性使用
      es6={o,k}  =&gt;es5={o:o,k:k}
2，方法使用
      methed={
          hello(){},
          test(){}
      }
3，拷贝方法
      for(let  [key,value] of Object.entries(text)){}
</code></pre><p>9、symbol使用</p>
<pre><code>1，作用
        设置的变量为独一无二，变量名相同，比较也为false
2，如何取symbol值

    for(let [key,value] of Object.entries(obj)){
        console.log(key,value);
    }//不能取到symbols定义的值
    Object.getOwnPropertySymbols(obj).forEach(function(item){
        console.log(obj[item])
    });//只能取到symbols的值
    Reflect.ownKeys(obj).forEach(function (item){
        console.log(item,obj[item])
    })//能同时取到所有值
</code></pre><p>10、set和map的使用</p>
<pre><code>1，数据结构对比，增查改删
    let map=new Map()
    let array=[]

    //添加
    map.set(&apos;t&apos;,1)
    array.push({t:1})
    console.info(map,array)

    //  查
    let map_exist=map.has(&apos;t&apos;)
    let array_exist=array.find(item=&gt;item.t)
    console.info(map_exist,array_exist)

    //改
    map.set(&apos;t&apos;,2)
    array.forEach(item=&gt;item.t?item.t=2:&apos;&apos;)
    console.info(map_exist,array_exist)

    //删除
    map.delete(&apos;t&apos;)
    let index=array.findIndex(item=&gt;item.t)
    array.splice(index,1)

2，SET对数据 的对比
    let set=new Set()
    let  array=[]

    //增
    set.add({t:1})

    //查
    set.has({t:1})

    //改
    set.forEach(item=&gt;item.t?item.t=2:&apos;&apos;)

    //删
    set.forEach(item=&gt;item.t?set.delete(item):&apos;&apos;)

3，map set对Object对比
    let item={t:1}
    let map=new Map()
    let set=new Set()
    let obj={}

    //增
    map.set(&apos;t&apos;,1)
    set.add(item)
    obj[&apos;t&apos;]=1

    //查
    console.info({
        a:map.has(&apos;t&apos;),
        b:set.has(item),
        c:&apos;t&apos; in obj
    })

    //改
    map.set(&apos;t&apos;,2)
    item.t=2
    obj[&apos;t&apos;]=2

    //删
    map.delete(&apos;t&apos;)
    set.delete(item)
    delete obj[&apos;t&apos;]

4，wrekSet wrekMap使用方法一样，但是只针对Object对象
</code></pre><p>12、proxy和reflect的使用（拦截器、代理器）</p>
<pre><code>let monitor=new Proxy(obj, {
    //拦截对象属性的读取
    get (target, key) {}

    //拦对象设置属性
    set (target, key, value) {}

    has(target, key) {}

    deleteProperty(target, key) {}

    //拦截object.keys,objoct.getownpropertysymbols.
    ownKeys() {}
}
</code></pre><p>13、类和对象的使用</p>
<pre><code>1，创建方法
{
    class Parent{
        constructor(name=&apos;wang&apos;){
            this.name=name;
        }
    }
2，继承方法
    class child extends Parent{//子继承父
        constructor(name=&apos;child&apos;){
            super(name);//表示父对象里面的属性和方法
            this.type=&apos;child&apos;
        }
    }

    let parent1=new Parent(&apos;cheng&apos;)
    console.log(parent1)
    console.log(new child())
}
3，静态方法使用，用于子对象专有，其它对像不能使用（static）
{
    class parent{
        constructor(name=&apos;wang&apos;){
            this.name=name;
        }
        static tell(){
            console.log(&apos;tell&apos;)
        }
    }
    parent.tell()
    parent.type=&apos;3454354&apos;
}
</code></pre><p>14、promise异步操作的使用</p>
<pre><code>{
  let ajax=function(){
    console.log(&apos;执行2&apos;);
    return new Promise(function(resolve,reject){
      setTimeout(function () {
        resolve()
      }, 1000);
    })
  };

  ajax().then(function(){
    console.log(&apos;promise&apos;,&apos;timeout2&apos;);
  })
}

{
  let ajax=function(){
    console.log(&apos;执行3&apos;);
    return new Promise(function(resolve,reject){
      setTimeout(function () {
        resolve()
      }, 1000);
    })
  };

  ajax()
    .then(function(){
    return new Promise(function(resolve,reject){
      setTimeout(function () {
        resolve()
      }, 2000);
    });
  })
    .then(function(){
    console.log(&apos;timeout3&apos;);
  })
}

{
  let ajax=function(num){
    console.log(&apos;执行4&apos;);
    return new Promise(function(resolve,reject){
      if(num&gt;5){
        resolve()
      }else{
        throw new Error(&apos;出错了&apos;)
      }
    })
  }

  ajax(6).then(function(){
    console.log(&apos;log&apos;,6);
  }).catch(function(err){
    console.log(&apos;catch&apos;,err);
  });

  ajax(3).then(function(){
    console.log(&apos;log&apos;,3);
  }).catch(function(err){
    console.log(&apos;catch&apos;,err);
  });
}
</code></pre><p>15、iterator的使用（遍历器方法，使用next（）下一步）</p>
<pre><code>{
  let arr=[&apos;hello&apos;,&apos;world&apos;];
  let map=arr[Symbol.iterator]();
  console.log(map.next());
  console.log(map.next());
  console.log(map.next());
}
</code></pre><p>16、generator的使用（异步编辑方法，使用*表示）</p>
<pre><code>{
  // genertaor基本定义
  let tell=function* (){
    yield &apos;a&apos;;
    yield &apos;b&apos;;
    return &apos;c&apos;
  };

  let k=tell();
  console.log(k.next());
  console.log(k.next());
  console.log(k.next());
  console.log(k.next());
}

{
  let obj={};
  obj[Symbol.iterator]=function* (){
    yield 1;
    yield 2;
    yield 3;
  }

  for(let value of obj){
    console.log(&apos;value&apos;,value);
  }
}

{
  let state=function* (){
    while(1){
      yield &apos;A&apos;;
      yield &apos;B&apos;;
      yield &apos;C&apos;;
    }
  }
  let status=state();
  console.log(status.next());
  console.log(status.next());
  console.log(status.next());
  console.log(status.next());
  console.log(status.next());
}
</code></pre><p>17、decorator的使用(修饰器的使用)</p>
<pre><code>{
  let readonly=function(target,name,descriptor){
    descriptor.writable=false;
    return descriptor
  };

  class Test{
    @readonly//修饰器使用方法
    time(){
      return &apos;2017-03-11&apos;
    }
  }
</code></pre><p>18、模块化使用方法</p>
<pre><code> export let A=123;

 export function test(){}

 export class Hello{
   test(){}
 }

export default {
  test,
  Hello
}
</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;ES6语法精简总结&lt;/p&gt;
&lt;p&gt;1、块级作用域，和常量声明&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;let  const
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt; 2、解构赋值&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;1，基本类型
    [a,b]=[1,2]
    [a,...b]=[1,2,
    
    </summary>
    
      <category term="学习笔记" scheme="www.wangchengzou.cn/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="javaScript" scheme="www.wangchengzou.cn/tags/javaScript/"/>
    
      <category term="ES6" scheme="www.wangchengzou.cn/tags/ES6/"/>
    
  </entry>
  
  <entry>
    <title>ES6 语法</title>
    <link href="www.wangchengzou.cn/2017/09/18/es6%E8%AF%AD%E6%B3%95/"/>
    <id>www.wangchengzou.cn/2017/09/18/es6语法/</id>
    <published>2017-09-18T12:48:26.000Z</published>
    <updated>2017-09-18T12:52:21.107Z</updated>
    
    <content type="html"><![CDATA[<p>ES6语法</p>
<p>1、let_const</p>
<pre><code>块级作用域，和常量声明
 function text(){
    for(let i=1;i&lt;3;i++){
        console.log(i)
    }
}
function last(){
    const PI=3.1415926;
    const k={
        a:1
    }
    k.b=3;
    console.log(PI,k)
}

text();
last();
</code></pre><p> 2、解构赋值</p>
<pre><code>//  { ... }这是一个块作用域的方法
{
    let a,b,rest;
    [a,b]=[1,2];
    console.log(a,b);//2 1
}
{
    let a,b,rest;
    [a,b,c=3]=[1,2];
    console.log(a,b,c);//1 2 3
}
{
    let a,b,rest;
    [a,b,...rest]=[1,2,3,4,5,6]
    console.log(a,b,rest)  //1 2 [3 4 5 6]
}
{
    let a,b;
    ({a,b}={a:1,b:2})
    console.log(a,b) //1 2
}
//变量交换
{
    let a=1;
    let b=2;
    [a,b]=[b,a];
    console.log(a,b) //2 1
}
{
    function f(){
        return [1,2]
    }
    let a,b;
    [a,b]=f();
    console.log(a,b) //1 2
}
//选择性接收数据
{
    function f(){
        return [1,2,3,4,5]
    }
    let a,b,c;
    [a,,,b]=f();
    console.log(a,b) //1 4
}
//不确定元素时使用方法
{
    function f(){
        return [1,2,3,4,5]
    }
    let a,b,c;
    [a,...b]=f();
    console.log(a,b) //1 [2 3 4 5]
}

//对象解构
{
    let o={p:42,q:true}
    let {p,q}=o;
    console.log(p,q)  //42 true
}
{
    let {a=10,b=5}={a:3}
    console.log(a,b)  //3 5
}
//json数据格式的处理,嵌套的使用方法
{
    let metaData={
        title:&apos;abc&apos;,
        test:[{
            title:&apos;text&apos;,
            desc:&apos;description&apos;
        }]
    }
    let {title:estitle,test:[{title:cntitle}]}=metaData;
    console.log(estitle,cntitle)  //abc text
}
</code></pre><p>3、正则扩展</p>
<pre><code>{
    // #构造函数#
    let regex = new RegExp(&apos;xyz&apos;, &apos;i&apos;);
    //第一个参数是字符串，第二个是修饰符
    let regex2 = new RegExp(/xyz/i);
    //第一个参数是正则表达式，不接受第二个参数，否则会报错
    console.log(regex.test(&apos;xyz123&apos;), regex2.test(&apos;xyz123&apos;));//true true
    console.log(regex.test(&apos;xyZ123&apos;), regex2.test(&apos;xyZ123&apos;));//true true

    let regex3 = new RegExp(/abc/ig, &apos;i&apos;);//i
    console.log(regex3.flags); //原有正则对象的修饰符是ig，它会被第二个参数i覆盖

}

// 字符串对象的4个使用正则表达式的方法：
    match(),replace(),search(),split()
    这四个方法全部调用RegExp的实例的方法。

{
    let regex = new RegExp(&apos;xyz&apos;, &apos;ig&apos;);
    console.log(regex.test(&apos;xyz0XYZ1xyz2&apos;), regex.exec(&apos;xyz0XYZ1xyz2&apos;));
}   //true [&quot;XYZ&quot;, index: 4, input: &quot;xyz0XYZ1xyz2&quot;]

{
    // y修饰符
    let s = &apos;bbbb_bbb_bb_b&apos;;
    var a1 = /b+/g;
    var a2 = /b+/y;

    console.log(a1.exec(s), a2.exec(s)); // [&quot;bbbb&quot;],[&quot;bbbb&quot;]
    console.log(a1.exec(s), a2.exec(s)); // [&quot;bbb&quot;],null

    console.log(a1.sticky, a2.sticky); //false true 表示是否开启了粘连模式
}

{
    console.log(&apos;u修饰符&apos;,/^\uD83D/.test(&apos;\uD83D\uDC2A&apos;)); // true
    console.log(&apos;u修饰符&apos;,/^\uD83D/u.test(&apos;\uD83D\uDC2A&apos;)); // false
    // 大括号表示Unicode字符，只有加上u才能识别
    console.log(/\u{61}/.test(&apos;a&apos;)); // false
    console.log(/\u{61}/u.test(&apos;a&apos;)); // true
    console.log(/\u{20BB7}/u.test(&apos;𠮷&apos;)); // true
    // 点（.）字符不能识别码点大于0xFFFF的Unicode字符，必须加上u修饰符。
    let s = &apos;𠮷&apos;;
    console.log(&apos;大于0xFFFF的Unicode字符&apos;,/^.$/.test(s)); // false
    console.log(&apos;使用u字符&apos;,/^.$/u.test(s)); // true

    // 使用u修饰符后，所有量词都会正确识别大于码点大于0xFFFF的Unicode字符。
    console.log(&apos;量词&apos;,/a{2}/.test(&apos;aa&apos;)); // true
    console.log(&apos;量词&apos;,/a{2}/u.test(&apos;aa&apos;)); // true
    console.log(&apos;量词&apos;,/𠮷{2}/.test(&apos;𠮷𠮷&apos;)); // false
    console.log(&apos;量词&apos;,/𠮷{2}/u.test(&apos;𠮷𠮷&apos;)); // true
}

{
    // #正则表达式中，点（.）是一个特殊字符，代表任意的单个字符，
    但是行终止符（line terminator character）除外
    // U+000A 换行符（\n）
    // U+000D 回车符（\r）
    // U+2028 行分隔符（line separator）
    // U+2029 段分隔符（paragraph separator）
    // 只是一个提案目前还不支持
    // let reg=/test.go/s;
    // console.log(reg.test(&apos;test\ngo&apos;));
    // console.log(reg.test(&apos;test\ngo&apos;));
    console.log(&apos;s变通方法&apos;,/foo.bar/.test(&apos;foo\nbar&apos;));//false
    console.log(&apos;s变通方法&apos;,/foo[^]bar/.test(&apos;foo\nbar&apos;));//true
}
</code></pre><p>4、字符串的扩展</p>
<pre><code>{
  console.log(&apos;a&apos;,`\u0061`);//a
  console.log(&apos;s&apos;,`\u20BB7`);//超出范围--乱码
  console.log(&apos;s&apos;,`\u{20BB7}`);//吉
}

{
  let s=&apos;𠮷&apos;;
  console.log(&apos;length&apos;,s.length);//2
  console.log(&apos;0&apos;,s.charAt(0));//乱码
  console.log(&apos;1&apos;,s.charAt(1));//乱码
  console.log(&apos;at0&apos;,s.charCodeAt(0));//55367
  console.log(&apos;at1&apos;,s.charCodeAt(1));//57271

  let s1=&apos;𠮷a&apos;;
  console.log(&apos;length&apos;,s1.length);//3
  console.log(&apos;code0&apos;,s1.codePointAt(0));//134071
  console.log(&apos;code0&apos;,s1.codePointAt(0).toString(16));//20bb7
  console.log(&apos;code1&apos;,s1.codePointAt(1));//57271
  console.log(&apos;code2&apos;,s1.codePointAt(2));//97
}

{
  console.log(String.fromCharCode(&quot;0x20bb7&quot;));//乱码
  console.log(String.fromCodePoint(&quot;0x20bb7&quot;));//吉
}

{
  let str=&apos;\u{20bb7}abc&apos;;
  for(let i=0;i&lt;str.length;i++){
    console.log(&apos;es5&apos;,str[i]);//乱码abc
  }
  for(let code of str){
    console.log(&apos;es6&apos;,code);// 吉abc
  }
}

{
  let str=&quot;string&quot;;
  console.log(&apos;includes&apos;,str.includes(&quot;c&quot;));//包含在里面 false
  console.log(&apos;start&apos;,str.startsWith(&apos;str&apos;));//以它开头 true
  console.log(&apos;end&apos;,str.endsWith(&apos;ng&apos;));//以它结尾 true
}

{
  let str=&quot;abc&quot;;
  console.log(str.repeat(2));// 字符复制 abcabc
}

{
  let name=&quot;list&quot;;
  let info=&quot;hello world&quot;;
  let m=`i am ${name},${info}`;
  console.log(m);//i am list ,hello world
}

{
  console.log(&apos;1&apos;.padStart(2,&apos;0&apos;));//向前补全 01
  console.log(&apos;1&apos;.padEnd(2,&apos;0&apos;));//向后补全 10
}

{
  let user={
    name:&apos;list&apos;,
    info:&apos;hello world&apos;
  };
  console.log(abc`i am ${user.name},${user.info}`);//[&quot;list&quot; &quot;hello world&quot;]
  function abc(s,v1,v2){
    console.log(s,v1,v2);
    return s+v1+v2
  }
}//i am ,,,listhello world

{
  console.log(String.raw`Hi\n${1+2}`);//转义字符失效 Hi\n3
  console.log(`Hi\n${1+2}`); //hi  3
}
</code></pre><p>5、数值扩展</p>
<pre><code>{
    console.log(0b0101010111010)//二进制表示
    console.log(0o2746)//八进制表示
}
{
    console.log(Number.isFinite(15))//是不是有尽值
    console.log(Number.isFinite(NaN))
    console.log(Number.isFinite(1/0))
}
{
    console.log(Number.isNaN(NaN));//判断是不是数
}
{
    console.log(Number.isInteger(25))//判断是不是整数
    console.log(Number.isInteger(25.0))//判断是不是整数
    console.log(Number.isInteger(25.2))//判断是不是整数
    console.log(Number.isInteger(&apos;21432&apos;))//判断是不是整数
}
{
    console.log(Number.MAX_SAFE_INTEGER)
    console.log(Number.MIN_SAFE_INTEGER)//表示数值的上下限
    console.log(Number.isSafeInteger(67))//表示数值在不在这个范围内
}
{
    console.log(4.1,Math.trunc(4.1))//4
    console.log(4.9,Math.trunc(4.9))//4
}
{
    console.log(Math.sign(-5))//-1
    console.log(Math.sign(0))//0
    console.log(Math.sign(5))//判断正负还是零 1
}
{
    console.log(Math.cbrt(-1))//-1
    console.log(Math.cbrt(8))//立方根 2
}
</code></pre><p>6、数组扩展</p>
<pre><code>{
  let arr = Array.of(3,4,7,9,11);
  console.log(&apos;arr=&apos;,arr);//[3,4,7,9,11]参数转换成对应类型，无参为空类型

  let empty=Array.of();
  console.log(&apos;empty&apos;,empty);
}

{
  let p=document.querySelectorAll(&apos;p&apos;);
  let pArr=Array.from(p);
  pArr.forEach(function(item){
    console.log(item.textContent);
  });

  console.log(Array.from([1,3,5],function(item){return item*2}));
  //[2,6,10]
}

{
  console.log(&apos;fill-7&apos;,[1,&apos;a&apos;,undefined].fill(7));[7,7,7]
  console.log(&apos;fill,pos&apos;,[&apos;a&apos;,&apos;b&apos;,&apos;c&apos;].fill(7,1,3));[a,7,7]替换,从第1位置到3位置结束
}

{
  for(let index of [&apos;1&apos;,&apos;c&apos;,&apos;ks&apos;].keys()){
    console.log(&apos;keys&apos;,index);
  }
  for(let value of [&apos;1&apos;,&apos;c&apos;,&apos;ks&apos;].values()){
    console.log(&apos;values&apos;,value);
  }
  for(let [index,value] of [&apos;1&apos;,&apos;c&apos;,&apos;ks&apos;].entries()){
    console.log(&apos;values&apos;,index,value);
  }
}

{
  console.log([1,2,3,4,5].copyWithin(0,3,4));
  //取3，4范围内的值是‘4’替换到0的位置 [4,2,3,4,5]
}

{
    //找到第一个匹配值并返回
  console.log([1,2,3,4,5,6].find(function(item){return item&gt;3}));
  //找到第一个匹配值并返回该值的下标
  console.log([1,2,3,4,5,6].findIndex(function(item){return item&gt;3}));
}

{
  console.log(&apos;number&apos;,[1,2,NaN].includes(1));//数组中是否包含1
  console.log(&apos;number&apos;,[1,2,NaN].includes(NaN));
}
</code></pre><p>7、函数扩展</p>
<pre><code>{
    function test(x,y=&apos;world&apos;){
        console.log(x,y)
    }
    test(&apos;hello&apos;)//hello world
    test(&apos;hello&apos;,&apos;wang&apos;)//hello wang
}//处理参数默认值

{
    let x=&apos;test&apos;;
    function test1(x,y=x){
        console.log(x,y)
    }
    test1(&apos;kill&apos;) kill kill
    test1(x)//test test
    test1() undefined undefined
}
{
    function test2(...arg){
        for(let v of arg){
            console.log(&apos;rest&apos;,v)
        }
    }
    test2(1,2,3,4,5,6)
}
{
    console.log(...[1,2,3,5])//1 2 3 5
    console.log(&apos;a&apos;,...[1,2,3,5])//a 1 2 3 5
}//数组离散
{
    let arrow=v=&gt;v+2;
    console.log(arrow(3))//5
    let arrow1=()=&gt;5;
    console.log(arrow1())//5
}
{
    function tail(x){
        console.log(x)
    }
    function fx(x) {
        return tail(x)
    }
    fx(123)//123
}//尾调用
</code></pre><p>8、对象扩展</p>
<pre><code> {
  let o=1;
  let k=2;
  let es5={
      o:o,
      k:k
  };
  let es6={
      o,k
  }
  console.log(es5,es6)

  let es5_method={
      hello:function(){
          console.log(&apos;hello&apos;)
      }
  };
  let es6_method={
      hello(){
          console.log(&apos;hello&apos;)
      }
  }
  console.log(es5_method.hello(),es6_method.hello())
  }
  {
      //属性表达式
      let a=&apos;b&apos;;
      let es5_obj={
          a:&apos;c&apos;
      }
      let es6_obj={
          [a]:&apos;c&apos;
      }
      console.log(es5_obj,es6_obj)
}
  {
      //新的API 是不是同一类型
      console.log(Object.is(&apos;abc&apos;,&apos;abc&apos;),&apos;abc&apos;===&apos;abc&apos;)
      console.log(Object.is([],[]),[]===[])

      //拷北
      console.log(Object.assign({a:&apos;a&apos;},{b:&apos;b&apos;}))
      let test={k:123,o:456}
      for(let [key,value] of Object .entries(test)){
          console.log([key,value])
      }
  }
</code></pre><p>9、symbol使用</p>
<pre><code>{
    let a1=Symbol();
    let a2=Symbol();
    console.log(a1===a2);

    let a3=Symbol.for(&apos;a3&apos;)
    let a4=Symbol.for(&apos;a3&apos;)
    console.log(a3===a4)
}
{
    let a1=Symbol.for(&apos;abc&apos;);
    let obj={
        [a1]:&apos;123&apos;,
        &apos;abc&apos;:345,
        &apos;c&apos;:678
    }
    console.log(obj);

    for(let [key,value] of Object.entries(obj)){
        console.log(key,value);
    }//不能取到symbols定义的值
    Object.getOwnPropertySymbols(obj).forEach(function(item){
        console.log(obj[item])
    });//能取到symbols的值
    Reflect.ownKeys(obj).forEach(function (item){
        console.log(item,obj[item])
    })//能同时取到所有值
}
</code></pre><p>10、set和map的使用</p>
<pre><code>{
    //数据结构对比，增查改删
    let map=new Map()
    let array=[]
    //添加
    map.set(&apos;t&apos;,1)
    array.push({t:1})
    console.info(map,array)
    //  查
    let map_exist=map.has(&apos;t&apos;)
    let array_exist=array.find(item=&gt;item.t)
    console.info(map_exist,array_exist)
    //改
    map.set(&apos;t&apos;,2)
    array.forEach(item=&gt;item.t?item.t=2:&apos;&apos;)
    console.info(map_exist,array_exist)
    //删除
    map.delete(&apos;t&apos;)
    let index=array.findIndex(item=&gt;item.t)
    array.splice(index,1)
}

{
     //SET对数据 的对比
    let set=new Set()
    let  array=[]
    //增
    set.add({t:1})
    //查
    set.has({t:1})
    //改
    set.forEach(item=&gt;item.t?item.t=2:&apos;&apos;)
    //删
    set.forEach(item=&gt;item.t?set.delete(item):&apos;&apos;)
}
{
    //map set对Object对比
    let item={t:1}
    let map=new Map()
    let set=new Set()
    let obj={}
    //增
    map.set(&apos;t&apos;,1)
    set.add(item)
    obj[&apos;t&apos;]=1
    //查
    console.info({
        a:map.has(&apos;t&apos;),
        b:set.has(item),
        c:&apos;t&apos; in obj
    })
    //改
    map.set(&apos;t&apos;,2)
    item.t=2
    obj[&apos;t&apos;]=2
    //删
    map.delete(&apos;t&apos;)
    set.delete(item)
    delete obj[&apos;t&apos;]
}
</code></pre><p>11、数据结构使用</p>
<pre><code>{
    let list=new Set();
    list.add(5);//添加
    list.add(7);
    console.log(list .size)//个数。
}
{
    let arr=[1,2,3,4,5]
    let list=new Set(arr)
    console.log(list .size)
}
{
    let list=new Set()
    list.add(1)
    list.add(2)
    list.add(1)
    console.log(list.size)

    let arr=[1,2,3,4,5,6,3,4,34,5,]
    let list1=new Set(arr);
    console.log(list1)
}//此方法可以去重
{
    let arr=[&apos;add&apos;,&apos;delete&apos;,&apos;clear&apos;,&apos;has&apos;]//使用方法
    let list=new Set(arr);
    console.log(list.has(&apos;add&apos;))//是否存在
    console.log(list.delete(&apos;add&apos;))//删除一个
    console.log(list.clear())//清空
    console.log(list.add(&apos;add&apos;))//添加 一个
}
{
    let arr=[&apos;add&apos;,&apos;delete&apos;,&apos;clear&apos;,&apos;has&apos;]
    let list=new Set(arr)
    for(let [key,value] of list.entries()){
        console.log(key,value)
    }
}
{
    let weaklist=new WeakSet();
    let arg={}
    weaklist.add(arg)
    console.log(weaklist)
}//只支持对象数据
{
    let map=new Map()
    let arr=[&apos;123&apos;]
    map.set(arr,&apos;455&apos;)
    console.log(map,map.get(arr))
}
{
    let map=new Map([[&apos;a&apos;,&apos;123&apos;],[&apos;b&apos;,&apos;456&apos;]])
    console.log(map,map.size)
    console.log(map,map.delete(&apos;a&apos;))
    console.log(map,map.clear())
}
{
    let weakmap=new WeakMap()
    let o={}
    weakmap.set(o,123)
    console.log(weakmap.get(o))
}
</code></pre><p>12、proxy和reflect的使用</p>
<pre><code>{
    let obj={
        time:&apos;2017-09-11&apos;,
        name:&apos;wang&apos;,
        _r:123
    }
    let monitor=new Proxy(obj, {
        //拦截对象属性的读取
        get (target, key) {
            return target[key].replace(&apos;2017&apos;, &apos;2018&apos;)
        },
        //拦对象设置属性
        set (target, key, value) {
            if (key === &apos;name&apos;) {
                return target[key] = value;
            } else {
                return target[key]
            }

        },
        has(target, key) {
            if (key === &apos;name&apos;) {
                return target[key]
            } else {
                return false;
            }
        },
        deleteProperty(target, key) {
            if (key.indexOf(&apos;_&apos;) &gt; -1) {
                delete target[key]
            } else {
                return target[key]
            }
        },
        //拦截object.keys,objoct.getownpropertysymbols.
        ownKeys() {
        }

    })
    console.log(monitor.time)
    monitor.time=&apos;2019&apos;;
    monitor.name=&apos;cheng&apos;
    console.log(monitor,monitor.name)
}
{
    let obj={
        time:&apos;2017-09-11&apos;,
        name:&apos;wang&apos;,
        _r:123
    }
    console.log(Reflect.get(obj,&apos;time&apos;))
    Reflect.set(obj,&apos;name&apos;,&apos;cheng&apos;)
    Reflect.has(obj,&apos;name&apos;)
}

//数据验证
{
    function validator(target,validator){
        return new Proxy(target,{
            _validator:validator,
            set(target,key ,value,proxy){
                if(target.hasOwnProperty(key)){
                    let va=this._validator[key];
                    if(!!va(value)){
                        return Reflect.set(target,key,value,proxy)
                    }else{
                        throw Error(`不能设置 ${key}到${value}`)
                    }
                }else{
                    throw Error(`${key}不存在`)
                }
            }
        })
    }
    const personValidators={
        name(val){
            return typeof val===&apos;string&apos;
        },
        age(val){
            return typeof val===&apos;number&apos;&amp;&amp;val&gt;18
        }
    }
    class Person{
        constructor(name,age){
            this.name=name;
            this.age=age;
            return validator(this,personValidators)
        }
    }
    const person=new Person(&apos;wang&apos;,12)
    console.log(person)
    person.name=13;
    console.log(person)
}
</code></pre><p>13、类和对象的使用</p>
<pre><code>{
    class Parent{
        constructor(name=&apos;wang&apos;){
            this.name=name;
        }
    }

    class child extends Parent{
        constructor(name=&apos;child&apos;){
            super(name);
            this.type=&apos;child&apos;
        }
    }

    let parent1=new Parent(&apos;cheng&apos;)
    console.log(parent1)
    console.log(new child())
}
{
    class Parent{
        constructor(name=&apos;wang&apos;){
            this.name=name;
        }
        get longname(){
            return &apos;mk&apos;+this.name;
        }
        set longname(value){
            this.name=value;
        }
    }

    let parent1=new Parent()
    console.log(parent1.longname)
    parent1.longname=&apos;tsHell&apos;
    console.log(parent1.longname)

}
{
    class parent{
        constructor(name=&apos;wang&apos;){
            this.name=name;
        }
        static tell(){
            console.log(&apos;tell&apos;)
        }
    }
    parent.tell()
    parent.type=&apos;3454354&apos;
}
</code></pre><p>14、promise异步操作的使用</p>
<pre><code>{
  // 基本定义
  let ajax=function(callback){
    console.log(&apos;执行&apos;);
    setTimeout(function () {
      callback&amp;&amp;callback.call()
    }, 1000);
  };
  ajax(function(){
    console.log(&apos;timeout1&apos;);
  })
}

{
  let ajax=function(){
    console.log(&apos;执行2&apos;);
    return new Promise(function(resolve,reject){
      setTimeout(function () {
        resolve()
      }, 1000);
    })
  };

  ajax().then(function(){
    console.log(&apos;promise&apos;,&apos;timeout2&apos;);
  })
}

{
  let ajax=function(){
    console.log(&apos;执行3&apos;);
    return new Promise(function(resolve,reject){
      setTimeout(function () {
        resolve()
      }, 1000);
    })
  };

  ajax()
    .then(function(){
    return new Promise(function(resolve,reject){
      setTimeout(function () {
        resolve()
      }, 2000);
    });
  })
    .then(function(){
    console.log(&apos;timeout3&apos;);
  })
}

{
  let ajax=function(num){
    console.log(&apos;执行4&apos;);
    return new Promise(function(resolve,reject){
      if(num&gt;5){
        resolve()
      }else{
        throw new Error(&apos;出错了&apos;)
      }
    })
  }

  ajax(6).then(function(){
    console.log(&apos;log&apos;,6);
  }).catch(function(err){
    console.log(&apos;catch&apos;,err);
  });

  ajax(3).then(function(){
    console.log(&apos;log&apos;,3);
  }).catch(function(err){
    console.log(&apos;catch&apos;,err);
  });
}
</code></pre><p>15、iterator的使用</p>
<pre><code>{
  let arr=[&apos;hello&apos;,&apos;world&apos;];
  let map=arr[Symbol.iterator]();
  console.log(map.next());
  console.log(map.next());
  console.log(map.next());
}

{
  let obj={
    start:[1,3,2],
    end:[7,9,8],
    [Symbol.iterator](){
      let self=this;
      let index=0;
      let arr=self.start.concat(self.end);
      let len=arr.length;
      return {
        next(){
          if(index&lt;len){
            return {
              value:arr[index++],
              done:false
            }
          }else{
            return {
              value:arr[index++],
              done:true
            }
          }
        }
      }
    }
  }
  for(let key of obj){
    console.log(key);
  }
}

{
  let arr=[&apos;hello&apos;,&apos;world&apos;];
  for(let value of arr){
    console.log(&apos;value&apos;,value);
  }
}
</code></pre><p>16、generator的使用</p>
<pre><code>{
  // genertaor基本定义
  let tell=function* (){
    yield &apos;a&apos;;
    yield &apos;b&apos;;
    return &apos;c&apos;
  };

  let k=tell();

  console.log(k.next());
  console.log(k.next());
  console.log(k.next());
  console.log(k.next());
}

{
  let obj={};
  obj[Symbol.iterator]=function* (){
    yield 1;
    yield 2;
    yield 3;
  }

  for(let value of obj){
    console.log(&apos;value&apos;,value);
  }
}

{
  let state=function* (){
    while(1){
      yield &apos;A&apos;;
      yield &apos;B&apos;;
      yield &apos;C&apos;;
    }
  }
  let status=state();
  console.log(status.next());
  console.log(status.next());
  console.log(status.next());
  console.log(status.next());
  console.log(status.next());
}

// {
//   let state=async function (){
//     while(1){
//       await &apos;A&apos;;
//       await &apos;B&apos;;
//       await &apos;C&apos;;
//     }
//   }
//   let status=state();
//   console.log(status.next());
//   console.log(status.next());
//   console.log(status.next());
//   console.log(status.next());
//   console.log(status.next());
// }
</code></pre><p>17、decorator的使用</p>
<pre><code>{
  let readonly=function(target,name,descriptor){
    descriptor.writable=false;
    return descriptor
  };

  class Test{
    @readonly
    time(){
      return &apos;2017-03-11&apos;
    }
  }

  let test=new Test();

  // test.time=function(){
  //   console.log(&apos;reset time&apos;);
  // };

  console.log(test.time());
}


{
  let typename=function(target,name,descriptor){
    target.myname=&apos;hello&apos;;
  }

  @typename
  class Test{

  }

  console.log(&apos;类修饰符&apos;,Test.myname);
  // 第三方库修饰器的js库：core-decorators; npm install core-decorators
}
</code></pre><p>18、模块化使用方法</p>
<pre><code>// export let A=123;
//
// export function test(){
//   console.log(&apos;test&apos;);
// }
//
// export class Hello{
//   test(){
//     console.log(&apos;class&apos;);
//   }
// }

let A=123;
let test=function(){
  console.log(&apos;test&apos;);
}
class Hello{
  test(){
    console.log(&apos;class&apos;);
  }
}

export default {
  A,
  test,
  Hello
}
</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;ES6语法&lt;/p&gt;
&lt;p&gt;1、let_const&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;块级作用域，和常量声明
 function text(){
    for(let i=1;i&amp;lt;3;i++){
        console.log(i)
    }
}
functio
    
    </summary>
    
      <category term="学习笔记" scheme="www.wangchengzou.cn/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="javaScript" scheme="www.wangchengzou.cn/tags/javaScript/"/>
    
      <category term="ES6" scheme="www.wangchengzou.cn/tags/ES6/"/>
    
  </entry>
  
  <entry>
    <title>mock数据模拟</title>
    <link href="www.wangchengzou.cn/2017/08/04/mock%E6%95%B0%E6%8D%AE%E6%A8%A1%E6%8B%9F/"/>
    <id>www.wangchengzou.cn/2017/08/04/mock数据模拟/</id>
    <published>2017-08-04T02:53:05.000Z</published>
    <updated>2017-08-04T03:00:58.315Z</updated>
    
    <content type="html"><![CDATA[<p>实例</p>
<pre><code>&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;title&gt;Document&lt;/title&gt;
&lt;script src=&quot;http://cdn.bootcss.com/jquery/3.1.1/jquery.min.js&quot;&gt;&lt;/script&gt;
&lt;script src=&quot;http://mockjs.com/dist/mock.js&quot;&gt;&lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;

&lt;div&gt;
    &lt;h1 id=&quot;mockjs&quot;&gt;mockjs&lt;/h1&gt;
&lt;/div&gt;

&lt;script type=&quot;text/javascript&quot;&gt;

    //调用mock方法模拟数据
    Mock.mock(
        &apos;http://mockjs&apos;, {
            &quot;userName&quot; : &apos;@name&apos;,     //模拟名称
            &quot;age|1-100&quot;:100,          //模拟年龄(1-100)
            &quot;color&quot;    : &quot;@color&quot;,    //模拟色值
            &quot;date&quot;     : &quot;@date(&apos;yyyy-MM-dd&apos;)&quot;,  //模拟时间
            &quot;url&quot;      : &quot;@url()&quot;,     //模拟url
            &quot;content&quot;  : &quot;@cparagraph()&quot; //模拟文本
        }
    );

    //ajax请求
    $(&quot;#mockjs&quot;).click(function(){
        $.ajax({
            url        : &quot;http://mockjs&quot;,    //请求的url地址
            dataType   : &quot;json&quot;,   //返回格式为json
            async      : true, //请求是否异步，默认为异步，这也是ajax重要特性
            data       : {},    //参数值
            type       : &quot;GET&quot;,   //请求方式
            beforeSend : function() {
                //请求前的处理
            },
            success: function(req) {
                //请求成功时处理
                console.log(req);
            },
            complete: function() {
                //请求完成的处理
            },
            error: function() {
                //请求出错处理
            }
        });
    });
&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre><p>CommonJs规范</p>
<pre><code>// 加载Mock.js插件，让前端开发与后端独立
window.Mock = require(&apos;mockjs&apos;)
// 加载Mock.mock方法
window.M = window.Mock.mock;
// 加载mock.Random方法
window.R = window.Mock.Random;

console.log(R.email())
console.log(M({email:&apos;@email&apos;}))
    // 这种@的方式叫&quot;占位符&quot;。它可以用来直接生成各种数据
</code></pre><p>Mock.Random 提供的完整方法（占位符）如下：</p>
<pre><code>Type    Method
Basic    boolean, natural, integer, float, character, string,
        range, date, time, datetime, now
Image    image, dataImage
Color    color
Text    paragraph, sentence, word, title, cparagraph, csentence, cword, ctitle
Name    first, last, name, cfirst, clast, cname
Web    url, domain, email, ip, tld
Address    area, region
Helper    capitalize, upper, lower, pick, shuffle
Miscellaneous    guid, id

    // 所有@占位符，都是R对象的演变,比如@email就是如下：
    console.log(R.email())

    // basic：https://github.com/nuysoft/Mock/wiki/Basic
    console.log(M({boolean:&apos;@boolean&apos;}))
    console.log(M({natural:&apos;@natural&apos;}))
    console.log(M({integer:&apos;@integer&apos;}))
    console.log(M({float:&apos;@float&apos;}))
    console.log(M({character:&apos;@character&apos;}))
    console.log(M({range:&apos;@range&apos;}))

    // date:https://github.com/nuysoft/Mock/wiki/Date
    console.log(M({date:&apos;@date&apos;}))
    console.log(M({time:&apos;@time&apos;}))
    console.log(M({datetime:&apos;@datetime&apos;}))
    console.log(M({now:&apos;@now&apos;}))

    // Image：https://github.com/nuysoft/Mock/wiki/Image
    console.log(M({image:&quot;@image()&quot;}))
    console.log(M({image:&quot;@image(60x60)&quot;}))
    console.log(M({image:&quot;@image(60x60,#000000)&quot;}))
    console.log(M({image:&quot;@image(&apos;200x100&apos;, &apos;#00405d&apos;, &apos;#FFF&apos;, &apos;Mock.js&apos;)&quot;}))
    console.log(M({dataImage:&apos;@dataImage&apos;}))
    console.log(M({dataImage:&quot;@dataImage(&apos;200x100&apos;)&quot;}))
    console.log(M({dataImage:&quot;@dataImage(&apos;200x100&apos;, &apos;Hello Mock.js!&apos;)&quot;}))

    // color : https://github.com/nuysoft/Mock/wiki/Color
    console.log(M({color:&apos;@color&apos;}))
    console.log(M({hex:&apos;@hex&apos;}))
    console.log(M({rgb:&apos;@rgb&apos;}))
    console.log(M({rgba:&apos;@rgba&apos;}))
    console.log(M({hsl:&apos;@hsl&apos;}))

    // text : https://github.com/nuysoft/Mock/wiki/Text
    console.log(M({paragraph:&apos;@paragraph&apos;}))
    console.log(M({sentence:&apos;@sentence&apos;}))
    console.log(M({title:&apos;@title&apos;}))
    console.log(M({cparagraph:&apos;@cparagraph&apos;}))
    console.log(M({csentence:&apos;@csentence&apos;}))
    console.log(M({cword:&apos;@cword&apos;}))
    console.log(M({ctitle:&apos;@ctitle&apos;}))

    // name : https://github.com/nuysoft/Mock/wiki/Name
    console.log(M({first:&apos;@first&apos;}))
    console.log(M({last:&apos;@last&apos;}))
    console.log(M({name:&apos;@name&apos;}))
    console.log(M({cfirst:&apos;@cfirst&apos;}))
    console.log(M({clast:&apos;@clast&apos;}))
    console.log(M({cname:&apos;@cname&apos;}))

    // Web　：　https://github.com/nuysoft/Mock/wiki/Name
    console.log(M({url:&apos;@url&apos;}))
    console.log(M({domain:&apos;@domain&apos;}))
    console.log(M({email:&apos;@email&apos;}))
    console.log(M({ip:&apos;@ip&apos;}))
    console.log(M({tld:&apos;@tld&apos;}))

    // address: https://github.com/nuysoft/Mock/wiki/Name
    console.log(M({region:&apos;@region&apos;}))
    console.log(M({province:&apos;@province&apos;}))
    console.log(M({city:&apos;@city&apos;}))
    console.log(M({county:&apos;@county&apos;}))
    console.log(M({zip:&apos;@zip&apos;}))

    // helper Methods : https://github.com/nuysoft/Mock/wiki/Helper
    console.log(M({capitalize:&apos;@capitalize(`hello`)&apos;}))
    console.log(M({upper:&apos;@upper(`hello`)&apos;}))
    console.log(M({lower:&apos;@lower(`HELLO`)&apos;}))
    console.log(M({pick:&quot;@pick([&apos;a&apos;, &apos;e&apos;, &apos;i&apos;, &apos;o&apos;, &apos;u&apos;])&quot;}))
    console.log(M({shuffle:&quot;@shuffle([&apos;a&apos;, &apos;e&apos;, &apos;i&apos;, &apos;o&apos;, &apos;u&apos;])&quot;}))

    // Miscellaneous: https://github.com/nuysoft/Mock/wiki/Miscellaneous
    console.log(M({guid:&apos;@guid&apos;}))
    console.log(M({id:&apos;@id&apos;}))
    console.log(M({increment:&apos;@increment&apos;}))
</code></pre><p>概述</p>
<pre><code>Mock.js实现的功能
基于 数据模板 生成数据
基于 HTML模板 生成数据
拦截并模拟 Ajax请求
</code></pre><p>用法</p>
<pre><code>浏览器：
&lt;!-- （必选）加载 Mock --&gt;
&lt;script src=&quot;http://mockjs.com/dist/mock.js&quot;&gt;&lt;/script&gt;
&lt;script&gt;
// 使用 Mock
var data = Mock.mock({
    &apos;list|1-10&apos;: [{
        &apos;id|+1&apos;: 1
    }]
});
$(&apos;&lt;pre&gt;&apos;).text(JSON.stringify(data, null, 4))
.appendTo(&apos;body&apos;)
&lt;/script&gt;
返回值:

{
&quot;list&quot;: [
    {
        &quot;id&quot;: 1
    },
    {
        &quot;id&quot;: 2
    },
    {
        &quot;id&quot;: 3
    }
    ]
}
</code></pre><p>JQuery：</p>
<pre><code>配置模拟数据：

Mock.mock(&apos;http://g.cn&apos;, {
    &apos;name&apos;     : &apos;@name&apos;,
    &apos;age|1-100&apos;: 100,
    &apos;color&apos;    : &apos;@color&apos;
});
发送Ajax请求：

$.ajax({
    url: &apos;http://g.cn&apos;,
    dataType:&apos;json&apos;
    }).done(function(data, status, xhr){
    console.log(
    JSON.stringify(data, null, 4)
    )
})；
返回数据：

// 结果1
{
&quot;name&quot;: &quot;Elizabeth Hall&quot;,
&quot;age&quot;: 91,
&quot;color&quot;: &quot;#0e64ea&quot;
}

// 结果2
{
&quot;name&quot;: &quot;Michael Taylor&quot;,
&quot;age&quot;: 61,
&quot;color&quot;: &quot;#081086&quot;
}
</code></pre><p>Node.js：</p>
<pre><code>// 安装
npm install mockjs

// 使用
var Mock = require(&apos;mockjs&apos;);
var data = Mock.mock({
    &apos;list|1-10&apos;: [{
        &apos;id|+1&apos;: 1
    }]
});

console.log(JSON.stringify(data, null, 4))
</code></pre><p>Angular.js:</p>
<pre><code>&lt;!-- 引用 --&gt;
&lt;script src=&quot;http://mockjs.com/dist/mock-min.js&quot;&gt;&lt;/script&gt;
&lt;script src=&quot;http://cdn.staticfile.org/angular.js/1.3.0-beta.13/angular.min.js&quot;&gt;&lt;/script&gt;

&lt;!-- 兼容angular (mock.js默认不兼容angular，需额外引用兼容包)--&gt;
&lt;script src=&quot;./src/mock.angular.js&quot;&gt;&lt;/script&gt;
&lt;!-- 模拟数据 --&gt;
&lt;script src=&quot;./mockData.js&quot;&gt;&lt;/script&gt;
&lt;!-- 使用 --&gt;
&lt;script&gt;
(function() {
    (function() {
        var app;
        app = angular.module(&apos;app&apos;, []);
        //使用mockjax方法覆盖Ajax请求
        Mock.mockjax(app);
        return app.controller(&apos;appCtrl&apos;, function($scope, $http) {
            var box;
            box = $scope.box = [];
            $scope.get = function() {
                $http({
                    url: &apos;http://www.baidu.com&apos;,
                    method: &apos;POST&apos;,
                    params: {a: 1},
                    data  : {b:1}
                }).success(function(data) {
                return box.push(data);
            });

            $http({
                url: &apos;http://baidu.com&apos;
                }).success(function(data) {
                console.log(data);
                });
            };
        return $scope.get();
        });
    })();

}).call(this);
&lt;/script&gt;
</code></pre><p>mock数据mockData.js:</p>
<pre><code>Mock.mock(&apos;http://www.baidu.com&apos;, {
    &apos;name&apos;: &apos;@name()&apos;,
    &apos;age|1-100&apos;: 100,
    &apos;color&apos;: &apos;@color&apos;
});
</code></pre><p>语法</p>
<pre><code>Mock.js 的语法规范包括两部分：
数据模板定义（Data Temaplte Definition，DTD）
数据占位符定义（Data Placeholder Definition，DPD）
数据模板定义 DTD
数据模板中的每个属性由 3 部分构成：属性名、生成规则、属性值：

// 属性名   name
// 生成规则 rule
// 属性值   value
&apos;name|rule&apos;: value
注意：
属性名 和 生成规则 之间用 | 分隔。
生成规则 是可选的。
生成规则 有 7 种格式：
&apos;name|min-max&apos;: value
&apos;name|count&apos;: value
&apos;name|min-max.dmin-dmax&apos;: value
&apos;name|min-max.dcount&apos;: value
&apos;name|count.dmin-dmax&apos;: value
&apos;name|count.dcount&apos;: value
&apos;name|+step&apos;: value
生成规则 的 含义 需要依赖 属性值 才能确定。
属性值 中可以含有 @占位符。
属性值 还指定了最终值的初始值和类型。
</code></pre><p>生成规则和示例：</p>
<pre><code>1. 属性值是字符串 String
&apos;name|min-max&apos;: &apos;value&apos; 通过重复 &apos;value&apos; 生成一个字符串，重复次数大于等于 min，小于等于 max。
&apos;name|count&apos;: &apos;value&apos; 通过重复 &apos;value&apos; 生成一个字符串，重复次数等于 count。

2. 属性值是数字 Number
&apos;name|+1&apos;: 100 属性值自动加 1，初始值为 100
&apos;name|1-100&apos;: 100 生成一个大于等于 1、小于等于 100 的整数，属性值 100 只用来确定类型。
&apos;name|1-100.1-10&apos;: 100 生成一个浮点数，整数部分大于等于 1、小于等于 100，小数部分保留 1 到 10 位。
    {
    &apos;number1|1-100.1-10&apos;: 1,
    &apos;number2|123.1-10&apos;: 1,
    &apos;number3|123.3&apos;: 1,
    &apos;number4|123.10&apos;: 1.123
    }
    // =&gt;
    {
    &quot;number1&quot;: 12.92,
    &quot;number2&quot;: 123.51,
    &quot;number3&quot;: 123.777,
    &quot;number4&quot;: 123.1231091814
    }

3. 属性值是布尔型 Boolean
&apos;name|1&apos;: value 随机生成一个布尔值，值为 true 的概率是 1/2，值为 false 的概率是 1/2。
&apos;name|min-max&apos;: value 随机生成一个布尔值，值为 value 的概率是 min / (min + max)，
    值为 !value 的概率是 max / (min + max)。

4. 属性值是对象 Object
&apos;name|min-max&apos;: {} 从属性值 {} 中随机选取 min 到 max 个属性。
&apos;name|count&apos;: {} 从属性值 {} 中随机选取 count 个属性。

5. 属性值是数组 Array
&apos;name|1&apos;: [{}, {} ...] 从属性值 [{}, {} ...] 中随机选取 1 个元素，作为最终值。
&apos;name|min-max&apos;: [{}, {} ...] 通过重复属性值 [{}, {} ...] 生成一个新数组，
    重复次数大于等于 min，小于等于 max。
&apos;name|count&apos;: [{}, {} ...] 通过重复属性值 [{}, {} ...] 生成一个新数组，重复次数为 count。

6. 属性值是数组 Function
&apos;name&apos;: function(){} 执行函数 function(){}，取其返回值作为最终的属性值，上下文为 &apos;name&apos; 所在的对象。
</code></pre><p>数据占位符定义 DPD</p>
<pre><code>占位符 只是在属性值字符串中占个位置，并不出现在最终的属性值中。占位符 的格式为：
@占位符
@占位符(参数 [, 参数])

注意：
用 @ 来标识其后的字符串是 占位符。
占位符 引用的是 Mock.Random 中的方法。
通过 Mock.Random.extend() 来扩展自定义占位符。
占位符 也可以引用 数据模板 中的属性。
占位符 会优先引用 数据模板 中的属性
{
 name: {
 first: &apos;@FIRST&apos;,
 middle: &apos;@FIRST&apos;,
 last: &apos;@LAST&apos;,
 full: &apos;@first @middle @last&apos;
    }
}
// =&gt;
{
 &quot;name&quot;: {
 &quot;first&quot;: &quot;Charles&quot;,
 &quot;middle&quot;: &quot;Brenda&quot;,
 &quot;last&quot;: &quot;Lopez&quot;,
 &quot;full&quot;: &quot;Charles Brenda Lopez&quot;
    }
}
</code></pre><p>常用方法</p>
<pre><code>Mock.mock( rurl?, rtype?, template|function(options) )
根据数据模板生成模拟数据。

参数的含义和默认值如下所示：
参数 rurl：可选。表示需要拦截的 URL，可以是 URL 字符串或 URL 正则。例如 /\/domain\/list.json/、&apos;/domian/list.json&apos;。
参数 rtype：可选。表示需要拦截的 Ajax 请求类型。例如 GET、POST、PUT、DELETE 等。
参数 template：可选。表示数据模板，可以是对象或字符串。例如 { &apos;data|1-10&apos;:[{}] }、&apos;@EMAIL&apos;。
参数 function(options)：可选。表示用于生成响应数据的函数。
参数 options：指向本次请求的 Ajax 选项集。
Mock.mockjax(library)
覆盖（拦截） Ajax 请求，目前内置支持 jQuery、Zepto、KISSY。
</code></pre><p>Mock.Random</p>
<pre><code>Mock.Random 是一个工具类，用于生成各种随机数据。
Mock.Random 的方法在数据模板中称为“占位符”，
引用格式为 @占位符(参数 [, 参数]) 。

Mock.tpl(input, options, helpers, partials)
基于 Handlebars、Mustache 的 HTML 模板生成模拟数据。
</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;实例&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html lang=&amp;quot;en&amp;quot;&amp;gt;
&amp;lt;head&amp;gt;
    &amp;lt;meta charset=&amp;quot;UTF-8&amp;quot;&amp;gt;
    &amp;lt;
    
    </summary>
    
      <category term="学习笔记" scheme="www.wangchengzou.cn/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="vue" scheme="www.wangchengzou.cn/tags/vue/"/>
    
      <category term="mock" scheme="www.wangchengzou.cn/tags/mock/"/>
    
  </entry>
  
  <entry>
    <title>element-ui响应式布局</title>
    <link href="www.wangchengzou.cn/2017/08/03/element-ui%E5%93%8D%E5%BA%94%E5%BC%8F%E9%9D%A2%E5%A3%81/"/>
    <id>www.wangchengzou.cn/2017/08/03/element-ui响应式面壁/</id>
    <published>2017-08-03T14:38:34.000Z</published>
    <updated>2017-08-03T14:49:58.079Z</updated>
    
    <content type="html"><![CDATA[<p>Layout布局</p>
<p>1、创建布局</p>
<pre><code>通过Col组件的:span属性调整Layout布局，分为24栏。
    el-row&gt;
      &lt;el-col :span=&quot;24&quot;&gt;
        &lt;div class=&quot;grid-content bg-purple-dark&quot;&gt;&lt;/div&gt;
      &lt;/el-col&gt;
    &lt;/el-row&gt;
</code></pre><p>2、分栏间隔</p>
<pre><code>通过Row组件的:gutter属性来调整布局之间的宽度。
&lt;el-row :gutter=&quot;20&quot;&gt;
  &lt;el-col :span=&quot;6&quot;&gt;&lt;div class=&quot;grid-content bg-purple&quot;&gt;&lt;/div&gt;&lt;/el-col&gt;
  &lt;el-col :span=&quot;6&quot;&gt;&lt;div class=&quot;grid-content bg-purple&quot;&gt;&lt;/div&gt;&lt;/el-col&gt;
&lt;/el-row&gt;
</code></pre><p>3、分栏漂移</p>
<pre><code>通过Col组件的:offset属性调整栅格的偏移位置（每次1格/24格）。
&lt;el-row :gutter=&quot;20&quot;&gt;
  &lt;el-col :span=&quot;6&quot; :offset=&quot;6&quot;&gt;&lt;div class=&quot;grid-content bg-purple&quot;&gt;&lt;/div&gt;&lt;/el-col&gt;
  &lt;el-col :span=&quot;6&quot; :offset=&quot;6&quot;&gt;&lt;div class=&quot;grid-content bg-purple&quot;&gt;&lt;/div&gt;&lt;/el-col&gt;
&lt;/el-row&gt;
</code></pre><p>4、对齐方式</p>
<pre><code>通过Row组件的type=&quot;flex&quot;启动flex布局，再通过Row组件的justify属性调整排版方式，属性值分别有
start 居前（默认）
center 居中
end 居后
space-between 分布自适应（两边–中间，两边没有空隙）
around （中间–两边，两边会有空隙）
&lt;el-row type=&quot;flex&quot; class=&quot;row-bg&quot; justify=&quot;center&quot;&gt;
  &lt;el-col :span=&quot;6&quot;&gt;&lt;div class=&quot;grid-content bg-purple&quot;&gt;&lt;/div&gt;&lt;/el-col&gt;
  &lt;el-col :span=&quot;6&quot;&gt;&lt;div class=&quot;grid-content bg-purple-light&quot;&gt;&lt;/div&gt;&lt;/el-col&gt;
&lt;/el-row&gt;
</code></pre><p>5、响应式布局</p>
<pre><code>参考bootstrap的响应式，预设四个尺寸
xs &lt;768px
sm ≥768px
md ≥992
lg ≥1200
&lt;el-row :gutter=&quot;10&quot;&gt;
  &lt;el-col :xs=&quot;8&quot; :sm=&quot;6&quot; :md=&quot;4&quot; :lg=&quot;3&quot;&gt;&lt;div class=&quot;grid-content bg-purple&quot;&gt;&lt;/div&gt;&lt;/el-col&gt;
  &lt;el-col :xs=&quot;4&quot; :sm=&quot;6&quot; :md=&quot;8&quot; :lg=&quot;9&quot;&gt;&lt;div class=&quot;grid-content bg-purple-light&quot;&gt;&lt;/div&gt;&lt;/el-col&gt;
  &lt;el-col :xs=&quot;4&quot; :sm=&quot;6&quot; :md=&quot;8&quot; :lg=&quot;9&quot;&gt;&lt;div class=&quot;grid-content bg-purple&quot;&gt;&lt;/div&gt;&lt;/el-col&gt;
  &lt;el-col :xs=&quot;8&quot; :sm=&quot;6&quot; :md=&quot;4&quot; :lg=&quot;3&quot;&gt;&lt;div class=&quot;grid-content bg-purple-light&quot;&gt;&lt;/div&gt;&lt;/el-col&gt;
&lt;/el-row&gt;
</code></pre><p>ICON图标</p>
<pre><code>今后可以使用&lt;i&gt;来做图标，给其class添加el-icon-iconName即可。
可以在&lt;button&gt;上添加icon属性。

&lt;i class=&quot;el-icon-edit&quot;&gt;&lt;/i&gt;
&lt;i class=&quot;el-icon-share&quot;&gt;&lt;/i&gt;
&lt;i class=&quot;el-icon-delete&quot;&gt;&lt;/i&gt;
&lt;el-button type=&quot;primary&quot; icon=&quot;search&quot;&gt;搜索&lt;/el-button&gt;
</code></pre><p>Button图标</p>
<p>1、主题风格</p>
<pre><code>default
primary 蓝色
text 文字蓝色无边框
&lt;el-button&gt;默认按钮&lt;/el-button&gt;
&lt;el-button type=&quot;primary&quot;&gt;主要按钮&lt;/el-button&gt;
&lt;el-button type=&quot;text&quot;&gt;文字按钮&lt;/el-button&gt;
</code></pre><p>2、禁用状态</p>
<pre><code>通过修改:disabled的boolean值true,false来控制按钮是否禁用。
&lt;el-button :plain=&quot;true&quot; :disabled=&quot;true&quot;&gt;主要按钮&lt;/el-button&gt;
&lt;el-button type=&quot;primary&quot; :disabled=&quot;true&quot;&gt;主要按钮&lt;/el-button&gt;
&lt;el-button type=&quot;text&quot; :disabled=&quot;true&quot;&gt;文字按钮&lt;/el-button&gt;
</code></pre><p>3、颜色暗示</p>
<pre><code>默认按钮，通过type的值来控制
朴素按钮，hover显示颜色 ，通过plain的boolean值来控制
</code></pre><p>4、图标按钮</p>
<pre><code>按钮不添加字，设置icon属性即可
&lt;el-button type=&quot;primary&quot; icon=&quot;edit&quot;&gt;&lt;/el-button&gt;

按钮添加字，图标居按钮文字左侧
&lt;el-button type=&quot;primary&quot; icon=&quot;search&quot;&gt;搜索&lt;/el-button&gt;

可以在&lt;button&gt;文字右侧添加&lt;i&gt;标签，图标居按钮文字右侧
&lt;el-button type=&quot;primary&quot;&gt;上传
&lt;i class=&quot;el-icon-upload el-icon--right&quot;&gt;&lt;/i&gt;
&lt;/el-button&gt;
</code></pre><p>5、加载中</p>
<pre><code>设置loading属性为true即可
&lt;el-button type=&quot;primary&quot; :loading=&quot;true&quot;&gt;加载中&lt;/el-button&gt;
</code></pre><p>6、按钮尺寸</p>
<pre><code>设置size属性来配置
large 大
正常
small 小
mini 超小
其他
autofocus：是否默认对焦，boolean
native-type：原生type，string（button,submit,reset）
</code></pre><p>Radio单选框(label前面到底加不加：冒号)</p>
<p>1、基本用法</p>
<pre><code>v-model属性用来绑定变量
label用来赋值（想要选中该单选框，label的值必须等于v-model绑定的变量值，Number/String）
&lt;template&gt;
  &lt;el-radio class=&quot;radio&quot; v-model=&quot;radio&quot; label=&quot;1&quot;&gt;备选项&lt;/el-radio&gt;
  &lt;el-radio class=&quot;radio&quot; v-model=&quot;radio&quot; label=&quot;2&quot;&gt;备选项&lt;/el-radio&gt;
&lt;/template&gt;

&lt;script&gt;
  export default {
    data () {
      return {
        radio: &apos;1&apos;
      };
    }
  }
&lt;/script&gt;
</code></pre><p>2、禁用状态</p>
<pre><code>设置disableed的boolean值为true
&lt;template&gt;
  &lt;el-radio disabled v-model=&quot;radio1&quot; label=&quot;禁用&quot;&gt;备选项&lt;/el-radio&gt;
  &lt;el-radio disabled v-model=&quot;radio1&quot; label=&quot;选中且禁用&quot;&gt;备选项&lt;/el-radio&gt;
&lt;/template&gt;

&lt;script&gt;
  export default {
    data () {
      return {
        radio1: &apos;选中且禁用&apos;//此处变量值等于label变量值
      };
    }
  }
&lt;/script&gt;
</code></pre><p>3、单选框组</p>
<pre><code>被&lt;el-radio-group&gt; &lt;/el-radio-group&gt; 包含即可。
只需要在&lt;el-radio-group&gt;中绑定v-model，
在&lt;el-radio&gt;中设置:label即可。
（提供可一个change方法响应变化，会传入一个value值）

&lt;template&gt;
  &lt;el-radio-group v-model=&quot;radio2&quot;&gt;
    &lt;el-radio :label=&quot;3&quot;&gt;备选项&lt;/el-radio&gt;
    &lt;el-radio :label=&quot;6&quot;&gt;备选项&lt;/el-radio&gt;
    &lt;el-radio :label=&quot;9&quot;&gt;备选项&lt;/el-radio&gt;
  &lt;/el-radio-group&gt;
&lt;/template&gt;

&lt;script&gt;
  export default {
    data () {
      return {
        radio2: 3
      };
    }
  }
&lt;/script&gt;
</code></pre><p>4、按钮组（单选）</p>
<pre><code>个人炒鸡喜欢
lable就是显示的值
在按钮组当中添加&lt;el-radio-button&gt;就可以实现，
并且支持对size属性设置large和small两个属性，不设置为默认。

&lt;el-radio-group v-model=&quot;radio5&quot; :disabled=&quot;true&quot;&gt;
    &lt;el-radio-button label=&quot;上海&quot; :disabled=&quot;true&quot;&gt;
    &lt;/el-radio-button&gt;
    &lt;el-radio-button label=&quot;北京&quot;&gt;&lt;/el-radio-button&gt;
    &lt;el-radio-button label=&quot;广州&quot;&gt;&lt;/el-radio-button&gt;
    &lt;el-radio-button label=&quot;深圳&quot;&gt;&lt;/el-radio-button&gt;
  &lt;/el-radio-group&gt;
&lt;/template&gt;

&lt;script&gt;
  export default {
    data () {
      return {
        radio5: &apos;上海&apos;
      };
    }
  }
&lt;/script&gt;
</code></pre><p>CheckBox单选框<br>1、基础用法</p>
<pre><code>设置v-model属性绑定变量。
&lt;template&gt;
  &lt;!-- `checked` 为 true 或 false --&gt;
  &lt;el-checkbox v-model=&quot;checked&quot;&gt;备选项&lt;/el-checkbox&gt;
&lt;/template&gt;
&lt;script&gt;
  export default {
    data() {
      return {
        checked: true
      };
    }
  };
&lt;/script&gt;
</code></pre><p>2、禁用状态</p>
<pre><code>设置disabled属性即可。
&lt;el-checkbox v-model=&quot;checked2&quot; disabled&gt;备选项&lt;/el-checkbox&gt;
</code></pre><p>CheckBox复选框<br>  1、基本用法</p>
<pre><code>按钮是单一时，绑定v-model变量，类型为boolean值。
&lt;template&gt;
  &lt;!-- `checked` 为 true 或 false --&gt;
  &lt;el-checkbox v-model=&quot;checked&quot;&gt;备选项&lt;/el-checkbox&gt;
&lt;/template&gt;
&lt;script&gt;
  export default {
    data() {
      return {
        checked: true
      };
    }
  };
&lt;/script&gt;
</code></pre><p>  2、禁用状态</p>
<pre><code>设置其disabled属性即可。
&lt;template&gt;
  &lt;el-checkbox v-model=&quot;checked1&quot; disabled&gt;备选项1&lt;/el-checkbox&gt;
  &lt;el-checkbox v-model=&quot;checked2&quot; disabled&gt;备选项&lt;/el-checkbox&gt;
&lt;/template&gt;
&lt;script&gt;
  export default {
    data() {
      return {
        checked1: false,
        checked2: true
      };
    }
  };
&lt;/script&gt;
</code></pre><p>  3、多选框组</p>
<pre><code>1.使用&lt;checkbox-group&gt; &lt;/checkbox-group&gt;包裹即可，v-model的值绑定为Array类型变量。
在&lt;el-checkbox&gt;中的label属性为checkbox对应的值。
（标签无内容，该属性充当checkbox按钮后的介绍）

label与数组中的元素值相对应。存在则为选中，不存在则不选中。
&lt;template&gt;
  &lt;el-checkbox-group v-model=&quot;checkList&quot;&gt;
    &lt;el-checkbox label=&quot;复选框 A&quot;&gt;&lt;/el-checkbox&gt;
    &lt;el-checkbox label=&quot;复选框 B&quot;&gt;&lt;/el-checkbox&gt;
    &lt;el-checkbox label=&quot;复选框 C&quot;&gt;&lt;/el-checkbox&gt;
    &lt;el-checkbox label=&quot;禁用&quot; disabled&gt;&lt;/el-checkbox&gt;
    &lt;el-checkbox label=&quot;选中且禁用&quot; disabled&gt;&lt;/el-checkbox&gt;
  &lt;/el-checkbox-group&gt;
&lt;/template&gt;

&lt;script&gt;
  export default {
    data () {
      return {
        checkList: [&apos;选中且禁用&apos;,&apos;复选框 A&apos;]
      };
    }
  };
&lt;/script&gt;
</code></pre><p>  4、indeterminate状态</p>
<pre><code>indeterminate属性只控制样式变化。
@change当绑定值变化时，触发的事件。
&lt;template&gt;
  &lt;el-checkbox :indeterminate=&quot;isIndeterminate&quot;
      v-model=&quot;checkAll&quot; @change=&quot;handleCheckAllChange&quot;&gt;全选&lt;/el-checkbox&gt;
  &lt;div style=&quot;margin: 15px 0;&quot;&gt;&lt;/div&gt;
  &lt;el-checkbox-group v-model=&quot;checkedCities&quot; @change=&quot;handleCheckedCitiesChange&quot;&gt;
    &lt;el-checkbox v-for=&quot;city in cities&quot; :label=&quot;city&quot;&gt;{{city}}&lt;/el-checkbox&gt;
  &lt;/el-checkbox-group&gt;
&lt;/template&gt;
&lt;script&gt;
  const cityOptions = [&apos;上海&apos;, &apos;北京&apos;, &apos;广州&apos;, &apos;深圳&apos;];
  export default {
    data() {
      return {
        checkAll: true,
        checkedCities: [&apos;上海&apos;, &apos;北京&apos;],
        cities: cityOptions,
        isIndeterminate: true
      };
    },
    methods: {
      handleCheckAllChange(event) {
        this.checkedCities = event.target.checked ? cityOptions : [];
        this.isIndeterminate = false;
      },
      handleCheckedCitiesChange(value) {
        let checkedCount = value.length;
        this.checkAll = checkedCount === this.cities.length;
        this.isIndeterminate = checkedCount &gt; 0 &amp;&amp; checkedCount &lt; this.cities.length;
      }
    }
  };
&lt;/script&gt;
</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Layout布局&lt;/p&gt;
&lt;p&gt;1、创建布局&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;通过Col组件的:span属性调整Layout布局，分为24栏。
    el-row&amp;gt;
      &amp;lt;el-col :span=&amp;quot;24&amp;quot;&amp;gt;
        &amp;
    
    </summary>
    
      <category term="学习笔记" scheme="www.wangchengzou.cn/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="vue" scheme="www.wangchengzou.cn/tags/vue/"/>
    
      <category term="element-ui" scheme="www.wangchengzou.cn/tags/element-ui/"/>
    
  </entry>
  
  <entry>
    <title>vue基础知识</title>
    <link href="www.wangchengzou.cn/2017/08/02/vue%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    <id>www.wangchengzou.cn/2017/08/02/vue基础知识/</id>
    <published>2017-08-02T07:21:52.000Z</published>
    <updated>2017-08-02T07:28:49.990Z</updated>
    
    <content type="html"><![CDATA[<p>一、Vue介绍</p>
<pre><code>vuejs.com
github.com/vuejs/awesome-vue
//列举了和vue先关的官方和第三方用的比较多的资源
what？VueJS是国内的开发者尤雨溪开发的js的框架
when？ 实现UI层的渐进式的框架
从最简单的数据处理，到数据交互，到DOM操作，到路由处理等，VueJS都有完整的解决方案
why？
学习曲线比较缓和
Vue借鉴了Angular的指令、React中组件和props等优点进行设计
Vue提供了全套的解决方案

how？
两种开发模式：
1、CLI
# 全局安装 vue-cli
$ npm install --global vue-cli
# 创建一个基于 webpack 模板的新项目
$ vue init webpack my-project
# 安装依赖，走你
$ cd my-project
$ npm install
$ npm run dev

2、引入js文件
直接下载，引入js文件即可
</code></pre><p>Vue所支持的指令</p>
<pre><code>选择：
v-if v-else v-else-if

循环：
v-for

显示：
v-show

绑定属性：
v-bind
在vue中 绑定html属性，必须使用v-bind
缩写的形式： v-bind:src --&gt; :src

双向数据绑定：
v-model 修饰符：.lazy .number .trim
&lt;input    type=&apos;number&apos; v-model.number=&apos;num1&apos;/&gt;

绑定事件：
v-on:click=&quot;handleClick&quot;
缩写形式： @click=&quot;&quot;
</code></pre><p>自定义指令</p>
<pre><code>3个钩子函数：
bind：绑定
update：更新
unbind：解绑
</code></pre><p>过滤器</p>
<pre><code>作用：数据的处理
自从Vue2.0之后，就已经自带的过滤取消，不再支持，用户要想使用，有两种方法：
①https://github.com/wy-ei/vue-filter
②自定义过滤器

像ng，通过| 管道符号，支持多重过滤，而且支持给过滤器传参
过滤器的本质就是一个函数！
①自定义过滤器创建
在Vue实例的filters属性中指定：
currency:function(value,arg1,arg2){
    return &apos;处理后的数据&apos;
}
②自定义过滤器使用
依然是管道符号，只有传参方式变了：
{{ price | currency('￥','@')}}
</code></pre><p>计算属性</p>
<pre><code>计算属性其实是一个方法，定义在computed属性中的方法。
计算属性的优势：
①计算属性的方法和methods中的方法实现的功能是一样的，但是由于计算属性是有计算缓存的，
    可以让更新更高效
②让代码更方便进行维护

什么时候需要使用计算属性？
方法所依赖的数据，性能开销比较大，适合用计算属性，正常情况，在methods定义方法也是可以的。
</code></pre><p>监听属性</p>
<pre><code>watch：{
kw:function(newValue,oldValue){}
kw2:function(newValue,oldValue){}
}
</code></pre><p>vue中生命周期</p>
<pre><code>create、mount、update、destroy
每个阶段都对应着有处理函数：

beforeCreate
created
beforeMount
mounted
beforeUpdate
updated
beforeDestroy
destroyed
</code></pre><p>组件</p>
<pre><code>①React
在React中组件的创建和使用：
var MyComponent = React.createClass({
    componentWillMount:func,
    getInitialState:func,
    handleCLick:
    render:function(){}
})

&lt;MyComponent&gt;&lt;/MyComponent&gt;

②Vue
Vue.component(&apos;my-component&apos;,{
    template:
})    data:...
&lt;my-component&gt;&lt;/my-component&gt;

组件命名：建议通过烤串式的命名方式（中间有-连接起来）
</code></pre><p>复合组件</p>
<pre><code>全局组件可以在父模板中的任何一个元素（组件）去使用，
局部组件只能够用在父模板中。

比如：局部组件 item，全局组件 my-list,my-item

可以在my-list中调用my-item，但是不可以调用item（局部组件）

当将局部组件或者全局组件放在一起构成的组件称之为复合组件。
MVVM：Model+View+ViewModel
MVC：Model+View+Controller
</code></pre><p>父组件给子组件传值</p>
<pre><code>props down
步骤：
①在创建子组件 指定属性，把要传递的值给属性
&lt;son name=&apos;zhangsan&apos;&gt;&lt;/son&gt;
②在子组件内部声明props属性
props:[&apos;name&apos;]
//props数组中的元素就是属性的名称，在组件创建完成之后，只要是通过该属性传值了，
    就可以直接在props的元素中拿到传递过来的数据

注意事项：
1、在组件中，data属性必须是一个带有返回值而且返回值是对象的方法
2、如果在通过属性传值时，值是会变化，通过v-bind指令将变量绑定到属性
&lt;son v-bind:name=&apos;kw&apos;&gt;&lt;/son&gt;
&lt;son :name=&apos;kw&apos;&gt;&lt;/son&gt;
</code></pre><p>子组件和父组件通信</p>
<pre><code>events up
步骤：
要想通过事件传值，要约定事件的名称：toFather
①在调用子组件时 绑定自定义的事件
&lt;son @toFather=&quot;&quot;&gt;&lt;/son&gt;
②在子组件中触发自定义的事件，并传值
this.$emit(&apos;事件的名称&apos;,&apos;传递的数据&apos;)
this.$emit(&apos;toFather&apos;,123);
</code></pre><p>ref</p>
<pre><code>父组件操作子组件：
&lt;子组件 ref=&apos;名称&apos;&gt;&lt;/子组件&gt;
在父组件中可以通过:this.$refs.名称
(react: this.refs.名称)

子组件操作父组件：
this.$parent.属性或者方法
</code></pre><p>兄弟组件之间通信</p>
<pre><code>借助于事件
var bus = new Vue()
this.$emit()
this.$on()
</code></pre><p>angularJs 多个控制器通信：</p>
<pre><code>①$rootScope
②借助于控制器之间的嵌套
③事件 $scope.$on $scope.$broadcast $scope.$emit
④借助于service

React 组件之间的通信：
①借助于props 传值 this.props
②借助于props传递方法
</code></pre><p>vue-router 路由</p>
<pre><code>ngRoute
①引入对应的angular-router.js 指定ngRoute
②ngView创建一个盛放代码片段的容器
③路由词典
app.config(function($routeProvider){
$routeProvider.when()
.otherwise
})
跳转： $location.path a href=&apos;#/myDetail&apos;
传参： ①发送接收 ②配置接收方路由 /myDetail --&gt;/myDetail/:id ③$routeParams
</code></pre><p>ui-router:支持代码片段的嵌套</p>
<pre><code>①引入对应的js文件，ionic [&apos;ui.router&apos;]
②uiView
③配置状态
$stateProvder.state()
$urlRouterProvider.otherwise
跳转：$state.go ui-sref a
传参：①发送接收 ②配置接收方状态对应的url ③$stateParams
</code></pre><p>vue-router</p>
<pre><code>①引入对应的vue-router.js
②指定容器
&lt;router-view&gt;&lt;/router-view&gt;
③配置路由词典
3.1 定义一个对象数组
每一个对象包含两个属性：path component
var myRoutes=[{path:&apos;&apos;,component:}]
3.2 创建VueRouter对象（路由词典）
var myRouter= new VueRouter({
    routes:myRoutes=
})
3.3 在Vue的实例中，指定router属性为myRouter

跳转：
&lt;router-link to=&apos;/myMain&apos;&gt;&lt;/router-link&gt;
this.$router.push(&apos;/myLogin&apos;)
a href=&apos;#/myLogin&apos;

传参：
①发送 、接受
②配置接收方的路由
③接受参数

从注册页面 跳转到 主页面 并发送数据123：
①发送：register 接受：main
②配置main的路由
{path:&apos;/myMain&apos;,com..}--&gt;
{path:&apos;/myMain/:id&apos;,com..}
③在组件生命周期钩子函数中读取传递过来的参数
mounted:function(){
    var result= this.$route.params.id
}
④ href=&apos;#/myMain/123&apos;
router-link to=&apos;/myMain/123&apos;
this.$router.push(&apos;/myMain/123&apos;)
</code></pre><p>vue-http 网络请求</p>
<pre><code>this.$http.get/post/ajax().then(function(response){})
</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;一、Vue介绍&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;vuejs.com
github.com/vuejs/awesome-vue
//列举了和vue先关的官方和第三方用的比较多的资源
what？VueJS是国内的开发者尤雨溪开发的js的框架
when？ 实现UI层的渐进式的框架

    
    </summary>
    
      <category term="学习笔记" scheme="www.wangchengzou.cn/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="vue" scheme="www.wangchengzou.cn/tags/vue/"/>
    
  </entry>
  
  <entry>
    <title>git/svn使用基础知识</title>
    <link href="www.wangchengzou.cn/2017/07/22/git/"/>
    <id>www.wangchengzou.cn/2017/07/22/git/</id>
    <published>2017-07-22T15:48:26.000Z</published>
    <updated>2017-09-23T00:10:07.969Z</updated>
    
    <content type="html"><![CDATA[<p>使用方法</p>
<pre><code>git  config  --global   user.name   &quot;name&quot;
git  config  --global   user.email   &quot;email@qq.com&quot;
</code></pre><p>指令说明</p>
<pre><code>git  status               查看工作区所有文件状态
git  add  1.jpg          把指定文件添加到暂存区
git  add  *.jpg          把指定后缀名的文件添加到暂存区
git  add  *              把所有文件添加到暂存区
git  add  .              把所有文件添加到暂存区
git  commit  -m  &quot;消息内容&quot;   把暂存区的修改提交给仓库
git  log                 查看仓库中所有的提交记录

git  reset  --hard  版本号     工作区回退到指定的版本
git  log       查看当前已经生效的所有版本号
git  reflog     查看当前已经生效&amp;撤销生效的所有版本号
</code></pre><p>远程仓库相关</p>
<pre><code>git  clone  远程仓库的地址
git  clone  git@github.com:jquery/jquery.git
git  clone  https://github.com/jquery/jquery.git
</code></pre><p>创建关联使用方法</p>
<pre><code>git  init           本地创建一个空白仓库
git  remote       查看当前仓库关联到哪些远程仓库
git  remote  add  关联仓库名  远程仓库的地址
git  pull  关联仓库名  master    从远程仓库“拉取(pull)”已有的文件和版本信息到本地仓库
git  add  .        修改本地仓库中的文件，添加到本地暂存区，提交给本地的仓库
git  commit   -m   &quot;说明信息&quot;
git  push  远程仓库名  master    把本地仓库中的新的版本信息“推送(push)”给远程仓库

git subtree push --prefix=dist origin gh-pages  建立分支结构
</code></pre><p>关于分支的使用方法</p>
<pre><code>1，将远程仓库克隆到本地：
    git clone https://github.com/**.git(项目克隆地址)
2，生成分支gh-pages并切换到此分支
    cd flexSupplement （进入到你克隆仓库的本地文件夹）
    git checkout - -orphan gh-pages (创建分支并切换，两个横杆)
3，将本地克隆文件(文件名为github仓库名)里面除.git文件以外的其他文件全部删除，
    再将根目录下dist文件夹里面的内容复制到克隆文件中。
    依次执行以下命令：
    git add . （将本地所有文件加到仓库里）
    git commit -m “message” （设置提交信息）
    git remote add origin https://github.com/***.git（本地仓库链接远程仓库）
    git push -u origin gh-pages （push文件到仓库中）
</code></pre><p>1、VCS系统</p>
<pre><code>Version Control System，版本控制系统；
用于记录项目文件的开发版本，完成项目文件的存储、共享、合并、回退、回溯等功能。
常见的VCS软件有：
  集中式VCS软件： CVS、SVN
  分布式VCS软件： Bitlocker、Git

仓库(Repository)：用于保存项目中所有文件（文本、二进制）,以及每个文件的每次修改记录(谁/何时/修改了什么)
工作区(Working Directory)：用于检出(Checkout)、编辑、提交(Commit)项目文件
</code></pre><p>2、SVN系统的使用</p>
<pre><code>服务器端：
  (1)安装一款SVN服务器软件(VisualSVN-Server)
  (2)启动SVN服务器
  (3)创建用户(User)和组(Group)
  (4)为每个项目创建一个仓库(Repository)，指定用户和组的访问权限
客户端：
  (1)安装一款SVN客户端软件
  (2)选择一个目录作为工作目录(Working Directory)，检出(Checkout)服务器上的已有内容
  (3)修改项目文件
  (4)提交(Commit)项目文件到SVN服务器
  (5)其他项目组员可以从SVN服务器上更新(Update)你提交的项目文件
</code></pre><p>3、使用WebStorm作为SVN客户端</p>
<pre><code>只要首先安装SVN客户端，再启动WebStorm，它可以自动发现系统中安装的SVN客户端，
如TortoiseSVN，可以使用WS中按钮直接实现SVN客户端的功能。
</code></pre><p>4、Git的使用</p>
<pre><code>快速入门：http://www.runoob.com/git/git-tutorial.html
深入入门：http://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000/
官方手册：https://www.gitbook.com/book/bingohuang/progit2/details
  Git是一个开源的分布式版本控制系统，用于敏捷高效地处理任何或小或大的项目。
  Git 是 Linus Torvalds 为了帮助管理 Linux 内核开发而开发的一个开放源码的版本控制软件。
  Git 与常用的版本控制工具 CVS, Subversion 等不同，它采用了分布式版本库的方式，不必服务器端软件支持。
  SVN和Git的异同点？
      1、GIT是分布式的，SVN是集中式：这是GIT和其它非分布式的版本控制系统，例如SVN，CVS等，最核心的区别。
      2、GIT把内容按元数据方式存储，而SVN是按文件：所有的资源控制系统都是把文件的元信息隐藏在一个类似.svn,.cvs等的文件夹里。
      3、GIT分支和SVN的分支不同：分支在SVN中一点不特别，就是版本库中的另外的一个目录。
      4、GIT没有一个全局的版本号，而SVN有：目前为止这是跟SVN相比GIT缺少的最大的一个特征。
      5、GIT的内容完整性要优于SVN：GIT的内容存储使用的是SHA-1哈希算法。这能确保代码内容的完整性，
          确保在遇到磁盘故障和网络问题时降低对版本库的破坏。
  提示：Git系统服务器不是必需的！每个终端都自带仓库。
      Git账户不需要向服务器申请，自己随意指定即可，但需要为自己创建一个唯一的身份识别号。
</code></pre><p>5、Git系统的使用</p>
<pre><code>Git是分布式的VCS系统，每个终端都是独立的（有工作区和仓库），
账户的name和email是自己指定的，也可以为每个终端都创建一个全球唯一的身份识别号。
使用步骤：
(1)安装一款Git客户端工具——msysgit
  从官网下载：Git-2.13.0-64-bit.exe
(2)使用Git GUI为自己分配一个全球唯一的身份识别号(SSH Key)
(3)在当前系统中安装的Git全局声明一下当前用户的认证信息
  git  config  --global   user.name   &quot;LiWenhua&quot;
  git  config  --global   user.email   &quot;lwh@qq.com&quot;
(4)创建一个空白工作区，其中包含一个仓库
  git  init
  提示：工作区所在的完整目录中不允许出现中文和空白字符
(5)在工作区中添加/编写/修改/删除项目文件，添加到暂存区，永久提交给仓库，生成版本号
  git  status               查看工作区所有文件状态
  git  add  1.jpg          把指定文件添加到暂存区
  git  add  *.jpg          把指定后缀名的文件添加到暂存区
  git  add  *              把所有文件添加到暂存区
  git  add  .              把所有文件添加到暂存区
  git  commit  -m  &quot;消息内容&quot;   把暂存区的修改提交给仓库
  git  log                 查看仓库中所有的提交记录
(6)可以使用git reset命令回退到历史上的指定版本
  git  reset  --hard  版本号     工作区回退到指定的版本
  git  log       查看当前已经生效的所有版本号
  git  reflog     查看当前已经生效&amp;撤销生效的所有版本号
</code></pre><p>6、Git的常用操作：</p>
<pre><code>使用Git作为VCS的步骤：
(1)安装一款Git客户端——msysgit——一路下一步。
(2)使用OpenSSL工具为自己创建一个唯一的身份识别号——若自己的Git服务器需要和其他的Git服务器进行数据同步，需要使用此识别号。
(3)为Git客户端中设置当前用户的user.name和user.email
    git  config   --global  user.name  &quot;用户名&quot;
    git  config   --global  user.email  &quot;邮箱名&quot;
    提示：上述命令中的双引号不能改用单引号！此命令本质是在修改c:/Users/Administrator/.gitconfig文件
(4)在自己的电脑上分配一个工作空间目录(整个路径中不能有中文和空白)，初始化一个仓库
git  init
(5)编写文件，提交到Git暂存区
    git  status    查看当前工作区文件的状态
    git  add  &lt;文件名&gt;    把指定的文件添加到Git暂存区
(6)把Git暂存区中的数据提交到仓库
    git  commit   -m   &quot;此次提交的说明文字&quot;     把暂存区内容永久提交到仓库
    git  log      查看所有的提交日志
</code></pre><p>  7、从Github.com上克隆他人项目仓库的步骤：</p>
<pre><code>(1)打开https://github.com/，注册(SignUp)，登录(SignIn)
(2)把自己当前git终端的SSH Key添加给github.com
(3)克隆github.com上的项目/仓库
  git  clone  远程仓库的地址
  git  clone  git@github.com:jquery/jquery.git
  git  clone  https://github.com/jquery/jquery.git

将自己本地的仓库与Github.com上的仓库同步：
    (1)打开https://github.com/，注册(SignUp)，登录(SignIn)
    (2)把自己当前git终端的SSH Key添加给github.com
    (3)在自己的github账户下创建公共项目仓库
    (4)在本地电脑上安装Git客户端，添加远程仓库，建立本地仓库与远程仓库的关联
      git  init           本地创建一个空白仓库
      git  remote       查看当前仓库关联到哪些远程仓库
      git  remote  add  关联仓库名  远程仓库的地址
    (5)从远程仓库“拉取(pull)”已有的文件和版本信息到本地仓库
       git  pull  关联仓库名  master
    (6)修改本地仓库中的文件，添加到本地暂存区，提交给本地的仓库
      git  add  .
      git  commit   -m   &quot;说明信息&quot;
    (7)把本地仓库中的新的版本信息“推送(push)”给远程仓库
      git  push  远程仓库名  master
</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;使用方法&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;git  config  --global   user.name   &amp;quot;name&amp;quot;
git  config  --global   user.email   &amp;quot;email@qq.com&amp;quot;
&lt;/
    
    </summary>
    
      <category term="学习笔记" scheme="www.wangchengzou.cn/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="git" scheme="www.wangchengzou.cn/tags/git/"/>
    
      <category term="svn" scheme="www.wangchengzou.cn/tags/svn/"/>
    
      <category term="打包" scheme="www.wangchengzou.cn/tags/%E6%89%93%E5%8C%85/"/>
    
  </entry>
  
  <entry>
    <title>Zetpojs基础知识</title>
    <link href="www.wangchengzou.cn/2017/07/22/Zeptojs/"/>
    <id>www.wangchengzou.cn/2017/07/22/Zeptojs/</id>
    <published>2017-07-22T15:48:26.000Z</published>
    <updated>2017-07-23T15:56:58.353Z</updated>
    
    <content type="html"><![CDATA[<p>一、zeptojs概述</p>
<pre><code>目标：实现一个10k以内的非常轻量的移动端用的方便DOM操作的js库
what？ 是一个js库
where？现代高级浏览器（移动端）
why？轻量（放弃了对ie等低端浏览器的支持）
how？类似jQuery的用法 只需要引入js文件，调用方法即可
特点：
    学习成本低
    轻量
注意：zeptojs官网下载的包 默认包含5个模块（zepto\ie\ajax\event\form）,
        如果要用到其他模块，去zeptoBuilder
        官网：http://github.e-sites.nl/zeptobuilder/
        选择需要用到的模块，勾选，下载即可
</code></pre><p>二、使用Zepto</p>
<pre><code>1、核心模块
    集合、数据、类型判断的操作
    选择器
    DOM增删改查

2、detect
    如果不是默认的模块，可以到zeptoBuilder下载对应的模块文件。
    $.os $.browser

3、event模块
    on off one trigger

4、Ajax模块
    $.get
    $.post
    $.ajax
    $.load

5、form模块
    serialize  将表单中的输入组件的name属性和对应的值 处理成urlEncoded的字符串
    serializeArray  将表单中的输入组件的name属性和对应的值（放在value中） [{name:&apos;&apos;,value:&apos;&apos;},{...}]
    submit 表单指定submit触发时 执行的处理函数

6、Touch模块
    点按事件：tap singleTap doubleTap longTap
    滑动事件：swipe swipeLeft swipeRight swipeUp swipeDown

7、Effects（Animate）模块
    show/hide/fadeIn/fadeOut/fadeToggle
    animate
</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;一、zeptojs概述&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;目标：实现一个10k以内的非常轻量的移动端用的方便DOM操作的js库
what？ 是一个js库
where？现代高级浏览器（移动端）
why？轻量（放弃了对ie等低端浏览器的支持）
how？类似jQuery的用法 只需要
    
    </summary>
    
      <category term="学习笔记" scheme="www.wangchengzou.cn/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="App" scheme="www.wangchengzou.cn/tags/App/"/>
    
      <category term="Zetpojs" scheme="www.wangchengzou.cn/tags/Zetpojs/"/>
    
  </entry>
  
  <entry>
    <title>ajax面试题点</title>
    <link href="www.wangchengzou.cn/2017/07/22/ajax%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    <id>www.wangchengzou.cn/2017/07/22/ajax面试题/</id>
    <published>2017-07-22T15:48:26.000Z</published>
    <updated>2017-07-27T14:23:51.280Z</updated>
    
    <content type="html"><![CDATA[<p>1、Ajax 是什么? 如何创建一个Ajax？</p>
<pre><code>Ajax并不算是一种新的技术，全称是asychronous javascript and xml，可以说是已有技术的组合，
主要用来实现客户端与服务器端的异步通信效果，实现页面的局部刷新，早期的浏览器并不能原生支持ajax
，可以使用隐藏帧（iframe）方式变相实现异步效果，后来的浏览器提供了对ajax的原生支持
使用ajax原生方式发送请求主要通过XMLHttpRequest(标准浏览器)、
ActiveXObject(IE浏览器)对象实现异步通信效果
基本步骤：
var xhr =null;//创建对象
if(window.XMLHttpRequest){
    xhr = new XMLHttpRequest();
}else{
    xhr = new ActiveXObject(&quot;Microsoft.XMLHTTP&quot;);
}
     xhr.open(“方式”,”地址”,”标志位”);//初始化请求
     xhr.setRequestHeader(“”,””);//设置http头信息
     xhr.onreadystatechange =function(){}//指定回调函数
     xhr.send();//发送请求
</code></pre><p>3、如何解决跨域问题?</p>
<pre><code>理解跨域的概念：协议、域名、端口都相同才同域，否则都是跨域
出于安全考虑，服务器不允许ajax跨域获取数据，但是可以跨域获取文件内容，
所以基于这一点，可以动态创建script标签，使用标签的src属性访问js文件的形式获取js脚本
，并且这个js脚本中的内容是函数调用，该函数调用的参数是服务器返回的数据，
为了获取这里的参数数据，需要事先在页面中定义回调函数，在回调函数中处理服务器返回的数据
，这就是解决跨域问题的主流解决方案
</code></pre><p>4、页面编码和被请求的资源编码如果不一致如何处理？</p>
<pre><code>对于ajax请求传递的参数，如果是get请求方式，参数如果传递中文，在有些浏览器会乱码，
不同的浏览器对参数编码的处理方式不同，所以对于get请求的参数需要使用
encodeURIComponent函数对参数进行编码处理，后台开发语言都有相应的解码api。
对于post请求不需要进行编码
</code></pre><p>5、简述ajax 的过程。</p>
<pre><code>1. 创建XMLHttpRequest对象,也就是创建一个异步调用对象
2. 创建一个新的HTTP请求,并指定该HTTP请求的方法、URL及验证信息
3. 设置响应HTTP请求状态变化的函数
4. 发送HTTP请求
5. 获取异步调用返回的数据
6. 使用JavaScript和DOM实现局部刷新
</code></pre><p>6、阐述一下异步加载。</p>
<pre><code>1. 异步加载的方案： 动态插入 script 标签
2. 通过 ajax 去获取 js 代码，然后通过 eval 执行
3. script 标签上添加 defer 或者 async 属性
4. 创建并插入 iframe，让它异步执行 js
</code></pre><p>7、请解释一下 JavaScript 的同源策略。</p>
<pre><code>同源策略是客户端脚本（尤其是Javascript）的重要的安全度量标准。
它最早出自Netscape Navigator2.0，其目的是防止某个文档或脚本从多个不同源装载。
所谓同源指的是：协议，域名，端口相同，同源策略是一种安全协议，
指一段脚本只能读取来自同一来源的窗口和文档的属性。
</code></pre><p>8、GET和POST的区别，何时使用POST？</p>
<pre><code>GET：一般用于信息获取，使用URL传递参数，对所发送信息的数量也有限制，
一般在2000个字符，有的浏览器是8000个字符
POST：一般用于修改服务器上的资源，对所发送的信息没有限制
在以下情况中，请使用 POST 请求：
1. 无法使用缓存文件（更新服务器上的文件或数据库）
2. 向服务器发送大量数据（POST 没有数据量限制）
3. 发送包含未知字符的用户输入时，POST 比 GET 更稳定也更可靠
</code></pre><p>9、ajax 是什么?ajax 的交互模型?同步和异步的区别?如何解决跨域问题?</p>
<pre><code>1. 通过异步模式，提升了用户体验
2. 优化了浏览器和服务器之间的传输，减少不必要的数据往返，减少了带宽占用
3.  Ajax在客户端运行，承担了一部分本来由服务器承担的工作，减少了大用户量下的服务器负载。
</code></pre><p>10、 Ajax的最大的特点是什么。</p>
<pre><code>Ajax可以实现异步通信效果，实现页面局部刷新，带来更好的用户体验；按需获取数据，节约带宽资源；
</code></pre><p>11、ajax的缺点</p>
<pre><code>1、ajax不支持浏览器back按钮。
2、安全问题 AJAX暴露了与服务器交互的细节。
3、对搜索引擎的支持比较弱。
4、破坏了程序的异常机制。
</code></pre><p>12、ajax请求的时候get 和post方式的区别</p>
<pre><code>get一般用来进行查询操作，url地址有长度限制，请求的参数都暴露在url地址当中，
如果传递中文参数，需要自己进行编码操作，安全性较低。
post请求方式主要用来提交数据，没有数据长度的限制，
提交的数据内容存在于http请求体中，数据不会暴漏在url地址中。
</code></pre><p>13、解释jsonp的原理，以及为什么不是真正的ajax</p>
<p>　　  Jsonp并不是一种数据格式，而json是一种数据格式，<br>    jsonp是用来解决跨域获取数据的一种解决方案，具体是通过动态创建script标签，<br>    然后通过标签的src属性获取js文件中的js脚本，该脚本的内容是一个函数调用，<br>    参数就是服务器返回的数据，为了处理这些返回的数据，需要事先在页面定义好回调函数<br>    ，本质上使用的并不是ajax技术</p>
<p>14、什么是Ajax和JSON，它们的优缺点。</p>
<pre><code>Ajax是全称是asynchronous JavaScript andXML，即异步JavaScript和xml，
用于在Web页面中实现异步数据交互，实现页面局部刷新。
优点：可以使得页面不重载全部内容的情况下加载局部内容，降低数据传输量，
避免用户不断刷新或者跳转页面，提高用户体验
缺点：对搜索引擎不友好；要实现ajax下的前后退功能成本较大；
可能造成请求数的增加跨域问题限制；
JSON是一种轻量级的数据交换格式，ECMA的一个子集
优点：轻量级、易于人的阅读和编写，便于机器（JavaScript）
解析，支持复合数据类型（数组、对象、字符串、数字）
</code></pre><p>15、http常见的状态码有那些？分别代表是什么意思？<br>    200 - 请求成功<br>    301 - 资源（网页等）被永久转移到其它URL<br>    404 - 请求的资源（网页等）不存在<br>    500 - 内部服务器错误</p>
<p>16、一个页面从输入 URL 到页面加载显示完成，这个过程中都发生了什么？</p>
<pre><code>分为4个步骤：
    1. 当发送一个 URL 请求时，不管这个 URL 是 Web 页面的 URL 还是 Web 页面上每个资源的 URL
    ，浏览器都会开启一个线程来处理这个请求  ，同时在远程 DNS 服务器上启动一个 DNS 查询。
    这能使浏览器获得请求对应的 IP 地址。
    2. 浏览器与远程 Web 服务器通过 TCP 三次握手协商来建立一个 TCP/IP 连接。
    该握手包括一个同步报文，一个同步-应答报文和一个应答报    文，这三个报文在
    浏览器和服务器之间传递。该握手首先由客户端尝试建立起通信，而后服务器应答并接受客户端的请求
    ，最后由客户端发出该请求已经    被接受的报文。
    3. 一旦 TCP/IP 连接建立，浏览器会通过该连接向远程服务器发送 HTTP 的 GET 请求。
    远程服务器找到资源并使用 HTTP响应返回该资源，值为 200 的 HTTP 响应状态表示一个正确的响应。
    4. 此时，Web 服务器提供资源服务，客户端开始下载资源。
</code></pre><p>17、ajax请求的时候get 和post方式的区别</p>
<pre><code>get一般用来进行查询操作，url地址有长度限制，请求的参数都暴露在url地址当中，
如果传递中文参数，需要自己进行编码操作，安全性较低。
post请求方式主要用来提交数据，没有数据长度的限制，提交的数据内容存在于http请求体中
，数据不会暴漏在url地址中。
</code></pre><p>18、ajax请求时，如何解释json数据</p>
<pre><code>使用eval()或者JSON.parse() 鉴于安全性考虑，推荐使用JSON.parse()更靠谱，
对数据的安全性更好。
</code></pre><p>19、.javascript的本地对象，内置对象和宿主对象</p>
<pre><code>本地对象为独立于宿主环境的ECMAScript提供的对象，包括ArrayObjectRegExp等可以new实例化的对象
内置对象为Gload，Math 等不可以实例化的(他们也是本地对象，内置对象是本地对象的一个子集)
宿主对象为所有的非本地对象，所有的BOM和DOM对象都是宿主对象，如浏览器自带的document,window 等对象
</code></pre><p>20、为什么利用多个域名来存储网站资源会更有效？</p>
<pre><code>确保用户在不同地区能用最快的速度打开网站，其中某个域名崩溃用户也能通过其他郁闷访问网站，
并且不同的资源放到不同的服务器上有利于减轻单台服务器的压力。
</code></pre><p>21、请说出三种减低页面加载时间的方法</p>
<pre><code>1、压缩css、js文件
2、合并js、css文件，减少http请求
3、外部js、css文件放在最底下
4、减少dom操作，尽可能用变量替代不必要的dom操作
</code></pre><p>22、HTTP状态码都有那些。</p>
<pre><code>200 OK      //客户端请求成功
400 Bad Request  //客户端请求有语法错误，不能被服务器所理解
403 Forbidden  //服务器收到请求，但是拒绝提供服务
404 Not Found  //请求资源不存在，输入了错误的URL
500 Internal Server Error //服务器发生不可预期的错误
503 Server Unavailable  //服务器当前不能处理客户端的请求，一段时间后可能恢复正常
</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;1、Ajax 是什么? 如何创建一个Ajax？&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Ajax并不算是一种新的技术，全称是asychronous javascript and xml，可以说是已有技术的组合，
主要用来实现客户端与服务器端的异步通信效果，实现页面的局部刷新，早期的浏
    
    </summary>
    
      <category term="面试题目" scheme="www.wangchengzou.cn/categories/%E9%9D%A2%E8%AF%95%E9%A2%98%E7%9B%AE/"/>
    
    
      <category term="ajax" scheme="www.wangchengzou.cn/tags/ajax/"/>
    
      <category term="js" scheme="www.wangchengzou.cn/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>MySql常用方法知识</title>
    <link href="www.wangchengzou.cn/2017/07/22/MySql/"/>
    <id>www.wangchengzou.cn/2017/07/22/MySql/</id>
    <published>2017-07-22T15:48:26.000Z</published>
    <updated>2017-07-23T16:08:55.461Z</updated>
    
    <content type="html"><![CDATA[<p>添加用户方法 grant</p>
<pre><code>&gt;grant select,insert,update,delete,create,drop
&gt;on tutorials.*
&gt;to &apos;zara&apos;@&apos;localhost&apos;
&gt;identified by &apos;zara123&apos;;
以上为为指定数据库tutorials添加用户zara 密码为zara123

&gt;use数据库名；--选择操作的数据库
&gt;show databases;   ---列出所有数据库
&gt;show tables;      ---列出数据库所有表
&gt;show columns from 数据表；----显示数据表属性，属性类型，主键信息
&gt;show index from 数据表； ---显示数据表索引信息
&gt;show table status like 数据表\G; ---输出统计信息
&gt;create database库名； ----创建库名
&gt;drop database库名；   ----弹出框显示是否删除库名
&gt;int bigint double varchar datetime now()  四大数据类型
&gt;create table 表名；  ---创建数据表
&gt;drop table 表名；    ---删除表
&gt;insert into 表名（列，列）values(值，值)；---添加数据
&gt;select 列名 from 表名 where 条件；  ----查询
&gt;update 表名 set 列=值，列=值 where 条件  ----更新或修改数据
&gt;delete from 表名 where 条件； ---直接删除表内记录列
&gt;drop database if exists 库名  ---判断是否存在数据库，存在就删除
&gt;create database 库名 charset=utf8；  ---指定库名编码
&gt;set names utf8  -----设置语句编码
&gt;primary key auto_increment  --- 主键自增加，指定位置用null代替
&gt;$_request[&apos;title&apos;];--获取表单中的参数
&gt;desc 表名；----将查看该表里面的所有类型
&gt;require();  ---引用初始化PHP文件
多表查询方法（
    SELECT n.title,n.ctime,u.uname    多表联系
    FROM t_user u,t_news n;           创建别名
    WHERE u.id==n.uid          条件关系
）

{命令窗口使用SQL文件加载数据库，中文显示
    &gt;set names utf8        --文件转换编码格式
    &gt;source 文件位置    --加载文件位置
    &gt;set names gbk        --临时使用gbk格式显示中文
}
</code></pre><p>php学习基本函数</p>
<pre><code>phpinfo();显示软件版本信息
var_dump();输出数组元素
count();输出数组里面元素的个数
foreach($arr as $k=&gt;$v);用于处理关联数组遍历问题
</code></pre><p>使用php操作mhsql服务器步骤(四步走)</p>
<pre><code>1创建到MySQL服务器的连接
  $conn=mysqli_connect(...);
    服务器地址IP    本机127.0.0.1：8081
    用户名      root
    密码          p
    选择库      库名
2向MySQL服务器发送sql指令，等待服务器执行
  $sql=&quot;...&quot;;//insert/delete/update
3读取MySQL服务器返回结果
  $result=mysqli_query($conn,$sql);
4判断返回结果是否成功
  if($result===false);
5断开与MySQL服务器连接
  mysqli_close($conn);
</code></pre><p>php mysql查询操作</p>
<pre><code>1:连接数据库
  $conn=mysqli_connect(...);
  服务器地址IP    本机127.0.0.1：8081
  用户名            root
  密码          p
  选择库      库名
2:发送查询sql   SELECT
   $sql=&quot;...&quot;;    SELECT * FROM t_user;
3:读取MySQL服务器返回结果 是不是true/false
   $result=mysqli_query($conn,$sql);
4:抓取结果中数据并且转换数组
   a:抓取一行数据{关联数组}
    mysqli_fetch_assoc(结果集对象);
   b:抓取一行数据{索引数组
    mysqli_fetch_row(结果集对象);
5:断开与MySQL服务器连接
   mysqli_close($conn);
</code></pre><p>php常用函数说明</p>
<pre><code>die($str);终止当前php文件执行，并向客户输出一个终止原因说明
@    压制住当前行代码警告消息，在行首位置添加！
#time() 返回当前系统时间，以毫秒为单位整数
#mysqli_insert _id($conn) 返回连接上刚刚执行insert 语句产生ID值
#mysqli_affected_rows($conn),返回刚刚连接上执行增删改语句影响行数
location.href   为跳转方式
</code></pre><p>ajax  GET的使用方法</p>
<pre><code>1.创建Ajax对象
    var xhr= new XMLHttpRequest();
2.绑定事件
    xhr.onreadystatechange=function(){
        alert(xhr.responseText);--输出事件运行文本状态
    }
3.打开连接
    xhr.open(&apos;GET&apos;,&apos;url&apos;,true);
4.发送请求
    xhr.send(null)
</code></pre><p>Ajax 常用对象和属性事件方法</p>
<pre><code>xhr对象：向web服务器发送请求并接收返回响应消息
    var xhr =new XMLHttpRequest();
    兼容性问题，老IE8以下不支持
    采用 new ActiveXObject(&quot;Microsoft.XMLHTTP&quot;)
    对兼容性做判断 if（window.XMLHttpRequest）确认使用创建对象方法

readyState ;xhr对象当前状态，会自动改变
    对应值：0 UNSENT 请求消息未发送
        1 OPENED XHR已经找开连接
        2 HEADERS_RECEVIED xhr已经接收信息
        3 LOADING  XHR正在加载消息
        4 DONE XHR接收完成消息

status  表示服务器返回的状态码
responseText  表示服务器响应文本
responseXML   表示服务器响应XML文本

属性使用方法
    open(method,url.isAsyn)  表示打开服务器连接
        method：请求方式，GET POST
        Ulr  请求地址
        isasyn：请求方式是异步TRUE还是同步FALSE

    send（data）请求消息发送web服务器
        data：请示消息主体内容:
           GET为send(null)
           POST 为数据放在里面如send（‘id=10&amp;name=tome&amp;age=19&apos;）
</code></pre><p>#AJAX POST  标准语法和用法</p>
<pre><code>1.创建AJAX对象
 xhr=new XMLHttpRequest()
2.绑定事件
    xhr.onreadystatechange=function(){
    判断事件输出信息，返回数据
    if(xhr.readyState===4&amp;&amp;xhr.status===200){
        if(parseInt(xhr.responseText)&gt;0){
            作输出 ，返回成功结果
        }else{
            输出 失败结果
        }
    }
  }
3.打开连接
  xhr.open(&apos;POST&apos;,&apos;URL&apos;,ture)
  修改头部信息
   xhr.setRequestHeader(&apos;Content-Type&apos;,&apos;application/x-www-form-urlencoded&apos;);
4.发送请求
  xhr.send(发送参数);
</code></pre><p>修改头部信息–php首行加头部信息</p>
<pre><code>纯文本text
    header(&quot;Content-Type:text/plain&quot;);
        html-&gt;ajax
        xhr.responseText
网页页面HTML
    header(&quot;Content-Type:text/html;charset=utf-8&quot;);
        html-&gt;ajax
        xhr.responseText;
javascript
    header(&quot;Content-Type:application/javascript;charset=utf-8&quot;);
     echo &quot;var msg=&apos;hello&apos;;alert(msg)&quot;;
                html-&gt;ajax
      eval(xhr.responseText);
      示例:国际化
       当前浏览器 zh-CN  你好
                 en-US   hello
</code></pre><p>json语法和要求</p>
<pre><code>一个JSON字符串有且只有一个根，可以是{}对象 []一个数组
JSON中可以表示 数字 bool null 字符串，字符串必须用双引号
数组中可以包含多值 ，用， 分开
对象中可以包含多个键值，使用逗号分开，

怎么处理JSON数据
服务器端PHP
    header(&quot;Content-Type:application/json;charset=utf-8&quot;);
    $str=json_encode($arr)
    echo $str;

javascript 接收
    var obj=JSON.parse(xhr.responstText);
</code></pre><p>XML语法要求</p>
<pre><code>XML 文档声明
    &lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
整篇xml字符串只能一个根元素 标签有开始有结束 不能交叉
所有属性必须用双引号

XML方法
    服务器PHP
    header(&quot;Content-Type:application/xml;charset=utf-8&quot;);
    echo &quot; xml....&quot;;
    客户端JS
    AJXX请求接收数据
    var xmlDoc=xhr.responseXML;---
    获取所有标签
    var book=xmlDoc.querySelectorAll(&quot;book&quot;)
    获取其中属性
    var name=xmldDoc.querySelector(&quot;name&quot;)
</code></pre><p>jquery 常用AJAX函数</p>
<pre><code>$.get(url,callback);    发送get请求
$.post(url,data,callback);   发送post请求
$.getJSON(url,callback);    发送JSON请求‘
$.load(url);       加载
$.getScript(url.callback);
$.ajax({})   全能
    全能使用方法
    ajax({
        type:&quot;GET&quot;        请求方式post,pub,delete
        url:&quot;  url&quot;        请求地址
        data:&quot;{---:--,--:--}&quot;
            请求服务器数据
        beforeSend:fn
            请求消息发送前调用函数
        success:fn
            响应完成并且成功调用函数
        error:fn
            响应完成但是有问题的调用函数
        complete:fn
            响应完成但是无论成功与否都调用函数
    })
</code></pre><p>开发项目</p>
<pre><code>开发流程
    需求说明书---技术经理，美工
    剪切图片集---UI
    静态网页----前端
    动态网页---后端
    部署服务器----运维
    测试---------功能
    上线-----
    调试---加新功能--升级
</code></pre><p>针对cookie作了解</p>
<pre><code>添加
    document.cookie = &apos;uid=10&apos;;
    document.cookie = &apos;uname=qiangdong&apos;;

读取
    function getCookieVal(key){
            //  [&quot;uid=10&quot;,&quot;uname=qiangdong&quot;]
        var rs = null;
            //1:创建变量保存最终返回结果值
        var line = document.cookie;
        var arr = line.split(&quot;;&quot;);
            //2:按照;拆分cookie中字符串
        for(var i=0;i&lt;arr.length;i++){
            //3:循环数组中每一个键值
            var kv = arr[i];
            var option = kv.split(&quot;=&quot;);
            //4:按照=拆分
            var k = option[0].trim();
            //5:下标0 k  ---  trim()去除字符串前后空格
            var v = option[1];
            //6:下标0 v
            if(key===k){
                //7:判断如果参数中指定
                key == k
                return v;
                //8:返回v
            }
        }
        return rs;
        //9:否则返回 null
    }
     var rs = getCookieVal(&quot;uid&quot;);    //调用函数
         console.log(rs);
     var rs = getCookieVal(&quot;uname&quot;);
         console.log(rs);
     var age = getCookieVal(&quot;age&quot;);
         console.log(age);
</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;添加用户方法 grant&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;gt;grant select,insert,update,delete,create,drop
&amp;gt;on tutorials.*
&amp;gt;to &amp;apos;zara&amp;apos;@&amp;apos;localhost&amp;
    
    </summary>
    
      <category term="学习笔记" scheme="www.wangchengzou.cn/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="MySql" scheme="www.wangchengzou.cn/tags/MySql/"/>
    
      <category term="PhP" scheme="www.wangchengzou.cn/tags/PhP/"/>
    
      <category term="Ajax" scheme="www.wangchengzou.cn/tags/Ajax/"/>
    
  </entry>
  
  <entry>
    <title>Vue快速上手知识</title>
    <link href="www.wangchengzou.cn/2017/07/22/Vue%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B%E7%9F%A5%E8%AF%86/"/>
    <id>www.wangchengzou.cn/2017/07/22/Vue快速上手知识/</id>
    <published>2017-07-22T15:48:26.000Z</published>
    <updated>2017-07-23T15:38:48.212Z</updated>
    
    <content type="html"><![CDATA[<p>1、基本绑定：</p>
<pre><code>new Vue(
    {
        el:&apos;#elID&apos;,
        data:{
            // data obj
        },
        computed:{
            // computed obj
        },
        methods:{
            // methods obj
        },
    }
);
</code></pre><p>2、指令：</p>
<pre><code>前缀为v-
*v-if, v-for, v-bind, v-on...
*特性插值会转为v-bind绑定: href=&apos;{{url}}&apos; --&gt; v-bind:href=&apos;url&apos;
</code></pre><p>3、数据绑定只接受单个表达式：</p>
<pre><code>{{number+1}}                                    ok
{{ok?'yes':'no'}}                                ok
{{message.split('').reverse().join('')}}        ok
{{var a=1}}                                        no
{{if(ok){return message}}}                        no
</code></pre><p>4、过滤器：</p>
<pre><code>管道式的写法 --&gt; {{message|capitalize}}
*可以串联: filterA|filterB
*可以带参数: filterA &apos;arg1&apos; arg2
</code></pre><p>5、修饰符</p>
<pre><code>前缀为.
*v-bind:href.literal=&apos;a/b/c&apos;
</code></pre><p>6、缩写</p>
<pre><code>v-bind:href=&apos;url&apos; --&gt; :href=&apos;url&apos;
v-on:click=&apos;dosomething&apos; --&gt; @click=&apos;dosomething&apos;
</code></pre><p>7、计算setter</p>
<pre><code>computed:{
    fullName:{
        get:function(){
            // getter
        }
        set:function(newValue){
            //setter
        }
    }
}
</code></pre><p>8、Class与Style绑定</p>
<pre><code>*变量语法：v-bind:class=&quot;{&apos;class-a&apos;:isA, &apos;class-b&apos;:isB}&quot;
 --&gt;        data:{isA:true, isB:false}
*对象语法：v-bind:class=&quot;classObj&quot;
--&gt;        data:{classObj:{&apos;class-a&apos;:true, &apos;class-b&apos;:false}}
*数组语法：v-bind:class=&apos;[classA, classB]&apos;
 --&gt;        data:{classA:&apos;class-a&apos;, classB:&apos;class-b&apos;}
</code></pre><p>9、条件渲染</p>
<pre><code>*v-if, v-show, v-else
*&lt;h1 v-if=&quot;ok&quot;&gt;Yes&lt;/h1&gt; &lt;h1 v-else&gt;No&lt;/h1&gt;
*&lt;h1 v-show=&quot;ok&quot;&gt;Yes&lt;/h1&gt; &lt;h1 v-else&gt;No&lt;/h1&gt;
*show只是简单的display:none
</code></pre><p>10、列表渲染</p>
<pre><code>v-for
*内置变量：{{$index}}
*用法：v-for=&apos;item in items&apos;
       v-for=&apos;(index, item) in items&apos;    *数组则是索引，遍历对象则是键
</code></pre><p>11、数组变动检测</p>
<pre><code>能触发视图更新的方法：
*push, pop, shift, unshift, splice, sort, reverse
// 变异方法
*filter, concat, slice
// 替换数组
*尽可能复用DOM: track-by
    v-for=&quot;item in items&quot; track-by=&quot;_uid&quot;
    track-by=&apos;$index&apos;
    // 根据index追踪，不是很明白！...片段不被移动，
    // 简单地已对应索引的新值刷新,也能处理数据数组中重复的值...

不能检测到以下变化：
    1.直接用索引设置元素：    vm.items[0]={};
    // vue解决方案：vm.items.$set(0, { childMsg: &apos;Changed!&apos;}),
                    vm.items.$remove(item)
    2.修改数据的长度：        vm.items.length=0;
    // js中常见的清空, vue解决方案：直接用空数组替换
</code></pre><p>12、对象v-for</p>
<pre><code>内置变量：$key
</code></pre><p>13、值域v-for</p>
<pre><code>&lt;span v-for=&quot;n in 10&quot;&gt;{{ n }}&lt;/span&gt;
</code></pre><p>14、内置的过滤器</p>
<pre><code>filterBy 和 orderBy
</code></pre><p>15、方法与事件处理器</p>
<pre><code>·v-on 监听DOM事件
    &lt;button v-on:click=&quot;greet&quot;&gt;&lt;/button&gt;
    &lt;button v-on:click=&quot;greet(&apos;xx&apos;, $event)&quot;&gt;&lt;/button&gt;
    // 内联语句处理器, $event为内置变量，原生的DOM事件
·事件修饰符
    &lt;a v-on:click.stop.prevent=&apos;doThis&apos; /&gt;
    // 阻止冒泡和默认行为，修饰符可以串联
·按键修饰符
    &lt;input v-on:keyup.13=&apos;submit&apos; &gt;
    // 键盘事件后面可接keyCode
    常见的按键有提供别名：
        ·enter
        ·tab
        ·delete
        ·esc
        ·space
        ·up
        ·down
        ·left
        ·right
</code></pre><p>16、表单控件绑定</p>
<pre><code>·v-model绑定字段
    &lt;input type=&quot;checkbox&quot; id=&quot;checkbox&quot; v-model=&quot;checked&quot;&gt;
    // 绑定的值通常是静态字符串，勾选框是布尔值
·参数特性
    lazy        // 延迟到change事件中同步(原为input)
    number        // 仅允许输入数字
    debounce    // 延时同步
</code></pre><p>17、过渡</p>
<pre><code>典型的过渡：
    &lt;div v-if=&quot;show&quot; transition=&quot;expand&quot;&gt;&lt;/div&gt;
    需要添加CSS样式：
        .expand-transition(必须), .expand-enter, .expand-leave
        *如果未设置, 默认为.v-transition, .v-enter, .v-leave
    同时提供钩子：
        Vue.transition(&apos;expand&apos;,{...});
        ·beforeEnter, enter, afterEnter, enterCancelled,
        beforeLeave, leave, afterLeave, leaveCancelled
    渐近过渡：
        &lt;div v-for=&apos;list&apos; transition stagger=&apos;100&apos;&gt;&lt;/div&gt;
        *钩子stagger, 延时过渡
</code></pre><p>18、组件</p>
<pre><code>·创建组件：        var c = Vue.extend({
                    template:&apos;&lt;div&gt;A custom component!&lt;/div&gt;&apos;,
                });
·注册组件:        Vue.component(&apos;my-component&apos;, c);
// 如果名字是myComponent, html中必须写成my-component
·使用组件：        &lt;div id=&apos;app&apos;&gt;&lt;my-component&gt;&lt;/my-component&gt;&lt;/div&gt;
// html
                new Vue({el:&apos;#app&apos;});
                // js

*注册可缩写为    vue.component(&apos;my-component&apos;,{
                    template:&apos;&lt;div&gt;A custom component!&lt;/div&gt;&apos;,
                });
局部注册：
    var c = Vue.extend({});
    var parentComponent = Vue.extend({
        components:{
            &apos;my-component&apos;: c,
        }
    });
组件选项：
    var c = Vue.extend({
        data:function(){
            return {a:1};
        }
    });

is特性：
    *table中限制其他的节点不能放置其中
    &lt;table&gt;
        &lt;tr is=&apos;my-component&apos;&gt;&lt;/tr&gt;
    &lt;/table&gt;

Props:
    props用以从父组件接收数据:
        使用：
            Vue.component(&apos;child&apos;,{
                props:[&apos;msg&apos;],
                template:&apos;&lt;span&gt;{{msg}}&lt;/span&gt;&apos;
            });
        声明：
            &lt;child msg=&apos;hello!&apos;&gt;&lt;/child&gt;            // 字面量语法
            &lt;child v-bind:msg=&apos;parentMsg&apos;&gt;&lt;/child&gt;    // 动态语法
        *如果props是myMsg, html中需要用my-msg
        (即：camelCase - kebab-case, 因为html的特性是不区分大小写)
        *字面量和动态语法稍有不同
            &lt;comp some-prop=&quot;1&quot;&gt;&lt;/comp&gt;        // 传递了一个字符串 &quot;1&quot;
            &lt;comp :some-prop=&quot;1&quot;&gt;&lt;/comp&gt;    // 传递实际的数字

Props绑定类型：
    &lt;child :msg=&quot;parentMsg&quot;&gt;&lt;/child&gt;        // 默认为单向绑定
    &lt;child :msg.sync=&quot;parentMsg&quot;&gt;&lt;/child&gt;    // 双向绑定
    &lt;child :msg.once=&quot;parentMsg&quot;&gt;&lt;/child&gt;    //单次绑定
    *如果prop是一个对象或数组，是按引用传递。不管使用哪种绑定方式，都将是双向绑定

Props验证：
    props:{            // 此时props是一个对象
        propA: Number,
        propB:{
            type: String,
            // 类型(原生构造器：String, Number, Boolean, Function, Object, Array)
            required: true,
            // 是否必须项
            default: &apos;thyiad&apos;,
            // 默认值(如果是Object, 默认值需由一个函数返回)
            validator: function(value){
            // 验证
                return value === &apos;thyiad&apos;;
            },
            coerce:function(val){
                return val+&apos;&apos;;
                // 将值强制转换为字符串
                return JSON.parse(val);
                // 将JSON字符串转换为对象
            }
        }
    }

父子组件通信：
    this.$parent        // 子组件访问父组件
    this.$root            // 访问根实例
    this.$children        // 父组件的所有子元素
    *不建议在子组件中修改父组件的状态

自定义事件：
    $on()                // 监听事件
    $emit()                // 触发事件
    $dispatch()            // 派发事件，沿着父链冒泡
    $broadcast()        // 广播事件, 向下传递给所有的后代
    使用：
        子组件中绑定函数派发事件：
            methods:{
                notify:function(){
                    this.$dispatch(&apos;child-msg&apos;,this.msg);
                }
            }
        父组件中定义事件：
            events:{
                &apos;child-msg&apos;:function(msg){
                    this.messages.push(msg);
                }
            }
        *更直观的声明方式：
            &lt;child v-on:child-msg=&apos;handleIt&apos;&gt;&lt;/child&gt;
            // 直观的为父组件定义事件(child-msg), 并且触发父组件的handleIt函数, 子组件只关注触发事件

子组件索引：
    &lt;child v-ref:profile&gt;&lt;/child&gt;
    var child = parent.$refs.profile;

使用Slot分发内容：
    单个Slot:
        父组件的内容将被抛弃，除非子组件包含&lt;slot&gt;.
        如果只有一个没有特性的slot, 整个内容将被插到它所在的地方, 替换slot.
            父组件：
            &lt;child&gt;
                &lt;p&gt;parent content&lt;/p&gt;
            &lt;/child&gt;
            子组件模板：
            &lt;div&gt;
                &lt;h1&gt;child content&lt;/h1&gt;
                &lt;slot&gt;
                    如果父节点没有设置内容，这里才会被显示
                &lt;/slot&gt;
            &lt;/div&gt;
    命名Slot：
        父组件模板：
            &lt;child&gt;
                &lt;p slot=&apos;one&apos;&gt;One&lt;/p&gt;
                &lt;p slot=&apos;two&apos;&gt;two&lt;/p&gt;
                &lt;p&gt;Default A&lt;/p&gt;
            &lt;/child&gt;
        子组件模板：
            &lt;div&gt;
                &lt;slot name=&apos;one&apos;&gt;&lt;/slot&gt;
                &lt;slot&gt;&lt;/slot&gt;
                // 默认slot, 找不到匹配内容的回退插槽, 如果没有默认的slot, 不匹配内容将被抛弃
                &lt;slot name=&apos;two&apos;&gt;&lt;/slot&gt;
            &lt;/div&gt;

    动态组件：
        可以在不同组件之间切换：
            new Vue({
                el:&apos;body&apos;,
                data:{
                    currentView:&apos;home&apos;,
                },
                components:{
                    home:{},
                    posts:{},
                    archive:{},
                }
            });
            父组件：
                &lt;component :is=&apos;currentView&apos; keep-alive&gt;&lt;/component&gt;
                // component是Vue保留的元素
                *keep-alive用来把切换出去的组件保留在内存中, 可以保留它的状态避免重新渲染
        activate钩子：
            用以在切入前做一些异步操作：
                activate:function(done){
                    var self = this;
                    loadDataAsync(function(data){
                        self.someData=data;
                        done();
                    });
                }
        transition-mode
            指定列两个动态组件之间如何过渡：
                &lt;component :is=&apos;currentView&apos; transition=&apos;fade&apos; transition-mode=&apos;out-in&apos;&gt;&lt;/component&gt;
                *默认进入与离开平滑地过渡, 可以指定另外两种模式：in-out, out-in (先进入or先离开)

    组件和v-for:
        &lt;child v-for=&apos;item in items&apos; :item=&apos;item&apos; :index=&apos;$index&apos;&gt;&lt;/child&gt;
        *因为组件的作用域是孤立的, v-for里的item无法直接传递给组件, 必须像上面一样使用props传递数据

    异步组件
    资源命名约定
    递归组件
    片段实例
        *推荐模板只有一个根节点(使用template选项时)
    内联模板
        组件把它的内容当做它的模板
        &lt;child inline-template&gt;&lt;/child&gt;
        *不推荐
</code></pre><p>19、深入响应式原理</p>
<pre><code>·如何追踪变化
    *使用Object.defineProperty设置getter/setter
·变化检测问题
    *不能检测到对象属性的添加或删除
    *vm.$set(&apos;b&apos;, 2);
     Vue.set(object, key, value);
·初始化数据
    *推荐在data对象上声明所有的响应属性
·异步更新队列
    *默认异步更新DOM, 下次事件循环时清空队列, 执行必要的DOM更新
    *Vue.nextTick(callback);
·计算属性的秘密
    *计算属性是有缓存的, 除非显示设置为不缓存
        computed:{
            attr:function(){
                return Date.now()+this.msg;
            }
        }
        TO:
        computed:{
            attr:{
                cache: false,
                get: function(){
                    return Date.now()+this.msg;
                }
            }
        }
        *但只是在JS中访问是这样的, 数据绑定仍是依赖驱动的。
</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;1、基本绑定：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;new Vue(
    {
        el:&amp;apos;#elID&amp;apos;,
        data:{
            // data obj
        },
        computed:{

    
    </summary>
    
      <category term="学习笔记" scheme="www.wangchengzou.cn/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Vue，App" scheme="www.wangchengzou.cn/tags/Vue%EF%BC%8CApp/"/>
    
  </entry>
  
  <entry>
    <title>bootStrap基础知识</title>
    <link href="www.wangchengzou.cn/2017/07/22/bootStrap/"/>
    <id>www.wangchengzou.cn/2017/07/22/bootStrap/</id>
    <published>2017-07-22T15:48:26.000Z</published>
    <updated>2017-07-23T13:23:05.120Z</updated>
    
    <content type="html"><![CDATA[<p>webstorm<br>    lorem 随机测试文本</p>
<p>1、响应式网页</p>
<pre><code>responsive web page  一个页面可以在电脑浏览器中浏览也可以在手机平板中浏览，并且配合不同设备有不同的响应结果
响应式网页特点：
    页面上的图片和文字要随着屏幕尺寸发生改变
    页面的布局随着屏幕尺寸而发生改变
如何测试响应式网页
    使用真实的物理设备
        优势：测试结果真实
        不足：设备太多，成本太大，测试任务量大
        方法：搭建本地服务器，部署项目 ，移动终端与服务接入相同网络
    使用三方模拟设备
        优势：无须添加更多设备
        不足：效率偏低，加载慢
    使用浏览器自带模拟器（emulator）
        优势：功能丰富
        不足：****
视口-viewport
    IOS中的safari最早引入的概念
    移动设备中，浏览器里显示网页的一块区域（Pc端会忽略）
    对于响应式网页，设置视口的信息：
        视口的宽度：要与设备宽度一致
        视口的缩放倍率：设置为1，即为不缩放
        视口的手动缩放：不允许缩放网页
    在html中指定视口信息：
        &lt;meta name=&quot;viewport&quot; content=&quot; &quot;&gt;
            视口的宽度：width
                取值：device-width
                     具体数值
            视口的初始缩放倍率：initial-scale
                取值：1  原始大小
            视口是否允许手动缩放：user-scalable
                取值：1、0、yes、no
        &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width,initial-scale=1,user-scalable=no&quot;&gt;
        快键--meta:vp
        以上代码，移动端必备！！！！
</code></pre><p>2、如何编写响应式网页</p>
<pre><code>必须声明视口
文字必须使用相对尺寸（em/rem），尽量不用绝对尺寸(px)
    css中的1px并不代表真实物理设备的1px
    EM    :父元素字体大小倍数
    REM  ：根元素字体大小倍数
容器元素使用相对尺寸（%，auto），尽量不用绝对尺寸(px)
图片使用相对尺寸（%,auto）,尽量不用绝对尺寸（px）
页面元素使用流式布局
    流式布局特点：
        元素默认靠向容器的左上方
        横向排列，排列不下则换行
    方法：float 浮动
         display:inline-block; 行内块
响应式网页都要使用CSS3 Media Query技术，最重要
</code></pre><p>3、CSS3 Media Query</p>
<pre><code>作用：可以根据不同的媒体类型以及特性执行不同的css
    Media:媒体，指浏览网页设备的类型，
        如：screen(pc/pad/phone),tv,tty
    语法：通过@media 规则进行声明
        @media MEDIA-TYPE and|not|only (MEDIA-FEATURE)
        MEDIA-TYPE:媒体类型
            取值：all 默认值，所有设备
                 screen ：电脑屏幕，智能手机 平板电脑
                 tv     :电视设备
        MEDIA-FEATURE:媒体特性
            取值：width:指定浏览器窗口大小
                 min-width:指定浏览器窗口宽度的最小值
                 max-width:指定浏览器窗口宽度的最大值
@media用法：
    有选择性的执行某个外部CSS文件
    &lt;link rel=&quot;&quot; href=&apos;&quot; media=&quot;screen&quot;&gt;
    &lt;link rel=&quot;&quot; href=&quot;&quot; media=&quot;screen&quot;and(max-width:px)&gt;
        不足：即使不满足当前设备条件的css文件也会被请求，但不会生效
    有选择性执行CSS片段中的内容
        在样式表中 @media screen and(max-width:px){
                        选择器{属性：值}
                    }
常见屏幕尺寸：
    超小屏幕（Extra Small:xs）
        width&lt;=767px
    小型屏幕（Small: sm）
        768&lt;=width&lt;=991px
    中型屏幕（Medium:md）
        992&lt;=width&lt;=1199px
    大型屏幕(Large:lg)
        width&gt;=1200px

大公司成型的大型框架（BOOT STRAP）开发公司Twitter
    官网：http://getbootstrap.com
    中文官网:http://www.bootcss.com
    重点： bootstrap.css   提供了上千个class  依赖于JS库-jquery
</code></pre><p>4、 bootstrap 第一步 起步</p>
<pre><code>基本模板：
    &lt;html lang=&quot;zh-cn&quot;&gt; 指定当前文件的基础语言
        作用：为浏览器的自动翻译功能指定语言基础
             为读屏软件指定基础发音
    &lt;meta name=&quot;viewport&quot;&gt;  必须
    &lt;meta http-equiv=&quot;x-ua-compatible&quot; content=&quot;ie=edge&quot;&gt;
        x-ua-compatible
            cross useragent compatible 跨（IE）浏览器兼容性
                指定用哪个IE的内核进行页面渲染
            IE=6  指定用IE6内核渲染页面
            IE=7  ...
            ..
            IE=edge  采用IE最新内核渲染页面
    两个Js 必须引用
          html5shiv.min.js  第三方的JS 自调函数，用于让老IE支持html5新标记（IE8以下）
          respond.min.js    第三方的JS 自调函数，用于让老IE支持CSS3媒体查询技术，响应式必备
          通过头部引用HACK判断是否为IE8以下的浏览器
              &lt;!--[if lt IE 9]&gt;
                 &lt;script src=&quot;***.js&quot;&gt;&lt;/script&gt;
             &lt;![endif]--&gt;
    两个JS 引用页面
        jquery.js  引入到页面中（先）
        bootstrap.js 引入到页面中（后）
        建议:尽量将以上两个文件放在页面最底端引入
</code></pre><p>5、 bootstrap 第二步， 全局CSS样式</p>
<pre><code>BOOTSTRAP 默认将屏幕分成四大类
    大型PC屏幕LG  width:1200px
    中型PC屏幕md  1199--992px
    小型PAD屏幕SM  768---991px
    超小型phone屏幕xs width:767px
bootstrap 提供两种容器
    定宽容器
    在大小不同的设备上，提供不同的width固定值
    类：container
        lg:width:1170px
        md:width:970px
        sm:width:750px
        xs:width:100%
变宽容器
    在任何设备中，宽度都是100%
    类：container-fluid
        width:100%
</code></pre><p>6、 bootstrap 按钮</p>
<pre><code>.btn
.btn-default 白底深色字
.btn-danger/success/warning/info/primary   五种不同颜色按钮
.btn-lg/sm/xs   几种大小按钮
.btn-block     块级按钮
</code></pre><p>7、 bootstrap 列表</p>
<pre><code>.list-unstyled 不带标识的列表
.list-inline   行内列表
.dl-horizontal 定义列表
</code></pre><p>8、 bootstrap 图像图片</p>
<pre><code>.img-rounded        圆角边框图像
.img-circle            圆形边框图像
.img-thumbnail        带几像素内边距边框图像缩进图片
.img-responsive     响应式布局图片
</code></pre><p>9、 bootstrap 表格</p>
<pre><code>.table
.table-bordered        带边框表格
.table-striped        隔行变色
.table-hover        悬停突出效果
.table-responsive    响应式表格   需要加在表格父元素
</code></pre><p>10、 bootstrap 文本和排版</p>
<pre><code>文本颜色
.text-danger
.text-success
.text-warning
.text-info
.text-primary
文本背景颜色
.bg-danger
.bg-success
.bg-warning
.bg-info
.bg-primary
文本大小写
.text-uppercase     全大写
.text-lowercase        全小写
.text-capitalize    首字母大写
文本对齐方式
.text-left
.text-center
.text-right
浮动
.pull-left        左浮动
.pull-right        右浮动
.clearfix        清浮动
</code></pre><p>11、 bootstrap 栅格布局</p>
<pre><code>table 布局
    好处:简单，容易控制
    不足:效率低
div+css 布局
    好处：效率高，
    不足：太灵活，不易控制
栅格布局
    好处：效率高 易控制轻松实现响应式
    不足：。。。。
    实际上就是由div组成的table样式的响应式结构
使用方法：
    系统最外层，必须是bootstrap提供的容器
        .container  .container-fluid
    允许在容器中放置若干行  div.row
        每行中最多等分为12列
    行中放置 div.col 即列，每列都需要指定宽度 1/12 n/12
        语法：&lt;div class=&quot;container&quot;&gt;
                &lt;div class=&quot;row&quot;&gt;
                    &lt;div class=&quot;col-*-*&quot;&gt;&lt;/div&gt;
                &lt;/div&gt;
            &lt;/div&gt;

    列 根据适用屏幕分成四个类型        N最大12列宽
        .col-xs-n   在超小屏幕中占N列宽
        .col-sm-n   在小型屏幕中占N列宽
        .col-md-n      在中型屏幕中占N列宽
        .col-lg-n   在大型屏幕中占N列宽
    列偏移数量
        每个列都可以指定向右偏移几列数量
        .col-xs-offset-n       在超小屏幕中当前列向右偏移N列距离
        .col-sm-offset-n
        .col-md-offset-n
        .col-lg-offset-n


    栅格布局系统可以嵌套
        .container&gt;.row.col-*_*&gt;.row&gt;.col-*-*

    适用于不同屏幕的列的class(xs/sm/md/lg)可以兼容更大的屏幕
        大屏幕class不能适应小屏幕  会垂直显示
        小屏幕class可适应大屏幕

    可以在一个div中指定在不同屏幕下的宽度占比
        &lt;div class=&quot;col-xs-9 col-sm-6 col-md-3&quot;&gt;&lt;/div&gt;

    指定列在特定屏幕下不显示
        .hidden-lg  在lg下隐藏
        .hidden-md
        .hidden-sm
        .hidden-xs
</code></pre><p>12、 全局样式  表单</p>
<pre><code>默认表单
    .form-group            定义表单控件组
    .form-control        定义表单控件
    .control-label        定义控件对应的label
    .help-block            定义提示文本

行内表单
    为&lt;form&gt;添加class=&quot;form-inline&quot;其它同上

水平表单
    水平表单=表单+栅格布局系统
    栅格：最外层：.container/.container-fluid
         行：.div.row
         列：.div.col-*-*

    水平表单栅格系统
        最外层：form.form-horizontal/.container
        行：div.form-group/div.row
        列：div.col-*-*
</code></pre><p> bootstrap</p>
<p> 13、    下拉菜单</p>
<pre><code>&lt;select&gt; &lt;option&gt;&lt;/option&gt;&lt;/select&gt;

外层必须是.dropdown/.dropup  或position:relative;
内层：为&lt;button&gt;或&lt;a&gt;
    class=“dropdown-toggle”
    data-toggle=&quot;dropdown&quot;        切换内容和隐藏
内层内容：ul 或 div 来组成
    class=&quot;dropdown-menu&quot;

    li.divider:      分割线效果
    li.disabled:    禁用菜单项
    li.dropdown-header    标题
</code></pre><p> 14、导航菜单</p>
<pre><code>标签页式导航
    &lt;ul class=&quot;nav nav-tabs&quot;&gt;
        &lt;li class=&quot;active&quot;&gt;
            &lt;a href=&quot;#&quot; data-toggle=&quot;tab&quot;&gt;...&lt;/a&gt;
        &lt;/li&gt;
    &lt;/ul&gt;
li.active        默认被激活
li.data-toggle=&quot;data&quot;    允许切换并且指定切换方式
</code></pre><p>15、图标字体</p>
<pre><code>在页面中，显示为图标，本质上是文字，可以设置字体，颜色，大小
在web程序中常用的图标字体：
    giyphicons 字体，收费中，
    fontawesome  免费

由于客户端不具备bootstrap中的图标字体，所以使用自定义的图标字体，必须声明
在服务器端做以下操作：
    ***.css
    声明字体
    @font-face{font-family:名称： src:url(地址)}
    对使用字体图标的选择器进行声明
    .glyphicon{ font-family:&quot;名称&quot;}

使用方法：    必须为空元素
    &lt;span class=&quot;glyphicon glyphicon-**&quot;&gt;&lt;/span&gt;
</code></pre><p>16、按钮组</p>
<pre><code>将多个按钮放在一个组中（btn-group）
    &lt;div&gt; class=&quot;btn-group&quot;
        &lt;button class=&quot;btn btn-deftult&quot;&gt;***&lt;/button&gt;
        &lt;button class=&quot;btn btn-deftult&quot;&gt;***&lt;/button&gt;
        &lt;button class=&quot;btn btn-deftult&quot;&gt;***&lt;/button&gt;
        &lt;button class=&quot;btn btn-deftult&quot;&gt;***&lt;/button&gt;
    &lt;/div&gt;
将一组btn-group 组合进一个.btn-boolbar(按钮工具栏)
按钮组尺寸
    .btn-group 增加.btn-group-** lg/md/sm/xs
两端对齐按钮组
    .btn-group .btn-group-justified
垂直放置的按钮组
    .btn-group-vertical
</code></pre><p>17、警告框</p>
<pre><code>允许将任意字符与可选的关闭按钮组合在一起的结构
所有警告框依赖于.alert
.alert
.alert-warning
...
...

允许关闭的警告框
    .alert-dismissible
    &lt;div class=&quot;alert alert-danger alert-dismissible&quot;&gt;
        lorem
        &lt;button class=&quot;close&quot; data-dismiss=&quot;alert&quot;&gt;&amp;times;&lt;/button&gt;
    &lt;/div&gt;
警告框中的链接
    &lt;a class=&quot;alert-link&quot;&gt;&lt;/a&gt;
</code></pre><p>18、面包屑导航/路径导航</p>
<pre><code>.breadcrumb
&lt;ul class=&quot;breadcrumb&quot;&gt;
    &lt;li&gt;
        &lt;a href=&quot;#&quot;&gt;首页&lt;/a&gt;
    &lt;/li&gt;
    &lt;li&gt;
        &lt;a href=&quot;#&quot;&gt;产品大全&lt;/a&gt;
    &lt;/li&gt;
&lt;/ul&gt;
</code></pre><p>19、分页条</p>
<pre><code>.pagination
.active : 被激活的页码
&lt;ul class=&quot;pagination&quot;&gt;
    &lt;li&gt;
        &lt;a href=&quot;#&quot;&gt;上一页&lt;/a&gt;
    &lt;/li&gt;
    &lt;li&gt;
        &lt;a href=&quot;#&quot;&gt;1&lt;/a&gt;
    &lt;/li&gt;
    &lt;li class=&quot;active&quot;&gt;
        &lt;a href=&quot;#&quot;&gt;2&lt;/a&gt;
    &lt;/li&gt;
    &lt;li&gt;
        &lt;a href=&quot;#&quot;&gt;...&lt;/a&gt;
    &lt;/li&gt;
    &lt;li&gt;
        &lt;a href=&quot;#&quot;&gt;下一页&lt;/a&gt;
    &lt;/li&gt;
&lt;/ul&gt;
</code></pre><p>20、分页器</p>
<pre><code>.pager
&lt;ul class=&quot;pager&quot;&gt;
&lt;/ul&gt;
</code></pre><p>21、标签</p>
<pre><code>所有的标签都依赖于 .label
.label
.label-default
.label-danger
.label-success
...
&lt;span class=&quot;label label-danger&quot;&gt;标签内容&lt;/span&gt;
</code></pre><p>22、徽章</p>
<pre><code>.badge
&lt;span class=&quot;badge&quot;&gt;35&lt;/span&gt;
</code></pre><p>23、巨幕</p>
<pre><code>.jumbotron
</code></pre><p>24、页头</p>
<pre><code>允许为 标题元素 增加适当的空间,与其他元素有一定的间隔
.page-header
</code></pre><p>25、Well (水井)</p>
<pre><code>.well
</code></pre><p>26、进度条</p>
<pre><code>外层：.progress
内层：
    .progress-bar
    .progress-bar-danger
    .progress-bar-success
    ...
    .progress-bar-striped
    .active : 被激活的
    通过 给内层元素 增加 style=&quot;width:50%&quot; 增加宽度
</code></pre><p>27、缩略图</p>
<pre><code>.thumbnail
.caption
&lt;div class=&quot;thumbnail&quot;&gt;
    &lt;img&gt;
    &lt;div class=&quot;caption&quot;&gt;
        &lt;p&gt;文本1&lt;/p&gt;
        &lt;p&gt;文本2&lt;/p&gt;
        &lt;p&gt;按钮&lt;/p&gt;
    &lt;/div&gt;
&lt;/div&gt;
</code></pre><p>28、媒体对象</p>
<pre><code>&lt;div class=&quot;media&quot;&gt;
    &lt;div class=&quot;media-left&quot;&gt;
        &lt;img&gt;
    &lt;/div&gt;
    &lt;div class=&quot;media-body&quot;&gt;
        &lt;h2 class=&quot;media-heading&quot;&gt;标题&lt;/h2&gt;
        形容的文本
    &lt;/div&gt;
    &lt;div class=&quot;media-right&quot;&gt;
        &lt;img&gt;
    &lt;/div&gt;
&lt;/div&gt;
</code></pre><p>29、列表组</p>
<pre><code>ul : class=&quot;list-group&quot;
li : class=&quot;list-group-item&quot;
</code></pre><p>30、面版</p>
<pre><code>呈现头部 主体 尾部 结构的组件
&lt;div class=&quot;panel panel-default panel-primary&quot;&gt;
    &lt;div class=&quot;panel-heading&quot;&gt;
        &lt;h2 class=&quot;panel-title&quot;&gt;标题文本&lt;/h2&gt;
    &lt;/div&gt;
    &lt;div class=&quot;panel-body&quot;&gt;
        主体内容
    &lt;/div&gt;
    &lt;div class=&quot;panel-footer&quot;&gt;
        脚注内容
    &lt;/div&gt;
&lt;/div&gt;
</code></pre><p>31、导航条</p>
<pre><code>基本导航条
    .navbar .navbar-default
    有需要的话允许增加div.container
    .navbar-header,内部允许包含class带有.navbar-brand&lt;a&gt;元素
    允许向导航条中添加链接列表，只需要增加
导航条中的表单
    导航中的表单不适用bootstrap中默认class使用时.navbar-form,配合.navbar-left/.navbar-right
导航条中的按钮
    class.navbar-btn 允许向不在form中的button(a)增加样式
导航条中的文本
    普通文本的话，需要增加class.navbar-text属性来设置样式
组件的对齐方式
    允许通过.navbar-left 实现左浮动
    允许通过.navbar-right 实现右浮动
导航栏的固定
    不会随着滚动条发生滚动，一直在可视化区域中
    固定在页面顶端：.navbar-fixed-top
    固定在页面底端：.navbar-fixed-bottom
    注意：最好为body设置内边距至少50px
</code></pre><p>32、 JS插件plugin</p>
<pre><code>Bootstrap 基于 jQuery ，在jQuery 基础上提供了十几个插件函数，
        每个都是一个独立的JS文件,可以一次性引入全部的JS操作 - bootstrap.js
每个插件函数都有两种调用方式：
1、data-* 方式调用
    &lt;a data-toggle=&quot;dropdown&quot;&gt;&lt;/a&gt;
2、JS编程方式
    手动编写JS代码完成行为的调用
    &lt;script&gt;
        $(&quot;选择器&quot;) : 在 Javascript(jQuery) 中获取页面指定选择器的元素
            $(&quot;#id&quot;)
            $(&quot;.class&quot;)
            $(&quot;div p&quot;)
        下拉列表：
         $(&quot;选择器&quot;).dropdown();
    &lt;/script&gt;
3、警告框
    父元素 class =&quot;alert alert-danger alert-dismissible&quot;
    关闭：&lt;button class=&quot;close&quot; data-dismiss=&quot;alert&quot;&gt;&lt;/button&gt;
    JS :
        $(&quot;关闭选择器&quot;).click(function(){
            $(this).alert(&quot;close&quot;);
        });
4、按钮
    1、设置按钮的操作文本
        为 按钮元素 添加 data-loading-text=&quot;显示的文本&quot;
        &lt;button class=&quot;btn btn-default&quot; data-loading-text=&quot;请稍后....&quot;&gt;文本&lt;/button&gt;

        //点击按钮时，改变按钮的文字为 data-loading-text
        $(&quot;按钮选择器&quot;).click(function(){
            $(this).button(&quot;loading&quot;);
        });


    2、设置 单选按钮 / 复选框
        1、将 若干 单选按钮 / 复选框 放到 btn-group中  ， 为btn-group增加属性 data-toggle=&quot;buttons&quot;
5、工具提示
    为元素增加
        data-toggle=&quot;tooltip&quot;
        data-palcement=&quot;top/right/bottom/left&quot;
        title=&quot;提示的文本&quot;
    配合 JS 代码
        $(&quot;选择器&quot;).tooltip();
6、弹出框
    为元素增加
        data-toggle=&quot;popover&quot; //指定为弹出框方式
        data-placement=&quot;top/right/bottom/left&quot;//方向
        data-content=&quot;弹出框内容区域的文本&quot;
        title=&quot;弹出框的标题&quot;;
    配合 JS 代码如下:
        $(&quot;选择器&quot;).popover();
7、标签页
    1、为导航组件里面 a 增加：
        1、data-toggle = &quot;tab&quot;
        2、href=&quot;#对应元素内容的ID&quot;
    2、创建内容组
        1、class 为 tab-content
        2、在 内容组中 增加对应显示的内容模块
            1、增加id属性
            2、增加 class=&quot;tab-pane active&quot;
    ex:
        &lt;div class=&quot;container&quot;&gt;
            &lt;ul class=&quot;nav nav-tabs&quot;&gt;
                &lt;li class=&quot;active&quot;&gt;
                    &lt;a href=&quot;#tab1&quot; data-toggle=&quot;tab&quot;&gt;&lt;/a&gt;
                &lt;/li&gt;
            &lt;/ul&gt;
            &lt;div class=&quot;tab-content&quot;&gt;
                &lt;!-- 内容1 --&gt;
                &lt;div class=&quot;tab-pane&quot; id=&quot;tab1&quot;&gt;
                    ....
                &lt;/div&gt;
            &lt;/div&gt;
        &lt;/div&gt;
8、模态对话框
    模态对话框：父窗口中弹出一个子窗口，只要子窗口不关闭，父窗口就无法获得输入的焦点
    模态对话框由两部分组成：
    1、触发元素，通常 a / button 组成
        &lt;a href=&quot;#模态框ID&quot; data-toggle=&quot;modal&quot;&gt;&lt;/a&gt;

        &lt;button data-toggle=&quot;model&quot; data-target=&quot;#模态框ID&quot;&gt;&lt;/button&gt;
    2、模态框元素
        // 提供了半透明的遮罩层
        &lt;div class=&quot;modal&quot; id=&quot;&quot; data-backdrop=&quot;static&quot;&gt;
            // 提供了 宽度，高度，定位
            &lt;div class=&quot;modal-dialog&quot;&gt;
                //背景色，边框，倒角，阴影
                &lt;div class=&quot;model-content&quot;&gt;
                    &lt;div class=&quot;modal-header&quot;&gt;
                        &lt;h4&gt;&lt;/h4&gt;
                        &lt;button&gt; ... &lt;/button&gt;
                    &lt;/div&gt;
                    &lt;div class=&quot;modal-body&quot;&gt;
                        显示主题内容
                    &lt;/div&gt;
                    &lt;div class=&quot;modal-footer&quot;&gt;
                        脚注信息
                    &lt;/div&gt;
                &lt;/div&gt;
            &lt;/div&gt;
        &lt;/div&gt;
9、折叠效果
    1、触发元素
        &lt;a data-toggle=&quot;collapse&quot; href=&quot;#id&quot;&gt;&lt;/a&gt;

        &lt;button data-toggle=&quot;collapse&quot; data-target=&quot;#id&quot;&gt;&lt;/button&gt;
    2、被折叠元素
        &lt;div class=&quot;collapse&quot; id=&quot;id&quot;&gt;
            ... ...
        &lt;/div&gt;
    特殊效果：
        1、手风琴(Accordion)
            Accordion = 面板组(panel-group) + 折叠插件
</code></pre><p>33、折叠</p>
<pre><code>响应式导航条
    当屏幕尺寸大于768时候，可以正常显示出所有的内容，
    当屏幕尺寸小于768时候一部分内容就会隐藏，通过点击弹出

响应式导航条由两部分组成
    .navbar-head
        用于显示navbar-brand和折叠点击按钮
        .navbar-brand:定义brand内容
        折叠按钮：屏幕大于768不显示
                屏幕小于768显示
                .navbar-toggle完成以上操作

    .navbar-collapse
        被折叠的内容，当屏幕大于768正常显示
                    当屏幕小于768就隐藏
        通过点击按钮完成展开显示
</code></pre><p>34、广告轮播 carousel</p>
<pre><code>基本class
    .carousel    data-ride=&quot;carousel&quot;
        .carousel-inner
            .item
            img
指定轮播时间
    父元素增加.data-interval=&quot;200s&quot;

图片说明文本
    img图片下放div.carousel-caption
        显示在图片正中间

带方向按钮的轮播
    &lt;a herf=&quot;#carousel的ID&quot;
        class=&quot;carousel-control left
        data-slide=&quot;prev&quot; &gt;
        &lt;span class=&quot;glyphicon glyphicon-chevron-left&quot;&gt;&lt;/span&gt;
    &lt;/a&gt;        这是左边
    &lt;a herf=&quot;#carousel的ID&quot;
        class=&quot;carousel-control right
        data-slide=&quot;next&quot; &gt;
        &lt;span class=&quot;glyphicon glyphicon-chevron-right&quot;&gt;&lt;/span&gt;
    &lt;/a&gt;        这是右边

带数字圆点导航的轮播
    &lt;ul class=&quot;carousel-indicators&quot;&gt;
        &lt;li class=&quot;active
            data-target=&quot;#carousel的ID&quot;
            data-slide-to=&quot;数字值&quot;&gt;
        &lt;/li&gt;
</code></pre><p>35、Less 和 Bootstrap 定制</p>
<pre><code>样式语言的分类
    静态样式语言：css
        可以被浏览器直接解析处理，但CSS并不是合格语言，
        缺少了基本的要素，如：变量 运算符 函数
        可维护维护性差
    动态样式语言：less sass、scSS 、stylus
        不可以被浏览器直接解析处理；必须经过编译（compile）得到CSS文件后才能使用

less语言        http://lesscss.org   中文 http://less.bootcss.com
    less是一本预处理语言，扩充了CSS，在纯静态的CSS基础上增加一部分内容 如：变量 混合，

在web项目中使用less的两种方式：
    在客户端浏览器中编译less，不推荐使用
        编写.less文件
        编写.html 引入.less再引入less.js
        浏览器访问.html会自行下载文件，并且在客户端进行编译转换成.css
    在服务器端编译less   推荐使用
        编写.less
        在服务器端搭建less编译器，把.less转换为CSS
        编写HTML直接引入CSS文件

搭建less服务器端编译环境   ！！！
    less编译器实际上是由JavaScript编写
    安装独立的js解释器 node.exe
        命令行中：执行 node -v显示：版本号
    在webstrorm中配置filewatchers（文件监视器）
        由ws自动检测less文件的编写与更改，自动进行编译，得到CSS文件
        配置filewatchers
        ws--&gt;file--&gt;settings--&gt;toos--&gt;filewiathcers
        --&gt;添加选择less--&gt;指定lessc.cmd文件地址
less语法
    less完全支持CSS语法
    less支持多行注释和单选注释，只有多行注释能被编译到CSS中
        多行：/***/
        单选：//注释  只一行
    less支持变量（variable）
        变量：在less中可以变化的数据
        语法：@变量名：值；
        使用变量：变量作为值，出现在CSS属性名称后
            @变量名;
    less变量可以使用运算符 +  - * % /

less支持在一组样式中混入另一种样式 名称为混合（mixin） 嵌套
    带参数的混合：声明选择器的时候，允许使用参数来表示暂时不确定的数据，在调用时将具体数值传递进来
        语法：选择器（@参数名1，@参数名2）{
                        width：@参数名1
                        height：@参数名2
                    }
    使用带参混合写法：
        选择器2{
            选择器（值1，值2）
        }
    使用默认值的混合写法：
        选择器2 (参数名1：默认值，参数名2：默认值){
              选择器（值1，值2）
       }
       当没有设定值时，为默认值输出，有设定值时，为设定值输出

嵌套规则
    在less中，允许在一个选择器内再声明另一个选择器，以便完成父子或后代结构
    语法：选择器1{
            --；
            --；
            选择器2{
                ---；
                ---；
            }
        }
    编译结果为
         选择器1{
             ---；
         }
         选择器1 选择器2{
             ---；
         }

    声明子代嵌套：选择器1{
                       --；
                       --；
                       &gt;选择器2{
                           ---；
                           ---；
                       }
                   }

less中提供的功能函数
    lighten（@color，20%）    返回一个变亮的颜色值(颜色减淡)
    darken(@color，30%)         返回一个变暗的颜色值（颜色加深）
    image-width(&quot;**.jpg&quot;)    返回指定图片的宽度
    image-height(&quot;**.jpg&quot;)    返回指定图片的高度
    ceil（@num）                对数字向上取整 返回四舍五入
    floor（@num）            对数字向下取整
    percentage（@num）        返回小数转换为%数字

@import功能
    在less中的@import，在服务器端将多个less文件内容整合一个less文件中
    语法：  @import&quot;***.less&quot;;
</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;webstorm&lt;br&gt;    lorem 随机测试文本&lt;/p&gt;
&lt;p&gt;1、响应式网页&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;responsive web page  一个页面可以在电脑浏览器中浏览也可以在手机平板中浏览，并且配合不同设备有不同的响应结果
响应式网页特点：
    
    
    </summary>
    
      <category term="学习笔记" scheme="www.wangchengzou.cn/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="bootStrap" scheme="www.wangchengzou.cn/tags/bootStrap/"/>
    
  </entry>
  
  <entry>
    <title>axios使用基础知识</title>
    <link href="www.wangchengzou.cn/2017/07/22/axios/"/>
    <id>www.wangchengzou.cn/2017/07/22/axios/</id>
    <published>2017-07-22T15:48:26.000Z</published>
    <updated>2017-08-02T03:25:25.164Z</updated>
    
    <content type="html"><![CDATA[<p>axios</p>
<p>##基于http客户端的promise，面向浏览器和nodejs</p>
<pre><code>特色
浏览器端发起XMLHttpRequests请求
node端发起http请求
支持Promise API
拦截请求和返回
转化请求和返回（数据）
取消请求
自动转化json数据
客户端支持抵御XSRF（跨站请求伪造）
</code></pre><p>安装</p>
<pre><code>使用npm：

$ npm i axios
使用 bower

$ bower instal axios
使用cdn

&lt;!--国内bootCDN--&gt;
&lt;script src=&quot;https://cdn.bootcss.com/axios/0.16.0/axios.min.js&quot;&gt;&lt;/script&gt;
</code></pre><p>示例</p>
<pre><code>发起一个GET请求
//发起一个user请求，参数为给定的ID
axios.get(&apos;/user?ID=1234&apos;)
.then(function(respone){
    console.log(response);
})
.catch(function(error){
    console.log(error);
});

//上面的请求也可选择下面的方式来写
axios.get(&apos;/user&apos;,{
    params:{
        ID:12345
    }
})
    .then(function(response){
        console.log(response);
    })
    .catch(function(error){
        console.log(error)
    });

发起一个POST请求
axios.post(&apos;/user&apos;,{
    firstName:&apos;friend&apos;,
    lastName:&apos;Flintstone&apos;
})
.then(function(response){
    console.log(response);
})
.catch(function(error){
    console.log(error);
});

发起一个多重并发请求
function getUserAccount(){
    return axios.get(&apos;/user/12345&apos;);
}

function getUserPermissions(){
    return axios.get(&apos;/user/12345/permissions&apos;);
}

axios.all([getUerAccount(),getUserPermissions()])
    .then(axios.spread(function(acc,pers){
        //两个请求现在都完成
    }));
</code></pre><p>axios API</p>
<pre><code>可以对axios进行一些设置来生成请求。axios(config)

//发起 POST请求
axios({
    method:&apos;post&apos;,//方法
    url:&apos;/user/12345&apos;,//地址
    data:{//参数
        firstName:&apos;Fred&apos;,
        lastName:&apos;Flintstone&apos;
    }
});

//通过请求获取远程图片
axios({
    method:&apos;get&apos;,
    url:&apos;http://bit.ly/2mTM3Ny&apos;,
    responseType:&apos;stream&apos;
})
    .then(function(response){
        response.data.pipe(fs.createWriteStream(&apos;ada_lovelace.jpg&apos;))
    })
axios(url[,config])

//发起一个GET请求
axios(&apos;/user/12345/);
请求方法的重命名。

为了方便，axios提供了所有请求方法的重命名支持
axios.request(config)
axios.get(url[,config])
axios.delete(url[,config])
axios.head(url[,config])
axios.options(url[,config])
axios.post(url[,data[,config]])
axios.put(url[,data[,config]])
axios.patch(url[,data[,config]])

注意
当时用重命名方法时url,method,以及data属性不需要在config中指定。

并发 Concurrency
有用的方法
axios.all(iterable)
axios.spread(callback)

创建一个实例
你可以使用自定义设置创建一个新的实例
axios.create([config])
var instance = axios.create({
    baseURL:&apos;http://some-domain.com/api/&apos;,
    timeout:1000,
    headers:{&apos;X-Custom-Header&apos;:&apos;foobar&apos;}
});
实例方法

下面列出了一些实例方法。具体的设置将在实例设置中被合并。
axios#request(config)
axios#get(url[,config])
axios#delete(url[,config])
axios#head(url[,config])
axios#post(url[,data[,config]])
axios#put(url[,data[,config]])
axios#patch(url[,data[,config]])

Requese Config请求设置
以下列出了一些请求时的设置选项。只有url是必须的，如果没有指明method的话，默认的请求方法是GET.
{
    //`url`是服务器链接，用来请求
    url:&apos;/user&apos;,

    //`method`是发起请求时的请求方法
    method:`get`,

    //`baseURL`如果`url`不是绝对地址，那么将会加在其前面。
    //当axios使用相对地址时这个设置非常方便
    //在其实例中的方法
    baseURL:&apos;http://some-domain.com/api/&apos;,

    //`transformRequest`允许请求的数据在传到服务器之前进行转化。
    //这个只适用于`PUT`,`GET`,`PATCH`方法。
    //数组中的最后一个函数必须返回一个字符串或者一个`ArrayBuffer`,
        或者`Stream`,`Buffer`实例,`ArrayBuffer`,`FormData`
    transformRequest:[function(data){
        //依自己的需求对请求数据进行处理
        return data;
    }],

    //`transformResponse`允许返回的数据传入then/catch之前进行处理
    transformResponse:[function(data){
        //依需要对数据进行处理
        return data;
    }],

    //`headers`是自定义的要被发送的头信息
    headers:{&apos;X-Requested-with&apos;:&apos;XMLHttpRequest&apos;},

    //`params`是请求连接中的请求参数，必须是一个纯对象，或者URLSearchParams对象
    params:{
        ID:12345
    },

    //`paramsSerializer`是一个可选的函数，是用来序列化参数
    //例如：（https://ww.npmjs.com/package/qs,http://api.jquery.com/jquery.param/)
    paramsSerializer: function(params){
        return Qs.stringify(params,{arrayFormat:&apos;brackets&apos;})
    },

    //`data`是请求提需要设置的数据
    //只适用于应用的&apos;PUT&apos;,&apos;POST&apos;,&apos;PATCH&apos;，请求方法
    //当没有设置`transformRequest`时，必须是以下其中之一的类型（不可重复？）：
    //-string,plain object,ArrayBuffer,ArrayBufferView,URLSearchParams
    //-仅浏览器：FormData,File,Blob
    //-仅Node：Stream
    data:{
        firstName:&apos;fred&apos;
    },
    //`timeout`定义请求的时间，单位是毫秒。
    //如果请求的时间超过这个设定时间，请求将会停止。
    timeout:1000,

    //`withCredentials`表明是否跨网站访问协议，
    //应该使用证书
    withCredentials:false //默认值

    //`adapter`适配器，允许自定义处理请求，这会使测试更简单。
    //返回一个promise，并且提供验证返回（查看[response docs](#response-api)）
    adapter:function(config){
        /*...*/
    },

    //`auth`表明HTTP基础的认证应该被使用，并且提供证书。
    //这个会设置一个`authorization` 头（header），并且覆盖你在header设置的Authorization头信息。
    auth:{
        username:&apos;janedoe&apos;,
        password:&apos;s00pers3cret&apos;
    },

    //`responsetype`表明服务器返回的数据类型，这些类型的设置应该是
    //&apos;arraybuffer&apos;,&apos;blob&apos;,&apos;document&apos;,&apos;json&apos;,&apos;text&apos;,stream&apos;
    responsetype:&apos;json&apos;,

    //`xsrfHeaderName` 是http头（header）的名字，并且该头携带xsrf的值
    xrsfHeadername:&apos;X-XSRF-TOKEN&apos;，//默认值

    //`onUploadProgress`允许处理上传过程的事件
    onUploadProgress: function(progressEvent){
        //本地过程事件发生时想做的事
    },

    //`onDownloadProgress`允许处理下载过程的事件
    onDownloadProgress: function(progressEvent){
        //下载过程中想做的事
    },

    //`maxContentLength` 定义http返回内容的最大容量
    maxContentLength: 2000,

    //`validateStatus` 定义promise的resolve和reject。
    //http返回状态码，如果`validateStatus`返回true
        （或者设置成null/undefined），promise将会接受；其他的promise将会拒绝。
    validateStatus: function(status){
        return status &gt;= 200 &amp;&amp; stauts &lt; 300;//默认
    },

    //`httpAgent` 和 `httpsAgent`当产生一个http或者https请求时分别
        定义一个自定义的代理，在nodejs中。
    //这个允许设置一些选选个，像是`keepAlive`--这个在默认中是没有开启的。
    httpAgent: new http.Agent({keepAlive:treu}),
    httpsAgent: new https.Agent({keepAlive:true}),

    //`proxy`定义服务器的主机名字和端口号。
    //`auth`表明HTTP基本认证应该跟`proxy`相连接，并且提供证书。
    //这个将设置一个&apos;Proxy-Authorization&apos;头(header)，覆盖原先自定义的。
    proxy:{
        host:127.0.0.1,
        port:9000,
        auth:{
            username:&apos;cdd&apos;,
            password:&apos;123456&apos;
        }
    },

    //`cancelTaken` 定义一个取消，能够用来取消请求
    //（查看 下面的Cancellation 的详细部分）
    cancelToken: new CancelToken(function(cancel){
    })
}

返回响应概要 Response Schema
一个请求的返回包含以下信息
{
    //`data`是服务器的提供的回复（相对于请求）
    data{},

    //`status`是服务器返回的http状态码
    status:200,


    //`statusText`是服务器返回的http状态信息
    statusText: &apos;ok&apos;,

    //`headers`是服务器返回中携带的headers
    headers:{},

    //`config`是对axios进行的设置，目的是为了请求（request）
    config:{}
}

使用then，你会接受打下面的信息
axios.get(&apos;/user/12345&apos;)
    .then(function(response){
        console.log(response.data);
        console.log(response.status);
        console.log(response.statusText);
        console.log(response.headers);
        console.log(response.config);
    });
使用catch时，或者传入一个reject callback作为then的第二个参数，
那么返回的错误信息将能够被使用。
</code></pre><p>默认设置（Config Default)</p>
<pre><code>你可以设置一个默认的设置，这设置将在所有的请求中有效。
全局默认设置 Global axios defaults
axios.defaults.baseURL = &apos;https://api.example.com&apos;;
axios.defaults.headers.common[&apos;Authorization&apos;] = AUTH_TOKEN;
axios.defaults.headers.post[&apos;Content-Type&apos;]=&apos;application/x-www-form-urlencoded&apos;;
实例中自定义默认值 Custom instance default
//当创建一个实例时进行默认设置
var instance = axios.create({
    baseURL:&apos;https://api.example.com&apos;
});

//在实例创建之后改变默认值
instance.defaults.headers.common[&apos;Authorization&apos;] = AUTH_TOKEN;
设置优先级 Config order of precedence
设置(config)将按照优先顺序整合起来。首先的是在lib/defaults.js中定义的默认设置，
    其次是defaults实例属性的设置，最后是请求中config参数的设置。
    越往后面的等级越高，会覆盖前面的设置。
看下面这个例子：

//使用默认库的设置创建一个实例，
//这个实例中，使用的是默认库的timeout设置，默认值是0。
var instance = axios.create();

//覆盖默认库中timeout的默认值
//此时，所有的请求的timeout时间是2.5秒
instance.defaults.timeout = 2500;

//覆盖该次请求中timeout的值，这个值设置的时间更长一些
instance.get(&apos;/longRequest&apos;,{
    timeout:5000
});
</code></pre><p>拦截器 interceptors</p>
<pre><code>你可以在请求或者返回被then或者catch处理之前对他们进行拦截。
//添加一个请求拦截器
axios.interceptors.request.use(function(config){
    //在请求发送之前做一些事
    return config;
},function(error){
    //当出现请求错误是做一些事
    return Promise.reject(error);
});

//添加一个返回拦截器
axios.interceptors.response.use(function(response){
    //对返回的数据进行一些处理
    return response;
},function(error){
    //对返回的错误进行一些处理
    return Promise.reject(error);
});

如果你需要在稍后移除拦截器,你可以
var myInterceptor = axios.interceptors.request.use(function(){/*...*/});
axios.interceptors.rquest.eject(myInterceptor);

你可以在一个axios实例中使用拦截器
var instance = axios.create();
instance.interceptors.request.use(function(){/*...*/});
</code></pre><p>错误处理 Handling Errors</p>
<pre><code>axios.get(&apos;user/12345&apos;)
    .catch(function(error){
        if(error.response){
            //存在请求，但是服务器的返回一个状态码
            //他们都在2xx之外
            console.log(error.response.data);
            console.log(error.response.status);
            console.log(error.response.headers);
        }else{
            //一些错误是在设置请求时触发的
            console.log(&apos;Error&apos;,error.message);
        }
        console.log(error.config);
    });

你可以使用validateStatus设置选项自定义HTTP状态码的错误范围。
axios.get(&apos;user/12345&apos;,{
    validateStatus:function(status){
        return status &lt; 500;//当返回码小于等于500时视为错误
    }
});
</code></pre><p>取消 Cancellation</p>
<pre><code>你可以使用cancel token取消一个请求
axios的cancel token API是基于**cnacelable promises proposal**，其目前处于第一阶段。

你可以使用CancelToken.source工厂函数创建一个cancel token，如下：
var CancelToken = axios.CancelToken;
var source = CancelToken.source();
axios.get(&apos;/user/12345&apos;, {
    cancelToken:source.toke
}).catch(function(thrown){
    if(axiso.isCancel(thrown)){
        console.log(&apos;Rquest canceled&apos;, thrown.message);
    }else{
        //handle error
    }
});

//取消请求(信息参数设可设置的)
source.cancel(&quot;操作被用户取消&quot;);
你可以给CancelToken构造函数传递一个executor function来创建一个cancel token:
var CancelToken = axios.CancelToken;
var cancel;
axios.get(&apos;/user/12345&apos;, {
    cancelToken: new CancelToken(function executor(c){
        //这个executor 函数接受一个cancel function作为参数
        cancel = c;
    })
});

//取消请求
cancel();
注意：你可以使用同一个cancel token取消多个请求。
使用 application/x-www-form-urlencoded 格式化
默认情况下，axios串联js对象为JSON格式。为了发送application/x-wwww-form-urlencoded格式数据，
你可以使用一下的设置。
</code></pre><p>浏览器 Browser</p>
<pre><code>在浏览器中你可以如下使用URLSearchParams API:
var params = new URLSearchParams();
params.append(&apos;param1&apos;,&apos;value1&apos;);
params.append(&apos;param2&apos;,&apos;value2&apos;);
axios.post(&apos;/foo&apos;,params);
注意：URLSearchParams不支持所有的浏览器，但是这里有个垫片
（poly fill）可用（确保垫片在浏览器全局环境中）

其他方法：你可以使用qs库来格式化数据。
var qs = require(&apos;qs&apos;);
axios.post(&apos;/foo&apos;, qs.stringify({&apos;bar&apos;:123}));
Node.js

在nodejs中，你可以如下使用querystring:
var querystring = require(&apos;querystring&apos;);
axios.post(&apos;http://something.com/&apos;, querystring.stringify({foo:&apos;bar&apos;}));
你同样可以使用qs库。
promises
axios 基于原生的ES6 Promise 实现。如果环境不支持请使用垫片.

TypeScript
axios 包含TypeScript定义

import axios from &apos;axios&apos;
axios.get(&apos;/user?ID=12345&apos;)
</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;axios&lt;/p&gt;
&lt;p&gt;##基于http客户端的promise，面向浏览器和nodejs&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;特色
浏览器端发起XMLHttpRequests请求
node端发起http请求
支持Promise API
拦截请求和返回
转化请求和返回（数据）
取
    
    </summary>
    
      <category term="学习笔记" scheme="www.wangchengzou.cn/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="vue" scheme="www.wangchengzou.cn/tags/vue/"/>
    
      <category term="axios" scheme="www.wangchengzou.cn/tags/axios/"/>
    
  </entry>
  
  <entry>
    <title>html和css3</title>
    <link href="www.wangchengzou.cn/2017/07/22/css3+HTML5%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    <id>www.wangchengzou.cn/2017/07/22/css3+HTML5面试题/</id>
    <published>2017-07-22T15:48:26.000Z</published>
    <updated>2017-07-28T01:27:39.844Z</updated>
    
    <content type="html"><![CDATA[<p>1、    CSS3有哪些新特性？</p>
<pre><code>1. CSS3实现圆角（border-radius），阴影（box-shadow），
2. 对文字加特效（text-shadow、），线性渐变（gradient），旋转（transform）
3.transform:rotate(9deg) scale(0.85,0.90) translate(0px,-30px)
 skew(-9deg,0deg);// 旋转,缩放,定位,倾斜
4. 增加了更多的CSS选择器  多背景 rgba
5. 在CSS3中唯一引入的伪元素是 ::selection.
6. 媒体查询，多栏布局
7. border-image
</code></pre><ol>
<li>html5有哪些新特性、移除了那些元素？如何处理HTML5新标签的浏览器兼容问题？<br>如何区分 HTML 和 HTML5？<br>新特性：<ol>
<li>拖拽释放(Drag and drop) API</li>
<li>语义化更好的内容标签（header,nav,footer,aside,article,section）</li>
<li>音频、视频API(audio,video)</li>
<li>画布(Canvas) API</li>
<li>地理(Geolocation) API</li>
<li>本地离线存储 localStorage 长期存储数据，浏览器关闭后数据不丢失；</li>
<li>sessionStorage 的数据在浏览器关闭后自动删除</li>
<li>表单控件，calendar、date、time、email、url、search</li>
<li>新的技术webworker, websocket, Geolocation<br>移除的元素：</li>
<li>纯表现的元素：basefont，big，center，font, s，strike，tt，u；</li>
<li>对可用性产生负面影响的元素：frame，frameset，noframes；<br>支持HTML5新标签：</li>
<li>IE8/IE7/IE6支持通过 document.createElement 方法产生的标签，<br>可以利用这一特性让这些浏览器支持 HTML5 新标签，浏览器支持新标签后，<br>还需要添加标签默认的样式（当然最好的方式是直接使用成熟的框架、使用最多的是html5shim框架）：<!--[if lt IE 9]>
<script> src="http://html5shim.googlecode.com/svn/trunk/html5.js"</script>
<![endif]-->
如何区分：<br>DOCTYPE声明新增的结构元素、功能元素</li>
</ol>
</li>
</ol>
<p>3、    本地存储（Local Storage ）和cookies（储存在用户本地终端上的数据）之间的区别是什么？</p>
<pre><code>Cookies:服务器和客户端都可以访问；大小只有4KB左右；有有效期，过期后将会删除；
本地存储：只有本地浏览器端可访问数据，服务器不能访问本地存储直到故意通过POST
或者GET的通道发送到服务器；每个域5MB；没有过期数据，它将保留知道用户从浏览器
清除或者使用Javascript代码移除
</code></pre><p>6、    什么是响应式设计？</p>
<pre><code>它是关于网页制作的过程中让不同的设备有不同的尺寸和不同的功能。
响应式设计是让所有的人能在这些设备上让网站运行正常
</code></pre><p>7、    新的 HTML5 文档类型和字符集是？</p>
<pre><code>HTML5文档类型：&lt;!doctype html&gt;
HTML5使用的编码&lt;meta charset=”UTF-8”&gt;
</code></pre><p>8、    HTML5 Canvas 元素有什么用？</p>
<pre><code>Canvas 元素用于在网页上绘制图形，该元素标签强大之处在于可以直接
在 HTML 上进行图形操作。
</code></pre><p>9、    HTML5 存储类型有什么区别？</p>
<pre><code>Media API、Text Track API、Application Cache API、
User Interaction、Data Transfer API、Command API、
Constraint Validation API、History API
</code></pre><p>11、    CSS3新增伪类有那些？</p>
<pre><code>p:first-of-type 选择属于其父元素的首个 &lt;p&gt; 元素的每个 &lt;p&gt; 元素。
p:last-of-type  选择属于其父元素的最后 &lt;p&gt; 元素的每个 &lt;p&gt; 元素。
p:only-of-type  选择属于其父元素唯一的 &lt;p&gt; 元素的每个 &lt;p&gt; 元素。
p:only-child    选择属于其父元素的唯一子元素的每个 &lt;p&gt; 元素。
p:nth-child(2)  选择属于其父元素的第二个子元素的每个 &lt;p&gt; 元素。
:enabled、:disabled 控制表单控件的禁用状态。
:checked，单选框或复选框被选中。
</code></pre><p>14、    html5\CSS3有哪些新特性、移除了那些元素？如何处理HTML5新标签的浏览器兼容问题？<br>    如何区分 HTML 和 HTML5？</p>
<pre><code>HTML5 现在已经不是 SGML 的子集，主要是关于图像，位置，存储，地理定位等功能的增加。
* 绘画 canvas 元素
  用于媒介回放的 video 和 audio 元素
  本地离线存储 localStorage 长期存储数据，浏览器关闭后数据不丢失；
  sessionStorage 的数据在浏览器关闭后自动删除
  语意化更好的内容元素，比如 article、footer、header、nav、section
  表单控件，calendar、date、time、email、url、search
  CSS3实现圆角，阴影，对文字加特效，增加了更多的CSS选择器  多背景 rgba
  新的技术webworker, websockt, Geolocation
移除的元素
纯表现的元素：basefont，big，center，font, s，strike，tt，u；
对可用性产生负面影响的元素：frame，frameset，noframes；
* 是IE8/IE7/IE6支持通过document.createElement方法产生的标签，
  可以利用这一特性让这些浏览器支持HTML5新标签，
  浏览器支持新标签后，还需要添加标签默认的样式：
* 当然最好的方式是直接使用成熟的框架、使用最多的是html5shim框架
&lt;!--[if lt IE 9]&gt;
&lt;script&gt; src=&quot;http://html5shim.googlecode.com/svn/trunk/html5.js&quot;&lt;/script&gt;
&lt;![endif]--&gt;
</code></pre><p>16、    你能描述一下渐进增强和优雅降级之间的不同吗?</p>
<pre><code>渐进增强 progressive enhancement：针对低版本浏览器进行构建页面，
保证最基本的功能，然后再针对高级浏览器进行效果、交互等改进和追加功能达到更好的用户体验。
优雅降级 graceful degradation：一开始就构建完整的功能，然后再针对低版本浏览器进行兼容。
　　区别：优雅降级是从复杂的现状开始，并试图减少用户体验的供给，而渐进增强则是
从一个非常基础的，能够起作用的版本开始，并不断扩充，以适应未来环境的需要。
降级（功能衰减）意味着往回看；而渐进增强则意味着朝前看，同时保证其根基处于安全地带。　
　
</code></pre><p>19、    请描述一下cookies，sessionStorage和localStorage的区别？<br>　　<br>    　　  sessionStorage用于本地存储一个会话（session）中的数据，<br>    这些数据只有在同一个会话中的页面才能访问并且当会话结束后数据也随之销毁。<br>    因此sessionStorage不是一种持久化的本地存储，仅仅是会话级别的存储。<br>    而localStorage用于持久化的本地存储，除非主动删除数据，<br>    否则数据是永远不会过期的。<br>    web storage和cookie的区别<br>    Web Storage的概念和cookie相似，区别是它是为了更大容量存储设计的。<br>    Cookie的大小是受限的，并且每次你请求一个新的页面的时候Cookie都会被发送过去，<br>    这样无形中浪费了带宽，另外cookie还需要指定作用域，不可以跨域调用。<br>    除此之外，Web Storage拥有setItem,getItem,removeItem,clear等方法，<br>    不像cookie需要前端开发者自己封装setCookie，getCookie。<br>    但是Cookie也是不可以或缺的：Cookie的作用是与服务器进行交互，<br>    作为HTTP规范的一部分而存在 ，而Web Storage仅仅是为了在本地“存储”数据而生。</p>
<p>20、    知道css有个content属性吗？有什么作用？有什么应用？</p>
<pre><code>css的content属性专门应用在 before/after 伪元素上，用来插入生成内容。
最常见的应用是利用伪类清除浮动。
//一种常见利用伪类清除浮动的代码
.clearfix:after {
    content:&quot;.&quot;; //这里利用到了content属性
    display:block;
    height:0;
    visibility:hidden;
    clear:both; }
.clearfix {
    *zoom:1;
}
after伪元素通过 content 在元素的后面生成了内容为一个点的块级素，
再利用clear:both清除浮动。
</code></pre><p>　　<br>21、    如何在 HTML5 页面中嵌入音频?</p>
<pre><code>HTML 5 包含嵌入音频文件的标准方式，支持的格式包括 MP3、Wav 和 Ogg：
&lt;audio controls&gt;
  &lt;source src=&quot;jamshed.mp3&quot; type=&quot;audio/mpeg&quot;&gt;
   Your browser does&apos;nt support audio embedding feature.
&lt;/audio&gt;
</code></pre><p>22、    如何在 HTML5 页面中嵌入视频？</p>
<pre><code>和音频一样，HTML5 定义了嵌入视频的标准方法，支持的格式包括：MP4、WebM 和 Ogg：
&lt;video width=&quot;450&quot; height=&quot;340&quot; controls&gt;
  &lt;source src=&quot;jamshed.mp4&quot; type=&quot;video/mp4&quot;&gt;
   Your browser does&apos;nt support video embedding feature.
&lt;/video&gt;
</code></pre><p>23、    HTML5 引入什么新的表单属性？</p>
<pre><code>Datalist   datetime   output   keygen  date  month  week
time  number   range   emailurl
</code></pre><p>26、    cookie在浏览器和服务器间来回传递。 sessionStorage和localStorage区别</p>
<pre><code>sessionStorage和localStorage的存储空间更大；
sessionStorage和localStorage有更多丰富易用的接口；
sessionStorage和localStorage各自独立的存储空间；
</code></pre><p>30、    HTML5的离线储存？</p>
<pre><code>localStorage    长期存储数据，浏览器关闭后数据不丢失；
sessionStorage  数据在浏览器关闭后自动删除。
</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;1、    CSS3有哪些新特性？&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;1. CSS3实现圆角（border-radius），阴影（box-shadow），
2. 对文字加特效（text-shadow、），线性渐变（gradient），旋转（transform）
3.transf
    
    </summary>
    
      <category term="面试题目" scheme="www.wangchengzou.cn/categories/%E9%9D%A2%E8%AF%95%E9%A2%98%E7%9B%AE/"/>
    
    
      <category term="html" scheme="www.wangchengzou.cn/tags/html/"/>
    
      <category term="H5" scheme="www.wangchengzou.cn/tags/H5/"/>
    
  </entry>
  
  <entry>
    <title>css hack兼容性</title>
    <link href="www.wangchengzou.cn/2017/07/22/css_hack/"/>
    <id>www.wangchengzou.cn/2017/07/22/css_hack/</id>
    <published>2017-07-22T15:48:26.000Z</published>
    <updated>2017-08-17T11:42:03.588Z</updated>
    
    <content type="html"><![CDATA[<p>css hack解决浏览器兼容性问题</p>
<pre><code>网页设计遇到最大的麻烦之一莫过于网页对不同浏览器的兼容性问题了，
因数ie6/ic7/fox2/opera9等主流浏览器对css解析不近相同，导
致设计的页面效果不一样，用于解决这个问题的方法就是css hack，
使用特别的css定义显示网页在不同浏览器的设计风格，针对不同的浏览器去写不同的css,
最大化兼容浏览器
</code></pre><p>比较频繁使用的css hack技巧</p>
<pre><code>！important，它可以针对ie和非IE浏览器设置不同的样式
*+html{...} 只无法充分IE7做样式时候使用
IE的if条件hack
    &lt;!--[if IE]&gt; Only IE &lt;![endif]--&gt; 所有的IE可识别
    &lt;!--[if IE 5.0]&gt; Only IE 5.0 &lt;![endif]--&gt; 只有IE5.0可以识别
    &lt;!--[if gt IE 5.0]&gt; Only IE 5.0+ &lt;![endif]--&gt; IE5.0包换IE5.5都可以识别
    &lt;!--[if lt IE 6]&gt; Only IE 6- &lt;![endif]--&gt; 仅IE6可识别
    &lt;!--[if gte IE 6]&gt; Only IE 6/+ &lt;![endif]--&gt; IE6以及IE6以下的IE5.x都可识别
    &lt;!--[if lte IE 7]&gt; Only IE 7/- &lt;![endif]--&gt; 仅IE7可识别
</code></pre><p>1、CSS HACK</p>
<pre><code>以下两种方法几乎能解决现今所有HACK.
1, !important (不是很推荐，用下面的一种感觉最安全)
    随着IE7对!important的支持, !important 方法现在只针对IE6的HACK.
    (注意写法.记得该声明位置需要提前.)
    代码: &lt;style&gt;
        #wrapper {
            width: 100px!important; /* IE7+FF */
            width: 80px; /* IE6 */ }
        &lt;/style&gt;

2, IE6/IE77对FireFox &lt;from 针对firefox ie6 ie7的css样式&gt;
    *+html 与 *html 是IE特有的标签, firefox 暂不支持.而*+html 又为 IE7特有标签.
        代码: &lt;style&gt;
                    #wrapper { width: 120px; } /* FireFox */
              *html #wrapper { width: 80px;} /* ie6 fixed */
             *+html #wrapper { width: 60px;} /* ie7 fixed, 注意顺序 */
            &lt;/style&gt;
        注意:  *+html 对IE7的HACK 必须保证HTML顶部有如下声明：
        代码:  &lt;!DOCTYPE HTML PUBLIC &quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot;
        &quot;http://www.w3.org/TR/html4/loose.dtd&quot;&gt;
</code></pre><p>2、万能 float 闭合(非常重要!)</p>
<pre><code>可以用这个解决多个div对齐时的间距不对，
关于 clear float 的原理可参见 [How To Clear Floats Without Structural Markup]
将以下代码加入Global CSS 中,给需要闭合的div加上 class=”clearfix” 即可,屡试不爽.
代码: &lt;style&gt;
    /* Clear Fix */
    .clearfix:after { content:&quot;.&quot;; display:block;
                    height:0; clear:both;
                    visibility:hidden; }
    .clearfix {  display:inline-block; }  /* Hide from IE Mac \*/
    .clearfix {display:block;} /* End hide from IE Mac */
                                /* end of clearfix */
    &lt;/style&gt;
</code></pre><p>3、其它兼容性技巧</p>
<pre><code>1、FF下给div设置padding后会导致width和height增加，但ie不会
    解决：可用！important

2、居中问题
    垂直居中
        将line-heigth设置为 当前div相同高度，再通过vertical-align:middle
    水平居中
        margin:0 auto;

3、若需要给a标签内容加上样式，需要设置
    display:block;(常用于导航标签)

4、FF和IE对BOX理解的差异导致相差2px
    设为float的div在IE下margin加倍问题

5、ul标签在FF下面默认有list-style和padding

6、作为外部wrapper的div不要定死高度，最好加上overflow:hidden
    以达到高度自适应

7、 关于手形光标. cursor: pointer. 而hand 只适用于 IE
</code></pre><p>4、针对firefox ie6 ie7的css样式</p>
<pre><code>现在大部分都是用!important来hack，对于ie6和firefox测试可以正常显示，
但是ie7对!important可以正确解释，会导致页 面没按要求显示！
找到一个针对IE7不错的hack方式就是使用“*+html”，现在用IE7浏览一下，
应该没有问题了现在写一个CSS可以这样：
    #1 { color: #333; } /* Moz */
    * html #1 { color: #666; } /* IE6 */
    *+html #1 { color: #999; } /* IE7 */
    那么在firefox下字体颜色显示为#333，
    IE6下字体颜色显示为#666，
    IE7下字体颜色显示为#999。
</code></pre><p>5、css布局中的居中问题</p>
<pre><code>主要的样式定义如下：
body {TEXT-ALIGN: center;}
#center { MARGIN-RIGHT: auto; MARGIN-LEFT: auto; }
说明：
    首先在父级元素定义TEXT-ALIGN: center;这个的意思就是在父级元素内的内容居中；
    对于IE这样设定就已经可以了。但在mozilla中不能居中。
    解决办法就是在子元素定义时候设定时再加上“MARGIN-RIGHT: auto;MARGIN-LEFT: auto; ”
    需要说明的是，如果你想用这个方法使整个页面要居中，建议不要套在一个DIV里，
    你可以依次拆出多个div，只要在每个拆出的div里定义
    MARGIN-RIGHT: auto;MARGIN-LEFT: auto; 就可以了。
</code></pre><p>6、盒模型不同解释</p>
<pre><code>#box{  width:600px;
    //for ie6.0- w\idth:500px;
    //for ff+ie6.0 }
#box{  width:600px!important
    //for ff  width:600px;
    //for ff+ie6.0  width /**/:500px;
    //for ie6.0- }
</code></pre><p>7、浮动IE产生的双倍距离</p>
<pre><code>#box{float:left;width:100px;margin:0 0 0 100px;}
解决：didplay:inline
block,inline两个元素
    Block元素的特点是:总是在新行上开始,高度,宽度,行高,边距都可以控制(块元素);
inline元素的特点是:和其他元素在同一行上,…不可控制(内嵌元素);
#box{ display:block; //可以为内嵌元素模拟为块元素
      display:inline; //实现同一行排列的的效果
      diplay:table;
</code></pre><p>8、IE与宽度和高度的问题</p>
<pre><code>IE不认得min-这个定义，但实际上它把正常的width和heigth当作有min的情况来使，
如果设置了min-，则ie下就等于没有设置宽高，设置背景图片最小宽度比较重要
解决:#box{width:80px;height:35px;}
    html&gt;body #box{width:auto;heigth:auto;min-width:80px;min-height:35px;}
</code></pre><p>9、清除浮动</p>
<pre><code>#box:after{
    content:&quot;&quot;;
    display:block;
    height；0；
    clear:both;
    visibility:hidden;
    }
</code></pre><p>10、DIV浮动IE文本产生3px的bug</p>
<pre><code>左边对象浮动，右边采用外补丁的左边距定位，右边对象内的文本会离左边有3px的间距
#box{float:left;width:800px;}
#left{float:left;width:50%}
#right{width:50%}
*html #left{margin-right:-3px;}
</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;css hack解决浏览器兼容性问题&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;网页设计遇到最大的麻烦之一莫过于网页对不同浏览器的兼容性问题了，
因数ie6/ic7/fox2/opera9等主流浏览器对css解析不近相同，导
致设计的页面效果不一样，用于解决这个问题的方法就是css h
    
    </summary>
    
      <category term="学习笔记" scheme="www.wangchengzou.cn/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="css3" scheme="www.wangchengzou.cn/tags/css3/"/>
    
  </entry>
  
  <entry>
    <title>Angular基础知识</title>
    <link href="www.wangchengzou.cn/2017/07/22/Angular/"/>
    <id>www.wangchengzou.cn/2017/07/22/Angular/</id>
    <published>2017-07-22T15:48:26.000Z</published>
    <updated>2017-07-27T12:53:02.708Z</updated>
    
    <content type="html"><![CDATA[<p>1、设计原则和设计模式</p>
<pre><code>拙劣的设计：
①僵化
②脆弱
③不必要的复杂
④晦涩。。

1、YAGNI（不要写不需要的代码）
you aren&apos;t gonna need it

2、KISS （越简单越好）
keep it simple and stupid
语义化的标记、命名规则、减少嵌套

3、DRY（善于使用封装和重用）
Don&apos;t Repeat Yourself

4、高内聚 低耦合（High cohesion,low coupling）
内聚：一个组件（模块）内部的不同部分的关系
耦合：不同组件（模块）之间的关系

5、SRP 单一责任原则
Single Responsibility Principle
实现功能的时候，尽可能的做到每一个模块实现一个单一的功能

6、OCP原则(对于扩展开放、对于修改关闭)
open close principle

7、LCP（迪米特法则）
Least Knowledge Principle 最少知识法则：封装的功能单位要尽可能的小，尽量做到只与自己相关

常用的设计模式分为3大类：①创建 ②结构 ③行为

常用的设计模式：工厂方法模式、单例模式、组合模式、迭代子模式、适配器。。
先去实现功能，在迭代的过程中优化代码。
</code></pre><p>2、AngularJS</p>
<pre><code>认识新东西最好的方式：
①官网
②维基百科 wikipedia.org
what?--ng(AngularJS)是一个开源的js框架
where？--用来实现SPA应用程序（单一页面应用程序single page application）
Gmail邮箱是由Google退出的前端历史中第一个SPA应用
why？
四大特征：
①采用了MVC的设计模式
Model 模型数据
View  视图
Controller 控制器
</code></pre><p>3、MVC的工作原理：</p>
<pre><code>View视图 接收用户的输入，通过控制器（Controller）当中的方法，完成对于Model的增删改查的操作。
1.数据绑定：将数据和视图绑定起来，一旦数据被修改了，视图就会更新
2.双向数据绑定
    数据-》视图
    视图用户的输入 -》 数据
3.依赖注入
4.模块化设计
</code></pre><p>4、使用ng</p>
<pre><code>1、基本语法
    &lt;any&gt;{{表达式}} &lt;/any&gt;
    直接按照上述方法写，结果是不对的，解决方案：在html标签写上了ng-app

2、常用指令
    ngApp
        ①启动ng
        ②指定作用范围，将指令写在根标签
    快捷键：在webStorm中alt+f2,快速选中要去执行在哪个浏览器。
    ngInit 指令 来完成数据的初始化
    &lt;any ng-init=&quot;num=2&quot;&gt;&lt;/any&gt;
        ①不需要在通过ngInit指令定义数据时候，加上var关键字
        ②ngInit所初始化的变量是可以在整个html去使用变量
</code></pre><p>5、常用指令</p>
<pre><code>ng中指令：由angularJS提供了，可以用在html中作为扩展属性、扩展标签。。

作为扩展属性来使用：
    &lt;div ng-**&gt;&lt;/div&gt;
    ngInit  --&gt; ng-init
    ngApp --&gt; ng-app
作为扩展标签来使用：
    &lt;ngView/&gt;
①ngApp
    启动ng
    指定作用范围，将指令写在根标签
    注意事项：调用一次ngApp
②ngInit
    通过ngInit调用一次，初始化多个变量？？
    &lt;any ng-init=&quot;a=1;b=2&quot;/&gt;
③ngRepeat
    重复实例化模板
    两种语法：
    &lt;any ng-repeat=&quot;临时变量的名称 in 集合的名称&quot;&gt;&lt;/any&gt;
    &lt;any ng-repeat=&quot;（key,value） in 集合的名称&quot;&gt;&lt;/any&gt;

    注意事项：在使用ngRpeat的时候要遍历的集合默认是不允许有重复的数据，
        可以通过 track by $index来指定一个不会重复的值就可以解决报错的问题。

④ngIf、ngShow、ngHide、ngSrc、ngDisabled、ngChecked
    ngIf-》选择是否要显示出来（挂载到DOM，从DOM中删除）
    ngShow/ngHide -&gt;选择是否要显示出来(显示或者隐藏)
    &lt;any ng-if=&quot;表达式&quot;&gt;&lt;/any&gt;
    &lt;any ng-show=&quot;表达式&quot;&gt;&lt;/any&gt;
    &lt;any ng-hide=&quot;表达式&quot;&gt;&lt;/any&gt;
    注意事项：在使用ngSrc去读取变量中值的时候，要记得加上双花括号
    &lt;img ng-src=&quot;img/{{imgUrl}}&quot; /&gt; 如果你写的不是ngSrc而是src，显示是ok的，
    但是控制台是会报错的，通过ngSrc去指定就搞定了
    &lt;any ng-disabled=&apos;表达式&apos;&gt;&lt;/any&gt;
    &lt;input type=&apos;checkbox&apos; ng-checked=&quot;表达式&quot;/&gt;
</code></pre><p>6、MVC</p>
<pre><code>在ng中：
    Model 模型数据：在ng中定义的一些变量
    View  视图：通过ng指令和表达式增强版的html
    Controller 控制器：负责数据的增删改查的
MVC的好处:在实现大型应用程序，可以通过将视图和数据隔离开，有效的降低代码的复杂度、耦合度
在ng中应该怎么做才能实现一个SPA？
准备工作：
①创建一个模块
    因为在ng中是以模块为基本单位的
    var app = angular.module(&apos;模块的名称&apos;，[&apos;依赖模块1&apos;,&apos;依赖模块2&apos;])
②使用模块
    采用ngApp指令
    &lt;html ng-app=&quot;模块的名称&quot;&gt;&lt;/html&gt;
③创建一个控制器
    app.controller(&apos;控制器的名称&apos;,function(){})
    第二个参数时控制器被调用时，要执行的方法
④调用控制器
    采用ngController指令来调用控制器
    &lt;div ng-controller=&apos;控制器的名称&apos;&gt;&lt;/div&gt;
    实现数据的创建和显示等：
⑤操作数据、显示出来

$scope是一个对象，称之为作用域对象，是一个非常重要的概念，
    建立起控制器中的数据和控制器的所指定的视图的桥梁

绑定事件的时候，在ng的做法： &lt;any ng-eventName=&quot;handle()&quot;&gt;
&lt;button ng-click=&quot;handleClick()&quot;&gt;&lt;/button&gt;

注意事项：
由于ngInit和$scope都可以完成数据的初始化，建议使用$scope,因为ngInit会增加代码的耦合度和复杂度。
</code></pre><p>7、ng是由很多指令的：</p>
<pre><code>ngApp ngRepeat ngIf ngShow ngHide ngChecked ngDisabled ngSrc
ngBind ngClass ngStyle

在webStorm中创建一个文件模板的基本步骤：
①拷贝要使用的代码
②点击左上角的file，选择new
③选择Edit File Templates
④点击弹窗中右上角的+号
⑤修改name和extension为创建的文件模板的名称以及格式，点击ok保存即可
</code></pre><p>8、自定义指令</p>
<pre><code>1、如何自定义？？
    angular.module()
    app.controller()
    //创建指令
    app.directive(&apos;指令的名称&apos;，function(){
        return {}
    })
    指令的命令规则：指令的名称由两部分构成，前缀：一般使我们模块或者项目的名字缩写；
    后缀：用来描述指令的功能
    属性：
    template：指定要显示的模板内容
    restrict: &quot;EAC&quot; //E(Element)A(Attribute)C(Class)M(Comment)
    replace: true,替换并显示出来
    scope

2、如何使用自定义的指令？？
    注意事项：指令在命名时是要遵循驼峰式命名规则；在使用时要遵循烤串式用方
    &apos;tsHello&apos; --&gt; ts-hello
    根据配置指令时的restrict属性所对应的值，在合适的场景下使用指令。

3、自定义指令传递参数
    怎么传？
        在调用指令的时候可以传 将参数作为属性对应的值
    怎么接受？
        scope
</code></pre><p>9、双向数据绑定</p>
<pre><code>方向1：从&apos;数据&apos;绑定到&apos;视图&apos;
绑定方式：
①常用指令： ngRepeat/ngIf/ngShow...
②双花括号：{{}}

方向2：从‘视图中用户的输入’绑定到‘数据’
绑定方式：指令：ngModel

如果要监听数据的变化：
$scope.$watch(&apos;txt&apos;,function(){

})

在实现下拉框的过程中，如果数据是动态的，可以通过ngOptions将数据绑定到视图中。
ngOptions语法：
 &lt;select
    ng-model=&quot;city&quot;
    ng-options=&quot;city.cityName for city in cities&quot;&gt;
 &lt;/select&gt;
</code></pre><p>10、过滤器</p>
<pre><code>a.内置的过滤器
    ng中的过滤器为了实现对于表达式结果的筛选、过滤、格式化，达到更好的表现效果。
    过滤器的语法：支持多重过滤和传参
    {{expression | 过滤器名称 : '参数' | 过滤器名称2：‘参数’ }
            | => 管道
            常用的过滤器：
                currency 货币样式的过滤器
                date 日期
                uppercase/lowercase 大小写的处理
                orderBy 对指定的数组进行升序或者降序排列
                number 格式化数字为文本（对有小数点的数据的处理）
                limitTo 限定数组或者字符串要显示的个数
        b.自定义过滤器
            自定义过滤器方式：
            app.filter('过滤器名称',function(){
                return function(input，arg){
                        //input是传递给过滤器的数据
                        //arg 是过滤器本身的参数
                    return '过滤后的结果'
                }
            })
            使用自定义的过滤器:
            和内置的过滤器用法是一样的

11、ng模块内置的方法

        序列化、反序列化
        toJson:将对象或者数组 序列化 为json格式的字符串
        fromJson：相反的过程

12、服务

    服务的本质是一个单例对象，提供数据和对象。
    两大类：
    ①内置服务
        $location、$http、$window、$scope...
        使用内置服务中提供的方法：
            第一步 将需要用到的服务注入进来 function($scope,$location)
            第二步 调用服务中提供的方法 数据。。
    ②自定义的服务
        面试题：$scope与$rootScope之间的关系
        1、不同的控制器之间的数据是彼此隔离的
        2、不同的控制器之间如何共享数据？？
        $scope的id是从2开始依次往上递增，
        id为1的是谁？ $rootScope是根作用域对象，其余的$scope都是子对象
            方式1：借助于$rootScope
                把要共享的数据存在$rootScope,所有的子对象就可以读取该数据
            方式2：借助于控制器之间的嵌套
                在调用控制器的元素 之间的嵌套关系
                @@div ng-controller='myCtrl02'>
                    @@<div ng-controller="myCtrl03"></div>
                @@
            方式3：触发事件传递参数
                绑定事件：
                $scope.$on('事件名称',function(event,data){

                })
        触发事件：
        //从子作用对象 向 父作用域对象 传递事件
        $scope.$emit()
        //从父作用对象 向 子作用域对象 传递事件
        $scope.$broadcaset()

13、服务

        双向数据绑定的工作原理：
        绑定时，ng会自动添加一个监听watcher,当数据发生变化时，会执行更新DOM操作的函数。
        怎么知道数据发生了变化？
        在ng中有一个循环$digest,会不断的对比数据，
        需要手工的触发循环做对比，可以通过：
        $scope.$digest();
        $scope.$apply();//触发$rootScope.$digest();

14、ng内置的服务：

        $location $scope $rootScope $window $interval $timeout
        1、在ng中定时器相关的处理--》$interval $timeout
        2、$http
        $http({method:'',url:''}).success().error()
        $http.get()
        $http.post()
        注意：如果需要发起post请求，需要设置:
         app.run(function ($http) {
                $http.defaults.headers.post =
        {'Content-Type':'application/x-www-form-urlencoded'};})

        在发起post请求时，如果需要对参数进行序列化:
        借助于$httpParamSerializer服务，首先注入进来，$httpParamSerializer（obj）。

15、自定义服务

        服务的目的是为了封装业务逻辑，提高代码的复用率
        自定义指令 app.directive
        自定义过滤器 app.filter
        自定义服务的方法：
        app.factory ('服务名称',function(){//普通方法 return {}})
app.service(&apos;服务名称&apos;,function(){//构造函数})
app.constant(&apos;服务名称&apos;，{})//创建常量服务
app.value(&apos;服务名称&apos;，{})//创建变量服务

注意事项：
自定义的服务 需要用到其它服务中方法
图：两个按钮：开始 结束。
</code></pre><p>16、依赖注入</p>
<pre><code>将代码部署到线上，都会对代码做压缩。
使用YUI-Compressor.jar （有java的运行环境）
①借助于CLI（command line）
    java -jar yui**.jar  c:\demo10.js &gt; c:\demo10.min.js

②IDE（webStorm）
    file-&gt;settings-&gt;tools-&gt;fileWathchers-&gt;+-&gt;选中YUI-Compressor JS，
    在弹窗中的program选中对应的jar，保存即可
压缩效果：
会删除所有的注释、删除没有语义的空白字符、尽可能的简化变量的名称（混淆），
但是数字、字符串、关键字是不会改变的。

解决压缩后的问题方式：
依赖注入：将依赖的服务或者其他，通过参数形式注入进来，背后ng框架会帮助对服务等做实例化的操作，
让我们可以去直接使用

注入的方式：
①推断式（猜测）
    这种方式在进行压缩会有问题
    app.controller(&apos;myCtrl&apos;,function($scope){});

②标记式
    由于文件压缩时，关键数据 字符串 关键字等不会被处理的；将所需要用到的服务，
    存在一个字符串（服务名称）数组。
    注意事项：在数组中服务名称的顺序和创建对应的处理函数参数的顺序是要保持一致的
    实现方式：
    1、将处理函数单独的存在一个变量中
    2、给变量设置$inject，值是一个由字符串构成的数组
    3、使用服务即可
③行内式（内联式）
    在构建一个ng对象时，允许将一个字符型数组 作为对象的参数，
    在数组中可以：服务名称、函数（必须是在数组的最后一个元素）
    app.controller(&apos;myCtrl&apos;,[&apos;$scope&apos;,function($scope){}])
    依赖注入3种方式，官方推荐采用行内式依赖注入。
    依赖注入的背后：$injector 注入器：快速的定位到应用需要用到的各种该服务，
    整个ng应用的注入对象都是由$injector定位和创建。
    $injector.has(&apos;服务名称&apos;) ==》判断指定的服务是否存在
    $injector.get(&apos;服务名称&apos;) ==》 得到指定的服务对应的实例
</code></pre><p>17、模块化设计</p>
<pre><code>ng有4大特征：
①MVC
②双向数据绑定
③依赖注入
④模块化设计

高内聚低耦合，在ng中有两种：①内置的模块 ②自定义的模块

如何自定义模块？
angular.module();

使用模块？
ng-app=&quot;&quot;
在创建模块时，在第二个参数所对应的数组中写上服务的名称

一个ng的模块都可以包含哪些？
控制器：对应部分业务逻辑的封装
服务：经常用到的重复代码封装
指令：扩展html标签、属性
过滤器：针对数据做一些筛选 过滤 格式化的处理
</code></pre><p>18、ngRoute（路由模块）</p>
<pre><code>ng是主要实现SPA（单一页面应用程序）
SPA的工作原理：
    1、页面url
    http://127.0.0.1/index.html#/路由地址
    例如：http://127.0.0.1/index.html#/start
    2、解析index.html 是一个完整的html页面，再解析路由地址(start)
    3、在路由词典中寻找路由地址(start)所对应的路由信息
    4、在路由信息所对应的对象中找到真实的模板页面地址
    5、（发起异步ajax）加载模板页面到指定的容器中，实现局部刷新

ngRoute（路由模块）可以定义路由词典，自动解析路由地址，查找路由词典，
自动发起ajax请求加载页面显示。
    0、在创建自定义模块，在依赖列表中指定ngRoute
    1、指定盛放代码片段的容器
    2、配置路由词典

使用ngRoute的基本步骤：
①创建一个完整的html页面
    记得引入angular.js angular-route.js

②创建模块，并指定依赖于ngRoute模块
    angular.module(&apos;myApp&apos;,[&apos;ng&apos;,&apos;ngRoute&apos;])

③使用指令创建一个盛放代码片段的容器
    调用ngView指令：创建一个容器，代码片段会加载到这里

④创建模板页面

⑤配置路由词典
    $routeProvider
    when是用来添加一条路由信息的(路由地址的字符串是以/开始)
    $routeProvider.when(&apos;/myStart&apos;,{controller:&apos;&apos;,template/templateUrl:&apos;&apos;})
    otherwise是用来指定异常的处理
    $routePriovder.otherwise({redirectTo:&apos;路由地址&apos;})

SPA在ng实现过程，代码片段的跳转：
①直接修改地址栏中的路由地址
    http://localhost:63342/day4/demo03_SPA%E7%BB%83%E4%B9%A0.html#/myLogin
    http://localhost:63342/day4/demo03_SPA%E7%BB%83%E4%B9%A0.html#/myRegister
②通过js的方式
    $location.path(&apos;路由地址&apos;)
③超链接的方式
    a href=&quot;#/myRegister&quot;
    login-&gt;start 10

SPA应用程序通过ngRoute来传递参数：
①搞明白 发送 接收
②配置接收方的路由
    $routeProvider.when(&apos;/myStart/:num&apos;,{
    templateUrl:&apos;tpl/start.html&apos;
    })
③拿到传递过来的参数
    $routeParams.num
④发送
    a href=&apos;#/myStart/10&apos;
    $location.path(&apos;/myStart/10&apos;)

注意事项：配置接收方路由时的冒号后的变量名称要和通过$routeParams解析参数的属性是要保持一致
    myStart/:id $routeParams.id

练习：实现一个SPA
完整的html manager.html
代码片段： checkProduct.html pay.html send.html

要求：能够实现不同页面的跳转以及参数的传递
checkProduct.html 能够a跳转到pay，传递price，在pay接收传递过来的参数显示在pay页面
pay 点击button跳转到send
send button以及a跳转到check.html

优化思路：如果多个控制器需要用到同一个方法或者数据，
    ①将方法和数据封装成一个服务
    ②$rootScope
    ③控制器之间的嵌套
    ④借助于事件

由于不同的代码片段都显示在了body的子元素中：body是所有代码片段的父元素，可以在body指定控制器，
控制器中的方法和数据，代码片段就可以用了。
①发送 接收
    checkProduct --&gt; pay

②配置接收方路由
    .when(&apos;/myPay/:price&apos;,{})

③$routeParams
    $routeParams.price

④发送参数
    href=&apos;#/myPay/20&apos;
    $location.path(&apos;/myPay/20&apos;)

ngInclude 引入多个地方同时需要用到的，比如页头、页尾。。。

要求：给综合练习的3个代码片段加上头信息(显示一个p标签)

注意事项：在使用ngInclude进行赋值的时候，对应的路径字符串要在双引号内 加上一对单引号
</code></pre><p>19、ngAnimate（动画模块）</p>
<pre><code>在angularJS添加动画效果，需要用到ngAnimate模块
基本步骤：
①引入对应的js文件
    angular-animate.js
②指定自定义模块依赖于ngAnimate
    angular.module(&apos;myModule&apos;,[&apos;ng&apos;,&apos;ngRoute&apos;,&apos;ngAnimate&apos;])
③css给ng应用程序添加动画效果：
    ngEnter 准备进入
    ngEnterActive 进入完成
    ngLeave 准备离开
    ngLeaveActive 离开完成
④引入对应的css文件

如果用到其它的模块整体思路：
    ①在ng每一个模块都有自己的js文件，用到哪个模块，把指定模块的js文件引入进来
    ②在创建模块，指定依赖列表
    ③根据模块中所提供的指令、服务。。结合业务需要进行
</code></pre><p>20、表单验证</p>
<pre><code>在ng中，针对表单和空间提供了属性，用于验证控件交互的状态
布尔类型：
$valid
$invalid
$dirty
$pristine
对象：
$error

注意事项：
①给表单以及表单组件 加上name属性
②给需要用到的表单组件 ，加上ngModel
③属性的用法
myForm.t_age.$dirty/$pristine/$valid/$invalid/$error
</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;1、设计原则和设计模式&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;拙劣的设计：
①僵化
②脆弱
③不必要的复杂
④晦涩。。

1、YAGNI（不要写不需要的代码）
you aren&amp;apos;t gonna need it

2、KISS （越简单越好）
keep it simple 
    
    </summary>
    
      <category term="学习笔记" scheme="www.wangchengzou.cn/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Angular" scheme="www.wangchengzou.cn/tags/Angular/"/>
    
  </entry>
  
  <entry>
    <title>CSS3笔记</title>
    <link href="www.wangchengzou.cn/2017/07/22/CSS3%E7%AC%94%E8%AE%B0/"/>
    <id>www.wangchengzou.cn/2017/07/22/CSS3笔记/</id>
    <published>2017-07-22T15:48:26.000Z</published>
    <updated>2017-07-23T10:29:58.932Z</updated>
    
    <content type="html"><![CDATA[<p>1、CSS概述</p>
<pre><code>1、问题
    1、控制页面中所有的文本颜色为 红色
    2、控制页面中所有div的文本颜色 为蓝色
    3、将 所有div 的颜色 变为 黄色

    HTML元素的不足：
        1、要完成相同的效果，使用的是不同的属性
            &lt;body text=&quot;red&quot;&gt;
            &lt;font color=&quot;blue&quot;&gt;
        2、没有提升 html属性的 可重用性和可维护性
            可重用性：重复的操作 不用重复的写

        可以通过 CSS 解决以上两个问题
2、什么是CSS
    CSS (Cascading Style Sheets),层叠样式表，级联样式表，简称：样式表。专门用于定义页面元素的样式的。
    以统一的方式定义页面元素的样式

    CSS实现了内容与表现相分离
    提升了代码的可重用性 和 可维护性
3、CSS 与 HTML之间的关系
    HTML : 专门用于构建网页结构
    CSS : 专门构建HTML网页的样式

    HTML属性效果 与 CSS样式效果相冲突的话：
    优先使用 CSS 定义页面元素的效果
</code></pre><p>2、CSS语法</p>
<pre><code>1、使用CSS样式表
    1、内联方式
        又称为 ：行内样式
        将样式定义在某个html元素中
        语法：
        &lt;ANY style=&quot;样式声明;样式声明;&quot;&gt;&lt;/ANY&gt;
        样式声明：
            由 属性名称 和 属性值 来组成，属性名称和属性值之间用 : 来关联
        ex:
            属性名称          属性值
            color             red,blue,yellow...
            background-color  合法颜色值即可..(同上)
            font-size         以px，pt，为单位的数值

            控制以下 文本颜色为 红色，背景颜色为 黄色，文字大小为 24px
            &lt;p&gt;静夜思&lt;/p&gt;
    2、内部样式表
        将样式定义在网页的一块独立位置处
        在 &lt;head&gt;&lt;/head&gt; 中 增加一对 &lt;style&gt;&lt;/style&gt;元素，在 &lt;style&gt; 元素中 定义元素的样式,具体语法如下：
        &lt;head&gt;
            &lt;title&gt;&lt;/title&gt;
            &lt;style&gt;
                样式规则1
                样式规则2
                ...
                样式规则n
            &lt;/style&gt;
        &lt;/head&gt;
        样式规则，由两部分组成
            1、选择器
                选择(规范)页面中哪些元素能够使用声明好的样式
                比如：元素选择器，由元素名称来充当选择器，控制某标记对应所有页面元素的样式
            2、若干样式声明

            样式规则 语法结构：
            选择器{
                样式声明1;
                样式声明2;
                ...
                样式声明n;
            }
            ex:
            p{
                color:red;
                background-color:yellow;
                font-size:24px;
            }

    3、外部样式表
        将样式定义在外部的&quot;样式表文件(*.css)&quot;中
        1、创建 .css 文件，编写样式规则
        2、在要使用 样式表的 html文件中进行引入
            &lt;head&gt;
                &lt;link rel=&quot;stylesheet&quot; href=&quot;样式表文件url&quot;&gt;
            &lt;/head&gt;
2、CSS样式表特征
    1、继承性
        大部分样式属性是可以被继承
    2、层叠性
        可以为一个元素定义多个样式规则
        如果 属性 不冲突时，多个样式规则可以层叠为一个(即都可以应用到当前元素上)
    3、优先级
        在层叠性基础上，如果 样式定义 冲突的话，那么就会按照不同使用方式的优先级，来选择性应用样式
        低 ：浏览器默认设置
        中 ：外部样式表 和 内部样式表
            就近原则
            后定义优先
        高 ：内联方式
    4、!important 规则
        显示调整样式属性的优先级
        语法：
            属性名:值 !important;
        谨慎使用!
3、选择器(重点)
    1、作用
        选择(规范)页面中哪些元素能够使用声明好的样式
        为了匹配页面的元素
    2、详解
        1、通用选择器
            作用：匹配页面中所有的元素
            语法：*{}
            缺点：效率较低，尽可能少用,可以通过 使用 body 的继承性 来替代 *
        2、元素选择器
            作用：匹配某一标记所对应的页面中所有的元素
            语法：元素/标签 {}
            ex:
            div{/*匹配页面中所有div*/}
            span{/*匹配页面中所有span*/}
            li{/*匹配页面中所有li*/}
        3、类选择器
            作用：事先定义好样式，可以由任意元素通过class属性进行引用
            语法：
                定义：.类名{}
                引用：&lt;ANY class=&quot;类名&quot;&gt;&lt;/ANY&gt;

            多类选择器的引用方式：
            让一个元素引用多个类选择器，中间用 空格 隔开即可

            分类选择器的声明方式：
                将元素选择器和类选择器结合到一起进行声明，实现对某种元素中的不同样式细分控制

                ex:想要控制 class为important的div元素，文字大小为 48px
                语法：元素选择器.类选择器{}
        4、id选择器
            作用：匹配 指定id值的元素的 样式
            ex:
                &lt;div id=&quot;nav&quot;&gt;&lt;/div&gt;

            语法：#ID值{}
        5、群组选择器
            群组选择器的声明以一个以 , 隔开的选择器列表
            语法：
                选择器1,选择器2,...{}
            ex:
                #title,p.redColor,.important,span{
                    color:red;
                }
        6、后代选择器
            后代：
                多于 一级 层级关系的元素，只能叫后代
                只具备 一级 层级关系的 也可以叫后代
            语法：
                选择器1 选择器2{}
                语义：匹配 在选择器1 中的  所有后代元素 选择器2
                ex:
                    #content span{}
        7、子代选择器
            子代：
                只具备 一级 层级关系的 称之为 子代
            语法：
                选择器1&gt;选择器2{}
                语义：匹配 在选择器1 中的 子级元素 选择器2
        8、伪类选择器
            伪类：专门匹配元素不同状态的选择器
            分类：
                1、链接伪类
                2、动态伪类

                3、目标伪类
                4、元素状态伪类
                5、结构伪类
                6、否定伪类
            语法：
                以 :作为开始的选择器

                1、链接伪类
                    1、:link
                        适用于未被访问的超链接
                    2、:visited
                        适用于访问过的超链接
                2、动态伪类
                    1、:hover
                        适用于鼠标悬停在html元素时
                    2、:active
                        适用于html元素被激活时
                    3、:focus
                        适用于html元素获取焦点时
</code></pre><p>3、尺寸与边框</p>
<pre><code>1、CSS单位
    1、尺寸单位
        1、px ：像素
        2、pt ：磅 (1pt=1/72in)
        3、in ：英寸，1in=2.54cm
        4、%  ：百分比，占据 当前元素 或 父元素 对应属性的 占比
        5、em ：倍数，多数用于 文字大小的描述
        6、mm ：毫米
        7、cm ：厘米
        注意：css中尺寸单位是不能省略的。
    2、颜色单位(取值)
        1、rgb(r,g,b)
                r : red , 范围 0-255
                g : green,范围 0-255
                b : blue, 范围 0-255

             ex：
                background-color:rgb(0,0,0);黑色
                background-color:rgb(255,0,0);红色
                background-color:rgb(255,255,255);白色
        2、rgb(r%,g%,b%)
        3、rgba(r,g,b,alpha)
            alpha : 透明度 0-1之间的数字
                0 : 完全透明
                1 : 完全不透明
                0.5 : 半透明
        4、#rrggbb
            通过6位16进制数字表示一个颜色
            每位数字范围：0-9 A-F
            #00ff00 : 绿色
            #ff0000 : 红色
            #1a2b3c : ?
        5、#rgb
            #rrggbb 每两位数字相同时，可以使用#rgb简化
            #00ff00 -&gt; #0f0
            #aabbcc -&gt; #abc
            #accdda -&gt; ×
        6、颜色的英文表示
            red,green,blur,orange,yellow...
2、尺寸属性
    1、作用
        用于设置元素的宽度和高度
        单位一般为 px 或 %(父元素对应属性的占比)
    2、语法
        1、宽度
            width
            min-width : 最小宽度
            max-width : 最大宽度
        2、高度
            height
            min-height : 最小高度
            max-height : 最大高度
        注意：
            页面中所有元素的高度，在不指定的情况全部是自适应(以内容为主)。

            页面中所有块级元素的宽度，默认占据父元素的100%
            页面中所有行内元素的宽度，默认自适应(以内容为主)
    3、页面中允许修改 尺寸 属性的元素
        1、所有块级元素都允许修改
        2、大部分的行内块元素
            所有的表单元素都是行内块元素
            除radio、checkbox之外，其他元素允许修改尺寸
        3、本身html元素就具备width 和 height的
            img，table 可以修改尺寸
        4、行内元素(除具备width和height之外)是不能修改尺寸
            span,b,a,i,s,b ... 不能修改尺寸
    4、溢出
        1、什么是溢出
            使用尺寸属性限制元素大小时，如果内容所需要的空间大于元素本身空间，则会导致内容溢出
        2、溢出处理属性
            属性：
                overflow
                overflow-x : 横向溢出处理
                overflow-y : 纵向溢出处理
            取值：
                1、visible
                    默认值，溢出可见
                2、hidden
                    隐藏
                3、scroll
                    滚动，让元素出现滚动条，溢出时，滚动条可用
                4、auto
                    自动，溢出时显示滚动条并可用，非溢出时，不显示滚动条
3、边框属性
    1、边框
        1、简写方式
            border:width style color;
            作用：设置元素上下左右四个边框的宽度，样式以及颜色
                width:边框的宽度(尺寸)
                style:边框的样式
                    取值：
                        1、solid ：直线
                        2、dotted ：虚线(点状)
                        3、dashed ：虚线(线状)
                color:边框的颜色,可以取值为 transparent(透明)

            ex:
                div{
                    border:1px solid red;
                }
        2、单边定义
            border-方向:width style color;
            方向可以被以下关键字所取代
            top : 上
            right : 右
            bottom : 下
            left:左
            ex:
                border-bottom:2px dashed #00ff00;
        3、单属性定义
            border-属性:值;
            属性可以被以下关键字取代：
            width:宽度
            style:样式
            color:颜色
            ex:
                border-width:5px;
                border-style:solid;
                border-color:#f00f00;
        4、单边单属性定义
            border-方向-属性:值;
            方向：top/right/bottom/left
            属性：width/style/color
            ex:
                border-top-color:yellow;
                border-right-style:dotted;
</code></pre><hr>
<p>1、边框</p>
<pre><code>1、边框
    边框实际上是由四个三角形组成的
2、边框倒角
    属性：border-radius
    取值：
        具体数值(px) 或 %
        最少一个值，最多4个值
    单角定义
        border-top-left-radius:左上角倒角半径
        border-bottom-right-radius:右下角
        ... ...
3、边框阴影
    属性：box-shadow
    取值：h-shadow v-shadow blur spread color inset;
        h-shadow:(必须)
            阴影的水平偏移距离
            取值为正，右偏移
            取值为负，左偏移
        v-shadow:(必须)
            阴影的垂直偏移距离
            取值为正，下偏移
            取值为负，上偏移
        blur : 模糊距离,取值为数值
        spread : 阴影的大小
        color : 颜色
        inset : 值，将默认的外阴影改为内阴影
4、轮廓
    1、什么是轮廓
        位于元素外围的一条线,位于边框之外的
    2、属性
        outline:width style color;
        outline-width:宽度;
        outline-style:样式;
        outline-color:颜色;

        常用：
            outline:none;
            或
            outline:0;
    练习：作业基础上
        1、为每幅图像增加四个角的倒角(5px)
        2、鼠标移入的时候，为每幅图像增加阴影
            右下偏移，大小不限，颜色不限
</code></pre><p>2、框模型(重难点)</p>
<pre><code>1、框 &amp; 框模型
    框：页面元素皆为框
    框模型：Box Model ,定义了元素框处理元素内容尺寸，内边距，边框和外边距的一种方式

    元素一旦增加框模型对应属性的属性，那么实际的占地区域会发生改变

    元素的实际宽度=左右外边距 + 左右边框 + 左右内边距 + width;

    元素的实际高度=上下外边距 + 上下边框 + 上下内边距 + height;
2、外边距
    1 、外边距
        围绕在元素边缘周围的空白区域
        默认不能被其他元素所占据
        作用：拉伸两个元素间的距离
    2、语法
        属性：
            margin:值;
            单边设置：
            margin-方向:值;
                方向：top/right/bottom/left
        取值：
            1、具体数值 px
            2、%
            3、负值
                左外边距取负值 ：左移动
                左外边距取正值 ：右移动
                上外边距取负值 ：上移动
                上外边距取正值 ：下移动
            4、auto
                自动，由浏览器计算外边距的值应该是多少
                注意：默认情况下，auto只对左右有效，上下无效。

                为块级元素设置宽度后，再设置其左右外边距为 auto，该元素能水平居中显示
        margin的简洁写法：
            margin:value; 四个方向外边距的值
                margin:5px;
            margin:v1 v2; v1 上下外边距 v2 左右外边距
                margin:5px 10px;
            margin:v1 v2 v3;v1 上外边距 v2 左右外边距 v3 下外边距
                margin:5px 15px 3px;
            margin:v1 v2 v3 v4;上 右 下 左
    3、页面中具备默认外边距的元素
    4、特殊注意
        1、外边距合并
            当两个垂直外边距相遇时，将合并成一个
        2、外边距的溢出
            特殊场合下，为子元素设置外边距(上下)会作用到父元素上
            特殊场合：
                1、父元素没有边框(上下)
                2、为第一个(最后一个)子元素设置外边距
            解决方案：
                1、为父元素增加边框(透明的)
                    弊端：父元素会变高
                2、可以为父元素设置上内边距来取代子元素上外边距
                    弊端：父元素高度会变高
                3、为父元素增加一个空子元素
                    &lt;table&gt;&lt;/table&gt;
                    弊端：多一个子元素
                4、后续讲解...(CSS3高级)
        3、为行内元素和行内块元素设置垂直外边距
            1、大部分行内元素垂直外边距无效
                img允许设置
            2、行内块元素设置垂直外边距，该行的所有元素都跟着变
3、内边距
    1、什么是内边距
        内容区域 和 边框(边缘)之间的距离
        注意：内边距会扩大边框所占用的区域
    2、语法
        属性：
            padding:值;
            padding-方向:值;
                方向：top/right/bottom/left
            取值：
                1、px
                2、%
                3、auto
        简写方式：
            padding:value; 上下左右
            padding:v1 v2; 上下  左右
            padding:v1 v2 v3;上  左右  下
            padding:v1 v2 v3 v4;上 右 下 左
    3、特殊注意
        1、为行内元素增加上下内边距时
            只影响自己，并不影响其他元素
4、box-sizing
    1、作用
        重新指定元素尺寸计算模式
        占地宽度 = margin+border+padding+width
        可见宽度 = border+padding+width
    2、语法
        属性：box-sizing
        取值：
            1、content-box
                默认值，width只表示内容区域的宽度，border和padding额外进行计算
                可见宽度=border+padding+width
            2、border-box
                width包含边框内所有的距离(padding,border)
                可见宽度=width(border+padding+宽度);
</code></pre><p>3、背景</p>
<pre><code>1、背景颜色
    属性：background-color
    取值：颜色值 或 transparent
    注意：背景颜色从边框位置处开始绘制
2、背景图像
    属性：background-image
    取值：url(背景图url)
3、背景重复
    属性：background-repeat
    取值：
        1、repeat
            默认值，即横向又纵向平铺
        2、repeat-x
            只在横向平铺
        3、repeat-y
            只在纵向平铺
        4、no-repeat
            不平铺
4、背景图片尺寸
    属性：background-size
    取值：
        1、value1 value2
            指定背景图像宽度 和 高度
        2、value1% value2%
            采用当前元素宽和高的占比，来作为背景图大小
        3、cover
            覆盖，会将背景图像等比放大，直到背景图完全覆盖到元素为止
        4、contain
            包含，会将背景图像等比放大，直到右边或下边碰到元素边缘为止
5、背景图片固定
    属性：background-attachment
    取值：
        1、scroll
            滚动，默认值
        2、fixed
            固定，让背景图一直在可视化区域中
6、背景图片定位
    改变背景图在元素中的位置
    属性：background-position
    取值：
        1、x y
            指定背景图水平 和 垂直偏移距离
            x : 水平偏移距离
                取值为正，背景图右偏移
                取值为负，背景图左偏移
            y : 垂直偏移距离
                取值为正，背景图下偏移
                取值为负，背景图上偏移
        2、x% y%
            0% 0% : 背景图在左上
            0% 100% : 背景图在左下
            100% 100% : 背景图在右下
        3、关键字
            x : left / center / right
            y : top / center/ bottom
7、背景属性
    在一个 background 属性中声明所有的北京属性值

    属性：background
    取值：color url repeat attachment position;

    ex:
        background:red;
        background:url(a.jpg) no-repeat;
8、特殊使用
    CSS Sprites(精灵图/雪碧图)
</code></pre><p>1、渐变</p>
<pre><code>1、什么是渐变
    多种颜色之间平缓过度的显示效果
2、渐变分类
    1、线性渐变(linear-gradient)
        按照直线的方式填充渐变颜色和方向
    2、径向渐变(radial-gradient)
        以圆的方式填充渐变效果(圆心位置，半径)
    3、重复渐变
        1、重复线性渐变
            repeating-linear-gradient
        2、重复径向渐变
            repeating-radial-gradient
3、渐变中的重要信息
    1、色标
        由 颜色 及其 出现的位置 来组成的
4、渐变的语法
    1、属性
        background-image
    2、取值
        1、linear-gradient()
            linear-gradient(angle,color-point1,color-point2);
            1、angle
                填充的方向或角度
                1、关键字
                    1、to top ：从下向上填充
                    2、to right ：从左向右填充
                    3、to bottom ：从上向下填充
                    4、to left ：从右向左填充
                2、角度
                    0deg ~ 360deg

                    0deg : to top
                    90deg : to right
                    180deg : to bottom
                    270deg : to left
            2、color-point
                渐变中的色标,由 颜色 及其 出现的位置组成
                ex:
                    1、red 0px
                        该色标颜色为 red ，位置为填充方向的 0px 处
                    2、green 50px
                        该色标颜色为 green,位置为填充方向的 50px 处
                    3、blue 50%
                        该色标颜色为 blue，位置为填充方向的 50% 处
                    4、
                        linear-gradient(to top,red,blue,green);
                        自动分配位置
        2、radial-gradient()
            radial-gradient([size at position,]color-point,color-point)

            1、[size at position,] : 允许被省略
                size:圆的半径
                at : 关键字
                position:圆心的位置
                    1、x y
                        以px为单位的具体数值
                    2、x% y%
                    3、关键字
                        x : left , center , right
                        y : top , center, bottom
        3、repeating-linear-gradient()
        4、repeating-radial-gradient()
5、浏览器兼容性问题
    主流浏览器都支持渐变
    对于不支持的浏览器，需要添加浏览器前缀的方式实现兼容性
        浏览器前缀：
            1、Firefox ：-moz-
            2、Chrome 和 Safari ：-webkit-
            3、Opear ：-o-
            4、Microsoft IE ：-ms-
        如果浏览器不支持属性的话，则将前缀添加到属性名称前
            ex:
                animation:值;
                -moz-aniamtion:值;
                -webkit-aniamtion:值;
                -o-aniamtion:值;
                -ms-animation:值;
        如果浏览器支持属性，但不支持属性值的话，则将前缀添加到属性值前
            ex:
                background-image:linear-gradient();
                background-image:-moz-linear-gradient();
                background-image:-webkit-linear-gradient();
                background-image:-o-linear-gradient();
                background-image:-ms-linear-gradient();
</code></pre><p>2、文本格式化</p>
<pre><code>1、字体属性
    1、指定字体
        属性：font-family
        取值：字体1,字体2,字体3;
        注意：字体中包含中文或特殊字符的话，尽量使用 &quot;&quot; 引起来
        ex:
            font-family:&quot;微软雅黑&quot;,Arial;
    2、字体大小
        属性：font-size
        取值：px 或 pt 为单位的数值
    3、字体加粗
        属性：font-weight
        取值：
            1、normal
                非加粗显示，正常体
            2、bold
                加粗显示 &lt;b&gt;&lt;/b&gt;
            3、400 ~ 900
                400 ：normal
                900 ：bold
    4、字体样式
        属性：font-style
        取值：
            1、normal
                正常体
            2、italic
                斜体 &lt;i&gt;&lt;/i&gt;
    5、小型大写字符
        效果：将小写英文字符变成大写，但是大小和小写字符一样
        属性：font-variant
        取值：
            1、normal
                正常，默认值
            2、small-caps
                小型大写字符
    6、字体属性
        属性：font
        取值：style variant weight size family;
        注意：该简写属性中，必须包含 family 的值
2、文本属性
    1、文本颜色
        属性：color
        取值：~
    2、文本排列
        作用：控制内容的的水平对齐方式
        属性：text-align
        取值：left/center/right/justify(两端对齐)
    3、文本修饰
        线条修饰
        属性：text-decoration
        取值：
            1、none
                无线条修饰
            2、underline
                显示下划线
            3、line-through
                显示删除线 &lt;s&gt;&lt;/s&gt;
            4、overline
                显示上划线
    4、行高
        作用：一行数据的高度
        属性：line-height
        取值：以px为单位 或 当前字体大小的倍数
            line-height:50px;
            line-height:1.5;
        注意：文字将在指定行高的范围内垂直居中显示
        场合：
            1、文字垂直居中
            2、行间距的设置
    5、文本阴影
        属性：text-shadow
        取值：h-shadow v-shadow blur color;
</code></pre><p>3、表格</p>
<pre><code>1、表格常用属性
    1、边距属性
        padding，margin(不能为td设置margin)
    2、尺寸属性
        width,height
    3、文本格式化属性
        font-*,text-*,line-height,color,... ...
    4、背景属性
        颜色，图片，渐变
    5、border属性
    6、垂直方向对齐
        属性：vertical-align
        取值：top / middle / bottom
2、表格特有属性
    1、边框合并属性
        属性：border-collapse
        取值：
            1、separate
                默认值
            2、collapse
                合并
    2、边框边距
        类似于 cellspacing
        属性：border-spacing
        取值：
            1、指定1个值
                每个单元格的水平和垂直间距相同
            2、指定2个值
                第一个值，表示水平间距
                第二个值，表示垂直间距
        注意：
            必须保证border-collapse是separate时才有效
    3、标题位置
        默认情况下，标题表格上方，水平居中
        属性：caption-side
        取值：
            1、top
                默认值
            2、bottom
                底部
    4、显示规则
        作用：指定浏览器如何来布局一张表格(指定行和列的尺寸的计算模式)
        属性：table-layout
        取值：
            1、auto
                自动，即自动表格布局，默认值
                列的宽度高度实际上是由内容来决定的
            2、fixed
                固定，即固定表格布局。
                列的宽度和高度由设定的值决定
        自动表格布局 VS 固定表格布局
            1、自动表格布局
                1、单元格的大小会适应内容
                2、表格复杂时，加载速度较慢(缺点)
                3、适用于不确定每列大小时使用
                4、特别灵活(优点)
            2、固定表格布局
                1、尺寸取决于设定的值，与单元格内容无关
                2、任何情况下，都会加速显示表格(优点)
                3、不够灵活(缺点)
        推荐：
            复杂的布局不能使用table
            简单，显示数据的布局，可以使用table
</code></pre><p>4、浮动</p>
<pre><code>1、定位
    改变元素在网页中的默认位置
2、定位的分类
    按照定位效果，可以分为以下几种方式：
    1、普通流定位/文档流定位
    2、浮动定位
    3、相对定位
    4、绝对定位
    5、固定定位
3、定位-普通流定位
    普通流定位，又称为 文档流定位，网页元素默认定位方式
    1、页面中所有元素都有自己的位置
    2、按照从左到右，从上到下的方式排列
    3、块级元素 - 从上到下排列
    4、行内/行内块 - 从左到右排列

    问题：让多个块级元素在一行内显示?
4、定位 - 浮动定位
    1、浮动定位特点
        将元素设置为浮动定位，将具备以下特征
        1、会排除在文档流之外即&quot;脱离文档流&quot;，不再占据页面空间，后续元素则上前补位
        2、浮动元素只在当前行内浮动
        3、浮动元素会停靠在父元素的左边或右边或其他已浮动元素的边缘上
        4、浮动元素依然位于父元素之内
        5、解决问题-多个块级元素在一行内的显示问题
    2、语法
        属性：float
        取值：
            1、none
                默认值，即无任何浮动
            2、left
                元素左浮动
                停靠在父元素的左边 或 其他已浮动元素的右边上
            3、right
                元素右浮动
                停靠在父元素的右边 或 其他已浮动元素的左边上
    3、浮动引发的特殊效果
        1、当父元素容纳不下所有已浮动子元素，最后一个将换行显示(有可能被卡住)
        2、元素一旦浮动起来后，宽度将变成自适应(非手动指定情况下)
        3、元素一旦浮动起来后，都将变成块级元素
            块级：允许修改尺寸，允许设置上下margin
            行内元素：不能改尺寸，不能设置上下margin
        4、行内元素，行内块元素，文本 采用的是环绕的排列方式，无法被浮动元素压在底下
</code></pre><p>1、浮动定位</p>
<pre><code>1、清除浮动
    1、什么是清除浮动
        清除当前元素前面的元素浮动所带来的影响
        清除浮动影响后，当前元素不会上前占位
    2、属性
        属性：clear
        取值：
            1、none
                默认值，无清除效果
            2、left
                清除当前元素前面元素左浮动带来的影响
            3、right
                清除当前元素前面元素右浮动带来的影响
            4、both
                清除当前元素前面元素任何一种浮动方向所带来的影响
    3、浮动元素为父元素高度带来的影响
        父元素的高度是以未浮动的子元素高度为准
        如果一个元素中所有的子元素全部都是浮动的，那么该父元素的高度为 0
        解决父元素的高度问题方案：
        1、直接设置父元素高度
            弊端：必须知道父元素的高度
        2、让父元素也浮动
            弊端：对后续元素会产生影响
        3、为父元素增加溢出处理属性
            属性：overflow
            取值：hidden 或 auto
            弊端：要溢出显示的内容，也一同被隐藏
        4、在父元素中，增加空子元素到最后一个位置处,并且设置其clear属性为both
            弊端：多一个子元素在页面上
</code></pre><p>2、显示</p>
<pre><code>1、显示方式
    属性：display
    取值：
        1、none
            让指定的元素不显示 并且 不占据页面空间
            (脱离文档流)
        2、block
            将指定的元素显示为块级
        3、inline
            将指定的元素显示为行内
        4、inline-block
            将指定的元素显示为行内块
            行内块特点：
                1、多个元素能够在一行内显示
                2、允许修改尺寸
        5、table
            将指定的元素显示为 table
2、显示效果
    1、visibility 属性
        作用：规范元素可见性
        取值：
            1、visible
                默认值，元素可见
            2、hidden
                元素不可见，但是占据页面空间
            3、collapse
                用在表格元素上，删除一行或一列时，不影响表格整体布局
        面试：
            display:none 和 visibility:hidden 区别
            1、display:none; 脱离文档流，所以不占据页面空间
            2、visibility:hidden; 只是改变可见性，并不脱离文档流，空间依然占据
    2、opacity 属性
        作用：改变元素的透明度
        取值：从0.0(完全透明) ~ 1.0(完全不透明) 之间的数字
    3、vertical-align 属性
        1、在 td 中，设置文本的垂直对齐方式
        2、设置行内块元素两边文本的垂直对齐方式
        3、设置图片两端文本垂直对齐方式

        语法：
            属性：vertical-align
            取值：
                1、top
                2、middle
                3、bottom
                4、baseline
                    基线对齐
3、光标
    改变鼠标在页面(元素)中的状态
    属性：cursor
    取值：
        1、default
        2、pointer
            小手
        3、crosshair
            +
        4、text
            文本状态 I
        5、wait
            等待
        6、help
            帮助
</code></pre><p>3、列表</p>
<pre><code>1、列表项标识
    属性：list-style-type
    取值：
        1、none
        2、disc ：实心圆
        ... ...
2、列表项图像
    属性：list-style-image
    取值：url()
3、列表项标识位置
    列表项标识的默认位置是在内容区域之外
    属性：list-style-position
    取值：
        1、outside
            默认值
        2、inside
            将列表项标识的位置改为内容区域之内
4、列表属性
    属性：list-style
    取值：type url position;
    常用方式：list-style:none;
5、CSS重写
    CSS Reset，修改元素的默认样式
    body,p,h1,h2,h3,h4,h5,h6,pre,ul,ol,dl,dd{
        margin:0;
        padding:0;
        list-style:none;
    }
</code></pre><p>4、定位(相对，绝对，固定)</p>
<pre><code>1、定位属性
    1、定位属性
        属性：position
        作用：改变元素定位方式
        取值：
            1、static
                静态的，默认值
            2、relative
                相对的
            3、absolute
                绝对的
            4、fixed
                固定定位
        注意：relative，absolute，fixed被称之为 &quot;已定位元素&quot;
    2、偏移属性
        作用：改变元素在页面中的位置
        属性：
            1、top
            2、bottom
            3、left
            4、right
        取值：偏移距离(px)
    3、堆叠顺序
        作用：在已定位元素中调整堆叠顺序
        属性：z-index
        取值：无单位的数字
2、定位 - 相对定位
    1、什么是相对定位
        元素会相对于它原来的位置偏移某个距离
        元素原来所占的空间会被保留
    2、语法
        position:relative;
        配合 top/right/bottom/left 偏移属性实现位置的微调
    3、使用场合
        1、元素位置微调
3、定位 - 绝对定位
    1、什么是绝对定位 &amp; 特点
        1、绝对定位的元素会脱离文档流即不占据页面空间
        2、绝对定位的元素会相对于离它最近的已定位的祖先元素去实现定位
        3、如果没有已定位的祖先元素，那么就会相对于最初的包含块去实现定位比如body或html
    2、语法
        position:absolute;
        配合着 top/right/bottom/left 实现位置定位
    3、特点
        1、绝对定位元素会变成块级元素
        2、绝对定位元素的margin可以使用，默认情况下，auto会失效
        &lt;div id=&quot;d1&quot;&gt;(无定位)
            &lt;div id=&quot;d2&quot;&gt;(无定位)
                &lt;p id=&quot;p1&quot;&gt;(无定位)
                    &lt;span&gt;这是一个span&lt;/span&gt;
                &lt;/p&gt;
            &lt;/div&gt;
        &lt;/div&gt;
4、堆叠顺序
    属性：z-index
    取值：无单位的数值
        数值越大，越靠前，默认是0
        可以取负值，当前元素在页面所有内容之下
    注意：
        1、只有已定位元素才能设置z-index
        2、默认的堆叠顺序是 后来者居上
        3、父子元素中，永远都是子压在父上,是不受z-index影响的
</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;1、CSS概述&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;1、问题
    1、控制页面中所有的文本颜色为 红色
    2、控制页面中所有div的文本颜色 为蓝色
    3、将 所有div 的颜色 变为 黄色

    HTML元素的不足：
        1、要完成相同的效果，使
    
    </summary>
    
      <category term="学习笔记" scheme="www.wangchengzou.cn/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="CSS" scheme="www.wangchengzou.cn/tags/CSS/"/>
    
      <category term="CSS3" scheme="www.wangchengzou.cn/tags/CSS3/"/>
    
  </entry>
  
  <entry>
    <title>CSS3高级笔记</title>
    <link href="www.wangchengzou.cn/2017/07/22/CSS3%E9%AB%98%E7%BA%A7/"/>
    <id>www.wangchengzou.cn/2017/07/22/CSS3高级/</id>
    <published>2017-07-22T15:48:26.000Z</published>
    <updated>2017-07-23T10:33:13.367Z</updated>
    
    <content type="html"><![CDATA[<p>1、复杂选择器</p>
<pre><code>1、兄弟选择器
    通过兄弟级别的位置关系来匹配页面元素
    注意，兄弟选择器，只能向后找，不能向前找
    语法：
        相邻兄弟选择器：通过相邻（紧紧挨着的）位置关系匹配元素
        选择器1+选择器2
        如：div+p   #top+.important
                通用兄弟选择器：用于匹配某元素后面所有的兄弟元素
        选择器1~选择器2
        如#d1~div
2、属性选择器
    通过元素所附带的属性及其值来匹配页面中的元素
    语法：
        基础属性选择器  [attr]
            匹配页面中的有附带attr属性的元素
        elem[attr]
            elem:表示任意元素名称
            attr:表示任意属性名称
            匹配页面中附带attr属性的elem元素
            如：div[id]:匹配页面中所有附带id属性的div元素
        [attr1][attr2][attr3]
            匹配页面中同时附带attr1和attr2属性的所有元素
            如 input[name][hype]
        [attr=value]
            匹配页面中所有attr属性的值为value的元素
            如input[type=text]
        [class~=value]
            主要使用在多类选择器上，匹配页面中class属性值中包含value选择器的元素
        [attr^=value]
            匹配以value值作为开始的attr属性的元素
        [attr$=value]
            匹配以value值作为结束的attr属性的元素
        [attr*=value]
            匹配attr属性值中包含value字符的所有元素
3、伪类选择器
    目标伪类
        突出显示活动的HTML锚元素
        语法： ：target
    结构伪类
        通过元素之间的结构关系来匹配元素
        ：first-child     获取属于其父元素中的首个子元素
        ：last-child     获取属于其父元素中的尾（最后）子元素
        :nth-child(N)  获取属于其父元素中的第N个子元素
        ：empty   空的，匹配没有子元素的元素，包含文本
        ：only-child   匹配属于其父元素中的唯一子元素
    否定伪类
        把匹配某选择器元素排除出去
        ：not(选择器 )
4、伪元素选择器
    伪类与伪元素
        伪类：匹配元素不同的状态
        伪元素：是匹配元素中的内容
    语法：
        ：first-letter
        ::first-letter  匹配某元素的首字符
        ：first-line    匹配某元素的首行字符
        ：：selection 匹配用户选取的内容部分
    ：和：：区别
        在CSS2.1中，伪类选择器和仿元素选择器都是用：来表示
        在CSS3中，所有伪类选择器用：表示，所有的伪元素选择器用：：表示
</code></pre><p>2、内容生成</p>
<pre><code>通过CSS动态的向某个元素的内容区域之前、之后增加一部分内容
伪元素选择器
    ：before   定位到元素内容区域之前
    ：after    定位到元素内容区域之后
语法：
    属性：content
    取值：普通文本
         图像，url(...)
         计数器
问题处理：
    外边距溢出问题
        为父元素添加边框
        使用父元素的内边距取代子元素的外边距
        在父元素的第一个或最后一个子元素位置处增加一个空的table
    浮动元素父元素的高度问题
</code></pre><p>3、弹性布局</p>
<pre><code>flexible box,可伸缩布局，为普通布局带来更大的灵活性
基本概念‘
    flex容器：简称容器，将元素设置为flex容器后，其子元素允许实现灵活的位置摆放
    flex项目：简称项目，存放在flex容器中的内容

语法：
    容器：display
        取值：flex 将块级元素变为flex容器
              inline-flex  将行内元素变为flex容器
        注意：将元素设置为flex布局后，子元素的float,clear,vertical-align属性将失去作用
    容器属性;
        该组属性要添加在容器元素上，控制子元素的位置
        flex-direction  决定主轴的方向（main-axsis）
            取值：
                row  主轴为水平方向的轴，起点在容器左端，默认值
                row-reverse 主轴为水平方向的轴，起点在容器右端
                column  主轴为交叉轴，起点在容器的顶端
                column-reverse 主轴为交叉轴，起点在容器的底端
        flex-wrap   当一条轴线（一行）排列不下时，子元素将如何换行
            取值：
                nowrap     默认值，不换行
                wrap        换行
                wrap-reverse  反方向换行
        flex-flow   dirextion和wrap的缩写方式
            取值：
                row nowrap 默认值
                direction wrap
        justify-content   定义项目在主轴上的对齐方式
            取值：
                flex-start   主轴起点对齐
                flex-end   主轴终点对齐
                center    居中对齐
                space-between  两端对齐，项目之间的距离是相等的
                space-around  每个项目两侧间距是相等的 项目与项目之间的间距，要比项目与父元素之间的间距大一倍
        align-items  定义项目在交叉轴的对齐方式（单行项目有效）
            取值：
                flex-start  交叉轴起点对齐
                flex-end   交叉轴终点对齐
                center     交叉轴中间对齐
                baseline   基线对齐，以所有项目中的第一行文本为准
                stretch    默认值，如果项目不设置高度或为auto时，那么项目将占满整个容器的高度
        align-content  定义了多跟轴线的对齐方式，如果项目只一根轴线，该属性无效
            取值：
                flex-start   交叉轴顶端对齐
                flex-end    交叉轴底端对齐
                center      交叉轴中间对齐
                space-between  与交叉轴两端对齐
                space-around     项目与项目间对齐
    项目属性：
        该组属性主要设置于项目中
        order  定义项目在排列顺序，值越小，越靠前，默认为0
        flex-grow  指定项目的放大比例，默认为0，即不放大
        flex-shrink 指定项目的缩小比例，默认为1，即空间不足时，等比缩小，为0时不缩小
        flex-basis  指定项目占据主轴的剩余空间大小 auto 默认值，项目本身大小
        flex  是flex-grow,flex-shrink,flex-basis 的简写模式
            取值，auto  相当于1  1   auto
                 none  相当于0 0  auto
                 flex-grow【,flex-shrink,flex-basis】
        align-self  允许定义当个项目与其他项目不一样的交叉轴对齐方式（类似于align-items）,能够覆盖align-items的效果
            取值： auto 默认值，使用
                  flex-start   主轴起点对齐
                flex-end   主轴终点对齐
                center    居中对齐
                base-line
                stretch
</code></pre><p>4、CSS Hack 兼容性</p>
<pre><code>标准模式和混杂模式和准标准模式
IE6之前，没有兼容性说法
IE6之后，各个浏览器追求标准统一，开始支持标准，IE的其它浏览器要向前兼容，所以出现各种模式
    混杂模式  无标准可言
        编写代码时，不写&lt;!doctylpe&gt;就是混杂模式，采用的是IE5.5的内核进行渲染
    标准模式  安全支持
    准标准模式，即支持标准，也同时向前兼容非标准代码
如何根据不同的浏览器编写不同的css
    css类内部Hack
        在属性名称前和值添加前后缀以便识别不同的浏览器
    选择器Hack
        在选择器前添加特殊标识以便识别不同的浏览器
    头部引用hack
        通过html的条件注释来判断浏览器版本，去执行不同的CSS
        条件注释
            条件：
                gt:判断当前浏览器是否大于指定定版本
                gte：判断当前浏览器是否大于等于指定定版本
                it:   判断当前浏览器是否小于指定版本
                ite： 判断当前浏览器是否小于等于指定版本
                !：   判断当前浏览器是否为非指定版本
                    &lt;!--[if !IE 8]&gt;
                        该段内容在除IE8以外浏览器中显示
                    &lt;![endif]--&gt;
</code></pre><p>5、转换</p>
<pre><code>说明：改变元素在页面中的形状，角度 大小 位置的一种效果
    允许进行2D和3D方向的转换
    2D转换：在平面中进行的操作
    3D转换：在空间中进行的操作
转换属性：
    rtansform:为元素应用2D或3D转换效果
        取值：none;  没有效果

            transform-functions:一组转换函数
                位移转换函数：translate()
                改变形状函数：skew()
                注意：如果指定多个转换函数的话中间用空格隔开
    转换原点：
        属性：transform-origin
        默认：转换原点在元素中心处
        取值：轴线给值
            两个轴线值：X Y
            三个轴线值：X Y Z
2D转换
    位移：改变元素在页面中的位置
        语法：transform
            fransform(x)  改变元素在X轴的位置
            fransform(X ,Y)  改变元素在两轴的位置
            fransformX(X) 只在X轴上位置移动
            fransformY(Y)  只在Y轴上位置移动
    缩放： 改变元素在页面中的大小】
        语法：transform
            scale(value)  表示两轴等比缩放
                取值：默认  为1
                    放大   为大于1的数值
                    缩小   为0~1之间小数
                    返转   负数
            sacle(X,Y)
            saclex(y)
            sacley(y)
    旋转：改变元素在页面上的角度，要根据原点实现转换效果
        语法：transform
            rotate(ndeg)
                n 取值正，顺时针旋转
                n 取值负，逆时针旋转
                deg 为角度
                0~360范围
        注意：转换原点问题
            元素坐标轴也跟着旋转
    倾斜：改变元素在页面中形状
        语法：transform
            skew(xdeg)  横向倾斜指定度数
                x 取值正，y轴逆时针倾斜一定角度
                  取值负，Y轴顺时针倾斜一定角度
            skew(xdeg,ydeg)
            skewx(xdeg)
            skewy(ydeg)
3D转换
    感觉空间
    属性：perspetive 假定人眼到投射平面的距离
    注意：该属性要放在3D转换元素的父元素上
        兼容性chrome和safari需要加前缀
            -wedkit-perspective:500px;
    旋转：以X轴中心轴旋转
            rotatex(xdeg)
          以Y轴中心轴旋转
            rotatey(ydeg)
          以Z轴中心轴旋转
            rotatez(zdeg)
        取值：正  顺时针
            负   逆时针
        以多个轴同时进行旋转
            rotate3d(x ,y, z ,ndeg)
                x y z 取值为1，该轴参与旋转
                x y z  取值为0 ，该轴不参与旋转
    位移：改变元素在Z轴上的位置
        语法：transform
            translatez(z)

            transform-style
                取值：flat  默认值，子元素不保留3D位置
                     preserve-3D  子元素保留3D位置
</code></pre><p>6、过渡</p>
<pre><code>作用效果：使得css属性值在一段时间内平缓变化的效果
要素与属性：
    指定过渡属性：指定哪个属性值在变化时使用过渡效果展示
        transition-property: 属性名称（width）
                      all   全部属性
                      none
        允许设置过渡效果的属性：
            颜色属性
            渐变属性
            取值为数字属性
            转换属性 transition-property:transform;
            visibility属性
            阴影属性
    指定过渡时长
        transition-duration: 以S、MS为单位数值
    指定过渡时速曲线函数  可选
        transition-timing-function
            取值：ease  默认值，慢速开始，快速变快，慢速结束
                 linear  匀速进行
                 ease-in   慢速开始，快速结束
                 ease-out  快速开始，慢速结束
                 ease-in-out  慢速开始和结束，先加速后减速
    指定过渡的延迟时间   可选
        transition-delay
            取值：以S或MS做为单位
    简写属性：transition:prop duration  timing-fun delay;
        多个过渡效果
            transition:prop1 duration1 timing-fun1 delay1,prop2 duration2 timing-fun2 delay2........;
触发过渡条件
    将过渡编写在元素声明的样式中，由:hover,:active等，进行触发,
    将过渡编写在:hover,:active伪类中
</code></pre><p>7、动画</p>
<pre><code>使元素从一种样式逐渐变化为另一种样式的过程，与动画相关的属性，增加浏览器前缀
动画使用步骤
    声明动画
        指定动画名称
        指定动画中的关键帧（keyframes）
            时间点（以百分比描述时间）
            元素状态（CSS样式）
    为元素调用动画
        指定调用动画的名称以及执行时长
语法：
    声明动画     注意前缀，兼容性问题
        &lt;style&gt;
            @keyframes 名称{
                0%{   动画开始时，元素的状态   }
                。。。。
                100%{  动画结束时，元素的状态  }
            }
        &lt;/style&gt;
    调用动画(animation)
        animation-name  指定调用动画名称
        animation-duration   指定动画周期时长，以S或MS为单位
        animation-timing-function  指定动画的速度时间出线函数
            取值：ease  默认值，慢速开始，快速变快，慢速结束
                 linear  匀速进行
                 ease-in   慢速开始，快速结束
                 ease-out  快速开始，慢速结束
                 ease-in-out  慢速开始和结束，先加速后减速
        animation-delay  指定动画延迟时间
        animation-iteration-count  指定动画播放次数
            取值：默认1次，具体数值
                infinite:无限次播放
        animation-direction  指定动画的播放方向
            取值：normal  从0%~100%
                reverse  从100%~0%
                alternate  轮流来回播放 奇数 0%~100%
                                 偶数 100%~0%
        animation  简写方式
            取值：name  duration  timing-fun delay  iteration-count direction;
        animation-fill-mode  指定动画播放之前、之后的填充模式
            取值：none  默认值
                 forwards  动画播放完成后，保持在最后一帧的位置
                 backwards 动画播放前，延迟时间内，动画保持在开始第一帧上的位置
                 both 同时应用在开始和最后的位置帧上
        animation-play-state  动画播放状态
            取值：paused 暂停
                 running 播放
</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;1、复杂选择器&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;1、兄弟选择器
    通过兄弟级别的位置关系来匹配页面元素
    注意，兄弟选择器，只能向后找，不能向前找
    语法：
        相邻兄弟选择器：通过相邻（紧紧挨着的）位置关系匹配元素
        选择器1+选
    
    </summary>
    
      <category term="学习笔记" scheme="www.wangchengzou.cn/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="CSS" scheme="www.wangchengzou.cn/tags/CSS/"/>
    
      <category term="CSS3" scheme="www.wangchengzou.cn/tags/CSS3/"/>
    
  </entry>
  
  <entry>
    <title>DOM_BOM笔记</title>
    <link href="www.wangchengzou.cn/2017/07/22/DOM_BOM%E7%AC%94%E8%AE%B0/"/>
    <id>www.wangchengzou.cn/2017/07/22/DOM_BOM笔记/</id>
    <published>2017-07-22T15:48:26.000Z</published>
    <updated>2017-07-23T10:57:34.367Z</updated>
    
    <content type="html"><![CDATA[<ol>
<li><p>DOM: Document Object Model</p>
<p> DOM是专门操作网页内容的API标准<br> 为什么: 早起js操作不同浏览器的API没有标准，有严重兼容性问题<br> 所以，W3C制定了统一的操作网页内容的API标准,所有浏览器厂商都遵照执行。<br> 结果，使用DOM API操作网页内容，几乎100%兼容所有浏览器<br> 何时: 只要操作网页内容，就用DOM API查找, 修改(内容,属性,样式), 添加, 删除.</p>
</li>
</ol>
<p>DOM Tree:</p>
<pre><code>什么是: 网页中一切内容在内存中都是以树形结构存储的
       网页中每一项内容都是树上的一个节点对象
       包括: 元素, 文字, 属性...
       树只有一个根节点: document, 包含了所有网页内容
Node: 每个节点都是一个node类型的对象
      node是所有节点的父类型
</code></pre><p>三大公共: nodeType  nodeName  nodeValue</p>
<pre><code>nodeType: 节点的类型
  值: document   9
     element     1
     attribute     2
     text         3
  何时: 只要判断节点类型，就用nodeType
        因为不同类型的节点，能执行的操作是不一样的
  问题: 不能进一步区分元素的名称
  解决:
nodeName: 节点的名称
  值: document   #document
     element    全大写的标签名
     attribute    属性名
     text        #text
  何时: 只要细致鉴别元素的标签名时
    强调: nodeName返回的是全大写的标签名
nodeValue: 节点值:
  值: document   null
     element     null
     attribute     属性值
     text         文本内容
</code></pre><p>2、查找: 4种:</p>
<pre><code>  a. 不需要查找，可直接获得的元素
        html   document.documentElement
        head   document.head
        body   document.body
  b. 按节点间关系查找:
节点树: 包含所有节点: 元素和文本
  1. 父子: elem.parentNode  找elem的父节点
        elem.childNodes  找elem的所有*直接*子节点
            返回，所有直接子节点组成的集合(类数组)
        elem.firstChild   找elem的第一个*直接*子节点
        elem.lastChild   找elem的最后一个*直接*子节点
  2. 兄弟: elem.previousSibling 找elem的前一个兄弟
        elem.nextSibling   找elem的下一个兄弟
 何时: 前提: 已经获得了一个节点
      要找周围临近的节点时
 问题: 连看不见的空字符，也算文本节点——干扰
 解决:
元素树: 仅包含元素节点的树结构
       不是一棵新树，仅是节点树的子集
 1. 父子: elem.parentElement  找elem的父元素
        elem.children  找elem的所有*直接*子元素
            返回，所有直接子元素组成的集合(类数组)
        elem.firstElementChild   第一个*直接*子元素
        elem.lastElementChild   最后一个*直接*子元素
 2. 兄弟:
   elem.previousElementSibling 找elem的前一个兄弟元素
   elem.nextElementSibling   找elem的下一个兄弟元素
 何时: 只要仅关心元素节点，不关心文本节点时
 问题: IE9+
 强调: childNodes和children返回的都是动态集合！
   凡是遍历动态集合，都要先缓存元素个数，再遍历
   for(var i=0,len= childNodes.length;i&lt;len;i++)
     不会导致反复查找DOM树
</code></pre><p>3、 按HTML查找:</p>
<pre><code>    优: 范围可大可小,可设置条件
a、按id查找: var elem=document.getElementById(&quot;id&quot;)
  强调: 1. 只能在document对象上调用
       2. 返回一个元素对象
b、按标签名查找:
    var elems=parent.getElementsByTagName(&quot;标签名&quot;);
  强调: 1. 可在任意父元素上
       2. 返回多个元素组成的集合
       3. 不但查找直接子元素，还查找所有后代元素
c、按name属性查找: 了解
   专门找表单中有name属性的表单元素
    var elems=document.getElementsByName(&quot;name&quot;)
    强调: 1. 只能在document上调用
         2. 返回多个元素组成的集合
d、按class属性查找:
    var elems=parent.getElementsByClassName(&quot;class&quot;)
    强调: 1. 可在任意父元素上调用
         2. 返回多个元素组成的集合
         3. 不要求完整匹配，只要包含即可！
缺: 每次只能按一个条件查找
   如果条件复杂，就无法一句话获得想要的元素
</code></pre><p>4、 按选择器查找:</p>
<pre><code>a. 只找一个元素:
  var elem=parent.querySelector(&quot;selector&quot;);
b. 找多个元素
  var elems=parent.querySelectorAll(&quot;selector&quot;);
</code></pre><p>5、 总结:</p>
<pre><code> A首次查找:
    1. 如果条件简单: 按HTML查找: id, 标签, className
    2. 如果条件复杂: 按选择器查找:
 B已经获得一个元素，找周围相邻: 按节点间关系
鄙视: 按HTML查找 vs 按选择器查找
 1.使用的难易程度: 当条件复杂时:
    按选择器查找——简单, 按HTML查找——繁琐
 2.返回值:
    getElementsByTagName() 返回多个元素的*动态*集合
      什么是动态集合: 不实际存储对象的属性值，每次访问，都要重新查找DOM树
    querySelectorAll()  返回多个元素的*非动态*集合
      什么是非动态集合: 实际存储对象的所有属性值，即使反复访问集合，也不会导致反复查找DOM树
 3.单次效率:
    按HTML查找——效率高!
    按选择器查找——效率低
</code></pre><p>3、 修改: (内容, 属性, 样式)</p>
<pre><code>1. 修改:
标准属性: 2种:
  1. 核心DOM: 操作一切结构化文档的API(HTML，XML)
    elem.attributes集合: 保存了当前元素的所有属性节点
    获取属性值: elem.getAttribute(&quot;属性名&quot;)
    修改属性值: elem.setAttribute(&quot;属性名&quot;,&quot;值&quot;)
    判断是否包含属性: elem.hasAttribute(&quot;属性名&quot;)
    移除属性: elem.removeAttribute(&quot;属性名&quot;)
  2. HTML DOM: 对部分常用DOM API的简化版本
     HTML DOM将标准属性都预定义在元素对象中
    获取属性值: elem.属性名
    修改属性值: elem.属性名=&quot;值&quot;;
    判断是否包含属性: elem.属性名===&quot;&quot; 不包含
    移除属性: elem.属性名=&quot;&quot;
    特例: class属性和ES标准中的class重名
          -&gt; DOM -&gt; className
    自定义属性: 比如: data-toggle=&quot;dropdown&quot;
      HTML DOM不能操作自定义属性
      暂时只能用核心DOM操作:
    三大状态: disabled  selected   checked
      核心DOM无法操作三大状态属性
      HTMLDOM: elem.disabled elem.selected  elem.checked
            值都是bool类型true/false
</code></pre><p>3.1、修改css样式:</p>
<pre><code>1. 仅获取/修改内联样式:  elem.style.css属性名
  问题1: css属性名有的带-
  解决: 所有css属性名都要去横线变驼峰
     比如: background-color: backgroundColor
          list-style-type: listStyleType
  问题2: 所有数值类型的属性值都是带单位的字符串
  解决: 获取时: 都要去单位，转数值
        修改时: 将单位拼回数值
  问题3: 仅能获得内联样式, 无法获得样式表中的样式
  解决: 计算后的样式: 最终应用到元素上的完整样式
    何时: 只要希望获得元素完整的样式时
    如何: 2步:
      1. 获得完整样式对象style
        var style=getComputedStyle(elem)
      2. 获得style对象中的css属性
        style.css属性名
     强调: style对象中的样式都是只读
结论: 1. 获取样式: getComputedStyle
     2. 修改样式: elem.style.css属性名
2. 运行时修改样式表中的样式:
  Step1: 获得样式表对象:
   var sheet=document.styleSheets[i]
  Step2: 获得样式表对象中某个CSSRule(一个选择器{})
   var rule=sheet.cssRules[i]
  Step3: 修改rule.style.css属性名=值
</code></pre><p>4、 添加和删除:</p>
<pre><code>添加: 3步:
 Step1: 创建空元素:
  var a=document.createElement(&quot;a&quot;);
  &lt;a&gt;&lt;/a&gt;
 Step2: 设置关键属性:
     a.href=&quot;http://tmooc.cn&quot;
     a.innerHTML=&quot;go to tmooc&quot;;
  &lt;a href=&quot;http://tmooc.cn&quot;&gt;go to tmooc&lt;/a&gt;
 Step3: 将元素添加到DOM树: 3种:
   1. 末尾追加: parent.appendChild(child)
   2. 中间插入: parent.insertBefore(child, oldChild)
   3. 替换: parent.replaceChild(child, oldChild)
</code></pre><p>优化: 尽量少的修改DOM树</p>
<pre><code>原因: 页面加载过程:
  html -&gt; DOM Tree(松树)
           ↓
        render Tree(圣诞树)-&gt; layout(计算绝对布局)-&gt;paint
           ↑                 最耗时
  css  -&gt; cssRules(装饰品)
  每次修改DOM树，都会导致重新layout，耗时。
如何: 2种:
 1. 如果同时添加父元素和子元素时，应该先在内存将子元素都添加到父元素中，再将父元素一次性整体添加到DOM树
    结果: 只触发一次layout
</code></pre><p>1、 HTML DOM 常用对象: 对常用HTML元素操作的简化</p>
<pre><code>Select: 代表页面上的一个select元素
 属性: select.value 当前选中项的value
                 没有value，就返回选中项的内容
      select.options 保存select下所有option元素对象
        相当于: select.getElementsByTagName(&quot;option&quot;)
        select.options.length 保存select下option的个数
        清空select下所有option: select.options.length=0;
      select.length 等效于select.options.length
        清空select下所有option: select.length=0;
                               select.innerHTML=&quot;&quot;;
      select.selectedIndex 当前选中项的下标
  事件: onchange 当选中项发生改变时
  方法: select.add(option) 向select中添加一个option
         相当于: select.appendChild(option)
         不支持文档片段
       select.remove(i) 移除select中i位置的一个option
Option: 代表页面上的一个option元素
  创建: var opt=new Option(text,value);
     创建一个option对象，同时设置opt的内容为text，设置opt的值为value
     相当于: var opt=document.createElement(&quot;option&quot;);
            opt.innerHTML=text;
            opt.value=value;
  属性: .text 代替.innerHTML
       .index  表示当前option在select下的下标位置
</code></pre><p>Table: 代表网页中一个table元素</p>
<pre><code> 管着行分组：
   添加行分组: var 行分组=table.createTHead|TBody|TFoot();
       强调: 即创建，同时又将行分组添加到table
   删除行分组: table.deleteTHead|TFoot()
   获取行分组: table.tHead|tFoot
              table.tBodies[i]
行分组: THead TBody TFoot
  管着行:
   添加行: var tr=行分组.insertRow(i)
       在行分组中i位置插入一个新行
       强调: 中间插入行，原i位置的行向后顺移
       固定套路: 1. 末尾追加一个新行: 行分组.insertRow()
                2. 开头插入: 行分组.insertRow(0)
   删除行: 行分组.deleteRow(i)
       删除行分组中第i行
       强调: i是当前行在行分组内的相对下标位置
   获取行: 行分组.rows

行: tr
  管着td:
    添加td: var td=tr.insertCell(i);
        省略i表示右侧末尾追加
        insertCell不支持添加th，只能添加td
    删除td: tr.deleteCell(i);
    获取td: tr.cells

删除行:
 tr上都有一个属性: tr.rowIndex 行在整个表的绝对下标
 问题：行分组，无法使用tr.rowIndex删除行。
 解决: table.deleteRow(tr.rowIndex)
 总结: 今后，删除行都用table.deleteRow(tr.rowIndex)
</code></pre><p>form: 代表页面上一个表单元素</p>
<pre><code> 获取: var form=document.forms[i/id]
 属性: form.elements 保存了表单中所有表单元素的数组
        包括: input   select   textarea  button
      form.elements.length 获得表单中表单元素的个数
      form.length =&gt; form.elements.length
 方法: form.submit();  用于手动提交表单
 事件: form.onsubmit  以任何方式提交表单之前自动触发
          常用于在提交之前，验证所有表单元素的内容
表单元素:
 获取: var elem=form.elements[i/id/name]
        简写: 如果表单元素有name属性: form.name
 方法: elem.focus() 让elem获得焦点
      elem.blur()  让elem失去焦点

Image: 代表页面上一个img元素
  创建: var img=new Image();
</code></pre><p>DOM总结: 查找-&gt;绑定事件-&gt;查找-&gt;修改/添加/删除</p>
<pre><code>查找: 4种:
  1. 不需要查找可直接获得: html  head  body  form
  2. 节点间关系: 节点树/元素树
      鄙视: 递归遍历
  3. 按HTML: 4种: ById, ByTagName, ByName, ByClassName
  4. 按选择器: 2种:
      只找一个: querySelector()
      找多个: querySelectorAll()
修改:
  内容: .innerHTML  .textContent/.innerText  .value
  属性:
    1. 标准属性: 1. 核心DOM; 2. HTML DOM
    2. 自定义属性: 核心DOM
    3. 状态属性: HTML DOM
  样式:
    修改: elem.style.css属性=值
    获取: var style=getComputedStyle(elem)
         style.css属性 ——只读
    可通过修改class属性批量应用修改多个css属性
添加: 3步:
   1. createElement,
   2.设置关键属性,
   3. appendChild/insertBefore/replaceChild
  优化: 尽量少的操作DOM树
  如何: 2种:
   1. 同时添加父子元素: 先将子元素加入父元素，再将父元素整体添加到页面
   2. 同时添加多个平级子元素: fragment
删除: parent.removeChild(child)
HTML DOM: Select/Option  Table/...  From/Element  Image
过渡动画: 2步:
  css中: 添加transition
  js中: 修改css属性值
   不支持transition: display  zIndex
   支持: width  height  opacity   bottom/top/left/right ...
</code></pre><p>2、BOM: Browser Object Model</p>
<pre><code>什么是: 专门操作浏览器窗口的API
比如: alert prompt confirm
问题: 1. 没有标准——兼容性问题;
     2. 不可定制
window对象: 2个角色:
  1. 代替ES中的Global充当全局作用域对象
  2. 封装所有BOM和DOM的API

打开超链接: 4种:
  1. 在当前窗口打开，可后退
    html: &lt;a href=&quot;url&quot; target=&quot;_self&quot;&gt;&lt;/a&gt;
    js: /*window.*/open(&quot;url&quot;,&quot;_self&quot;)
  2. 在当前窗口打开，不可后退
    js: location.replace(&quot;url&quot;);
       用新url代替history中当前url，结果: 无法后退
  3. 在新窗口打开，可打开多个
    html: &lt;a href=&quot;url&quot; target=&quot;_blank&quot;&gt;&lt;/a&gt;
    js: open(&quot;url&quot;,&quot;_blank&quot;)
  4. 在新窗口打开，只能打开一个
    html: &lt;a href=&quot;url&quot; target=&quot;自定义name属性值&quot;&gt;&lt;/a&gt;
    js: open(&quot;url&quot;,&quot;自定义name属性值&quot;)
    原理: 内存中每个窗口都有一个唯一的name属性来唯一标示一个窗口
      浏览器规定，相同name属性的窗口只能打开一个
    其实: html中的target属性就是在设置新窗口的name属性值。
    如果target中使用自定义的窗口名，则只能打开一个
    预定义:
      _self: 默认使用当前窗口自己的name属性
           结果，新窗口覆盖当前窗口
      _blank: 意为不指定窗口名, 浏览器会随机生成不同的窗口名。
           结果: 每次打开新窗口都随机生成不同的name
                 结果: 可打开任意多个
</code></pre><p>定时器: 2种:</p>
<pre><code>1. 周期性定时器:
  什么是: 让程序按照指定时间间隔，反复执行一项任务
  何时: 只要让程序按照指定时间间隔，反复执行一项任务
  如何: 3件事:
    1. 任务函数: 让定时器反复调用的函数
    2. 启动定时器:
     var timer=setInterval(任务函数, 间隔的毫秒数)
    3. 停止定时器: clearInterval(timer)
        问题: timer中的序号会残留在timer变量中
        解决: 停止定时器后，主动清空timer
             timer=null
  停止定时器: 2种:
    1. 用户手动停止定时器: 用按钮调用clearInterval
    2. 自动停止定时器: 在任务函数中:
       1. 设定临界条件
       2. 如果达到临界条件就自动调用clearInterval

2. 一次性定时器:
 什么是: 让程序先等待一段时间，再自动执行一次任务
         执行一次后，定时器自动停止
 何时: 只要先等待，再执行一次任务
 如何: 三件事
   1. 任务函数
   2. 启动: var timer=setTimeout(任务函数, 等待的毫秒数)
   3. 停止: clearTimeout(timer)
</code></pre><p>鄙视: 定时器中的函数，只能在主程序所有程序执行后才能执行</p>
<pre><code>for(var i=0;i&lt;3;i++){
  setTimeout(function(){
    console.log(i);
  },0);
}//结果: 3 3 3
//alert(&quot;Hello&quot;) 如果不点确定，则永远不输出333
</code></pre><p>window:<br> history，location，document，navigator，screen，event</p>
<pre><code>history: 保存当前窗口打开后，成功访问过的历史记录的栈
  history封装的非常严密
  只能前进，后退，刷新: history.go(n)
   前进: go(1)  后退:go(-1)  刷新:go(0)

location: 专门保存当前窗口正在打开的url的对象
 属性: location.href 保存了完整的url
        在当前窗口打开: location.href=新url
      location.protocol: 协议
            .host: 主机名+端口号
            .hostname: 主机名
            .port: 端口号
      location.pathname: 相对路径
            .hash: 锚点地址#xxx
            .search: 表单提交后地址栏中的查询字符串
                   ?变量名=值&amp;变量名=值&amp;...
 方法:
   1. 替换history中当前url,实现进制后退:
     location.replace(&quot;新url&quot;)
   2. 在当前页面打开，可后退:
     location.assign(&quot;新url&quot;)
       =&gt; location.href=&quot;新url&quot;
        =&gt; location=&quot;新url&quot;
   3. 刷新页面:  location.reload(false/true);
     鄙视: false/true的差别
       浏览器本地是有缓存的
         浏览器的缓存中会保存css，图片等静态资源
       每次请求时，首先查看缓存中是否有想要文件
         没有想要文件，或文件过期，才去服务器下载新文件
       reload(false) 优先使用本地缓存的文件
       reload(true) 强制去服务器下载新文件
     查 浏览器缓存的原理！
</code></pre><p>1、event</p>
<pre><code>绑定事件: 2种:
 1. 在HTML中绑定: &lt;ANY on事件名=&quot;js语句&quot;
    问题: 不符合内容与行为分离的原则——不便于维护
 2. 在js中动态绑定: 2种:
    1. 一个事件只绑定一个处理函数:
       elem.on事件名=function(){
         //this-&gt;elem
       }
       解除绑定: elem.on事件名=null;
       问题: 每个事件只能绑定一个处理函数
       解决:
    2. 一个事件可同时绑定多个处理函数:
       elem.addEventListener(&quot;事件名&quot;,function(){
         //this-&gt;elem
       })
       解除绑定:
        elem.removeEventListener(&quot;事件名&quot;,&quot;函数名&quot;);
        强调: 如果一个事件处理函数可能被动态移除，则绑定时，不能使用匿名函数，必须使用有名称的函数

    事件模型: DOM标准: 3个阶段
      1. 捕获: 由外向内，记录各级父元素绑定的事件处理函数
      2. 目标触发: 首先执行目标元素上的事件处理函数
      3. 冒泡: 由内向外，反向执行捕获阶段记录的处理函数

    事件对象: 事件发生时自动创建的
             封装事件信息
             提供操作事件的API 的对象
      何时: 只要希望获得事件信息或修改事件的默认行为
      如何: 事件对象，在事件发生时，通常作为事件处理函数的第一个参数，默认自动传入！
          .on事件名=function(e){
             //e会自动获得事件对象
          }
    阻止蔓延/冒泡: e.stopPropagation();
    利用冒泡:
      优化: 尽量少的添加事件监听
      原理: 因为浏览器触发事件监听，是采用遍历查找的方式。添加的监听越多，遍历的速度越慢
      如何: 如果多个子元素都要绑定相同的事件
          只要在父元素绑定一次，所有子元素即可共用
      难题:
         1. 获得目标元素:
            不能用this, 因为this指父元素
            应该用e.target，保存实际点击的目标元素
         2. 鉴别目标元素:
            先判断目标元素的nodeName或className...
            只有目标元素符合要求时，才执行事件操作
    取消事件/阻止默认行为: e.preventDefault();
    事件坐标: 3对儿:
      1. 相对于整个屏幕左上角的坐标: e.screenX|screenY
      2. 相对于文档显示区左上角的坐标: e.clientX|clientY
      3. 相对于当前元素左上角的坐标: e.offsetX|offsetY

    页面滚动:
      事件: window.onscroll
      获得页面滚动位置: document.body.scrollTop
          页面超出文档显示区顶部的距离
</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;ol&gt;
&lt;li&gt;&lt;p&gt;DOM: Document Object Model&lt;/p&gt;
&lt;p&gt; DOM是专门操作网页内容的API标准&lt;br&gt; 为什么: 早起js操作不同浏览器的API没有标准，有严重兼容性问题&lt;br&gt; 所以，W3C制定了统一的操作网页内容的API标准,所有浏览器厂商
    
    </summary>
    
      <category term="学习笔记" scheme="www.wangchengzou.cn/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="javaScript" scheme="www.wangchengzou.cn/tags/javaScript/"/>
    
      <category term="DOM" scheme="www.wangchengzou.cn/tags/DOM/"/>
    
      <category term="BOM" scheme="www.wangchengzou.cn/tags/BOM/"/>
    
  </entry>
  
</feed>
