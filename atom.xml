<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>~~博客园~~</title>
  <subtitle>千帆渡</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="www.wangchengzou.cn/"/>
  <updated>2017-07-27T14:23:51.280Z</updated>
  <id>www.wangchengzou.cn/</id>
  
  <author>
    <name>汪成邹</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>ajax面试题点</title>
    <link href="www.wangchengzou.cn/2017/07/22/ajax%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    <id>www.wangchengzou.cn/2017/07/22/ajax面试题/</id>
    <published>2017-07-22T15:48:26.000Z</published>
    <updated>2017-07-27T14:23:51.280Z</updated>
    
    <content type="html"><![CDATA[<p>1、Ajax 是什么? 如何创建一个Ajax？</p>
<pre><code>Ajax并不算是一种新的技术，全称是asychronous javascript and xml，可以说是已有技术的组合，
主要用来实现客户端与服务器端的异步通信效果，实现页面的局部刷新，早期的浏览器并不能原生支持ajax
，可以使用隐藏帧（iframe）方式变相实现异步效果，后来的浏览器提供了对ajax的原生支持
使用ajax原生方式发送请求主要通过XMLHttpRequest(标准浏览器)、
ActiveXObject(IE浏览器)对象实现异步通信效果
基本步骤：
var xhr =null;//创建对象
if(window.XMLHttpRequest){
    xhr = new XMLHttpRequest();
}else{
    xhr = new ActiveXObject(&quot;Microsoft.XMLHTTP&quot;);
}
     xhr.open(“方式”,”地址”,”标志位”);//初始化请求
     xhr.setRequestHeader(“”,””);//设置http头信息
     xhr.onreadystatechange =function(){}//指定回调函数
     xhr.send();//发送请求
</code></pre><p>3、如何解决跨域问题?</p>
<pre><code>理解跨域的概念：协议、域名、端口都相同才同域，否则都是跨域
出于安全考虑，服务器不允许ajax跨域获取数据，但是可以跨域获取文件内容，
所以基于这一点，可以动态创建script标签，使用标签的src属性访问js文件的形式获取js脚本
，并且这个js脚本中的内容是函数调用，该函数调用的参数是服务器返回的数据，
为了获取这里的参数数据，需要事先在页面中定义回调函数，在回调函数中处理服务器返回的数据
，这就是解决跨域问题的主流解决方案
</code></pre><p>4、页面编码和被请求的资源编码如果不一致如何处理？</p>
<pre><code>对于ajax请求传递的参数，如果是get请求方式，参数如果传递中文，在有些浏览器会乱码，
不同的浏览器对参数编码的处理方式不同，所以对于get请求的参数需要使用
encodeURIComponent函数对参数进行编码处理，后台开发语言都有相应的解码api。
对于post请求不需要进行编码
</code></pre><p>5、简述ajax 的过程。</p>
<pre><code>1. 创建XMLHttpRequest对象,也就是创建一个异步调用对象
2. 创建一个新的HTTP请求,并指定该HTTP请求的方法、URL及验证信息
3. 设置响应HTTP请求状态变化的函数
4. 发送HTTP请求
5. 获取异步调用返回的数据
6. 使用JavaScript和DOM实现局部刷新
</code></pre><p>6、阐述一下异步加载。</p>
<pre><code>1. 异步加载的方案： 动态插入 script 标签
2. 通过 ajax 去获取 js 代码，然后通过 eval 执行
3. script 标签上添加 defer 或者 async 属性
4. 创建并插入 iframe，让它异步执行 js
</code></pre><p>7、请解释一下 JavaScript 的同源策略。</p>
<pre><code>同源策略是客户端脚本（尤其是Javascript）的重要的安全度量标准。
它最早出自Netscape Navigator2.0，其目的是防止某个文档或脚本从多个不同源装载。
所谓同源指的是：协议，域名，端口相同，同源策略是一种安全协议，
指一段脚本只能读取来自同一来源的窗口和文档的属性。
</code></pre><p>8、GET和POST的区别，何时使用POST？</p>
<pre><code>GET：一般用于信息获取，使用URL传递参数，对所发送信息的数量也有限制，
一般在2000个字符，有的浏览器是8000个字符
POST：一般用于修改服务器上的资源，对所发送的信息没有限制
在以下情况中，请使用 POST 请求：
1. 无法使用缓存文件（更新服务器上的文件或数据库）
2. 向服务器发送大量数据（POST 没有数据量限制）
3. 发送包含未知字符的用户输入时，POST 比 GET 更稳定也更可靠
</code></pre><p>9、ajax 是什么?ajax 的交互模型?同步和异步的区别?如何解决跨域问题?</p>
<pre><code>1. 通过异步模式，提升了用户体验
2. 优化了浏览器和服务器之间的传输，减少不必要的数据往返，减少了带宽占用
3.  Ajax在客户端运行，承担了一部分本来由服务器承担的工作，减少了大用户量下的服务器负载。
</code></pre><p>10、 Ajax的最大的特点是什么。</p>
<pre><code>Ajax可以实现异步通信效果，实现页面局部刷新，带来更好的用户体验；按需获取数据，节约带宽资源；
</code></pre><p>11、ajax的缺点</p>
<pre><code>1、ajax不支持浏览器back按钮。
2、安全问题 AJAX暴露了与服务器交互的细节。
3、对搜索引擎的支持比较弱。
4、破坏了程序的异常机制。
</code></pre><p>12、ajax请求的时候get 和post方式的区别</p>
<pre><code>get一般用来进行查询操作，url地址有长度限制，请求的参数都暴露在url地址当中，
如果传递中文参数，需要自己进行编码操作，安全性较低。
post请求方式主要用来提交数据，没有数据长度的限制，
提交的数据内容存在于http请求体中，数据不会暴漏在url地址中。
</code></pre><p>13、解释jsonp的原理，以及为什么不是真正的ajax</p>
<p>　　  Jsonp并不是一种数据格式，而json是一种数据格式，<br>    jsonp是用来解决跨域获取数据的一种解决方案，具体是通过动态创建script标签，<br>    然后通过标签的src属性获取js文件中的js脚本，该脚本的内容是一个函数调用，<br>    参数就是服务器返回的数据，为了处理这些返回的数据，需要事先在页面定义好回调函数<br>    ，本质上使用的并不是ajax技术</p>
<p>14、什么是Ajax和JSON，它们的优缺点。</p>
<pre><code>Ajax是全称是asynchronous JavaScript andXML，即异步JavaScript和xml，
用于在Web页面中实现异步数据交互，实现页面局部刷新。
优点：可以使得页面不重载全部内容的情况下加载局部内容，降低数据传输量，
避免用户不断刷新或者跳转页面，提高用户体验
缺点：对搜索引擎不友好；要实现ajax下的前后退功能成本较大；
可能造成请求数的增加跨域问题限制；
JSON是一种轻量级的数据交换格式，ECMA的一个子集
优点：轻量级、易于人的阅读和编写，便于机器（JavaScript）
解析，支持复合数据类型（数组、对象、字符串、数字）
</code></pre><p>15、http常见的状态码有那些？分别代表是什么意思？<br>    200 - 请求成功<br>    301 - 资源（网页等）被永久转移到其它URL<br>    404 - 请求的资源（网页等）不存在<br>    500 - 内部服务器错误</p>
<p>16、一个页面从输入 URL 到页面加载显示完成，这个过程中都发生了什么？</p>
<pre><code>分为4个步骤：
    1. 当发送一个 URL 请求时，不管这个 URL 是 Web 页面的 URL 还是 Web 页面上每个资源的 URL
    ，浏览器都会开启一个线程来处理这个请求  ，同时在远程 DNS 服务器上启动一个 DNS 查询。
    这能使浏览器获得请求对应的 IP 地址。
    2. 浏览器与远程 Web 服务器通过 TCP 三次握手协商来建立一个 TCP/IP 连接。
    该握手包括一个同步报文，一个同步-应答报文和一个应答报    文，这三个报文在
    浏览器和服务器之间传递。该握手首先由客户端尝试建立起通信，而后服务器应答并接受客户端的请求
    ，最后由客户端发出该请求已经    被接受的报文。
    3. 一旦 TCP/IP 连接建立，浏览器会通过该连接向远程服务器发送 HTTP 的 GET 请求。
    远程服务器找到资源并使用 HTTP响应返回该资源，值为 200 的 HTTP 响应状态表示一个正确的响应。
    4. 此时，Web 服务器提供资源服务，客户端开始下载资源。
</code></pre><p>17、ajax请求的时候get 和post方式的区别</p>
<pre><code>get一般用来进行查询操作，url地址有长度限制，请求的参数都暴露在url地址当中，
如果传递中文参数，需要自己进行编码操作，安全性较低。
post请求方式主要用来提交数据，没有数据长度的限制，提交的数据内容存在于http请求体中
，数据不会暴漏在url地址中。
</code></pre><p>18、ajax请求时，如何解释json数据</p>
<pre><code>使用eval()或者JSON.parse() 鉴于安全性考虑，推荐使用JSON.parse()更靠谱，
对数据的安全性更好。
</code></pre><p>19、.javascript的本地对象，内置对象和宿主对象</p>
<pre><code>本地对象为独立于宿主环境的ECMAScript提供的对象，包括ArrayObjectRegExp等可以new实例化的对象
内置对象为Gload，Math 等不可以实例化的(他们也是本地对象，内置对象是本地对象的一个子集)
宿主对象为所有的非本地对象，所有的BOM和DOM对象都是宿主对象，如浏览器自带的document,window 等对象
</code></pre><p>20、为什么利用多个域名来存储网站资源会更有效？</p>
<pre><code>确保用户在不同地区能用最快的速度打开网站，其中某个域名崩溃用户也能通过其他郁闷访问网站，
并且不同的资源放到不同的服务器上有利于减轻单台服务器的压力。
</code></pre><p>21、请说出三种减低页面加载时间的方法</p>
<pre><code>1、压缩css、js文件
2、合并js、css文件，减少http请求
3、外部js、css文件放在最底下
4、减少dom操作，尽可能用变量替代不必要的dom操作
</code></pre><p>22、HTTP状态码都有那些。</p>
<pre><code>200 OK      //客户端请求成功
400 Bad Request  //客户端请求有语法错误，不能被服务器所理解
403 Forbidden  //服务器收到请求，但是拒绝提供服务
404 Not Found  //请求资源不存在，输入了错误的URL
500 Internal Server Error //服务器发生不可预期的错误
503 Server Unavailable  //服务器当前不能处理客户端的请求，一段时间后可能恢复正常
</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;1、Ajax 是什么? 如何创建一个Ajax？&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Ajax并不算是一种新的技术，全称是asychronous javascript and xml，可以说是已有技术的组合，
主要用来实现客户端与服务器端的异步通信效果，实现页面的局部刷新，早期的浏
    
    </summary>
    
      <category term="面试题目" scheme="www.wangchengzou.cn/categories/%E9%9D%A2%E8%AF%95%E9%A2%98%E7%9B%AE/"/>
    
    
      <category term="ajax" scheme="www.wangchengzou.cn/tags/ajax/"/>
    
      <category term="js" scheme="www.wangchengzou.cn/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>CSS3高级笔记</title>
    <link href="www.wangchengzou.cn/2017/07/22/CSS3%E9%AB%98%E7%BA%A7/"/>
    <id>www.wangchengzou.cn/2017/07/22/CSS3高级/</id>
    <published>2017-07-22T15:48:26.000Z</published>
    <updated>2017-07-23T10:33:13.367Z</updated>
    
    <content type="html"><![CDATA[<p>1、复杂选择器</p>
<pre><code>1、兄弟选择器
    通过兄弟级别的位置关系来匹配页面元素
    注意，兄弟选择器，只能向后找，不能向前找
    语法：
        相邻兄弟选择器：通过相邻（紧紧挨着的）位置关系匹配元素
        选择器1+选择器2
        如：div+p   #top+.important
                通用兄弟选择器：用于匹配某元素后面所有的兄弟元素
        选择器1~选择器2
        如#d1~div
2、属性选择器
    通过元素所附带的属性及其值来匹配页面中的元素
    语法：
        基础属性选择器  [attr]
            匹配页面中的有附带attr属性的元素
        elem[attr]
            elem:表示任意元素名称
            attr:表示任意属性名称
            匹配页面中附带attr属性的elem元素
            如：div[id]:匹配页面中所有附带id属性的div元素
        [attr1][attr2][attr3]
            匹配页面中同时附带attr1和attr2属性的所有元素
            如 input[name][hype]
        [attr=value]
            匹配页面中所有attr属性的值为value的元素
            如input[type=text]
        [class~=value]
            主要使用在多类选择器上，匹配页面中class属性值中包含value选择器的元素
        [attr^=value]
            匹配以value值作为开始的attr属性的元素
        [attr$=value]
            匹配以value值作为结束的attr属性的元素
        [attr*=value]
            匹配attr属性值中包含value字符的所有元素
3、伪类选择器
    目标伪类
        突出显示活动的HTML锚元素
        语法： ：target
    结构伪类
        通过元素之间的结构关系来匹配元素
        ：first-child     获取属于其父元素中的首个子元素
        ：last-child     获取属于其父元素中的尾（最后）子元素
        :nth-child(N)  获取属于其父元素中的第N个子元素
        ：empty   空的，匹配没有子元素的元素，包含文本
        ：only-child   匹配属于其父元素中的唯一子元素
    否定伪类
        把匹配某选择器元素排除出去
        ：not(选择器 )
4、伪元素选择器
    伪类与伪元素
        伪类：匹配元素不同的状态
        伪元素：是匹配元素中的内容
    语法：
        ：first-letter
        ::first-letter  匹配某元素的首字符
        ：first-line    匹配某元素的首行字符
        ：：selection 匹配用户选取的内容部分
    ：和：：区别
        在CSS2.1中，伪类选择器和仿元素选择器都是用：来表示
        在CSS3中，所有伪类选择器用：表示，所有的伪元素选择器用：：表示
</code></pre><p>2、内容生成</p>
<pre><code>通过CSS动态的向某个元素的内容区域之前、之后增加一部分内容
伪元素选择器
    ：before   定位到元素内容区域之前
    ：after    定位到元素内容区域之后
语法：
    属性：content
    取值：普通文本
         图像，url(...)
         计数器
问题处理：
    外边距溢出问题
        为父元素添加边框
        使用父元素的内边距取代子元素的外边距
        在父元素的第一个或最后一个子元素位置处增加一个空的table
    浮动元素父元素的高度问题
</code></pre><p>3、弹性布局</p>
<pre><code>flexible box,可伸缩布局，为普通布局带来更大的灵活性
基本概念‘
    flex容器：简称容器，将元素设置为flex容器后，其子元素允许实现灵活的位置摆放
    flex项目：简称项目，存放在flex容器中的内容

语法：
    容器：display
        取值：flex 将块级元素变为flex容器
              inline-flex  将行内元素变为flex容器
        注意：将元素设置为flex布局后，子元素的float,clear,vertical-align属性将失去作用
    容器属性;
        该组属性要添加在容器元素上，控制子元素的位置
        flex-direction  决定主轴的方向（main-axsis）
            取值：
                row  主轴为水平方向的轴，起点在容器左端，默认值
                row-reverse 主轴为水平方向的轴，起点在容器右端
                column  主轴为交叉轴，起点在容器的顶端
                column-reverse 主轴为交叉轴，起点在容器的底端
        flex-wrap   当一条轴线（一行）排列不下时，子元素将如何换行
            取值：
                nowrap     默认值，不换行
                wrap        换行
                wrap-reverse  反方向换行
        flex-flow   dirextion和wrap的缩写方式
            取值：
                row nowrap 默认值
                direction wrap
        justify-content   定义项目在主轴上的对齐方式
            取值：
                flex-start   主轴起点对齐
                flex-end   主轴终点对齐
                center    居中对齐
                space-between  两端对齐，项目之间的距离是相等的
                space-around  每个项目两侧间距是相等的 项目与项目之间的间距，要比项目与父元素之间的间距大一倍
        align-items  定义项目在交叉轴的对齐方式（单行项目有效）
            取值：
                flex-start  交叉轴起点对齐
                flex-end   交叉轴终点对齐
                center     交叉轴中间对齐
                baseline   基线对齐，以所有项目中的第一行文本为准
                stretch    默认值，如果项目不设置高度或为auto时，那么项目将占满整个容器的高度
        align-content  定义了多跟轴线的对齐方式，如果项目只一根轴线，该属性无效
            取值：
                flex-start   交叉轴顶端对齐
                flex-end    交叉轴底端对齐
                center      交叉轴中间对齐
                space-between  与交叉轴两端对齐
                space-around     项目与项目间对齐
    项目属性：
        该组属性主要设置于项目中
        order  定义项目在排列顺序，值越小，越靠前，默认为0
        flex-grow  指定项目的放大比例，默认为0，即不放大
        flex-shrink 指定项目的缩小比例，默认为1，即空间不足时，等比缩小，为0时不缩小
        flex-basis  指定项目占据主轴的剩余空间大小 auto 默认值，项目本身大小
        flex  是flex-grow,flex-shrink,flex-basis 的简写模式
            取值，auto  相当于1  1   auto
                 none  相当于0 0  auto
                 flex-grow【,flex-shrink,flex-basis】
        align-self  允许定义当个项目与其他项目不一样的交叉轴对齐方式（类似于align-items）,能够覆盖align-items的效果
            取值： auto 默认值，使用
                  flex-start   主轴起点对齐
                flex-end   主轴终点对齐
                center    居中对齐
                base-line
                stretch
</code></pre><p>4、CSS Hack 兼容性</p>
<pre><code>标准模式和混杂模式和准标准模式
IE6之前，没有兼容性说法
IE6之后，各个浏览器追求标准统一，开始支持标准，IE的其它浏览器要向前兼容，所以出现各种模式
    混杂模式  无标准可言
        编写代码时，不写&lt;!doctylpe&gt;就是混杂模式，采用的是IE5.5的内核进行渲染
    标准模式  安全支持
    准标准模式，即支持标准，也同时向前兼容非标准代码
如何根据不同的浏览器编写不同的css
    css类内部Hack
        在属性名称前和值添加前后缀以便识别不同的浏览器
    选择器Hack
        在选择器前添加特殊标识以便识别不同的浏览器
    头部引用hack
        通过html的条件注释来判断浏览器版本，去执行不同的CSS
        条件注释
            条件：
                gt:判断当前浏览器是否大于指定定版本
                gte：判断当前浏览器是否大于等于指定定版本
                it:   判断当前浏览器是否小于指定版本
                ite： 判断当前浏览器是否小于等于指定版本
                !：   判断当前浏览器是否为非指定版本
                    &lt;!--[if !IE 8]&gt;
                        该段内容在除IE8以外浏览器中显示
                    &lt;![endif]--&gt;
</code></pre><p>5、转换</p>
<pre><code>说明：改变元素在页面中的形状，角度 大小 位置的一种效果
    允许进行2D和3D方向的转换
    2D转换：在平面中进行的操作
    3D转换：在空间中进行的操作
转换属性：
    rtansform:为元素应用2D或3D转换效果
        取值：none;  没有效果

            transform-functions:一组转换函数
                位移转换函数：translate()
                改变形状函数：skew()
                注意：如果指定多个转换函数的话中间用空格隔开
    转换原点：
        属性：transform-origin
        默认：转换原点在元素中心处
        取值：轴线给值
            两个轴线值：X Y
            三个轴线值：X Y Z
2D转换
    位移：改变元素在页面中的位置
        语法：transform
            fransform(x)  改变元素在X轴的位置
            fransform(X ,Y)  改变元素在两轴的位置
            fransformX(X) 只在X轴上位置移动
            fransformY(Y)  只在Y轴上位置移动
    缩放： 改变元素在页面中的大小】
        语法：transform
            scale(value)  表示两轴等比缩放
                取值：默认  为1
                    放大   为大于1的数值
                    缩小   为0~1之间小数
                    返转   负数
            sacle(X,Y)
            saclex(y)
            sacley(y)
    旋转：改变元素在页面上的角度，要根据原点实现转换效果
        语法：transform
            rotate(ndeg)
                n 取值正，顺时针旋转
                n 取值负，逆时针旋转
                deg 为角度
                0~360范围
        注意：转换原点问题
            元素坐标轴也跟着旋转
    倾斜：改变元素在页面中形状
        语法：transform
            skew(xdeg)  横向倾斜指定度数
                x 取值正，y轴逆时针倾斜一定角度
                  取值负，Y轴顺时针倾斜一定角度
            skew(xdeg,ydeg)
            skewx(xdeg)
            skewy(ydeg)
3D转换
    感觉空间
    属性：perspetive 假定人眼到投射平面的距离
    注意：该属性要放在3D转换元素的父元素上
        兼容性chrome和safari需要加前缀
            -wedkit-perspective:500px;
    旋转：以X轴中心轴旋转
            rotatex(xdeg)
          以Y轴中心轴旋转
            rotatey(ydeg)
          以Z轴中心轴旋转
            rotatez(zdeg)
        取值：正  顺时针
            负   逆时针
        以多个轴同时进行旋转
            rotate3d(x ,y, z ,ndeg)
                x y z 取值为1，该轴参与旋转
                x y z  取值为0 ，该轴不参与旋转
    位移：改变元素在Z轴上的位置
        语法：transform
            translatez(z)

            transform-style
                取值：flat  默认值，子元素不保留3D位置
                     preserve-3D  子元素保留3D位置
</code></pre><p>6、过渡</p>
<pre><code>作用效果：使得css属性值在一段时间内平缓变化的效果
要素与属性：
    指定过渡属性：指定哪个属性值在变化时使用过渡效果展示
        transition-property: 属性名称（width）
                      all   全部属性
                      none
        允许设置过渡效果的属性：
            颜色属性
            渐变属性
            取值为数字属性
            转换属性 transition-property:transform;
            visibility属性
            阴影属性
    指定过渡时长
        transition-duration: 以S、MS为单位数值
    指定过渡时速曲线函数  可选
        transition-timing-function
            取值：ease  默认值，慢速开始，快速变快，慢速结束
                 linear  匀速进行
                 ease-in   慢速开始，快速结束
                 ease-out  快速开始，慢速结束
                 ease-in-out  慢速开始和结束，先加速后减速
    指定过渡的延迟时间   可选
        transition-delay
            取值：以S或MS做为单位
    简写属性：transition:prop duration  timing-fun delay;
        多个过渡效果
            transition:prop1 duration1 timing-fun1 delay1,prop2 duration2 timing-fun2 delay2........;
触发过渡条件
    将过渡编写在元素声明的样式中，由:hover,:active等，进行触发,
    将过渡编写在:hover,:active伪类中
</code></pre><p>7、动画</p>
<pre><code>使元素从一种样式逐渐变化为另一种样式的过程，与动画相关的属性，增加浏览器前缀
动画使用步骤
    声明动画
        指定动画名称
        指定动画中的关键帧（keyframes）
            时间点（以百分比描述时间）
            元素状态（CSS样式）
    为元素调用动画
        指定调用动画的名称以及执行时长
语法：
    声明动画     注意前缀，兼容性问题
        &lt;style&gt;
            @keyframes 名称{
                0%{   动画开始时，元素的状态   }
                。。。。
                100%{  动画结束时，元素的状态  }
            }
        &lt;/style&gt;
    调用动画(animation)
        animation-name  指定调用动画名称
        animation-duration   指定动画周期时长，以S或MS为单位
        animation-timing-function  指定动画的速度时间出线函数
            取值：ease  默认值，慢速开始，快速变快，慢速结束
                 linear  匀速进行
                 ease-in   慢速开始，快速结束
                 ease-out  快速开始，慢速结束
                 ease-in-out  慢速开始和结束，先加速后减速
        animation-delay  指定动画延迟时间
        animation-iteration-count  指定动画播放次数
            取值：默认1次，具体数值
                infinite:无限次播放
        animation-direction  指定动画的播放方向
            取值：normal  从0%~100%
                reverse  从100%~0%
                alternate  轮流来回播放 奇数 0%~100%
                                 偶数 100%~0%
        animation  简写方式
            取值：name  duration  timing-fun delay  iteration-count direction;
        animation-fill-mode  指定动画播放之前、之后的填充模式
            取值：none  默认值
                 forwards  动画播放完成后，保持在最后一帧的位置
                 backwards 动画播放前，延迟时间内，动画保持在开始第一帧上的位置
                 both 同时应用在开始和最后的位置帧上
        animation-play-state  动画播放状态
            取值：paused 暂停
                 running 播放
</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;1、复杂选择器&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;1、兄弟选择器
    通过兄弟级别的位置关系来匹配页面元素
    注意，兄弟选择器，只能向后找，不能向前找
    语法：
        相邻兄弟选择器：通过相邻（紧紧挨着的）位置关系匹配元素
        选择器1+选
    
    </summary>
    
      <category term="学习笔记" scheme="www.wangchengzou.cn/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="CSS" scheme="www.wangchengzou.cn/tags/CSS/"/>
    
      <category term="CSS3" scheme="www.wangchengzou.cn/tags/CSS3/"/>
    
  </entry>
  
  <entry>
    <title>DOM_BOM笔记</title>
    <link href="www.wangchengzou.cn/2017/07/22/DOM_BOM%E7%AC%94%E8%AE%B0/"/>
    <id>www.wangchengzou.cn/2017/07/22/DOM_BOM笔记/</id>
    <published>2017-07-22T15:48:26.000Z</published>
    <updated>2017-07-23T10:57:34.367Z</updated>
    
    <content type="html"><![CDATA[<ol>
<li><p>DOM: Document Object Model</p>
<p> DOM是专门操作网页内容的API标准<br> 为什么: 早起js操作不同浏览器的API没有标准，有严重兼容性问题<br> 所以，W3C制定了统一的操作网页内容的API标准,所有浏览器厂商都遵照执行。<br> 结果，使用DOM API操作网页内容，几乎100%兼容所有浏览器<br> 何时: 只要操作网页内容，就用DOM API查找, 修改(内容,属性,样式), 添加, 删除.</p>
</li>
</ol>
<p>DOM Tree:</p>
<pre><code>什么是: 网页中一切内容在内存中都是以树形结构存储的
       网页中每一项内容都是树上的一个节点对象
       包括: 元素, 文字, 属性...
       树只有一个根节点: document, 包含了所有网页内容
Node: 每个节点都是一个node类型的对象
      node是所有节点的父类型
</code></pre><p>三大公共: nodeType  nodeName  nodeValue</p>
<pre><code>nodeType: 节点的类型
  值: document   9
     element     1
     attribute     2
     text         3
  何时: 只要判断节点类型，就用nodeType
        因为不同类型的节点，能执行的操作是不一样的
  问题: 不能进一步区分元素的名称
  解决:
nodeName: 节点的名称
  值: document   #document
     element    全大写的标签名
     attribute    属性名
     text        #text
  何时: 只要细致鉴别元素的标签名时
    强调: nodeName返回的是全大写的标签名
nodeValue: 节点值:
  值: document   null
     element     null
     attribute     属性值
     text         文本内容
</code></pre><p>2、查找: 4种:</p>
<pre><code>  a. 不需要查找，可直接获得的元素
        html   document.documentElement
        head   document.head
        body   document.body
  b. 按节点间关系查找:
节点树: 包含所有节点: 元素和文本
  1. 父子: elem.parentNode  找elem的父节点
        elem.childNodes  找elem的所有*直接*子节点
            返回，所有直接子节点组成的集合(类数组)
        elem.firstChild   找elem的第一个*直接*子节点
        elem.lastChild   找elem的最后一个*直接*子节点
  2. 兄弟: elem.previousSibling 找elem的前一个兄弟
        elem.nextSibling   找elem的下一个兄弟
 何时: 前提: 已经获得了一个节点
      要找周围临近的节点时
 问题: 连看不见的空字符，也算文本节点——干扰
 解决:
元素树: 仅包含元素节点的树结构
       不是一棵新树，仅是节点树的子集
 1. 父子: elem.parentElement  找elem的父元素
        elem.children  找elem的所有*直接*子元素
            返回，所有直接子元素组成的集合(类数组)
        elem.firstElementChild   第一个*直接*子元素
        elem.lastElementChild   最后一个*直接*子元素
 2. 兄弟:
   elem.previousElementSibling 找elem的前一个兄弟元素
   elem.nextElementSibling   找elem的下一个兄弟元素
 何时: 只要仅关心元素节点，不关心文本节点时
 问题: IE9+
 强调: childNodes和children返回的都是动态集合！
   凡是遍历动态集合，都要先缓存元素个数，再遍历
   for(var i=0,len= childNodes.length;i&lt;len;i++)
     不会导致反复查找DOM树
</code></pre><p>3、 按HTML查找:</p>
<pre><code>    优: 范围可大可小,可设置条件
a、按id查找: var elem=document.getElementById(&quot;id&quot;)
  强调: 1. 只能在document对象上调用
       2. 返回一个元素对象
b、按标签名查找:
    var elems=parent.getElementsByTagName(&quot;标签名&quot;);
  强调: 1. 可在任意父元素上
       2. 返回多个元素组成的集合
       3. 不但查找直接子元素，还查找所有后代元素
c、按name属性查找: 了解
   专门找表单中有name属性的表单元素
    var elems=document.getElementsByName(&quot;name&quot;)
    强调: 1. 只能在document上调用
         2. 返回多个元素组成的集合
d、按class属性查找:
    var elems=parent.getElementsByClassName(&quot;class&quot;)
    强调: 1. 可在任意父元素上调用
         2. 返回多个元素组成的集合
         3. 不要求完整匹配，只要包含即可！
缺: 每次只能按一个条件查找
   如果条件复杂，就无法一句话获得想要的元素
</code></pre><p>4、 按选择器查找:</p>
<pre><code>a. 只找一个元素:
  var elem=parent.querySelector(&quot;selector&quot;);
b. 找多个元素
  var elems=parent.querySelectorAll(&quot;selector&quot;);
</code></pre><p>5、 总结:</p>
<pre><code> A首次查找:
    1. 如果条件简单: 按HTML查找: id, 标签, className
    2. 如果条件复杂: 按选择器查找:
 B已经获得一个元素，找周围相邻: 按节点间关系
鄙视: 按HTML查找 vs 按选择器查找
 1.使用的难易程度: 当条件复杂时:
    按选择器查找——简单, 按HTML查找——繁琐
 2.返回值:
    getElementsByTagName() 返回多个元素的*动态*集合
      什么是动态集合: 不实际存储对象的属性值，每次访问，都要重新查找DOM树
    querySelectorAll()  返回多个元素的*非动态*集合
      什么是非动态集合: 实际存储对象的所有属性值，即使反复访问集合，也不会导致反复查找DOM树
 3.单次效率:
    按HTML查找——效率高!
    按选择器查找——效率低
</code></pre><p>3、 修改: (内容, 属性, 样式)</p>
<pre><code>1. 修改:
标准属性: 2种:
  1. 核心DOM: 操作一切结构化文档的API(HTML，XML)
    elem.attributes集合: 保存了当前元素的所有属性节点
    获取属性值: elem.getAttribute(&quot;属性名&quot;)
    修改属性值: elem.setAttribute(&quot;属性名&quot;,&quot;值&quot;)
    判断是否包含属性: elem.hasAttribute(&quot;属性名&quot;)
    移除属性: elem.removeAttribute(&quot;属性名&quot;)
  2. HTML DOM: 对部分常用DOM API的简化版本
     HTML DOM将标准属性都预定义在元素对象中
    获取属性值: elem.属性名
    修改属性值: elem.属性名=&quot;值&quot;;
    判断是否包含属性: elem.属性名===&quot;&quot; 不包含
    移除属性: elem.属性名=&quot;&quot;
    特例: class属性和ES标准中的class重名
          -&gt; DOM -&gt; className
    自定义属性: 比如: data-toggle=&quot;dropdown&quot;
      HTML DOM不能操作自定义属性
      暂时只能用核心DOM操作:
    三大状态: disabled  selected   checked
      核心DOM无法操作三大状态属性
      HTMLDOM: elem.disabled elem.selected  elem.checked
            值都是bool类型true/false
</code></pre><p>3.1、修改css样式:</p>
<pre><code>1. 仅获取/修改内联样式:  elem.style.css属性名
  问题1: css属性名有的带-
  解决: 所有css属性名都要去横线变驼峰
     比如: background-color: backgroundColor
          list-style-type: listStyleType
  问题2: 所有数值类型的属性值都是带单位的字符串
  解决: 获取时: 都要去单位，转数值
        修改时: 将单位拼回数值
  问题3: 仅能获得内联样式, 无法获得样式表中的样式
  解决: 计算后的样式: 最终应用到元素上的完整样式
    何时: 只要希望获得元素完整的样式时
    如何: 2步:
      1. 获得完整样式对象style
        var style=getComputedStyle(elem)
      2. 获得style对象中的css属性
        style.css属性名
     强调: style对象中的样式都是只读
结论: 1. 获取样式: getComputedStyle
     2. 修改样式: elem.style.css属性名
2. 运行时修改样式表中的样式:
  Step1: 获得样式表对象:
   var sheet=document.styleSheets[i]
  Step2: 获得样式表对象中某个CSSRule(一个选择器{})
   var rule=sheet.cssRules[i]
  Step3: 修改rule.style.css属性名=值
</code></pre><p>4、 添加和删除:</p>
<pre><code>添加: 3步:
 Step1: 创建空元素:
  var a=document.createElement(&quot;a&quot;);
  &lt;a&gt;&lt;/a&gt;
 Step2: 设置关键属性:
     a.href=&quot;http://tmooc.cn&quot;
     a.innerHTML=&quot;go to tmooc&quot;;
  &lt;a href=&quot;http://tmooc.cn&quot;&gt;go to tmooc&lt;/a&gt;
 Step3: 将元素添加到DOM树: 3种:
   1. 末尾追加: parent.appendChild(child)
   2. 中间插入: parent.insertBefore(child, oldChild)
   3. 替换: parent.replaceChild(child, oldChild)
</code></pre><p>优化: 尽量少的修改DOM树</p>
<pre><code>原因: 页面加载过程:
  html -&gt; DOM Tree(松树)
           ↓
        render Tree(圣诞树)-&gt; layout(计算绝对布局)-&gt;paint
           ↑                 最耗时
  css  -&gt; cssRules(装饰品)
  每次修改DOM树，都会导致重新layout，耗时。
如何: 2种:
 1. 如果同时添加父元素和子元素时，应该先在内存将子元素都添加到父元素中，再将父元素一次性整体添加到DOM树
    结果: 只触发一次layout
</code></pre><p>1、 HTML DOM 常用对象: 对常用HTML元素操作的简化</p>
<pre><code>Select: 代表页面上的一个select元素
 属性: select.value 当前选中项的value
                 没有value，就返回选中项的内容
      select.options 保存select下所有option元素对象
        相当于: select.getElementsByTagName(&quot;option&quot;)
        select.options.length 保存select下option的个数
        清空select下所有option: select.options.length=0;
      select.length 等效于select.options.length
        清空select下所有option: select.length=0;
                               select.innerHTML=&quot;&quot;;
      select.selectedIndex 当前选中项的下标
  事件: onchange 当选中项发生改变时
  方法: select.add(option) 向select中添加一个option
         相当于: select.appendChild(option)
         不支持文档片段
       select.remove(i) 移除select中i位置的一个option
Option: 代表页面上的一个option元素
  创建: var opt=new Option(text,value);
     创建一个option对象，同时设置opt的内容为text，设置opt的值为value
     相当于: var opt=document.createElement(&quot;option&quot;);
            opt.innerHTML=text;
            opt.value=value;
  属性: .text 代替.innerHTML
       .index  表示当前option在select下的下标位置
</code></pre><p>Table: 代表网页中一个table元素</p>
<pre><code> 管着行分组：
   添加行分组: var 行分组=table.createTHead|TBody|TFoot();
       强调: 即创建，同时又将行分组添加到table
   删除行分组: table.deleteTHead|TFoot()
   获取行分组: table.tHead|tFoot
              table.tBodies[i]
行分组: THead TBody TFoot
  管着行:
   添加行: var tr=行分组.insertRow(i)
       在行分组中i位置插入一个新行
       强调: 中间插入行，原i位置的行向后顺移
       固定套路: 1. 末尾追加一个新行: 行分组.insertRow()
                2. 开头插入: 行分组.insertRow(0)
   删除行: 行分组.deleteRow(i)
       删除行分组中第i行
       强调: i是当前行在行分组内的相对下标位置
   获取行: 行分组.rows

行: tr
  管着td:
    添加td: var td=tr.insertCell(i);
        省略i表示右侧末尾追加
        insertCell不支持添加th，只能添加td
    删除td: tr.deleteCell(i);
    获取td: tr.cells

删除行:
 tr上都有一个属性: tr.rowIndex 行在整个表的绝对下标
 问题：行分组，无法使用tr.rowIndex删除行。
 解决: table.deleteRow(tr.rowIndex)
 总结: 今后，删除行都用table.deleteRow(tr.rowIndex)
</code></pre><p>form: 代表页面上一个表单元素</p>
<pre><code> 获取: var form=document.forms[i/id]
 属性: form.elements 保存了表单中所有表单元素的数组
        包括: input   select   textarea  button
      form.elements.length 获得表单中表单元素的个数
      form.length =&gt; form.elements.length
 方法: form.submit();  用于手动提交表单
 事件: form.onsubmit  以任何方式提交表单之前自动触发
          常用于在提交之前，验证所有表单元素的内容
表单元素:
 获取: var elem=form.elements[i/id/name]
        简写: 如果表单元素有name属性: form.name
 方法: elem.focus() 让elem获得焦点
      elem.blur()  让elem失去焦点

Image: 代表页面上一个img元素
  创建: var img=new Image();
</code></pre><p>DOM总结: 查找-&gt;绑定事件-&gt;查找-&gt;修改/添加/删除</p>
<pre><code>查找: 4种:
  1. 不需要查找可直接获得: html  head  body  form
  2. 节点间关系: 节点树/元素树
      鄙视: 递归遍历
  3. 按HTML: 4种: ById, ByTagName, ByName, ByClassName
  4. 按选择器: 2种:
      只找一个: querySelector()
      找多个: querySelectorAll()
修改:
  内容: .innerHTML  .textContent/.innerText  .value
  属性:
    1. 标准属性: 1. 核心DOM; 2. HTML DOM
    2. 自定义属性: 核心DOM
    3. 状态属性: HTML DOM
  样式:
    修改: elem.style.css属性=值
    获取: var style=getComputedStyle(elem)
         style.css属性 ——只读
    可通过修改class属性批量应用修改多个css属性
添加: 3步:
   1. createElement,
   2.设置关键属性,
   3. appendChild/insertBefore/replaceChild
  优化: 尽量少的操作DOM树
  如何: 2种:
   1. 同时添加父子元素: 先将子元素加入父元素，再将父元素整体添加到页面
   2. 同时添加多个平级子元素: fragment
删除: parent.removeChild(child)
HTML DOM: Select/Option  Table/...  From/Element  Image
过渡动画: 2步:
  css中: 添加transition
  js中: 修改css属性值
   不支持transition: display  zIndex
   支持: width  height  opacity   bottom/top/left/right ...
</code></pre><p>2、BOM: Browser Object Model</p>
<pre><code>什么是: 专门操作浏览器窗口的API
比如: alert prompt confirm
问题: 1. 没有标准——兼容性问题;
     2. 不可定制
window对象: 2个角色:
  1. 代替ES中的Global充当全局作用域对象
  2. 封装所有BOM和DOM的API

打开超链接: 4种:
  1. 在当前窗口打开，可后退
    html: &lt;a href=&quot;url&quot; target=&quot;_self&quot;&gt;&lt;/a&gt;
    js: /*window.*/open(&quot;url&quot;,&quot;_self&quot;)
  2. 在当前窗口打开，不可后退
    js: location.replace(&quot;url&quot;);
       用新url代替history中当前url，结果: 无法后退
  3. 在新窗口打开，可打开多个
    html: &lt;a href=&quot;url&quot; target=&quot;_blank&quot;&gt;&lt;/a&gt;
    js: open(&quot;url&quot;,&quot;_blank&quot;)
  4. 在新窗口打开，只能打开一个
    html: &lt;a href=&quot;url&quot; target=&quot;自定义name属性值&quot;&gt;&lt;/a&gt;
    js: open(&quot;url&quot;,&quot;自定义name属性值&quot;)
    原理: 内存中每个窗口都有一个唯一的name属性来唯一标示一个窗口
      浏览器规定，相同name属性的窗口只能打开一个
    其实: html中的target属性就是在设置新窗口的name属性值。
    如果target中使用自定义的窗口名，则只能打开一个
    预定义:
      _self: 默认使用当前窗口自己的name属性
           结果，新窗口覆盖当前窗口
      _blank: 意为不指定窗口名, 浏览器会随机生成不同的窗口名。
           结果: 每次打开新窗口都随机生成不同的name
                 结果: 可打开任意多个
</code></pre><p>定时器: 2种:</p>
<pre><code>1. 周期性定时器:
  什么是: 让程序按照指定时间间隔，反复执行一项任务
  何时: 只要让程序按照指定时间间隔，反复执行一项任务
  如何: 3件事:
    1. 任务函数: 让定时器反复调用的函数
    2. 启动定时器:
     var timer=setInterval(任务函数, 间隔的毫秒数)
    3. 停止定时器: clearInterval(timer)
        问题: timer中的序号会残留在timer变量中
        解决: 停止定时器后，主动清空timer
             timer=null
  停止定时器: 2种:
    1. 用户手动停止定时器: 用按钮调用clearInterval
    2. 自动停止定时器: 在任务函数中:
       1. 设定临界条件
       2. 如果达到临界条件就自动调用clearInterval

2. 一次性定时器:
 什么是: 让程序先等待一段时间，再自动执行一次任务
         执行一次后，定时器自动停止
 何时: 只要先等待，再执行一次任务
 如何: 三件事
   1. 任务函数
   2. 启动: var timer=setTimeout(任务函数, 等待的毫秒数)
   3. 停止: clearTimeout(timer)
</code></pre><p>鄙视: 定时器中的函数，只能在主程序所有程序执行后才能执行</p>
<pre><code>for(var i=0;i&lt;3;i++){
  setTimeout(function(){
    console.log(i);
  },0);
}//结果: 3 3 3
//alert(&quot;Hello&quot;) 如果不点确定，则永远不输出333
</code></pre><p>window:<br> history，location，document，navigator，screen，event</p>
<pre><code>history: 保存当前窗口打开后，成功访问过的历史记录的栈
  history封装的非常严密
  只能前进，后退，刷新: history.go(n)
   前进: go(1)  后退:go(-1)  刷新:go(0)

location: 专门保存当前窗口正在打开的url的对象
 属性: location.href 保存了完整的url
        在当前窗口打开: location.href=新url
      location.protocol: 协议
            .host: 主机名+端口号
            .hostname: 主机名
            .port: 端口号
      location.pathname: 相对路径
            .hash: 锚点地址#xxx
            .search: 表单提交后地址栏中的查询字符串
                   ?变量名=值&amp;变量名=值&amp;...
 方法:
   1. 替换history中当前url,实现进制后退:
     location.replace(&quot;新url&quot;)
   2. 在当前页面打开，可后退:
     location.assign(&quot;新url&quot;)
       =&gt; location.href=&quot;新url&quot;
        =&gt; location=&quot;新url&quot;
   3. 刷新页面:  location.reload(false/true);
     鄙视: false/true的差别
       浏览器本地是有缓存的
         浏览器的缓存中会保存css，图片等静态资源
       每次请求时，首先查看缓存中是否有想要文件
         没有想要文件，或文件过期，才去服务器下载新文件
       reload(false) 优先使用本地缓存的文件
       reload(true) 强制去服务器下载新文件
     查 浏览器缓存的原理！
</code></pre><p>1、event</p>
<pre><code>绑定事件: 2种:
 1. 在HTML中绑定: &lt;ANY on事件名=&quot;js语句&quot;
    问题: 不符合内容与行为分离的原则——不便于维护
 2. 在js中动态绑定: 2种:
    1. 一个事件只绑定一个处理函数:
       elem.on事件名=function(){
         //this-&gt;elem
       }
       解除绑定: elem.on事件名=null;
       问题: 每个事件只能绑定一个处理函数
       解决:
    2. 一个事件可同时绑定多个处理函数:
       elem.addEventListener(&quot;事件名&quot;,function(){
         //this-&gt;elem
       })
       解除绑定:
        elem.removeEventListener(&quot;事件名&quot;,&quot;函数名&quot;);
        强调: 如果一个事件处理函数可能被动态移除，则绑定时，不能使用匿名函数，必须使用有名称的函数

    事件模型: DOM标准: 3个阶段
      1. 捕获: 由外向内，记录各级父元素绑定的事件处理函数
      2. 目标触发: 首先执行目标元素上的事件处理函数
      3. 冒泡: 由内向外，反向执行捕获阶段记录的处理函数

    事件对象: 事件发生时自动创建的
             封装事件信息
             提供操作事件的API 的对象
      何时: 只要希望获得事件信息或修改事件的默认行为
      如何: 事件对象，在事件发生时，通常作为事件处理函数的第一个参数，默认自动传入！
          .on事件名=function(e){
             //e会自动获得事件对象
          }
    阻止蔓延/冒泡: e.stopPropagation();
    利用冒泡:
      优化: 尽量少的添加事件监听
      原理: 因为浏览器触发事件监听，是采用遍历查找的方式。添加的监听越多，遍历的速度越慢
      如何: 如果多个子元素都要绑定相同的事件
          只要在父元素绑定一次，所有子元素即可共用
      难题:
         1. 获得目标元素:
            不能用this, 因为this指父元素
            应该用e.target，保存实际点击的目标元素
         2. 鉴别目标元素:
            先判断目标元素的nodeName或className...
            只有目标元素符合要求时，才执行事件操作
    取消事件/阻止默认行为: e.preventDefault();
    事件坐标: 3对儿:
      1. 相对于整个屏幕左上角的坐标: e.screenX|screenY
      2. 相对于文档显示区左上角的坐标: e.clientX|clientY
      3. 相对于当前元素左上角的坐标: e.offsetX|offsetY

    页面滚动:
      事件: window.onscroll
      获得页面滚动位置: document.body.scrollTop
          页面超出文档显示区顶部的距离
</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;ol&gt;
&lt;li&gt;&lt;p&gt;DOM: Document Object Model&lt;/p&gt;
&lt;p&gt; DOM是专门操作网页内容的API标准&lt;br&gt; 为什么: 早起js操作不同浏览器的API没有标准，有严重兼容性问题&lt;br&gt; 所以，W3C制定了统一的操作网页内容的API标准,所有浏览器厂商
    
    </summary>
    
      <category term="学习笔记" scheme="www.wangchengzou.cn/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="javaScript" scheme="www.wangchengzou.cn/tags/javaScript/"/>
    
      <category term="DOM" scheme="www.wangchengzou.cn/tags/DOM/"/>
    
      <category term="BOM" scheme="www.wangchengzou.cn/tags/BOM/"/>
    
  </entry>
  
  <entry>
    <title>CSS3笔记</title>
    <link href="www.wangchengzou.cn/2017/07/22/CSS3%E7%AC%94%E8%AE%B0/"/>
    <id>www.wangchengzou.cn/2017/07/22/CSS3笔记/</id>
    <published>2017-07-22T15:48:26.000Z</published>
    <updated>2017-07-23T10:29:58.932Z</updated>
    
    <content type="html"><![CDATA[<p>1、CSS概述</p>
<pre><code>1、问题
    1、控制页面中所有的文本颜色为 红色
    2、控制页面中所有div的文本颜色 为蓝色
    3、将 所有div 的颜色 变为 黄色

    HTML元素的不足：
        1、要完成相同的效果，使用的是不同的属性
            &lt;body text=&quot;red&quot;&gt;
            &lt;font color=&quot;blue&quot;&gt;
        2、没有提升 html属性的 可重用性和可维护性
            可重用性：重复的操作 不用重复的写

        可以通过 CSS 解决以上两个问题
2、什么是CSS
    CSS (Cascading Style Sheets),层叠样式表，级联样式表，简称：样式表。专门用于定义页面元素的样式的。
    以统一的方式定义页面元素的样式

    CSS实现了内容与表现相分离
    提升了代码的可重用性 和 可维护性
3、CSS 与 HTML之间的关系
    HTML : 专门用于构建网页结构
    CSS : 专门构建HTML网页的样式

    HTML属性效果 与 CSS样式效果相冲突的话：
    优先使用 CSS 定义页面元素的效果
</code></pre><p>2、CSS语法</p>
<pre><code>1、使用CSS样式表
    1、内联方式
        又称为 ：行内样式
        将样式定义在某个html元素中
        语法：
        &lt;ANY style=&quot;样式声明;样式声明;&quot;&gt;&lt;/ANY&gt;
        样式声明：
            由 属性名称 和 属性值 来组成，属性名称和属性值之间用 : 来关联
        ex:
            属性名称          属性值
            color             red,blue,yellow...
            background-color  合法颜色值即可..(同上)
            font-size         以px，pt，为单位的数值

            控制以下 文本颜色为 红色，背景颜色为 黄色，文字大小为 24px
            &lt;p&gt;静夜思&lt;/p&gt;
    2、内部样式表
        将样式定义在网页的一块独立位置处
        在 &lt;head&gt;&lt;/head&gt; 中 增加一对 &lt;style&gt;&lt;/style&gt;元素，在 &lt;style&gt; 元素中 定义元素的样式,具体语法如下：
        &lt;head&gt;
            &lt;title&gt;&lt;/title&gt;
            &lt;style&gt;
                样式规则1
                样式规则2
                ...
                样式规则n
            &lt;/style&gt;
        &lt;/head&gt;
        样式规则，由两部分组成
            1、选择器
                选择(规范)页面中哪些元素能够使用声明好的样式
                比如：元素选择器，由元素名称来充当选择器，控制某标记对应所有页面元素的样式
            2、若干样式声明

            样式规则 语法结构：
            选择器{
                样式声明1;
                样式声明2;
                ...
                样式声明n;
            }
            ex:
            p{
                color:red;
                background-color:yellow;
                font-size:24px;
            }

    3、外部样式表
        将样式定义在外部的&quot;样式表文件(*.css)&quot;中
        1、创建 .css 文件，编写样式规则
        2、在要使用 样式表的 html文件中进行引入
            &lt;head&gt;
                &lt;link rel=&quot;stylesheet&quot; href=&quot;样式表文件url&quot;&gt;
            &lt;/head&gt;
2、CSS样式表特征
    1、继承性
        大部分样式属性是可以被继承
    2、层叠性
        可以为一个元素定义多个样式规则
        如果 属性 不冲突时，多个样式规则可以层叠为一个(即都可以应用到当前元素上)
    3、优先级
        在层叠性基础上，如果 样式定义 冲突的话，那么就会按照不同使用方式的优先级，来选择性应用样式
        低 ：浏览器默认设置
        中 ：外部样式表 和 内部样式表
            就近原则
            后定义优先
        高 ：内联方式
    4、!important 规则
        显示调整样式属性的优先级
        语法：
            属性名:值 !important;
        谨慎使用!
3、选择器(重点)
    1、作用
        选择(规范)页面中哪些元素能够使用声明好的样式
        为了匹配页面的元素
    2、详解
        1、通用选择器
            作用：匹配页面中所有的元素
            语法：*{}
            缺点：效率较低，尽可能少用,可以通过 使用 body 的继承性 来替代 *
        2、元素选择器
            作用：匹配某一标记所对应的页面中所有的元素
            语法：元素/标签 {}
            ex:
            div{/*匹配页面中所有div*/}
            span{/*匹配页面中所有span*/}
            li{/*匹配页面中所有li*/}
        3、类选择器
            作用：事先定义好样式，可以由任意元素通过class属性进行引用
            语法：
                定义：.类名{}
                引用：&lt;ANY class=&quot;类名&quot;&gt;&lt;/ANY&gt;

            多类选择器的引用方式：
            让一个元素引用多个类选择器，中间用 空格 隔开即可

            分类选择器的声明方式：
                将元素选择器和类选择器结合到一起进行声明，实现对某种元素中的不同样式细分控制

                ex:想要控制 class为important的div元素，文字大小为 48px
                语法：元素选择器.类选择器{}
        4、id选择器
            作用：匹配 指定id值的元素的 样式
            ex:
                &lt;div id=&quot;nav&quot;&gt;&lt;/div&gt;

            语法：#ID值{}
        5、群组选择器
            群组选择器的声明以一个以 , 隔开的选择器列表
            语法：
                选择器1,选择器2,...{}
            ex:
                #title,p.redColor,.important,span{
                    color:red;
                }
        6、后代选择器
            后代：
                多于 一级 层级关系的元素，只能叫后代
                只具备 一级 层级关系的 也可以叫后代
            语法：
                选择器1 选择器2{}
                语义：匹配 在选择器1 中的  所有后代元素 选择器2
                ex:
                    #content span{}
        7、子代选择器
            子代：
                只具备 一级 层级关系的 称之为 子代
            语法：
                选择器1&gt;选择器2{}
                语义：匹配 在选择器1 中的 子级元素 选择器2
        8、伪类选择器
            伪类：专门匹配元素不同状态的选择器
            分类：
                1、链接伪类
                2、动态伪类

                3、目标伪类
                4、元素状态伪类
                5、结构伪类
                6、否定伪类
            语法：
                以 :作为开始的选择器

                1、链接伪类
                    1、:link
                        适用于未被访问的超链接
                    2、:visited
                        适用于访问过的超链接
                2、动态伪类
                    1、:hover
                        适用于鼠标悬停在html元素时
                    2、:active
                        适用于html元素被激活时
                    3、:focus
                        适用于html元素获取焦点时
</code></pre><p>3、尺寸与边框</p>
<pre><code>1、CSS单位
    1、尺寸单位
        1、px ：像素
        2、pt ：磅 (1pt=1/72in)
        3、in ：英寸，1in=2.54cm
        4、%  ：百分比，占据 当前元素 或 父元素 对应属性的 占比
        5、em ：倍数，多数用于 文字大小的描述
        6、mm ：毫米
        7、cm ：厘米
        注意：css中尺寸单位是不能省略的。
    2、颜色单位(取值)
        1、rgb(r,g,b)
                r : red , 范围 0-255
                g : green,范围 0-255
                b : blue, 范围 0-255

             ex：
                background-color:rgb(0,0,0);黑色
                background-color:rgb(255,0,0);红色
                background-color:rgb(255,255,255);白色
        2、rgb(r%,g%,b%)
        3、rgba(r,g,b,alpha)
            alpha : 透明度 0-1之间的数字
                0 : 完全透明
                1 : 完全不透明
                0.5 : 半透明
        4、#rrggbb
            通过6位16进制数字表示一个颜色
            每位数字范围：0-9 A-F
            #00ff00 : 绿色
            #ff0000 : 红色
            #1a2b3c : ?
        5、#rgb
            #rrggbb 每两位数字相同时，可以使用#rgb简化
            #00ff00 -&gt; #0f0
            #aabbcc -&gt; #abc
            #accdda -&gt; ×
        6、颜色的英文表示
            red,green,blur,orange,yellow...
2、尺寸属性
    1、作用
        用于设置元素的宽度和高度
        单位一般为 px 或 %(父元素对应属性的占比)
    2、语法
        1、宽度
            width
            min-width : 最小宽度
            max-width : 最大宽度
        2、高度
            height
            min-height : 最小高度
            max-height : 最大高度
        注意：
            页面中所有元素的高度，在不指定的情况全部是自适应(以内容为主)。

            页面中所有块级元素的宽度，默认占据父元素的100%
            页面中所有行内元素的宽度，默认自适应(以内容为主)
    3、页面中允许修改 尺寸 属性的元素
        1、所有块级元素都允许修改
        2、大部分的行内块元素
            所有的表单元素都是行内块元素
            除radio、checkbox之外，其他元素允许修改尺寸
        3、本身html元素就具备width 和 height的
            img，table 可以修改尺寸
        4、行内元素(除具备width和height之外)是不能修改尺寸
            span,b,a,i,s,b ... 不能修改尺寸
    4、溢出
        1、什么是溢出
            使用尺寸属性限制元素大小时，如果内容所需要的空间大于元素本身空间，则会导致内容溢出
        2、溢出处理属性
            属性：
                overflow
                overflow-x : 横向溢出处理
                overflow-y : 纵向溢出处理
            取值：
                1、visible
                    默认值，溢出可见
                2、hidden
                    隐藏
                3、scroll
                    滚动，让元素出现滚动条，溢出时，滚动条可用
                4、auto
                    自动，溢出时显示滚动条并可用，非溢出时，不显示滚动条
3、边框属性
    1、边框
        1、简写方式
            border:width style color;
            作用：设置元素上下左右四个边框的宽度，样式以及颜色
                width:边框的宽度(尺寸)
                style:边框的样式
                    取值：
                        1、solid ：直线
                        2、dotted ：虚线(点状)
                        3、dashed ：虚线(线状)
                color:边框的颜色,可以取值为 transparent(透明)

            ex:
                div{
                    border:1px solid red;
                }
        2、单边定义
            border-方向:width style color;
            方向可以被以下关键字所取代
            top : 上
            right : 右
            bottom : 下
            left:左
            ex:
                border-bottom:2px dashed #00ff00;
        3、单属性定义
            border-属性:值;
            属性可以被以下关键字取代：
            width:宽度
            style:样式
            color:颜色
            ex:
                border-width:5px;
                border-style:solid;
                border-color:#f00f00;
        4、单边单属性定义
            border-方向-属性:值;
            方向：top/right/bottom/left
            属性：width/style/color
            ex:
                border-top-color:yellow;
                border-right-style:dotted;
</code></pre><hr>
<p>1、边框</p>
<pre><code>1、边框
    边框实际上是由四个三角形组成的
2、边框倒角
    属性：border-radius
    取值：
        具体数值(px) 或 %
        最少一个值，最多4个值
    单角定义
        border-top-left-radius:左上角倒角半径
        border-bottom-right-radius:右下角
        ... ...
3、边框阴影
    属性：box-shadow
    取值：h-shadow v-shadow blur spread color inset;
        h-shadow:(必须)
            阴影的水平偏移距离
            取值为正，右偏移
            取值为负，左偏移
        v-shadow:(必须)
            阴影的垂直偏移距离
            取值为正，下偏移
            取值为负，上偏移
        blur : 模糊距离,取值为数值
        spread : 阴影的大小
        color : 颜色
        inset : 值，将默认的外阴影改为内阴影
4、轮廓
    1、什么是轮廓
        位于元素外围的一条线,位于边框之外的
    2、属性
        outline:width style color;
        outline-width:宽度;
        outline-style:样式;
        outline-color:颜色;

        常用：
            outline:none;
            或
            outline:0;
    练习：作业基础上
        1、为每幅图像增加四个角的倒角(5px)
        2、鼠标移入的时候，为每幅图像增加阴影
            右下偏移，大小不限，颜色不限
</code></pre><p>2、框模型(重难点)</p>
<pre><code>1、框 &amp; 框模型
    框：页面元素皆为框
    框模型：Box Model ,定义了元素框处理元素内容尺寸，内边距，边框和外边距的一种方式

    元素一旦增加框模型对应属性的属性，那么实际的占地区域会发生改变

    元素的实际宽度=左右外边距 + 左右边框 + 左右内边距 + width;

    元素的实际高度=上下外边距 + 上下边框 + 上下内边距 + height;
2、外边距
    1 、外边距
        围绕在元素边缘周围的空白区域
        默认不能被其他元素所占据
        作用：拉伸两个元素间的距离
    2、语法
        属性：
            margin:值;
            单边设置：
            margin-方向:值;
                方向：top/right/bottom/left
        取值：
            1、具体数值 px
            2、%
            3、负值
                左外边距取负值 ：左移动
                左外边距取正值 ：右移动
                上外边距取负值 ：上移动
                上外边距取正值 ：下移动
            4、auto
                自动，由浏览器计算外边距的值应该是多少
                注意：默认情况下，auto只对左右有效，上下无效。

                为块级元素设置宽度后，再设置其左右外边距为 auto，该元素能水平居中显示
        margin的简洁写法：
            margin:value; 四个方向外边距的值
                margin:5px;
            margin:v1 v2; v1 上下外边距 v2 左右外边距
                margin:5px 10px;
            margin:v1 v2 v3;v1 上外边距 v2 左右外边距 v3 下外边距
                margin:5px 15px 3px;
            margin:v1 v2 v3 v4;上 右 下 左
    3、页面中具备默认外边距的元素
    4、特殊注意
        1、外边距合并
            当两个垂直外边距相遇时，将合并成一个
        2、外边距的溢出
            特殊场合下，为子元素设置外边距(上下)会作用到父元素上
            特殊场合：
                1、父元素没有边框(上下)
                2、为第一个(最后一个)子元素设置外边距
            解决方案：
                1、为父元素增加边框(透明的)
                    弊端：父元素会变高
                2、可以为父元素设置上内边距来取代子元素上外边距
                    弊端：父元素高度会变高
                3、为父元素增加一个空子元素
                    &lt;table&gt;&lt;/table&gt;
                    弊端：多一个子元素
                4、后续讲解...(CSS3高级)
        3、为行内元素和行内块元素设置垂直外边距
            1、大部分行内元素垂直外边距无效
                img允许设置
            2、行内块元素设置垂直外边距，该行的所有元素都跟着变
3、内边距
    1、什么是内边距
        内容区域 和 边框(边缘)之间的距离
        注意：内边距会扩大边框所占用的区域
    2、语法
        属性：
            padding:值;
            padding-方向:值;
                方向：top/right/bottom/left
            取值：
                1、px
                2、%
                3、auto
        简写方式：
            padding:value; 上下左右
            padding:v1 v2; 上下  左右
            padding:v1 v2 v3;上  左右  下
            padding:v1 v2 v3 v4;上 右 下 左
    3、特殊注意
        1、为行内元素增加上下内边距时
            只影响自己，并不影响其他元素
4、box-sizing
    1、作用
        重新指定元素尺寸计算模式
        占地宽度 = margin+border+padding+width
        可见宽度 = border+padding+width
    2、语法
        属性：box-sizing
        取值：
            1、content-box
                默认值，width只表示内容区域的宽度，border和padding额外进行计算
                可见宽度=border+padding+width
            2、border-box
                width包含边框内所有的距离(padding,border)
                可见宽度=width(border+padding+宽度);
</code></pre><p>3、背景</p>
<pre><code>1、背景颜色
    属性：background-color
    取值：颜色值 或 transparent
    注意：背景颜色从边框位置处开始绘制
2、背景图像
    属性：background-image
    取值：url(背景图url)
3、背景重复
    属性：background-repeat
    取值：
        1、repeat
            默认值，即横向又纵向平铺
        2、repeat-x
            只在横向平铺
        3、repeat-y
            只在纵向平铺
        4、no-repeat
            不平铺
4、背景图片尺寸
    属性：background-size
    取值：
        1、value1 value2
            指定背景图像宽度 和 高度
        2、value1% value2%
            采用当前元素宽和高的占比，来作为背景图大小
        3、cover
            覆盖，会将背景图像等比放大，直到背景图完全覆盖到元素为止
        4、contain
            包含，会将背景图像等比放大，直到右边或下边碰到元素边缘为止
5、背景图片固定
    属性：background-attachment
    取值：
        1、scroll
            滚动，默认值
        2、fixed
            固定，让背景图一直在可视化区域中
6、背景图片定位
    改变背景图在元素中的位置
    属性：background-position
    取值：
        1、x y
            指定背景图水平 和 垂直偏移距离
            x : 水平偏移距离
                取值为正，背景图右偏移
                取值为负，背景图左偏移
            y : 垂直偏移距离
                取值为正，背景图下偏移
                取值为负，背景图上偏移
        2、x% y%
            0% 0% : 背景图在左上
            0% 100% : 背景图在左下
            100% 100% : 背景图在右下
        3、关键字
            x : left / center / right
            y : top / center/ bottom
7、背景属性
    在一个 background 属性中声明所有的北京属性值

    属性：background
    取值：color url repeat attachment position;

    ex:
        background:red;
        background:url(a.jpg) no-repeat;
8、特殊使用
    CSS Sprites(精灵图/雪碧图)
</code></pre><p>1、渐变</p>
<pre><code>1、什么是渐变
    多种颜色之间平缓过度的显示效果
2、渐变分类
    1、线性渐变(linear-gradient)
        按照直线的方式填充渐变颜色和方向
    2、径向渐变(radial-gradient)
        以圆的方式填充渐变效果(圆心位置，半径)
    3、重复渐变
        1、重复线性渐变
            repeating-linear-gradient
        2、重复径向渐变
            repeating-radial-gradient
3、渐变中的重要信息
    1、色标
        由 颜色 及其 出现的位置 来组成的
4、渐变的语法
    1、属性
        background-image
    2、取值
        1、linear-gradient()
            linear-gradient(angle,color-point1,color-point2);
            1、angle
                填充的方向或角度
                1、关键字
                    1、to top ：从下向上填充
                    2、to right ：从左向右填充
                    3、to bottom ：从上向下填充
                    4、to left ：从右向左填充
                2、角度
                    0deg ~ 360deg

                    0deg : to top
                    90deg : to right
                    180deg : to bottom
                    270deg : to left
            2、color-point
                渐变中的色标,由 颜色 及其 出现的位置组成
                ex:
                    1、red 0px
                        该色标颜色为 red ，位置为填充方向的 0px 处
                    2、green 50px
                        该色标颜色为 green,位置为填充方向的 50px 处
                    3、blue 50%
                        该色标颜色为 blue，位置为填充方向的 50% 处
                    4、
                        linear-gradient(to top,red,blue,green);
                        自动分配位置
        2、radial-gradient()
            radial-gradient([size at position,]color-point,color-point)

            1、[size at position,] : 允许被省略
                size:圆的半径
                at : 关键字
                position:圆心的位置
                    1、x y
                        以px为单位的具体数值
                    2、x% y%
                    3、关键字
                        x : left , center , right
                        y : top , center, bottom
        3、repeating-linear-gradient()
        4、repeating-radial-gradient()
5、浏览器兼容性问题
    主流浏览器都支持渐变
    对于不支持的浏览器，需要添加浏览器前缀的方式实现兼容性
        浏览器前缀：
            1、Firefox ：-moz-
            2、Chrome 和 Safari ：-webkit-
            3、Opear ：-o-
            4、Microsoft IE ：-ms-
        如果浏览器不支持属性的话，则将前缀添加到属性名称前
            ex:
                animation:值;
                -moz-aniamtion:值;
                -webkit-aniamtion:值;
                -o-aniamtion:值;
                -ms-animation:值;
        如果浏览器支持属性，但不支持属性值的话，则将前缀添加到属性值前
            ex:
                background-image:linear-gradient();
                background-image:-moz-linear-gradient();
                background-image:-webkit-linear-gradient();
                background-image:-o-linear-gradient();
                background-image:-ms-linear-gradient();
</code></pre><p>2、文本格式化</p>
<pre><code>1、字体属性
    1、指定字体
        属性：font-family
        取值：字体1,字体2,字体3;
        注意：字体中包含中文或特殊字符的话，尽量使用 &quot;&quot; 引起来
        ex:
            font-family:&quot;微软雅黑&quot;,Arial;
    2、字体大小
        属性：font-size
        取值：px 或 pt 为单位的数值
    3、字体加粗
        属性：font-weight
        取值：
            1、normal
                非加粗显示，正常体
            2、bold
                加粗显示 &lt;b&gt;&lt;/b&gt;
            3、400 ~ 900
                400 ：normal
                900 ：bold
    4、字体样式
        属性：font-style
        取值：
            1、normal
                正常体
            2、italic
                斜体 &lt;i&gt;&lt;/i&gt;
    5、小型大写字符
        效果：将小写英文字符变成大写，但是大小和小写字符一样
        属性：font-variant
        取值：
            1、normal
                正常，默认值
            2、small-caps
                小型大写字符
    6、字体属性
        属性：font
        取值：style variant weight size family;
        注意：该简写属性中，必须包含 family 的值
2、文本属性
    1、文本颜色
        属性：color
        取值：~
    2、文本排列
        作用：控制内容的的水平对齐方式
        属性：text-align
        取值：left/center/right/justify(两端对齐)
    3、文本修饰
        线条修饰
        属性：text-decoration
        取值：
            1、none
                无线条修饰
            2、underline
                显示下划线
            3、line-through
                显示删除线 &lt;s&gt;&lt;/s&gt;
            4、overline
                显示上划线
    4、行高
        作用：一行数据的高度
        属性：line-height
        取值：以px为单位 或 当前字体大小的倍数
            line-height:50px;
            line-height:1.5;
        注意：文字将在指定行高的范围内垂直居中显示
        场合：
            1、文字垂直居中
            2、行间距的设置
    5、文本阴影
        属性：text-shadow
        取值：h-shadow v-shadow blur color;
</code></pre><p>3、表格</p>
<pre><code>1、表格常用属性
    1、边距属性
        padding，margin(不能为td设置margin)
    2、尺寸属性
        width,height
    3、文本格式化属性
        font-*,text-*,line-height,color,... ...
    4、背景属性
        颜色，图片，渐变
    5、border属性
    6、垂直方向对齐
        属性：vertical-align
        取值：top / middle / bottom
2、表格特有属性
    1、边框合并属性
        属性：border-collapse
        取值：
            1、separate
                默认值
            2、collapse
                合并
    2、边框边距
        类似于 cellspacing
        属性：border-spacing
        取值：
            1、指定1个值
                每个单元格的水平和垂直间距相同
            2、指定2个值
                第一个值，表示水平间距
                第二个值，表示垂直间距
        注意：
            必须保证border-collapse是separate时才有效
    3、标题位置
        默认情况下，标题表格上方，水平居中
        属性：caption-side
        取值：
            1、top
                默认值
            2、bottom
                底部
    4、显示规则
        作用：指定浏览器如何来布局一张表格(指定行和列的尺寸的计算模式)
        属性：table-layout
        取值：
            1、auto
                自动，即自动表格布局，默认值
                列的宽度高度实际上是由内容来决定的
            2、fixed
                固定，即固定表格布局。
                列的宽度和高度由设定的值决定
        自动表格布局 VS 固定表格布局
            1、自动表格布局
                1、单元格的大小会适应内容
                2、表格复杂时，加载速度较慢(缺点)
                3、适用于不确定每列大小时使用
                4、特别灵活(优点)
            2、固定表格布局
                1、尺寸取决于设定的值，与单元格内容无关
                2、任何情况下，都会加速显示表格(优点)
                3、不够灵活(缺点)
        推荐：
            复杂的布局不能使用table
            简单，显示数据的布局，可以使用table
</code></pre><p>4、浮动</p>
<pre><code>1、定位
    改变元素在网页中的默认位置
2、定位的分类
    按照定位效果，可以分为以下几种方式：
    1、普通流定位/文档流定位
    2、浮动定位
    3、相对定位
    4、绝对定位
    5、固定定位
3、定位-普通流定位
    普通流定位，又称为 文档流定位，网页元素默认定位方式
    1、页面中所有元素都有自己的位置
    2、按照从左到右，从上到下的方式排列
    3、块级元素 - 从上到下排列
    4、行内/行内块 - 从左到右排列

    问题：让多个块级元素在一行内显示?
4、定位 - 浮动定位
    1、浮动定位特点
        将元素设置为浮动定位，将具备以下特征
        1、会排除在文档流之外即&quot;脱离文档流&quot;，不再占据页面空间，后续元素则上前补位
        2、浮动元素只在当前行内浮动
        3、浮动元素会停靠在父元素的左边或右边或其他已浮动元素的边缘上
        4、浮动元素依然位于父元素之内
        5、解决问题-多个块级元素在一行内的显示问题
    2、语法
        属性：float
        取值：
            1、none
                默认值，即无任何浮动
            2、left
                元素左浮动
                停靠在父元素的左边 或 其他已浮动元素的右边上
            3、right
                元素右浮动
                停靠在父元素的右边 或 其他已浮动元素的左边上
    3、浮动引发的特殊效果
        1、当父元素容纳不下所有已浮动子元素，最后一个将换行显示(有可能被卡住)
        2、元素一旦浮动起来后，宽度将变成自适应(非手动指定情况下)
        3、元素一旦浮动起来后，都将变成块级元素
            块级：允许修改尺寸，允许设置上下margin
            行内元素：不能改尺寸，不能设置上下margin
        4、行内元素，行内块元素，文本 采用的是环绕的排列方式，无法被浮动元素压在底下
</code></pre><p>1、浮动定位</p>
<pre><code>1、清除浮动
    1、什么是清除浮动
        清除当前元素前面的元素浮动所带来的影响
        清除浮动影响后，当前元素不会上前占位
    2、属性
        属性：clear
        取值：
            1、none
                默认值，无清除效果
            2、left
                清除当前元素前面元素左浮动带来的影响
            3、right
                清除当前元素前面元素右浮动带来的影响
            4、both
                清除当前元素前面元素任何一种浮动方向所带来的影响
    3、浮动元素为父元素高度带来的影响
        父元素的高度是以未浮动的子元素高度为准
        如果一个元素中所有的子元素全部都是浮动的，那么该父元素的高度为 0
        解决父元素的高度问题方案：
        1、直接设置父元素高度
            弊端：必须知道父元素的高度
        2、让父元素也浮动
            弊端：对后续元素会产生影响
        3、为父元素增加溢出处理属性
            属性：overflow
            取值：hidden 或 auto
            弊端：要溢出显示的内容，也一同被隐藏
        4、在父元素中，增加空子元素到最后一个位置处,并且设置其clear属性为both
            弊端：多一个子元素在页面上
</code></pre><p>2、显示</p>
<pre><code>1、显示方式
    属性：display
    取值：
        1、none
            让指定的元素不显示 并且 不占据页面空间
            (脱离文档流)
        2、block
            将指定的元素显示为块级
        3、inline
            将指定的元素显示为行内
        4、inline-block
            将指定的元素显示为行内块
            行内块特点：
                1、多个元素能够在一行内显示
                2、允许修改尺寸
        5、table
            将指定的元素显示为 table
2、显示效果
    1、visibility 属性
        作用：规范元素可见性
        取值：
            1、visible
                默认值，元素可见
            2、hidden
                元素不可见，但是占据页面空间
            3、collapse
                用在表格元素上，删除一行或一列时，不影响表格整体布局
        面试：
            display:none 和 visibility:hidden 区别
            1、display:none; 脱离文档流，所以不占据页面空间
            2、visibility:hidden; 只是改变可见性，并不脱离文档流，空间依然占据
    2、opacity 属性
        作用：改变元素的透明度
        取值：从0.0(完全透明) ~ 1.0(完全不透明) 之间的数字
    3、vertical-align 属性
        1、在 td 中，设置文本的垂直对齐方式
        2、设置行内块元素两边文本的垂直对齐方式
        3、设置图片两端文本垂直对齐方式

        语法：
            属性：vertical-align
            取值：
                1、top
                2、middle
                3、bottom
                4、baseline
                    基线对齐
3、光标
    改变鼠标在页面(元素)中的状态
    属性：cursor
    取值：
        1、default
        2、pointer
            小手
        3、crosshair
            +
        4、text
            文本状态 I
        5、wait
            等待
        6、help
            帮助
</code></pre><p>3、列表</p>
<pre><code>1、列表项标识
    属性：list-style-type
    取值：
        1、none
        2、disc ：实心圆
        ... ...
2、列表项图像
    属性：list-style-image
    取值：url()
3、列表项标识位置
    列表项标识的默认位置是在内容区域之外
    属性：list-style-position
    取值：
        1、outside
            默认值
        2、inside
            将列表项标识的位置改为内容区域之内
4、列表属性
    属性：list-style
    取值：type url position;
    常用方式：list-style:none;
5、CSS重写
    CSS Reset，修改元素的默认样式
    body,p,h1,h2,h3,h4,h5,h6,pre,ul,ol,dl,dd{
        margin:0;
        padding:0;
        list-style:none;
    }
</code></pre><p>4、定位(相对，绝对，固定)</p>
<pre><code>1、定位属性
    1、定位属性
        属性：position
        作用：改变元素定位方式
        取值：
            1、static
                静态的，默认值
            2、relative
                相对的
            3、absolute
                绝对的
            4、fixed
                固定定位
        注意：relative，absolute，fixed被称之为 &quot;已定位元素&quot;
    2、偏移属性
        作用：改变元素在页面中的位置
        属性：
            1、top
            2、bottom
            3、left
            4、right
        取值：偏移距离(px)
    3、堆叠顺序
        作用：在已定位元素中调整堆叠顺序
        属性：z-index
        取值：无单位的数字
2、定位 - 相对定位
    1、什么是相对定位
        元素会相对于它原来的位置偏移某个距离
        元素原来所占的空间会被保留
    2、语法
        position:relative;
        配合 top/right/bottom/left 偏移属性实现位置的微调
    3、使用场合
        1、元素位置微调
3、定位 - 绝对定位
    1、什么是绝对定位 &amp; 特点
        1、绝对定位的元素会脱离文档流即不占据页面空间
        2、绝对定位的元素会相对于离它最近的已定位的祖先元素去实现定位
        3、如果没有已定位的祖先元素，那么就会相对于最初的包含块去实现定位比如body或html
    2、语法
        position:absolute;
        配合着 top/right/bottom/left 实现位置定位
    3、特点
        1、绝对定位元素会变成块级元素
        2、绝对定位元素的margin可以使用，默认情况下，auto会失效
        &lt;div id=&quot;d1&quot;&gt;(无定位)
            &lt;div id=&quot;d2&quot;&gt;(无定位)
                &lt;p id=&quot;p1&quot;&gt;(无定位)
                    &lt;span&gt;这是一个span&lt;/span&gt;
                &lt;/p&gt;
            &lt;/div&gt;
        &lt;/div&gt;
4、堆叠顺序
    属性：z-index
    取值：无单位的数值
        数值越大，越靠前，默认是0
        可以取负值，当前元素在页面所有内容之下
    注意：
        1、只有已定位元素才能设置z-index
        2、默认的堆叠顺序是 后来者居上
        3、父子元素中，永远都是子压在父上,是不受z-index影响的
</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;1、CSS概述&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;1、问题
    1、控制页面中所有的文本颜色为 红色
    2、控制页面中所有div的文本颜色 为蓝色
    3、将 所有div 的颜色 变为 黄色

    HTML元素的不足：
        1、要完成相同的效果，使
    
    </summary>
    
      <category term="学习笔记" scheme="www.wangchengzou.cn/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="CSS" scheme="www.wangchengzou.cn/tags/CSS/"/>
    
      <category term="CSS3" scheme="www.wangchengzou.cn/tags/CSS3/"/>
    
  </entry>
  
  <entry>
    <title>Ajax_php基础知识</title>
    <link href="www.wangchengzou.cn/2017/07/22/Ajax_php/"/>
    <id>www.wangchengzou.cn/2017/07/22/Ajax_php/</id>
    <published>2017-07-22T15:48:26.000Z</published>
    <updated>2017-07-23T13:10:35.427Z</updated>
    
    <content type="html"><![CDATA[<p> 1、如何从数据库中将数据表中数据抓取出来并且显示.</p>
<pre><code>解决方法:语言php 负责从数据库中抓取数据并且显示给用户.
  a:什么是服务器
    能够在网站中提供各种(浏览网页,收发邮件
    视频,语言)等服务器的软件与硬件集合。
    硬件服务器:高可用,高性能计算机
    软件服务器(通常):(WEB/FTP/EMAIL/DB/DNS..)
    web:apache
    db:mysql
b:数据库服务器(软件)
    数据库软件特点：所有其它软件所没有
    1:永久海量存储数据
    2:高速查询
c:数据库服务器分类
    网状数据库:
    树型数据库:
    关系型数据库:
    MySQL***/Oracle/SQLServer/DB2
    NOSQL数据库:Redis
d:什么是关系型数据库
    以横行竖列的方式保存数据,mysql
e:关系型数据库层次
    数据库软件(mysql)--&gt;库--&gt;表--&gt;行--&gt;列
f:mysql之父:马丁
    MYSQL AB(瑞典)-&gt;SUN-&gt;Oracle
g:mysql版本:
  主版本: 企业版(收费)社区版(免费)
    小版本:5.0 5.1 5.2 5.4 5.5 5.6 5.7 ..
    建议:下载哪个版本
    ?如果开发全新网站项目:新版本 5.6
    ?如果二次开发选旧版本.
g:下载
https://www.oracle.com 官网
https://www.mysql.com/downloads/
搜狐镜像
http://mirrors.sohu.com/
mysql windows(64/32)(zip/exe)
linux  unix
    mysql-5.6.34-win32.msi (32)
i:使用软件包(XAMPP)
    (包含:mysql/php/apache/..)
</code></pre><p>   2、如何使用xampp</p>
<pre><code>1:双击xampp图标
2:点击 apache  [start]启动(饭店)
     点击 mysql   [start]启动
3:点击 右侧[shell]
4:输入命令
    mysql -uroot -p
    #mysql 指令专门进入数据库系统
    #-u    指定用户名
    #root  root是mysql软件最高级别用户
    #-p    root用户密码
5:退出软件
    #exit
    #点击右上角[X]
</code></pre><p>3、 sql(结构化查询语言)专用于(增删改查)数据库中数据语言.</p>
<pre><code>使用sql两种方式:
    a:交互模式(上课)
      一行一行执行指令
       用户输入一个sql指令,mysql执行一个指令.
    b:脚本模式(做项目)
    把所有sql指令保存在一个.sql文件中一次执行在mysql中执行

  ￥sql语句的分类
    1:DDL:数据定义指令
         CREATE/DROP/ALTER/TUNCATE
    2:DML:数据操作指令
         INSERT/UPDATE/DELETE
    3:DQL:数据查询指令
         SELECT
    4:DCL:权限指令
        GRANT/REVOKE
    熟练掌握:
        [CREATE/INSERT/UPDATE/DELETE/SELECT]
</code></pre><p>  4、 #CREATE 指令功能创建(库)创建表</p>
<pre><code>指令格式:
      CREATE DATABASE 库名;(库)
建议:(库名/表名/列名)
     :英文不要数字或特殊字符开头
     :中文空格不要
    test01    ok
    2017test  error
    test 02   error
    大旭之家  error
</code></pre><p> 5、 #CREATE 指令功能创建表</p>
<pre><code>a:列数据类型(常用列类型)
     int      整型(年龄) 范围-21亿~21亿
      varchar(10)   字符串(10个字符[数字，字母，汉字])
      double(10,2)  浮点(小数)总长10位其中2位小数
      datetime      日期和时间
 分析表:商品表
     1:商品编号     int   1 2 3 5
     2:商品名称     varchar(20)
     3:商品上架时间 datetime
     4:商品价格     double(10,2)

b:创建表语法
 CREATE TABLE 表名(
     列名1 列类型,
     列名2 列类型,
     列名3 列类型
     );
 c:指令 use 库名称;
 d:查看表是否创建成功
     SHOW TABLES;
     use test001;
     CREATE TABLE t_product(id INT,name VARCHAR(20),ctime DATETIME,price DOUBLE(10,2));
     SHOW TABLES;
</code></pre><p>6、小结上午重点</p>
<pre><code>1:创建库
  CREATE DATABASE 库名; 创建库
  SHOW DATABASES;       查询库是否创建成功
2:创建表
  USE 库名;
  CREATE TABLE 表名(
     列名 列类型(int/varchar/double/datetime)
    );
  SHOW TABLES;
</code></pre><p>7、向数据库中添加记录(行)</p>
<pre><code>a:标准语法
a.1:向所有列添加数据
INSERT INTO 表名 VALUES(列值1,列值2,列值3,.);
INSERT INTO t_stu VALUES(1,&apos;wsl001&apos;,&apos;xuxu&apos;,19);
INSERT INTO t_class VALUES(1,&apos;WEB&apos;,100);
验证:
SELECT * FROM t_stu;
 #字符串类型列加单引号
 #小心中文/(英文)单引号
 #小心日期写法
 #SQL指令结束使用分号
a.2:向部分列添加数据
INSERT INTO 表名(列名1，列名2)VALUES(列值1,列值2,..);
INSERT INTO t_stu(id,no)VALUES(4,&apos;tao&apos;);

a.3:日期类型 &apos;2017-04-12&apos; 字符串
  now()        函数(当前日期时间)
INSERT INTO t_product VALUES(10,&apos;book&apos;,&apos;2010-10-10&apos;,100.99);
INSERT INTO t_product VALUES(20,&apos;js&apos;,&apos;2017-04-12&apos;,99);
INSERT INTO t_product VALUES(30,&apos;css&apos;,now(),98);
</code></pre><p> 8、删除记录(行)</p>
<pre><code>#标准语法:
条件: = &lt; &gt; &lt;= != &lt;&gt;
DELETE FROM 表名 WHERE 条件;
  示例:
  DELETE FROM t_product id = 10;   //ok
  DELETE FROM t_product price = 100.99;
  DELETE FROM t_product name = &apos;book&apos;;
</code></pre><p> 9、 更新记录(行)</p>
<pre><code>#标准语法
UPDATE 表名 SET  列名1=新值1
,列名2=新值2 ..
WHERE 条件;
UPDATE t_stu SET age = 16,name=&apos;daxu&apos;WHERE id = 1;
</code></pre><p>10、 查询记录(行)</p>
<pre><code>  语法:SELECT 列名1,列名2,...
    FROM 表名
    WHERE 条件
    ORDER BY 列名1 #排序

SELECT * FROM 表名;  # *所有列
SELECT id,name FROM t_emp;
SELECT sal FROM t_emp;
SELECT * FROM t_emp;
SELECT id,name,sal,sal*1.2 FROM t_emp;
</code></pre><p>  11、 小结SQL:</p>
<pre><code>a:分类
  DDL:数据定义语句
    CREATE/DROP
    DML:数据操作语句
    DELETE/UPDATE/INSERT
    DQL:数据查询语句
    SELECT
    DCL:
b:常用SQL
  CREATE DATABASE 库名;    创建库
SHOW DATABASES;          查询库名
CREATE TABLE 表名(
      列名1 列类型,
        ....
    );
列类型(INT/VARCHAR(10)/DOUBLE(10,2)/DATETIME)

USE 库名;    进入指定库中
SHOW TABLES; 查询表名
INSERT INTO 表名VALUES(值1,值2,,...);
INSERT INTO 表名(列1,列2)VALUES(值1);
字符串值:&apos;&apos;
日期值  :&apos;&apos; now()
DELETE FROM 表名 WHERE 条件;
UPDATE 表名 SET 列名=新值1,列名=新值2
WHERE 条件;
SELECT * FROM 表名;#*所有列
SELECT id,name FROM 表名;
ORDER BY 列名;
ORDER BY 列名 DESC;
count(列)/sum(列)/max(列)/min(列)/avg(列)
子查询
</code></pre><p>  12、 面试题:如何自学一门新的编程语言</p>
<pre><code>1)了解背景，历史，现状，发展，特点，应用领域
2)建设环境=写出HelloWorld
3)数据类型
4)变量常量
5)运算符
6)逻辑结构
7)通用小程序
8)函数,对象
9)常用函数库，类库，中间件，框架
10)实用项目

   #php 背景特点
     php是一种运行在服务器端(apache)的编程序言,用于
     生成动态网页内容.

   2000,Zend公司成立，维护php语言.发布php解释器环境
     php特点:开源，简单，(易上手),
      跨平台(windows/linux),占用资源少
      尤其适合中小型web应用开发
      (微博/微信/论坛)...

   #搭建软件环境
    1:服务器端环境创建:下载选择web服务器
          apache/Microsoft IIS/Nginx
            c:/xampp/apache/
    2:服务器端:下载并且安装php解析软件
          c:/xampp/php/php.exe
    3:服务器端:编写并保存php程序保存哪里
      c:/xampp/htdocs/1.php
    4:服务器端:启动web服务器
          [start]
    5:客户端:打开浏览器/直接输入服务器程序地址按回车
        http://127.0.0.1/1.php
</code></pre><p>13、php语法              必须掌握</p>
<pre><code>a:程序位置 c:/xampp/htdocs/??
b:创建程序 后缀.php  1.php 2.php
c:代码
    &lt;?php
    ?&gt;
d:声明一个变量
     $变量名 = 值;
    $name = &quot;tom&quot;;
e:访问程序{浏览器}
      http://127.0.0.1/1.php  回车
f:一个php程序由html/css/js/php 代码混合写
</code></pre><p>  14、 php 数据类型</p>
<pre><code>1:值类型/标量类型
    string        字符串类 &quot;&quot;
    boolean/bool  true/false
    int/integer
    float/double
2:复合类型
    object php面向对象2005年之后才出现
    array  php索引/关联数组
3:特殊类型
    null/NULL
    resource 资源:数据库连接，查询结果
4.php 练习数据类型
5.php 练习数组
6.php 综合示例
</code></pre><p>15、使用php操作数据库    重点&amp;难点</p>
<pre><code>?数据库乱码问题处理
原因:脚本文件格式不正确
解决：保存脚本文件 utf-8

php中操作mysql数据库函数
1:php官方最初提供一套连接mysql函数:mysql_xxx();
2:php官方提供增强版mysql函数:      mysqli_xxx();
</code></pre><p>16、 使用php操作mysql服务器步骤</p>
<pre><code>1:创建到mysql服务器连接
  $conn = mysqli_connect(...);
    1:数据库服务器地址ip 127.0.0.1
    2:数据库用户名       root
    3:数据库密码
    4:选库               dangdang
2:向mysql服务器发送sql指令,
  等待服务器执行
    $sql = &quot;....&quot;;//insert/delete/update
    $result = mysqli_query($conn,$sql);
3:读取mysql服务器返回结果
  if($result===false)
4:断开与mysql服务器连接--可以省略
  mysqli_close($conn);
</code></pre><p> 17、 小结:</p>
<pre><code>1:php语法
  $age = 10;
  $stop = &quot;tom $age&quot;;
  $run = &apos;tom&apos;.$age;
2:php数组
  $arr = [1,2,3,4];
  $arr[] = 5;
  $arr = [&quot;name&quot;=&gt;&quot;tom&quot;,&quot;age&quot;=&gt;10];
  foreach($arr as $k=&gt;$v){...}
3:php连接mysql
  a:创建连接
    $conn = mysqli_connect(数据库ip,数据库用户名,密码,库);
    $sql = &quot;SET NAMES UTF8&quot;;
    mysqli_query($conn,$sql);
    b:发送sql
    $sql = &quot;INSERT INTO dd_book VALUES(null,&apos;d&apos;)&quot;;
    $result = mysqli_query($conn,$sql);
    c:判断结果
    if($result === false)

  1:连接数据库
    $conn = mysqli_connect(&quot;127.0.0.1&quot;,&quot;root&quot;,&quot;&quot;,&quot;dangdang&quot;);
    $sql = &quot;SET NAMES utf8&quot;;
    mysqli_query($conn,$sql);
  2:发送sql语句
    $sql = &quot;INSERT INTO 表名....&quot;;
    $result = mysqli_query($conn,$sql);
  3:获取判断返回结果
    if($result===false)
   4:关闭连接
    mysqli_close($conn);
   小结：
      1：发送sql
         解决:在mysql命令输入sql--&gt;copy
              如果列是字符串类型一定 &apos;&apos;
            如果列是整型不用加&apos;&apos;
     2: 表单获取参数
        html: &lt;input type=&quot;text&quot; name=&quot;uid&quot;
        php :  $uid = $_REQUEST[&apos;uid&apos;]
    3:问题{乱码/set names 作用}
      乱码:?????
        解决:
        a:顺序:
          1:news.sql 按照utf-8保存
            2:set names utf8;
              source 不加分号
        b:指令:
          1:SET NAMES UTF-8;
          2:创建库编码指定错误
              CREATE DATABASE bbs CHARSET=UTF8;
        C:1.php
          SET NAMES UTF8;
</code></pre><p>18、学习总结上周重点</p>
<pre><code>1.1:mysql
      数据库软件:
       海量存储永久数据
       快速查询
    SQL:结构化查询语言(操作数据库)
      DDL:DROP/CREATE (DATABASE/TABLE)
      DML:INSERT/UPDATE/DELETE
      DQL:SELECT
      DCL:
      SET NAMES UTF8; 设置SQL编码
      SHOW TABLES;    查询当前库表名
      SHOW DATABASES; 查询当前MYSQL库名
      ..
1.2:php
  后台语言:运行在(服务器 apache)
      &lt;?php
      ?&gt;
      $age = 10;
      $str = &apos;hello php&apos;;
      $str = &quot;hello $age php&quot;;
      php mysql
      a:INSERT/UPDATE/DELETE
        1:连接数据库
          $conn = mysqli_connect(&quot;127.0.0.1&quot;,&apos;root&apos;,&apos;&apos;,&apos;dangdang&apos;);
        2:发送sql
              $sql = &quot;INSERT/UPDATE/DELETE&quot;;
          $result = mysqli_query($conn,$sql);
        3:if($result===true){
          执行成功
           }
      b:SELECT
        1:连接数据库
          $conn = mysqli_connect(&quot;127.0.0.1&quot;,&quot;root&quot;,&quot;&quot;,&quot;dangdang&quot;);
        2:发送sql
          $sql = &quot;SELECT ...&quot;;
          $result = mysqli_query($conn,$sql);
        3:返回结果集对象
        4:抓取
          $row = mysqli_fetch_row($result); 索引
          $row = mysqli_fetch_assoc($result);关联
</code></pre><p>19、 php常用函数</p>
<pre><code>1:#die($str); 终止当前php文件执行,
      并且向客户输出一个终止原因说明.
2:#@ 压制住当前行代码警告消息.
3:#time() 返回当前系统时间,以秒为单位整数
4:#$id = mysqli_insert_id($conn);
  返回连接上刚刚执行insert语句产生id值
  CREATE TABLE t_user(
      id INT PRIMARY KEY AUTO_INCREMENT,
   );
  INSERT INTO t_user VALUES(null,);
5:#$count = mysqli_affected_rows($conn)
  返回刚刚连接上执行增删改语句影响行数
6:$rows = mysql_fetch_all($result,MYSQLI_ASSOC);
  从结果集对象中抓取所有记录,返回二维数组;
</code></pre><p>20、 http协议(零碎.没有太多相关性)重点&amp;难点</p>
<pre><code>1:学习http协议目标
    1:调试AJAX应用&quot;看不见摸不着&quot;的错误
    2:进行web访问优化---高阶面试题
    2.3.1.1:URL
        统一资源定位符:
    互联网任何资源都有一个URL才能被访问
    http://www.baidu.com  网站
    https://www.baidu.com/img/bd_logo1.png 图片
    http://127.0.0.1/01.php

    a:scheme:方案 指定以哪种协议从服务器获取指定资源
    常见方案:http/https/ftp/mailto/file/telnet....
    http:获取网络资源{明文}
    https:获取网络资源{加密}
    http://www.ccb.com/cn        建行
    https://ibsbjstar.ccb.com.cn 建行登录

    b:host 主机名:资源在服务器ip地址或者域名
        http://127.0.0.1      ip地址
        http://www.baidu.com  域名(DNS 域名-&gt;ip)
        http://tmooc.cn       域名

    c:port 端口号*****(面试题)
        每一项网络服务在服务器都对应一个端口号
        ftp    21  文件上传下载
        ssh    22  安全远程登录
        telnet 23  远程登录
        smtp   25  邮件传输发送
        dns    53  域名解析
        http   80  超文本传输***(apache)
        pop3   110 邮件接收
        https  443 加密传输

    d:path
        http://127.0.0.1/ajaxday03/01.php
         e:?&lt;query&gt;
        http://127.0.0.1/ajaxday03/01.php?id=10&amp;age=10
        $id = $_REQUEST[&apos;id&apos;];
        $age = $_REQUEST[&apos;age&apos;];

      #分清一个概念:URL/URN/URI(了解)
        URL:统一资源定位符
        URN:统一资源命名符
        URI:统一资源标示符
        URI图.jpg
        URI==URL+URN
        URL:&lt;a href=&quot;login.html&quot;&gt;....&lt;/a&gt;
            &lt;img src=&quot;http://tmoo.cn/logo.jpg&quot;&gt;....&lt;/a&gt;
        URN:
           &lt;a href=&quot;mailto:admin@tmooc.cn&quot;&gt;..&lt;/a&gt;
           &lt;a href=&quot;javascript:void(0)&quot;&gt;..&lt;/a&gt;

 21、http协议概述

        作用:传输网页
        协议标准:生活标准(手机: 3g 4g 5g)
                 USB(2.0 3.0)
        国际互联网任务组(IETF)制定http协议标准
        1991: http/0.9 有严重缺陷
        1996: http/1.0 正式版本
        1999: http/1.1 当前主流版本(***)

    面试题:
    http/1.1比http/1.0改进哪些地方?
        http协议工作原理方式:请求和响应
        1:客户端浏览器发送请求 (google-&gt;apache)
        2:服务器响应请求并且返回数据
                               (apache-&gt;google)
     解答问题:
        1:支持虚拟主机技术，在一个web服务器上
          同时并存多个不同域名的网站
            个人博客:500w(128 CPU 1T 2000块)
            3网页 index.html photo.html review.html
            20/年
            d:/tmooc    www.tmooc.cn  50w
            e:/tts      www.tts.cn    50w
            ...10
            http: Host:tmooc.cn 虚拟主机域名
        2:支持持久连接技术
          不支持持久边接技术情况
            (每次客户端与服务器数据传输)
            固定流程 101(300握 400挥)
            三次握手 3--&gt;1--&gt;4
            四次握手
            http: keep-alive  (3)--101--(4)
        3:支持代理连接
            Proxy:xxx


22、 http协议规定两种消息格式:

     请求(Request) --客户端浏览器发送web服务器
     响应(Response)--web服务器发送客户端浏览器
     Message:消息/报文,是在http客户端和服务器传递数据块
     http协议规定,消息必须符合特定格式才能版此理解..
     消息内容 &quot;思维导图&quot;
</code></pre><p>23、http协议-(响应)</p>
<pre><code>http:作用传输网页
http:工作方式 请求与响应
请求消息:
 请求方式:{GET/POST/PUT/DELETE/HEAD/CONNECT/TRACE/OPTIONS}
响应消息:
 响应状态码:
 100-199 提示消息
 200-299 响应成功   200
 300-399 重定向     304
 400-499 客户端请求错误 404
 500-599 服务器错误  500
 响应主体类型:
 text/plain
 text/html
 text/css
 application/javascript
 application/json

 1：面试题:GET/POST区别?
    a:语义
        GET:客户端获取服务器上资源
        POST:客户端将数据提交服务器
    b:安全级别
        GET:不安全
        POST:不安全 {https}
    c:数据长度
        GET:通过浏览器地址栏 请求请起启 1KB   汉字20-30
        POST:通过http响应主体 长度没限制
    d:编码
        GET:不会自动编码-&gt;可能出现中文乱码
        POST:自动编码----&gt;不会中文乱码
    e:如何发起
        GET:
        1:浏览器地址栏输入地址回车
        2:标签href  &lt;a&gt;   点击发GET
            src   &lt;img&gt; 自动发GET
            css   like  自动发GET
            script src  自动发GET
        3:js自动跳转
            location.href = &quot;1.html&quot;;
        4:表单
            &lt;form method=&quot;get&quot; action=&quot;&quot;&gt;
            &lt;form action=&quot;1.ph&quot;&gt;
        5:ajax GET
            POST:
            1:表单
            &lt;form action=&quot;&quot; method=&quot;post&quot;&gt;
            2:ajax post

  2：面试题:如何使用http协议相关知识进行web优化
    提示:web访问可以很多方面考虑:
        :优化数据库
        :优化php
        :优化web服务器(apache/nginx)
        :网速
        :传输数据
        :浏览器解析速度(html/css/js)
    下面仅从http请求和响应角度考虑
         1:域名解析
           尽可能减少域名解析次数--减少跨站外
             资源引用.
             DNS(www.tmmoc.cn-&gt;120.132.68.230)
             tmooc.com
             http://www.tmooc.cn/index.html
             index.html
             &lt;img src=&quot;www.tmooc.cn/1.jpg&quot;&gt;
             &lt;script src=&quot;www.tmooc.cn/1.js&quot;&gt;&lt;/script&gt;
         2:创建连接
           努力减少连接创建次数-Connection:keep-alive
             启用持久连接
         3:减少发送请求次数
           尽量减少请求次数--合理进行资源合并，
             合理使用缓存.
         4:等待响应时间
           提交服务器运行速度-提高数据运算及查询速度
         5:接收响应
           尽可能减少响应数据长度--删除空白字符，启压缩
        http://tool.oschina.net/jscompress/
</code></pre><p>24、 ajax    重点&amp;难点 9</p>
<pre><code>a:快速入门
  ajax:异步javascript and xml
    google 推出技术--&gt;酷
    生活场景:ajax 微信餐厅
    最大不同:(发送请求和接收数据都由js完成)

b:原理细节知识
  *功能:添加新用户 msg/t_user(uname,upwd)
     *1:创建add_user.php
    a:获取参数uname,upwd
    b:创建sql insert 发送sql
    c:输出结果添加成功或失败
     *2:创建add_user_input.html
    a:创建表单(uname,upwd)
    b:在表单&lt;input type=&quot;button&quot; value=&quot;新建用户&quot;/&gt;
    c:为button按钮绑定点击事件
    c.1:获取用户名和密码
    d:通过ajax发送请求并且接收服务器
    输出一句话&quot;添加成功&quot;&quot;添加失败&quot;
    以下ajax代码固定js
    1:创建ajax对象
      var xhr = new XMLHttpRequest();
    2:绑定事件
      xhr.onreadystatechange = function(){}
    3:打开连接(连接php程序)
      xhr.open(&apos;GET&apos;,&apos;add_user.php&apos;,true);
    4:发送请求
      xhr.send(null);
</code></pre><p>25、 ajax请求并且接收响应4步</p>
<pre><code>1:创建ajax对象
  var xhr = new XMLHttpRequest();
2:绑定事件:监听xhr对象状态
  xhr.onreadystatechange = function(){
    }
3:连接web服务器php程序
  xhr.open(请求方式,请求地址,是否异步);
    xhr.open(&apos;GET&apos;,&apos;add_user.php?&apos;,true);
4:发送请求消息
  xhr.send(null);
</code></pre><p>26、 ajax原理</p>
<pre><code>a:2002年由Google搜索引擎，提示建议
    AJAX=HTML/CSS/JS/DOM/XML/HTTP
b:ajax作用:
    实现在&apos;无刷新&apos;&apos;无提交&apos;&apos;无跳转&apos;的情况下完成页面局部更新.
c:ajax应用场景
    常见场合:聊天室，在线走势图,搜索建议..
d:ajax 异步javascript and XML 异步:
    1:ajax异步请求:XHR
    2:    同步请求:
    1.1:地址栏输入地址回车
    1.2:表单 submit
    1.3:&lt;a href=&quot;1.php&quot;&gt;
    1.4:&lt;img src=&quot;1.jpg&quot;&gt;
    1.5:location.href = &apos;1.php&apos;
</code></pre><p>27、 ajax常用对象和属性事件方法</p>
<pre><code>1:xhr对象:作用，向web服务器发送请求,并接收返回响应消息.
  var xhr = new XMLHttpRequest();
#注意:产品兼容性
#老IE IE8- 不支持xhr
  new ActiveXObject(&quot;Microsoft.XMLHTTP&quot;);
#兼容性写法
  var xhr = null;
  if(window.XMLHttpRequest){
  xhr = new XMLHttpRequest();
  }else{
      xhr = new ActiveXObject(&quot;Microsoft.XMLHTTP&quot;);
  }
  alert(xhr);
2:xhr对象常用属性*****
  2.1:readyState xhr对象当前状态
    不能手工赋值，可以取值其值会随着(请求-响应)过程进行自动改变
    0 UNSENT  请求消息沿未发送
    1 OPENED  XHR己经打开web服务器连接
    2 HEADERS_RECEVIED xhr己经接收服务器响应消息头部
    3 LOADING XHR正在加载响应消息主体
    4 DONE    XHR接收完成响应消息主体

   2.2:xhr.readyState状态改变
    0 UNSEND  xhr.open();
    1 OPENED  xhr.send();
    2 HREADERS_RECEIVED   自然(不能控制)
    3 LOADING            自然(不能控制)
    4 DONE

  2.3:status
  2.4:statusText
  2.5:responseText
</code></pre><p>28、 ajax 原理与ajax接收不同类型数据</p>
<pre><code>a:核心 XMLHttpRequest    -创建对象
   var xhr = null;
   if(window.XMLHttpRequest){
       xhr = new XMLHttpRequest();
   }else{
       xhr = new ActiveXObject(&quot;Microsoft.XMLHTTP&quot;);
   }
b:xhr属性、方法、事件
  b.1:xhr.readyState 表示xhr状态
   0 未发送      UNSENT
   1 打开连接    OPENED
   2 己经接收服务器返回头信息
          HEADERS_RECEIVED
   3 接收服务器数据
          LOADING
   4 接收完成
          DONE
  B.2:status    表示服务器返回状态码===200
  B.3:responseText 表示服务器响应文本
  B.4:responseXML  表示服务器响应XML文本
    方法:
  B.5:open(method,url.isAsyn)
       表示:打开到服务器连接
       method:请求方式 GET POST
       url:   请求url地址(程序地址)
       isAsyn:请求方式是异步true   同步false
  B.6:send(data)
      表示:把请求消息发送web服务器
          data:请求消息主体内容
      GET--&gt;内容为null
      send(null);
      POST--&gt;请求数据放在里面
      send(&apos;id=10&amp;name=tom&amp;age=19&apos;);
            事件:onreadystatechange
      xhr.readyState每次改变时候触发
        事件0 1 2 3 4
</code></pre><p>29、 AJAX POST 标准语法</p>
<pre><code>1:创建ajax对象 xhr
2:绑定事件     xhr.onreadystatechange
3:打开连接
xhr.open(&apos;POST&apos;,&apos;book_add.php&apos;,true);
3.1:修改请求头信息(将参数编码)
xhr.setRequestHeader(&apos;Content-Type&apos;,&apos;application/x-www-form-urlencoded&apos;);
4:xhr.send(`id=10&amp;name=tom&amp;age=19`);

如果ajax输出
    1:创建php     地址栏输入回车
      http://127.0.0.1/ajaxday06/dangdang/book_add.php?name=1&amp;pic=2.jpg&amp;price=100&amp;pubDate=2010-10-10
    2:创建html/js
      console.log(&quot;1&quot;+变量);
    3:F12/network

  5.0 text/plain     纯文本
        php第一行
            header(&quot;Content-Type:text/plain&quot;);
            html-&gt;ajax
            xhr.responseText
  5.1 text/html      (默认)
        php第一行
        header(&quot;Content-Type:text/html;charset=utf-8&quot;);
        html-&gt;ajax
        xhr.responseText;
  5.2 javascript
        php第一行
        header(&quot;Content-Type:application/javascript;charset=utf-8&quot;);
        echo &quot;var msg=&apos;hello&apos;;alert(msg)&quot;;
      html-&gt;ajax
        eval(xhr.responseText);
        示例:国际化
        当前浏览器 zh-CN  你好
               en-US   hello
      a:编写php i18n.php
        读取客户端请求头部信息
        Accept-Language 截最后二个字符
            CN  你好
        US  hello
       b:i18n.html
     ajax 发送请求--&gt;获取服务器返回信息
    alert();
  5.3 xml       ---- 很少(代码复杂)
  5.4 json      ---- 重点&amp;难点
</code></pre><p>30、 JSON 语法</p>
<pre><code> 1:标准语法 json 要求
   1:一个JSON字符串有且只有一个根，
   可以是{}表示一个对象
       []表示一个数组
    员工信息 {&quot;name&quot;:&quot;tom&quot;,&quot;age&quot;:19}
    一组整型 [10,20,90,100]
    一组员工信息
    [
     {&quot;name&quot;:&quot;jerry&quot;,&quot;age&quot;:21},
     {&quot;name&quot;:&quot;james&quot;,&quot;age&quot;:22},
     {&quot;name&quot;:&quot;gogo&quot;,&quot;age&quot;:19}
    ]
    错误json
    {&quot;name&quot;:&quot;tom1&quot;}
    {&quot;name&quot;:&quot;tom2&quot;}
    {&quot;name&quot;:&quot;tom3&quot;}
2:JSON中可以表示，数字，bool,null,字符串
   注意:字符串必须用双引号
3:数组中可以包含多个值，使用逗号分隔
4:对象中可以包含多个键值，使用逗号分隔
  不同值，键和值之间用分号分隔,键必须是双引号.
</code></pre><p>31、 如何处理JSON数据:</p>
<pre><code>1:服务器端php
  1.1:header(&quot;Content-Type:application/json;charset=utf-8&quot;);
  1.2:$str = json_encode($arr);
  1.3:echo $str;
2:javascript 接收
  var obj = JSON.parse(xhr.responseText);
    obj--&gt;js数组   obj--&gt;js对象

 #JSON字符串格式概述
   XML是字符串数据格式，用于描述数据，
稍微有点麻烦--重量级数据格式.
10字节-&gt;XML--&gt;50字节
JSON是字符串数据格式，用于描述数据,
更加简单--轻量级数据格式.
10字节-&gt;JSON-&gt;22字节

 JSON(JavaScript Object Natation)
是一种轻量级数据交换格式,
易于编写，同时易于程序解析生成
.语法基于JS语言.但是目前被各种语句
所支持.成为一种&quot;异构系统交互数据
标准格式&quot;;
JAVA---- {JSON}   html/js/css
C#------ {JSON}   html/js/css
php----- {JSON}   html/js/css
</code></pre><p>32、ajax处理xml数据格式 – 了解</p>
<pre><code>xml:
html:超文本标记语言，所有标签都是预定义好的，
     用于描述一个网页结构.
xml:可扩展的标签语言，所有的标签都是自定义的
    用于描述一段数据--尤其是批量复合数据.

xml语法要求:
1:xml文档声明
  &lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
2:整篇xml字符串有且只能一个根元素
  &lt;booklist&gt;
    &lt;book&gt;&lt;/book&gt;
    &lt;book&gt;&lt;/book&gt;
    &lt;/booklist&gt;
3:标签有开始必须有结束
  &lt;book&gt;&lt;/book&gt;
4:标签可能嵌套不能交叉
  &lt;book&gt;&lt;name&gt;&lt;/name&gt;&lt;/book&gt;  ok
    &lt;book&gt;&lt;name&gt;&lt;id&gt;&lt;/name&gt;&lt;/id&gt;&lt;/book&gt;
5:标签所有属性&apos;值&apos;必须用双引号括起来
  &lt;book id=&quot;1&quot; name=&quot;tom&quot;&gt;&lt;/book&gt;
总结:xml和html用途不同，xml语法严格

32、 jquery 常用ajax函数

    a:$.get(url,callback);--简单
    作用含义:
         发起一个ajax的GET请求,如果服务器返回成功
         响应消息，调用callback函数,
         在方法中处理响应的数据
        callback  function(data){}
    b:$.post(url,data,callback);
    作用:
         发起一个ajax POST请求，并在请求主体中
         提交请求数据，如果服务器返回成功响应
         消息，调用callback，在cllback方法中
         处理响应数据.
      使用方法三种:
        a:$.post(url,data,callback);
        b:$.post(url,&apos;id=1&amp;name=tom&apos;,callback);
        c:$.post(url,{id:1,name:tom},callback);
        d:$.getJSON(url,callback);
        e:$.load(url);
        f:$.getScript(url,callback);
        g:$.ajax({})--功能最全最强
            万能AJAX封装函数，提供非常多的可选项,
            可以处理各种情形，前面函数都是它的
            简化版.
      $.ajax({
         type:&apos;GET&apos;      //请求方式post/pub/delete/head
         url:&quot;x.php&quot;     //请求地址
         data:&apos;k=v&amp;k1=v1&apos;//请求服务器数据
         beforeSend:fn   //请求消息发送之前调用fn
         success:fn      //响应完成并且成功调用fn
         error:fn        //响应完成但有问题调用fn
         complete:fn     //响应完成回调(无论成败)fn
    });
</code></pre><p>  33、 #ajax注意</p>
<pre><code>对于异步请求成功后创建DOM元素,
不能进行直接事件绑定! click()/bind().
因为在执行此事件绑定时，这些元素在DOM
还不存在。
必须将相关事件委托给DOM树上己经存在父元素!
</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt; 1、如何从数据库中将数据表中数据抓取出来并且显示.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;解决方法:语言php 负责从数据库中抓取数据并且显示给用户.
  a:什么是服务器
    能够在网站中提供各种(浏览网页,收发邮件
    视频,语言)等服务器的软件与硬件集合。
    
    
    </summary>
    
      <category term="学习笔记" scheme="www.wangchengzou.cn/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="ajax" scheme="www.wangchengzou.cn/tags/ajax/"/>
    
      <category term="php" scheme="www.wangchengzou.cn/tags/php/"/>
    
  </entry>
  
  <entry>
    <title>Ionic基础知识</title>
    <link href="www.wangchengzou.cn/2017/07/22/Ionic/"/>
    <id>www.wangchengzou.cn/2017/07/22/Ionic/</id>
    <published>2017-07-22T15:48:26.000Z</published>
    <updated>2017-07-23T15:53:37.919Z</updated>
    
    <content type="html"><![CDATA[<p>一、当前移动端开发的整体趋势</p>
<pre><code>三种趋势
WebApp:通过前端技术来实现的接近传统应用程序体验的app
NativeApp:通过（Google或者Apple）SDK（software development kit 软件开发包）提供的原生的组件和服务，编写的app称之为原生应用
HybridApp：通过前端技术与原生技术混合编程所生成的app称为hybirdApp

学习WebApp以及HybridApp。

将3中开发模式对比，hybridApp是非常有潜力的，可以实现原生应用程序的功能，支持上传到应用市场，让用户去下载 去使用

前端+原生
想要创建ios的应用程序，开发工具：xcode（apple）,模拟器需要在MacOSX
想要创建Android的应用程序，开发工具：eclipse/AndroidStudio,模拟器是可以运行PC、MacOSX、Linux
</code></pre><p>二、第一个Android应用程序–搭建Android的开发环境</p>
<pre><code>采用的开发语言：java

使用Goolge公司所提供的SDK，java

①安装jdk
    java development kit java开发工具箱
②安装eclipse
③安装sdk
    http://www.androiddevtools.cn/
    ①、下载jdk 直接安装
    ②、下载ADT bundle（集成了eclipse、sdk）
</code></pre><p>三、使用Eclipse创建第一个AndroidApp</p>
<pre><code>操作注意事项：
    工具条--》window--》show/hide toolbar 显示隐藏工具条
    工具条--》window--》reset perspective 恢复默认视图
    工具条--》window--》preferences-&gt;genaeral-&gt;apperance-&gt;color and fonts-&gt;basic-&gt; text font-&gt;edit

    sdk manager：更新SDK
    Android Virtual Device Manager:管理模拟器的创建、编辑、删除
    创建模拟器：1、testPhone 2、选中4寸的设备 3、给SD卡指定大小
    start-》launch

创建Android项目
file-&gt;new -&gt;Android Application Project-&gt;配置应用名称以及包的名称-》配置icon，finish完成Android工程的创建

运行Android项目
选中项目，点击右键，run as-&gt;Android Application Project

对于AndroidApp来说，添加权限，基本步骤：
①找到工程中根目录下的AndroidManefiest.xml文件
②打开，选中选项卡permissions
③点击add，在弹窗中选中uses permission
④在右侧的下拉菜单中选中需要用到的权限，保存即可

Android工程所对应的目录功能：
src(source) 源代码，java文件的修改
gen 自动生成的文件夹 R.java非常关键的文件，可以通过R这个类找到android工程中所有的资源文件
Android* 是google所提供的sdk文件
assets 不希望被处理的文件放在该文件夹(在将工程代码打包成可执行文件的，多数文件都会被处理)
bin 运行工程（编译、链接）时所生成的可执行文件(apk)
libs(libraries) 库文件：使用第三方的包
res（resource） 资源文件：图片、布局文件、变量
AndroidManifest.xml： 版本号、权限、图标的配置、应用的配置。。。
</code></pre><p>四、第一个hybridApp  – webView</p>
<pre><code>1、基本步骤：
①按照功能和要求 把前端代码编写完毕
②将前端代码 放到 Android工程的assets目录
③创建一个WebView（网页视图组件），配置webView加载指定的html页面
④将webView作为一个app的内容视图展现出来
⑤运行，最终是生成了安装包

2、练习：（15:40 - 15：55）
创建一个混合编程app，有一个p、有一个按钮，点击按钮将段落隐藏。
要求：创建一个新的Android。
问题：判断变量、数据，通过console.log控制台打印出来，确认是不是要的数据。
解决：借助于webview的setWebChromeClient

3、混合编程的常见的两种方式
①直接将在pc端测试好的前端代码 全部拷贝到 android工程，打包生成一个app
②将测试号的代码直接部署在服务器端， 让webview去加载指定的服务器的地址，加上网络权限


练习：将开饭啦项目部署在服务器端（本地的服务器 apache mysql），然后通过webview加载，生成app
http://localhost/chaptor4_code/angularjs/kfl/kaifanle.html
localhost替换成当前pc的真实的ip地址：windows+R-&gt;cmd-&gt;ipconfig 查看ipv4的地址
http://172.163.100.53/chaptor4_code/angularjs/kfl/kaifanle.html
注意事项：①加上网络权限 ②允许执行js

技巧：
①timeout 超时
    只需要将eclipse和模拟器关掉再打开
②ActivityManager: Warning: Activity not started, its current task has been brought to the front
    没有对原有的项目做任何的修改，又去重复去运行，会提示该警告
③android library projects can&apos;t be launched
    创建Android工程，把工程标记为了一个库项目，只能重新新建工程
ADB：Android Debug Bridge 建立起PC端和移动端的桥梁。

如何完成Android工程的创建、运行基本流程以及工作方式
学习HybridApp的创建和运行

扩展1：
js调用原生组件：
①创建一个接口类的文件
②activity配置使用接口
③在js中调用java中的一些接口

扩展2：
js调用原生组件：
①创建一个接口类的文件
    @JavascriptInterface

②activity配置使用接口
 wv.addJavascriptInterface(
new webInterfac(getApplicationContext()),&quot;android&quot;);

③在js中调用java中的一些接口
function callShowToast(){
    android.showToast();
  }
</code></pre><p>五、Ionic概述</p>
<pre><code>移动端app的开发有很多实现方案，原生、现成的框架（ionic、jQueryMobile）
Ionic是一个强大的h5的混合编程app开发框架
Ionic集成了ng、cordova、一套非常漂亮的移动的ui库
注意事项：Ionic放弃了iOS6、Android4.1以下版本的支持
特点：
    ①完美融合了ng
    ②集成了cordova，能够通过前端代码调用智能设备的底层硬件
    ③设计风格好
    ④性能优越，运行速度块
    Ionic = ng + cordova + 移动ui库
</code></pre><p>六、搭建Ionic的开发环境</p>
<pre><code>1、方式1 （命令行）
http://ionicframework.com/getting-started/
①npm install -g cordova ionic
    全局安装cordova以及ionic
②ionic start myApp tabs/sidemenu
    创建一个基于ionic的项目myApp，类型为tabs、sideMenu
③ionic serve
2、方式2：借助于官方所提供的js、css文件
</code></pre><p>七、学习Ionic样式类</p>
<pre><code>1、color
    9个常用的值 ，参考手册中最后一个color的介绍

2、button按钮
    button/button-small/button-large/button-outline/
    button-clear/buttn-block/icon-left/icon-right/
    ion-***/button-bar

3、list 列表
    list/item/item-icon-left/item-icon-right/list-inset(嵌入效果)/
    item-divider(分隔符)/badge(badge-assertive)
    item-avator/item-thumbnail-left/right

4、card 卡片式

5、form 表单
    list/item/item-input/input-label/item-stacked-label/item-floating-label
    item-toggle(ionToggle)/item-select/ionCheckbox /ionRadio

6、grid
    row/col
    col-10/20/50..(指定列的宽度)
    .col-10    10%
    .col-20    20%
    .col-25    25%
    .col-33    33.3333%
    .col-50    50%
    .col-67    66.6666%
    .col-75    75%
    .col-80    80%
    .col-90    90%(设置列与列之间的offset)

    .col-offset-10    10%
    .col-offset-20    20%
    .col-offset-25    25%
    .col-offset-33    33.3333%
    .col-offset-50    50%
    .col-offset-67    66.6666%
    .col-offset-75    75%
    .col-offset-80    80%
    .col-offset-90    90%
    col-center/col-top/col-bottom
</code></pre><p>八、IonRefresher 下拉刷新</p>
<pre><code>①指定下拉刷新的处理函数
on-refresh
②处理完之后，结束刷新动作
$scope.$broadcast(&apos;scroll.refreshComplete&apos;);
③ionContent第一个子元素
</code></pre><p>九、IonInfiniteScroll 无限滚动（上拉加载更多）</p>
<pre><code>①指定上拉的处理函数
on-infinite
②数据更新完成之后，结束刷新
scroll.infiniteScrollComplete
③ionContent最后一个子元素
immediate-check=&apos;false&apos;
</code></pre><p>十、$ionicScrollDelegate</p>
<pre><code>scrollTop/Bottom() 滚动到顶部或者底部
scrollTo(left,top) 滚动到指定的位置
getScrollPostion() 得到当前的滚动位置（返回对象：top\left）
</code></pre><p>十一、ionTabs 实现选项卡</p>
<pre><code>ionTabs 常用属性：
tabs-icon-top/left/right/bottom/only tabs-positive
http://ionicons.com/
ionTab 常用的属性：title/icon/icon-on/icon-off/on-select(ionTabs默认是第一个被选中)
                  badge/badge-style/on-select/ng-click
</code></pre><p>十二、ionSideMenus 侧边栏菜单</p>
<pre><code>ionSideMenus父级元素，在中间写上:ionSideMenuContent(正文),ionSideMenu（侧边栏菜单）
操作侧边栏菜单打开或者关闭：
1、js：
    $ionicSideMenuDelegate.toggleLeft/toggleRight(true/false);
2、滑动打开
3、属性
    menu-close 将现在打开的侧边栏菜单关掉
    menu-toggle=&apos;left/right&apos; 对左边或则右边的侧边栏菜单进行开关的切换
</code></pre><p>十三、ActionSheet</p>
<pre><code>给用户提供有多种选择的小菜单，借助于$ionicActionSheet来实现
    $ionicActionSheet.show({

    })
在show方法的对象中常用属性：titleText/cancelText/buttons/destructiveText/
cancel/buttonClicked/destructiveButtonClicked
(处理方法中，可以通过返回true，关掉当前打开的actionSheet)
</code></pre><p>十四、$ionicLoading</p>
<pre><code>在移动端当需要处理的时间比较久时，通过该服务显示一个遮盖层
$ionicLoading.show({template/templateUrl/duration/delay})
$ionicLoading.hide();
</code></pre><p>十五、$ionicPopup</p>
<pre><code>在ionic中内容弹窗（警告、确认。。）
$ionicPopup.alert/confirm/prompt/show()
</code></pre><p>十六、自定义弹窗</p>
<pre><code>$ionicModal 模态窗
①指定要去显示的模板内容
②调用fromTemplate/fromTemplateUrl加载模板，并在then方法中得到对应的ionicModal的实例:$scope.modal
③调用$scope.modal.show()
</code></pre><p>十七、uiRouter</p>
<pre><code>定位：UI-Router is a client-side router for single page web applications.
注意：uiRouter用在ng、react中
uiRouter与ngRoute最大的区别：uiRouter支持路由的嵌套。

ngRoute：
①路由的基本步骤
   自定义模块，指定ngRoute模块（angular-route.js）
   指定盛放代码片段的容器 ngView
   创建代码片段
   配置路由词典
    $routerProvider.when().otherwise()
②跳转
  直接修改地址栏
  $location.path(路由地址)
  a href=&apos;#路由地址&apos;
③参数的传递
  发送方、接收方
  配置接收方的路由
  $routeParams
  发送参数

uiRouter的基本使用步骤：
 指定依赖的模块‘ui.router’
 盛放代码片段的容器 uiView
 创建模板文件
 设置状态
    $stateProvider.state()
注意事项：在ionic中的ionic模块 本身在创建时已经指定过依赖于ui.router模块，
        在ionic的项目没有必须要指定ui.router
</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;一、当前移动端开发的整体趋势&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;三种趋势
WebApp:通过前端技术来实现的接近传统应用程序体验的app
NativeApp:通过（Google或者Apple）SDK（software development kit 软件开发包）提供的原生的组件
    
    </summary>
    
      <category term="学习笔记" scheme="www.wangchengzou.cn/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="App" scheme="www.wangchengzou.cn/tags/App/"/>
    
      <category term="Ionic" scheme="www.wangchengzou.cn/tags/Ionic/"/>
    
  </entry>
  
  <entry>
    <title>Html5基础知识</title>
    <link href="www.wangchengzou.cn/2017/07/22/HTML5/"/>
    <id>www.wangchengzou.cn/2017/07/22/HTML5/</id>
    <published>2017-07-22T15:48:26.000Z</published>
    <updated>2017-07-23T16:50:23.596Z</updated>
    
    <content type="html"><![CDATA[<p>一、HTML5新特性 —— 十个新特性：凌乱</p>
<pre><code>(1)新的语义标签
(2)增强型表单(表单2.0)
(3)音频和视频
(4)Canvas绘图
(5)SVG绘图
(6)地理定位
(7)拖放API
(8)Web Worker
(9)Web Storage
(10)Web Socket
</code></pre><p>二、HTML5中表单的新特性</p>
<pre><code>(1)新的input type      &lt;input type=&quot;?&quot;&gt;
  H4中的input type：text、password、radio、checkbox、file、hidden、submit、reset、image
  H5中的input type：email、url、number、tel、search、range、color、date、month、week
(2)新的表单元素
  H4中的表单元素：input、textarea、select/option、label
  H5中新增的表单元素：datalist、progress、meter、output
(3)表单元素的新属性
</code></pre><p>三、H5中新增的表单元素 —— datalist</p>
<pre><code>&lt;datalist id=&quot;list3&quot;&gt;        datalist本身不可见
  &lt;option&gt;XX&lt;/option&gt;
  &lt;option&gt;YY&lt;/option&gt;
&lt;/datalist&gt;
&lt;input type=&quot;text&quot; list=&quot;list3&quot;&gt;
  datalist为input提供输入建议列表，用户可以从中选取，也可以手工输入
</code></pre><p>四、H5中新增的表单元素 —— progress</p>
<pre><code>显示一个进度条，有两种形式：
&lt;progress&gt;&lt;/progress&gt; 左右晃动的进度条
&lt;progress value=&quot;0.7&quot;&gt;&lt;/progress&gt; 具有指定进度值的进度条
</code></pre><p>五、H5中新增的表单元素 —— meter</p>
<pre><code>Meter：度量衡、刻度尺，用于标示一个值所处的范围：不可接受(红色)、可以接受(黄色)、非常优秀(绿色)
&lt;meter min=&quot;可取的最小值&quot; max=&quot;可取的最大值&quot; low=&quot;合理的下限值&quot;
      high=&quot;合理的上限值&quot; optimum=&quot;最佳值&quot;  value=&quot;当前实际值&quot;&gt;
&lt;/meter&gt;
</code></pre><p>六、H5中新增的表单元素 —— output</p>
<pre><code>output：输出，语义标签，没有任何外观样式，样式上等同于SPAN。
  商品单价: ￥3.50
购买数量：&lt;input type=&quot;number&quot; value=&quot;1&quot;&gt;
小计：&lt;output&gt;￥3.50&lt;/output&gt;
</code></pre><p>七、H5表单新特性 —— 表单元素的新属性</p>
<pre><code>H4中表单元素的属性：  &lt;input ?&gt;
  id、class、title、style、type、value、name、readonly、disabled、checked
H5中表单元素的新属性：
  (1)placeholder：占位字符
    &lt;input value=&quot;tom&quot; placeholder=&quot;请输入用户名&quot;&gt;
  (2)autofocus：自动获取输入焦点
    &lt;input autofocus&gt;
  (3)multiple：允许输入框中出现多个输入（用逗号分隔），如邮箱输入域
    &lt;input type=&quot;email&quot; multiple&gt;
  (4)form：用于把输入域放置到FORM外部
    &lt;form id=&quot;f5&quot;&gt;&lt;/form&gt;
    &lt;input form=&quot;f5&quot;&gt;
  ====输入验证相关的新属性======
  (5)required：必填项，内容不能为空
    &lt;input required&gt;
  (6)maxlength：指定字符串的最大长度
    &lt;input maxlength=&quot;9&quot;&gt;
  (7)minlength：指定字符串的最小长度
    &lt;input minlength=&quot;6&quot;&gt;
  (8)max：指定数字的最大值
    &lt;input max=&quot;60&quot;&gt;
  (9)min：指定数字的最小值
    &lt;input min=&quot;18&quot;&gt;
  (10)pattern：指定输入必需符合的正则表达式
    &lt;input pattern=&quot;1[35789]\d{9}&quot;&gt;
  上述验证属性会影响表单元素对应的JS对象的validity属性。
</code></pre><p>九、H5新特性——视频播放</p>
<pre><code>H5提供了一个新的标签用于播放视频：
  &lt;video src=&quot;res/birds.mp4&quot;&gt;&lt;/video&gt;
  &lt;video&gt;
          &lt;source src=&quot;res/birds.mp4&quot;&gt;
          &lt;source src=&quot;res/birds.ogg&quot;&gt;
          &lt;source src=&quot;res/birds.webm&quot;&gt;
          您的浏览器不支持VIDEO播放！
  &lt;/video&gt;
它本身是一个300*150的inline-block元素。
VIDEO标签/对象常用的成员：
成员属性：
  autoplay：false，是否自动播放
  controls：false，是否显示播放控件
  loop：false，是否循环播放
  muted：false，是否静音播放
  poster：&apos;&apos;，在播放第一帧之前显示的海报
  preload：视频的预加载策略，可取值：
      auto：预加载视频的元数据以及缓冲一定时长
      metadata：仅预加载视频的元数据(尺寸、时长、第一帧内容)，没有视频缓冲
      none：不预加载任何数据
   -------------JS对象属性---------------------
  currentTime：当前播放的时长
  duration：总时长
  paused：true，当前视频是否处于暂停状态
  volume：1，当前音量
  playbackRate：1，回放速率，大于1表快放，小于1表慢放
成员方法：
  play( )： 播放视频
  pause( )： 暂停播放
成员事件：
  onplay：    当视频开始播放时触发的事件
  onpause：当视频开始暂停时触发的事件
</code></pre><p>十、H5新特性——音频播放</p>
<pre><code>H5提供了一个新的标签用于播放音频：
  &lt;audio src=&quot;res/bg.mp3&quot;&gt;&lt;/audio&gt;
  &lt;audio&gt;
          &lt;source src=&quot;res/bg.mp3&quot;&gt;
          &lt;source src=&quot;res/bg.ogg&quot;&gt;
          &lt;source src=&quot;res/bg.wav&quot;&gt;
          您的浏览器不支持AUDIO播放！
  &lt;/audio&gt;
它默认是一个300*30的inline-block元素；但若没有controls属性，则display:none。
AUDIO标签/对象常用的成员：
成员属性：
  autoplay：false，是否自动播放
  controls：false，是否显示播放控件
  loop：false，是否循环播放
  muted：false，是否静音播放
  preload：视频的预加载策略，可取值：
      auto：预加载视频的元数据以及缓冲一定时长
      metadata：仅预加载视频的元数据(尺寸、时长、第一帧内容)，没有视频缓冲
      none：不预加载任何数据
   -------------JS对象属性---------------------
  currentTime：当前播放的时长
  duration：总时长
  paused：true，当前视频是否处于暂停状态
  volume：1，当前音量
  playbackRate：1，回放速率，大于1表快放，小于1表慢放
成员方法：
  play( )： 播放视频
  pause( )： 暂停播放
成员事件：
  onplay：    当视频开始播放时触发的事件
  onpause：当视频开始暂停时触发的事件
</code></pre><p>十一、网页中可用的绘图技术</p>
<pre><code>  网页中的实时走势图、统计图、在线画图板、网页游戏、地图应用都要使用到绘图技术。有三种绘图技术：
  (1)SVG绘图：2D矢量绘图技术，2000年出现，后纳入H5标准
  (2)Canvas绘图：2D位图绘图技术，H5提出的绘图技术
  (3)WebGL绘图：3D绘图技术，尚未纳入H5标准

Canvas绘图难点所在：
(1)坐标系
(2)单词比较多
</code></pre><p>十二、H5新特性——Canvas绘图技术</p>
<pre><code>Canvas：画布，是H5提供的2D绘图技术。
  &lt;canvas width=&quot;500&quot; height=&quot;400&quot;&gt;
      您的浏览器不支持Canvas标签！
  &lt;/canvas&gt;
CANVAS标签在浏览器中默认是300*150的inline-block。
画布的宽和高只能使用HTML/JS属性来赋值，不能使用CSS样式赋值！
每个画布上有且只有一个“画笔”对象——称为“绘图上下文”对象——使用该对象进行绘图！
  var ctx = canvas.getContext(&apos;2d&apos;)  //得到画布上的画笔对象
  (1)使用Canvas绘制矩形
      矩形的定位点在自己的左上角
      ctx.lineWidth = 1            描边宽度
      ctx.fillStyle = &apos;#000&apos;        填充样式/颜色
      ctx.strokeStyle = &apos;#000&apos;        描边样式/颜色
      ctx.fillRect( x, y, w, h )        填充一个矩形
      ctx.strokeRect( x, y, w, h )    描边一个矩形
      ctx.clearRect( x, y, w, h )        清除一个矩形范围内所有的绘图
  (2)使用Canvas绘制文本
    一段文字的定位点在其文本基线的起点
      ctx.textBaseline = &apos;alphabetic&apos;    文本基线
      ctx.font = &apos;12px sans-serif&apos;    文本大小和字体
      ctx.fillText( str, x, y )            填充一段文本
      ctx.strokeText( str, x, y )        描边一段文本
      ctx.measureText( str )    基于当前文字大小字体设置测量文本，返回一个对象：{width: x}
</code></pre><p>十三、Canvas绘图中使用渐变对象</p>
<pre><code>线性渐变： linearGradient
径向渐变： radialGradient
可以参考PS中的渐变效果。
var g = ctx.createLinearGradient( x1, y1,  x2,  y2 );
g.addColorStop( offset,  color )
....
g.addColorStop( offset,  color )
ctx.strokeStyle = g;
ctx.fillStyle = g;
</code></pre><p>十四、Canvas：是H5提供的2D位图绘图技术。</p>
<pre><code>&lt;canvas id=&quot;c1&quot; width=&quot;500&quot; height=&quot;400&quot;&gt;
    您的浏览器不支持Canvas
&lt;/canvas&gt;
var ctx = c1.getContext(&apos;2d&apos;)
//绘制矩形  ctx.fillRect()/strokeRect()/clearRect()
//绘制文本  ctx.fillText()/strokeText()/measureText()
//绘制路径
//绘制图像

1.Canvas的尺寸不能用CSS指定
  使用CSS指定的Canvas尺寸，实际不是修改了画布尺寸，而是进行了拉伸，上面的绘图内容也会随着进行拉伸。
  可以使用HTML标签的width和height属性，也可以使用JS对象的width和height属性。

2.使用Canvas进行绘图 —— 路径
  Path：类似于PS中的“钢笔工具”，由多个坐标点组成的任意形状，路径不可见，可用于“描边”、“填充”、“裁剪”。
  ctx.beginPath()        开始一条新路径
  ctx.closePath()        闭合当前路径
  ctx.moveTo(x, y)        移动到指定点
  ctx.lineTo(x, y)        从当前点到指定点画直线
  ctx.arc(cx, cy, r, start, end)    绘制圆拱路径

  ctx.stroke()            对当前路径描边
  ctx.fill()                对当前路径填充
  ctx.clip()            使用当前路径进行裁剪

3.使用Canvas进行绘图 —— 图像
  Canvas属于客户端技术，图片在服务器中，所以浏览器必须先下载要绘制的图片，且等待图片异步加载完成：
  var p3 = new Image();
  p3.src = &apos;img/p3.png&apos;;    //浏览器会自动异步请求图片
  console.log(p3.width);    //0
  p3.onload = function(){      //图片加载完成
        console.log(p3.width);      //200
        //开始绘制图片到画布上....
    ctx.drawImage( p3, x, y );        //原始大小绘图
    ctx.drawImage( p3, x, y, w, h );    //拉伸绘图
  }

Canvas绘图核心知识点：—— 重点
绘制矩形：
  ctx.fillRect()  ctx.strokeRect()   ctx.clearRect()
绘制文本：
  ctx.fillText()  ctx.strokeText()   ctx.measureText().width
绘制路径：
  ctx.beginPath()    ctx.closePath()
  ctx.moveTo()   ctx.lineTo()
  ctx.arc()
  ctx.stroke()   ctx.fill()    ctx.clip()
绘制图像：
  ctx.drawImage()


4.使用Canvas绘图时进行变形操作
  CSS中有变形相关样式： transform: rotate/scale/translate/skew，这些变形只能作用于某个HTML元素。
  Canvas绘图中也有变形技术，可以针对某一个图像/图形的绘制过程进行变形：rotate、scale、translate。
  ctx.rotate( 弧度 )     旋转绘图上下文对象(即画笔),轴点是画布的原点
  ctx.translate( x, y )  将整个画布的原点平移到指定的点
  ctx.save()         保存画笔当前的所有变形状态值（游戏中从存盘）
  ctx.restore()        恢复画笔变形状态到最近的一次保存（游戏中读取存盘）

5.第三方绘制统计图工具
  (1)Chart.js：免费的，提供了八种统计图表
  (2)FusionCharts.js：收费的，提供了90+中统计图表
  (3)ECharts：百度提供的免费的绘图工具，与地图整合的很好
  (4)FreeCharts ....

提示：第三方工具使用无需记忆！重点掌握自学的过程：
(1)打开官网，查看说明
    http://www.chartjs.org/
(2)仿照DEMO编写示例
    开源免费的、8种图表、基于H5 Canvas、支持响应式
(3)在实际项目中加以应用，查看详细API说明
    &lt;canvas id=&quot;c15&quot; width=&quot;500&quot; height=&quot;400&quot;&gt;
            您的浏览器不支持Canvas绘图！
    &lt;/canvas&gt;
    &lt;script src=&quot;js/Chart.js&quot;&gt;&lt;/script&gt;
    &lt;script&gt;
        new Chart(c15, {
            type: &apos;bar&apos;,//line、pie、noughnut...
            data: {},
            options: {}
            });
    &lt;/script&gt;

位图(Photoshop)：由一个又一个像素点组成，每个点各有自己的颜色，色彩细腻，但放大会失真
矢量图(Illustrator)：由一个又一个线条组成，每个线条可以指定颜色、方向，可以无限缩放，但细节不够丰富
</code></pre><p>十五、HTML5新特性——SVG绘图</p>
<pre><code>Scalable Vector Graph：可缩放的矢量图
Canvas绘图    SVG绘图
类型    2D位图    2D矢量图
如何绘图    使用JS代码绘图    使用标签绘图
事件绑定    每个图形不是元素，无法直接绑定事件    每个图形都是元素，可以直接绑定事件监听
应用场合    统计图、游戏    统计图、图标、地图
  SVG技术诞生于2000年，早期作为XML的扩展应用出现；H5标准把常用的SVG标签采纳为标准，但有些被废弃掉。

SVG技术在HTML5出现之前的使用方法：
    (1)在一个XML文档中声明要绘制的图形
    (2)再编写HTML文档，使用IMG/IFRAME应用XML文档即可
SVG技术在HTML5出现之后的使用方法：
    直接创建HTML5文档，在其中书写SVG标签即可
    &lt;svg&gt;&lt;/svg&gt;本身是一个300*150的inline-block。

使用SVG标签绘制矩形：
    &lt;rect&gt;
使用SVG标签绘制圆形：
    &lt;circle&gt;
使用SVG标签绘制椭圆：
    &lt;ellipse&gt;
使用SVG标签绘制直线：
    &lt;line&gt;
使用SVG标签绘制折线：
    &lt;polyline&gt;
使用SVG标签绘制多边形：
    &lt;polygon&gt;
</code></pre><p>十六、补充：Canvans上如何按照特定的顺序绘制图片</p>
<pre><code>Canvas绘图中若需要多张图片，他们的加载都是异步的，无法预测哪一张先加载完成！
但是绘图往往需要按照一定顺序，如先绘背景，再绘上面的内容。所以必须等待所有图片全部加载完成，才能开始绘图。
var progress = 0; //所有图片的总加载进度
var imgBg = new Image();
imgBg.src = &apos;img/bg.jpg&apos;;
imgBg.onload = function(){
  progress += 40;    //为每张图片赋一个权重值
  if(progress===100){
    startDraw();
  }
}
var imgDisc = new Image();
imgDisc.src = &apos;img/disc.png&apos;;
imgDisc.onload = function(){
  progress += 60;
  if(progress===100){
    startDraw();
  }
}
</code></pre><p>十七、补充：如何为Canvas上的图形/图像绑定事件监听</p>
<pre><code>网页中只能为HTML元素绑定监听函数，Canvas上的图形/图像都是用JS绘制的，不是DOM元素，不能直接进行事件绑定！
只能绑定给整个Canvas！然后再具体计算事件发生坐标是否处于某个图像/图形内部——仅适用于规则图像/图形。
  SVG图形中为元素绑定事件监听
  SVG图形中每个图形/图像都是一个标签，可以很方便进行事件绑定
</code></pre><p>十八、SVG绘图的特点——着重注意！</p>
<pre><code>(1)所有的图形默认只有填充色（黑色），没有描边色。
(2)SVG图形的样式可以用元素属性声明，也可以用CSS形式来声明。但用CSS声明时，只能使用SVG专用的样式，不能使用CSS样式，如边框设置只能用stroke，而不用border！
(3)图形可以使用JS来对属性赋值；但不能使用HTML DOM形式，只能用核心DOM操作，如：
  r.x = 10;   r.width = 100;    //无效
  r.setAttribute(&apos;x&apos;, 10); r.setAttribute(&apos;width&apos;, 100)//有效
(4)动态添加SVG图形可以使用两种方式：
   1)HTML字符串拼接
       var html = `&lt;rect&gt;&lt;/rect&gt;`;
       svg.innerHTML = html;
   2)使用document.createElementNS(&apos;http://www.w3.org/2000/svg&apos;,&apos;标签名&apos;)创建

4.使用SVG进行绘图——矩形
  &lt;rect width=&quot;&quot; height=&quot;&quot; x=&quot;&quot; y=&quot;&quot; fill=&quot;&quot; fill-opacity=&quot;&quot; stroke=&quot;&quot; stroke-width=&quot;&quot; stroke-opacity=&quot;&quot;&gt;&lt;/rect&gt;

5.使用SVG进行绘图——圆形
  &lt;circle r=&quot;&quot; cx=&quot;&quot; cy=&quot;&quot; fill=&quot;&quot; fill-opacity=&quot;&quot; stroke=&quot;&quot; stroke-opacity=&quot;&quot;&gt;&lt;/circle&gt;

6.使用SVG进行绘图——椭圆
  &lt;ellipse rx=&quot;&quot; ry=&quot;&quot; cx=&quot;&quot; cy=&quot;&quot;&gt;&lt;/ellipse&gt;

7.使用SVG进行绘图——直线
  &lt;line x1=&quot;&quot; y1=&quot;&quot; x2=&quot;&quot; y2=&quot;&quot; stroke=&quot;&quot; stroke-width=&quot;&quot; stroke-linecap=&quot;butt/square/round&quot;&gt;&lt;/line&gt;
 练习：使用SVG中的直线绘制如下的图标

提示：若多个SVG图形有完全一样的属性，可以抽出来，放在一个公共的父元素中（小组）
&lt;g stroke=&quot;#000&quot;&gt;
   &lt;line&gt;&lt;/line&gt;
   &lt;line&gt;&lt;/line&gt;
&lt;/g&gt;

8.使用SVG进行绘图——折线
  一条折线上可以有任意多个连续的点
  &lt;polyline points=&quot;50,50  100,300 ...&quot; fill=&quot;transparent&quot; stroke=&quot;#000&quot;&gt;&lt;/polyline&gt;
 练习：使用折线绘制如下图标

9.使用SVG进行绘图——多边形
&lt;polygon points=&quot;50,50  100,300 ...&quot; fill=&quot;&quot;&gt;&lt;/ polygon&gt;
  练习：使用多边形绘制如下两个图标

10.附加：使用SVG进行绘图——文本
  SVG画布上不允许使用普通的HTML元素绘制文本，如SPAN、P等！只能使用：
  &lt;text font-size=&quot;&quot; alignment-baseline=&quot;before-edge&quot; fill=&quot;&quot; stroke=&quot;&quot; x=&quot;&quot; y=&quot;&quot;&gt;文本内容 &lt;/text&gt;

11.附加：使用SVG进行绘图——图像
  不能使用IMG置于SVG画布上！只能使用：
  &lt;image xlink:href=&quot;disc.png&quot; width=&quot;200&quot; height=&quot;200&quot; x=&quot;&quot; y=&quot;&quot;&gt;&lt;/image&gt;
SVG绘图的主要知识点：
&lt;svg&gt;
  &lt;rect&gt;&lt;/rect&gt;
  &lt;circle&gt;&lt;/circle&gt;
  &lt;ellipse&gt;&lt;/ellipse&gt;
  &lt;line&gt;&lt;/line&gt;
  &lt;polyline&gt;&lt;/polyline&gt;
  &lt;polygon&gt;&lt;/polygon&gt;
  &lt;text&gt;&lt;/text&gt;
  &lt;image&gt;&lt;/image&gt;
&lt;/svg&gt;

12.补充小知识：如何在SVG中使用渐变
  &lt;defs&gt;      定义特效对象：渐变对象属于一种特效对象
    &lt;linearGradient id=&quot;g3&quot; x1=&quot;&quot; y1=&quot;&quot; x2=&quot;&quot; y2=&quot;&quot;&gt;
        &lt;stop offset=&quot;0&quot; stop-color=&quot;&quot; stop-opacity=&quot;&quot;/&gt;
        &lt;stop offset=&quot;1&quot; stop-color=&quot;&quot; stop-opacity=&quot;&quot;/&gt;
    &lt;/linearGradient&gt;
  &lt;/defs&gt;
  &lt;ANY fill=&quot;url(#g3)&quot;  stroke=&quot;url(#g3)&quot;&gt;&lt;/ANY&gt;
 练习：使用渐变对象，为不同的柱子分配不同的渐变色


13.补充小知识：如何在SVG中使用滤镜
  &lt;defs&gt;
    &lt;filter id=&quot;f2&quot;&gt;
        &lt;feGaussianBlur stdDeviation=&quot;3&quot;/&gt;
    &lt;/filter&gt;
  &lt;/defs&gt;
  &lt;ANY filter=&quot;url(#f2)&quot;&gt;

SVG中支持的所有滤镜：
https://developer.mozilla.org/en-US/docs/Web/SVG/Element/filter

网页中可用的绘图技术：
(1)Canvas绘图
(2)SVG绘图
(3)WebGL绘图

14.第三方绘图工具库  —— Two.js

 (1)打开官网，查看说明
    https://two.js.org/
    是一个2D绘图函数库，提供了一套API，可用于不同的技术下的绘图，如SVG/CANVAS/WEBGL。
 (2)参考DEMO，编写示例
    var two = new Two({ }).appendTo(box);
    //绘制一个圆形
    var c = two.makeCircle(200,200,100);
    //绘制一个矩形——定位点在矩形中心，而不是左上角
    var r = two.makeRectangle(600,200, 200,200);
    //把绘图对象中的内容绘制到DOM树
    two.update(); //更新DOM树
 (3)查看API，在项目中加以应用
</code></pre><p>十九、HTML5新特性之六 —— 地理定位</p>
<pre><code>  Geolocation：地理定位，使用JS获取当前浏览器所在的地理坐标
  （经度、维度、海拔、速度）数据，用于实现LBS应用(Location Based Service)，
  如饿了么、高德导航...
  手机浏览器如何获得定位信息：
    (1)首选手机中的GPS芯片与卫星通信，定位精度在米
    (2)次选手机通信基站进行定位获取，定位精度在公里
  PC浏览器如何获得定位信息：
    通过IP地址进行反向解析，定位精度取决于IP地址库的大小

HTML5中提供了一个新的对象，用于获取当前浏览器的定位信息：
  window.navigator.geolocation{
    getCurrentPosition: fn,    获得当前定位信息
    watchPosition: fn, 监视定位数据的改变
    clearWatch: fn  取消监视
  }
获得客户端的定位信息：
navigator.geolocation.getCurrentPosition(
    (pos)=&gt;{ pos.coords.latitude   pos.coords.longitude },
    (err)=&gt;{    err.code   err.message }
)

2.扩展小知识：在网页中如何嵌入百度地图
  (1)注册百度开发者账号
    http://lbsyun.baidu.com/
  (2)创建一个网站；登录百度地图，为网站申请一个地图的AccessKey
    http://lbsyun.baidu.com/apiconsole/key

  (3)在自己的网页中嵌入百度地图提供的API，嵌入百度地图
    官方手册：http://lbsyun.baidu.com/index.php?title=jspopular
    var map = new BMap.Map(&quot;container&quot;);          // 创建地图实例
    var point = new BMap.Point(116.300829,39.915836);  // 创建点坐标
    map.centerAndZoom(point, 17);   // 以指定点为中心并缩放
</code></pre><p>二十、HTML5新特性之七 —— 拖放API</p>
<pre><code>Drag &amp; Drop：拖动和释放
HTML5为拖放行为提供了7个事件，分为两组：
拖动的源对象(会动)可以触发的事件：
  dragstart：拖动开始
  drag：拖动中
  dragend：拖动结束
  整个拖动过程： dragstart*1 + drag*n + dragend*1
拖动的目标对象(不动)可以触发的事件：
  dragenter：拖动着进入
  dragover：拖动着悬停在上方
  dragleave：拖动着离开
  drop：在上方释放
  整个拖动过程1： dragenter*1 + dragover*n + dragleave*1
  整个拖动过程2： dragenter*1 + dragover*n + drop*1
注意：必须阻止dragover的默认行为，drop才可能触发！
</code></pre><p>二十一、HTML5新特性之八 —— Web Worker —— 代码就3行</p>
<pre><code>  程序：Program，指可被CPU执行的代码，存储在外存中
  进程：Process/Task，指程序被OS调入内存，分配执行空间，随时供CPU调度执行
  线程：Thread，线程是进程内执行代码基本单位

  进程和线程：
    (1)进程是操作系统分配内存的基本单位；
    (2)线程是CPU执行代码的基本单位；
    (3)线程必须处于某个进程内部；
    (4)一个进程内必须至少有一个线程；也可以有多个；
    (5)一个操作系统中可能同时存在几千个线程，它们是“并发执行的”—— 宏观上看同时执行，微观上看是依次循环执行

    Chrome浏览器中的线程模型：
    一个Chrome进程内，至少有6个线程，可以“同时/并发”向Web服务器发起HTTP请求，以获得所需的资源——资源请求线程。
    还有一个线程负责将所有内容绘制到浏览器页面中——UI主线程——不允许多线程同时绘图，防止内容布局错乱。

    5.观察如下一段代码执行特点
      &lt;button onclick=&quot;console.log(111)&quot;&gt;按钮1&lt;/button&gt;
      &lt;script src=&quot;14.js&quot;&gt;很耗时的JS任务&lt;/script&gt;
      &lt;button onclick=&quot;console.log(222)&quot;&gt;按钮

      现象：JS执行过程中，按钮1可见，但点击无效；按钮2不可见。
      原因：浏览器中执行代码的只有一个线程——UI主线程
      解决办法：创建新的线程，由它来执行耗时的JS任务；UI主线程继续执行后续的HTML渲染：
      &lt;button onclick=&quot;console.log(111)&quot;&gt;按钮1&lt;/button&gt;
      &lt;script&gt;
        var w = new Worker(&apos;14.js&apos;)
      &lt;/script&gt;
      &lt;button onclick=&quot;console.log(222)&quot;&gt;按钮

1.补充小知识：在拖动源对象和目标对象间传递数据
  如：拖动开始时(src.ondragstart)记录被拖动元素的ID，释放时(target.ondrop)根据ID查找拖动的源对象，进行相关操作。
  方法1：使用一个全局变量 —— 造成全局对象的污染
  方法2：使用H5拖放API专供的e.dataTransfer（数据传递）

  //拖动的源对象
  src.ondragstart = function(e){
    //海南：往拖拉机中装数据
    e.dataTransfer.setData(&apos;key&apos;, &apos;value&apos;)
  }
  //拖动的目标对象
  target.ondrop = function(e){
    //哈尔滨：从拖拉机中读取数据
    var data = e.dataTransfer.getData(&apos;key&apos;);            //value
  }
</code></pre><p>二十二、HTML5新特性之八——WebWorker——代码就3行，重点在理论理解</p>
<pre><code>进程：操作系统分配内存的单位 —— 工厂
线程：处于进程内部，用于执行代码 —— 生产线
线程并发：操作系统中所有的线程宏观上看“同时执行”；微观上看是“依次交替执行”
Chrome中的线程模型： 请求资源——6个线程；运行代码/渲染页面内容——1个线程
&lt;button&gt;按钮1&lt;/button&gt;
&lt;script src=&quot;x.js&quot;&gt;&lt;/script&gt;
&lt;button&gt;按钮2&lt;/button&gt;
上述代码中若x.js很耗时，按钮1无法点击，按钮2在运行js过程中不可见——所有的代码(HTML/CSS/JS)都在单线程(UI主线程)中执行

解决方案：创建一个并发执行的新线程，让它来执行耗时的JS任务

3.Worker线程的致命缺陷
浏览器不允许Worker线程操作任何的DOM&amp;BOM对象！！
原因：浏览器只允许UI主线程操作DOM&amp;BOM！若多个线程同时都可以操作DOM结构，页面将混乱。
所以，类似jQuery的脚步决不能使用Worker来加载执行。

Worker线程可以给UI主线程发数据消息：
  UI主线程：
      var w6 =new Worker(&apos;6.js&apos;);
      w6.onmessage = function(e){ e.data }
  Worker线程：
      postMessage(stringMsg)
UI主线程可以给Worker线程发数据消息：
  UI主线程：
      var w6 =new Worker(&apos;6.js&apos;);
      w6.postMessage(stringMsg)
  Worker线程：
      onmessage = function(e){ e.data }

  项目中Worker的使用场景：
  (1)只要js中有DOM&amp;BOM就不能用Worker！
  (2)Worker适合于执行耗时的JS任务！如复杂计算、加密和解密、大数据统计、路径规划......
</code></pre><p>二十三、HTML5新特性之九 —— WebStorage</p>
<pre><code>  在浏览器中存储当前用户专有的数据：访问历史、内容定制、样式定制...
  在客户端存储数据可以使用的技术：
  (1)Cookie技术：浏览器兼容性好；不能超过4KB，操作复杂
  (2)Flash存储：依赖于Flash播放器
  (3)H5 WebStorage：不能超过8MB，操作简单
  (4)IndexedDB：可存大量数据，还不是标准技术

Session：会话，浏览器从打开某个网站的一个页面开始，中间可能打开很多页面，
直到关闭浏览器，整个过程称为“浏览器与Web服务器的一次会话”。

WebStorage技术中，浏览器为用户提供了两个对象：
  (1)window.sessionStorage：类数组对象，会话级数据存储
    在浏览器进程所分得的内存存储着一次Web会话可用的数据，可供此次会话中所有的页面共同使用
    ；浏览器一旦关闭就消失了。
作用：在同一个会话中的所有页面间共享数据，如登录用户名。
    sessionStorage[key] = value            //保存一个数据
    sessionStorage.setItem(key, value)        //保存一个数据
    var v = sessionStorage[key]            //读取一个数据
    var v = sessionStorage.getItem(key)    //读取一个数据
    sessionStorage.removeItem(key)        //删除一个数据
    sessionStorage.clear()                //清除所有数据
    sessionStorage.length                //数据的数量
    sessionStorage.key(i)                //获取第i个key

  (2)window.localStorage：类数组对象，本地存储(跨会话级存储)
    在浏览器所能管理的外存(硬盘)中存储着用户的浏览数据，可供此次会话以及后续的会话中的页面共同使用；
即使浏览器关闭也不会消失——永久存在。作用：在当前客户端所对应的所有会话中共享数据，如登录用户名。
    localStorage[key] = value            //保存一个数据
    localStorage.setItem(key, value)        //保存一个数据
    var v = localStorage [key]            //读取一个数据
    var v = localStorage.getItem(key)        //读取一个数据
    localStorage.removeItem(key)        //删除一个数据
    localStorage.clear()                //清除所有数据
    localStorage.length            //数据的数量
    localStorage.key(i)                //获取第i个key

localStorage中若数据发生了修改，会触发一次window.onstorage事件，可以监听此事件，实现监视localStorage数据改变的目的，
用于在一个窗口中监视其它窗口中对localStorage数据的修改——不能监视sessionStorage数据的修改！

5.HTML5新特性之十 —— WebSocket——代码不复杂重点在原理的理解
  HTTP协议：属于“请求-响应”模型，只有客户端发起请求消息，服务器才会返回响应消息，没有请求就没有响应；
一个请求，只能得到一个响应。有些场景中，此模型就力不从心了：实时走势应用、在线聊天室。
解决方案：长轮询(Long-Polling)/心跳请求——定时器+AJAX——请求过于频繁，服务器压力过大；
不够频繁，客户端数据延迟较大。
  WebSocket协议：属于“广播-收听”模型，客户端连接到服务器就不再断开，永久的连接，双方就随时向对方发送消息，
且是全双工不对等发送。WS协议在实时走势应用、在线聊天室应用中有着特别的优势。


  WS协议的应用程序也分为客户端程序和服务器端程序：
  WS服务器端应用：
    监听指定端口，接收客户端请求，向对方发消息，并接收消息；可以使用php/java/node.js等语言编写
  WS客户端应用：
    主动发起连接请求，保持永久的连接，向对方消息，并接收消息，可以使用php/java/node.js/html5等语言编写

6.了解：使用Node.js创建WS协议的服务器
  node.js官方没有提供ws协议的模块，必须使用NPM下载第三方ws协议模块：  npm  i  ws
  查看README,编写WS协议的服务器：
  ......

7.掌握：使用HTML5创建WS协议的客户端应用
  //连接到WS服务器
  var socket = new WebSocket(&apos;ws://127.0.0.1:9001&apos;)
  //向服务器发消息
  socket.send(stringMsg)
  //接收服务器发来的消息
  socket.onmessage = function(e){
    e.data   //消息内容
  }
  //断开到WS服务器的连接
  socket.close();
</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;一、HTML5新特性 —— 十个新特性：凌乱&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;(1)新的语义标签
(2)增强型表单(表单2.0)
(3)音频和视频
(4)Canvas绘图
(5)SVG绘图
(6)地理定位
(7)拖放API
(8)Web Worker
(9)Web Stora
    
    </summary>
    
      <category term="学习笔记" scheme="www.wangchengzou.cn/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="h5" scheme="www.wangchengzou.cn/tags/h5/"/>
    
      <category term="html" scheme="www.wangchengzou.cn/tags/html/"/>
    
  </entry>
  
  <entry>
    <title>JQuery基础知识</title>
    <link href="www.wangchengzou.cn/2017/07/22/JQuery/"/>
    <id>www.wangchengzou.cn/2017/07/22/JQuery/</id>
    <published>2017-07-22T15:48:26.000Z</published>
    <updated>2017-07-23T13:47:56.493Z</updated>
    
    <content type="html"><![CDATA[<p>1、 DOM分为三部分：</p>
<pre><code>(1)核心DOM：操作任意标签树
(2)HTML DOM：操作HTML标签树
(3)XML DOM：操作XML标签树
</code></pre><p>2、常用的核心DOM操作</p>
<pre><code>(1)查找元素的方法
    document.getElementById(&apos;p1&apos;)
    document.getElementsByName(&apos;uname&apos;)
    document.getElementsByTagName(&apos;div&apos;)
    document.getElementsByClassName(&apos;btn&apos;)
    document.querySelector(&apos;选择器&apos;)
    document.querySelectorAll(&apos;选择器&apos;)
    遍历DOM节点：
    node.parentNode
    parent.childNodes、parent.children
    node.nextSibling、node.previousSibling
(2)修改元素的属性
    node.setAttribute(&apos;title&apos;,&apos;值&apos;)
    node.getAttribute(&apos;title&apos;)
(3)修改元素的内容
    element.innerHTML
    element.textContent/innerText
(4)修改元素的样式
    element.style.color = &apos;red&apos;;
    element.className = &apos;btn btn-danger&apos;
(5)修改元素的值
    inputElement.value
(6)添加新元素
    var newElement = document.createElement(&apos;div&apos;);
    parent.appendChild(newElement)
(7)删除已有元素
    parent.removeChild(node)
(8)替换旧元素
    parent.replaceChild(oldChild, newChild)
(9)元素克隆
    element.cloneNode()

总结：核心DOM操作的问题
  · 方法名普遍比较长
  · 操作比较僵硬
  · 方法存在浏览器兼容性
</code></pre><p>3、jQuery 概述</p>
<pre><code>jQuery是一个DOM操作的函数库，简化了常用的DOM操作。
理念：Write Less，Do More
jQuery提供了四类函数：
  (1)DOM操作 —— 重点
  (2)事件处理
  (3)动画函数
  (4)AJAX
</code></pre><p>4、 jQuery的版本问题：</p>
<pre><code>(1)jQuery 1.x：比较大、功能偏弱、兼容老IE
(2)jQuery 2.x：比较小、功能强大、不兼容老IE
(3)jQuery 3.x：比较小、功能更强大、不兼容老IE
面试题：jQuery3的新特性有哪些？
HTML中使用jQuery，只需要使用SCRIPT标签引入jquery-*.js即可，会为window添加两个新的成员：
    window.$
    window.jQuery
</code></pre><p>5、jQuery函数的特点</p>
<pre><code>(1) $或者jQuery是一个函数，返回值是一个jQuery类数组对象
(2)即使没有查找到需要的元素，jQuery类数组对象也不会是null/undefined，调用jQuery函数不会报错！
(3)jQuery类数组对象提供的函数都自带for循环遍历每个查找到的元素
(4)jQuery函数底层都是DOM操作，所以可和原生的DOM操作组合使用
(5)原生DOM对象不能调用jQuery提供的函数；jQuery函数返回的类数组对象也不能调用核心DOM成员
(6)原生DOM对象和jQuery对象间如何转换：
  原生DOM对象封装到一个jQuery类数组对象
      $(domObject)
  jQuery类数组中取出封装的DOM对象：
      $(&apos;button&apos;)[index]
(7)jQuery对象方法的返回值一般还是当前选定的类数组对象，可以实现“链式调用”
</code></pre><p>6、jQuery函数第一部分：DOM操作函数 —— 查找元素</p>
<pre><code>$( &apos;选择器&apos; )
jQuery的选择器语法支持所有的CSS选择器语法！并屏蔽了浏览器兼容性；同时还扩展了一些新的选择器语法。
面试题：jQuery中的哪些选择器是CSS中没有的？ —— 执行效率较低
</code></pre><p>7、 第一组：基本选择器   —— 重点</p>
<pre><code>(1)#id
  练习：点击一个button#bt1，让下方的一个p#p1隐藏起来
  提示：jQuery类数组对象提供的.hide()函数可以隐藏一个元素
(2).className
  练习：点击一个button#bt2，让下方所有的span.badge字体变大为2em
  提示：jQuery类数组对象提供的.css(&apos;color&apos;, &apos;red&apos;)函数可以修改当前选定元素的指定样式
(3)标签名
  练习：li元素上发生鼠标进入事件时，当前li显示出下边框
  提示：使用.on(&apos;mouseover&apos;, fn)监听鼠标进入事件
(4)*
  练习：单击button#bt3后，让所有的元素的box-sizing变为border-box，所有元素的margin变为0
(5)div, p, #c3
  练习：页面加载完成后，为所有的button、.btn、role=&quot;button&quot;的元素，添加事件监听，点击后打印出当前系统时间
</code></pre><p>8、第二组：层级选择器       —— 重点</p>
<pre><code>(6) ancestor descendant   后代选择器
  练习：为所有#alert1中的.btn添加事件监听，单击后，隐藏#alert1
(7) parent &gt; child     直接子代选择器
  练习：为所有#alert2中的直接子元素.btn添加事件监听，单击后，隐藏#alert2
(8) prev + next      下一个相邻兄弟选择器
  练习：为UL中的LI添加上边框，实现如下效果：
  $(&apos;li + li&apos;).....
  $(&apos;li:not(:first-child)&apos;)....
(9) prev ~ siblings    后续的所有兄弟选择器
</code></pre><p>9、第三组：基本过滤选择器       —— 重点</p>
<pre><code>注意：基本过滤选择器把所有满足选中的元素放在一个大集合中进行排序，不论是否在同一个父元素中与否。下标从0开始！
(10) :first
  练习：把所有列表中的第一个LI字体加粗显示
(11) :last:
  练习：把所有列表中的最后一个LI字体斜体显示
(12) :eq(index)
  练习：把所有列表中的第index个LI添加有边框
(13) :gt(index)
  练习：把所有列表中的下标大于index的LI添加删除线
(14) :lt(index)
  练习：把所有列表中的下标小于index的LI添加下划线
(15) :odd
  练习：把所有列表中的下标为奇数的LI背景颜色变为淡黄色
(16) :even
  练习：把所有列表中的下标为偶数的LI背景颜色变为淡蓝色
(17) :not(selector)
</code></pre><p>10、第四组：子元素过滤选择器       —— 重点</p>
<pre><code>注意：在每个父元素中进行分组，查找指定的子元素。下标从1开始。
(18) :first-child
  $(&apos;li:first-child&apos;);
  练习：把每个列表中的第一个子LI字体变浅蓝
(19) :last-child
  练习：把每个列表中的第最后一个子LI字体变红色
(20) :nth-child(index)
  练习：把每个列表中的第2个子LI字体添加绿色背景
  $(&apos;li:nth-child(2)&apos;)...
  $(&apos;li:nth-child(odd)&apos;)       $(&apos;li:nth-child(2n+2)&apos;)
  $(&apos;li:nth-child(even)&apos;)    $(&apos;li:nth-child(2n)&apos;)
(21) :only-child
  $(&apos;li:only-child&apos;)
</code></pre><p>11、第五组：属性选择器</p>
<pre><code>(22) [attribute]
  选中所有具备title属性的a元素： $(&apos;a[title]&apos;)...
(23) [attribute=value]
  选中所有具备data-toggle属性且值为dropddown的元素：
  $(&apos;[data-toggle=&quot;dropdown&quot;]&apos;)....
(24) [attribute!=value]
(25) [attribute^=value]
(26) [attribute$=value]
(27) [attribute*=value]    具备指定的属性，且值中包含指定字符
</code></pre><p>12、第六组：可见性选择器</p>
<pre><code>(28) :visible         $(&apos;:visible&apos;)选中所有可见元素
(29) :hidden        $(&apos;:hidden&apos;)选中所有隐藏元素
测试：哪些是:hidden可以选中的？
      · display: none            可以
      · visibility: hidden        不可以
      · opacity: 0            不可以
      · input[type=&quot;hidden&quot;]    可以
</code></pre><p>13、第七组：内容过滤选择器</p>
<pre><code>  (30) :contains(txt)
    练习：选中文本中包含“提交”字的button元素，让它们变为绿色按钮
  (31) :has(selector)
    练习：选中包含.close按钮的.alert元素，让它们变为红色的警告框；
选中不包含.close按钮的.alert元素，让它们变为红色的警告框
  (32) :empty
    练习：选中内容为空的警告框    $(&apos;.alert:empty&apos;).....
  (33) :parent
    练习：选中内容不为空的警告框，即包含子元素或文本内容
    $(&apos;.alert:parent&apos;).....
</code></pre><p>14、第八组：表单元素选择器</p>
<pre><code>: input         :text         :password     :radio
:checkbox     :submit         :image         :reset
:button     :file             :hidden

:enabled     :disabled     :checked         :selected
  &lt;input type=&quot;image&quot; src=&quot;img/1.jpg&quot;&gt;
</code></pre><p>15、 W3C DOM把HTML文档看做树型结构，并提供操作节点方法；–总结</p>
<pre><code>jQuery是一个函数库，用于简化DOM操作，屏蔽了浏览器兼容性问题。函数分为四类：
  (1)DOM操作
  (2)事件处理
  (3)动画
  (4)AJAX
jQueryDOM操作——查找节点
  jQuery(&apos;选择器&apos;)    =》  类数组对象
基本选择器：
    #id、.class、div、*、button,.btn
层级选择器：
    parent  child
    parent &gt; child
    prev + next
    prev ~ siblings
基本过滤选择器：
    :first        :last        :eq(i)    :gt(i)        :lt(i)
    :odd        :even    :not(selector)
子代过滤选择器：
    :first-child    :last-child        :nth-child(i)
    :nth-child(odd)   :nth-child(even)
属性选择器：
    [attr=&quot;value&quot;]
可见性选择器：
    :visible        :hidden
内容选择器：
    :contains(txt)        :has(selector)
    :empty            :parent
表单元素选择器：
    :text        :radio    :submit
    :disabled    :enabled     :checked    :selected
</code></pre><p>16、操作元素的属性</p>
<pre><code>&lt;a  href=&quot;&quot; title=&quot;&quot;  data-toggle=&quot;dropdown&quot;&gt;
核心DOM：
  element.getAttribute(&apos;title&apos;)
  element.setAttribute(&apos;title&apos;, &apos;abc&apos;)
jQuery：
  var value  = $(..).attr(&apos;title&apos;)        //读取属性的值
  $(..).attr(&apos;title&apos;, &apos;abc&apos;)            //设置属性的值
提示：读取和设置元素的data-*扩展属性，可以使用attr()方法，也可以使用data()方法，如： &lt;a data-my-target=&quot;1.jpg&quot;&gt;
  var v = $(...).data(&apos;my-target&apos;)        //读取
  $(...).data(&apos;my-target&apos;, &apos;2.jpg&apos;)        //设置

练习：点击某个小图，下方就显示出对应的大图
  &lt;img src=&quot;img/4.jpg&quot; data-target=&quot;img/Koala.jpg&quot;&gt;
</code></pre><p>17、操作元素的内容</p>
<pre><code>核心DOM：
  var h = element.innerHTML;
  element.innerHTML = h;
  var t = element.innerText/textContent;
  element.innerText/textContext = t;
jQuery：
  $(..).html( )        //读取innerHTML
  $(..).html( &apos;html&apos; )    //设置innerHTML
  $(..).text( )        //读取innerText
  $(..).text( &apos;txt&apos; )        //设置innerText
练习：点击一个Button，上方显示出已点击的次数
练习：&lt;a href=&quot;#&quot;&gt;再次点击即显示下一张图片&lt;/a&gt;
  1再次点击即显示下一张图片
  2&lt;img src=&quot;1.jpg&quot;&gt;
  3再次点击即显示下一张图片
  4&lt;img src=&quot;2.jpg&quot;&gt;
  5再次点击即显示下一张图片
  6 ....
</code></pre><p>18、操作元素的样式</p>
<pre><code>核心DOM：
  var c = element.style.color        //读取行内样式
  element.style.color = &apos;red&apos;        //设置行内样式
  var n = element.className        //读取ClassName
  element.className = n            //设置ClassName
jQuery：
  $(..).css(&apos;color&apos;)        //读取指定样式的值
  $(..).css(&apos;color&apos;, &apos;red&apos;)    //设置行内样式
  $(..).addClass(&apos;alert&apos;)    //添加一个class
  $(..).removeClass(&apos;alert&apos;)    //删除一个class
  $(..).hasClass(&apos;alert&apos;)    //判断选定元素是否具有指定class
练习：实现一个“双态按钮”，点击一次变为深色，再点击变为浅色
  .up {  }            .down {  }
</code></pre><p>19、操作表单元素的值</p>
<pre><code>核心DOM：
    var v = input.value        //读取值
    input.value = &apos;v&apos;        //设置值
jQuery：
    $(...).val( )            //读取值
    $(...).val(&apos;value&apos;)    //设置值
练习：“用户名”和“密码”输入框，点击“提交注册信息”按钮后，读取用户的两个输入，打印出来，在输入框中清除用户的输入

面试题：在操作元素的相关属性时，使用attr()、val()、prop()、data()有何区别？
attr()一般只用于操作元素的HTML字面属性，如src、href、name...
val()操作的是HTML元素对应的JS对象的value属性
prop()操作的是HTML元素对应的JS对象的disabled、readyonly、selected、checked等Boolean类型属性
data()操作的是HTML元素对应的JS对象的扩展数据属性（对象缓存数据），而attr(&apos;data-xx&apos;)读取/修改的HTML元素字面属性
</code></pre><p>20、遍历DOM树上的节点</p>
<pre><code>核心DOM：
  element.parentNode            //寻找父节点
  element.childNodes/children        //获取子节点
  elemnet.nextSibling            //获取下一个兄弟
  element.previousSibling            //获取上一个兄弟
jQuery：
  $(..).parent()            //返回选定元素的父节点
  $(..).children()            //返回所有子节点
  $(..).next()            //返回下一个兄弟
  $(..).prev()            //返回上一个兄弟
  $(..).siblings()            //返回所有的同辈兄弟
练习：实现一个自己的页签组件

  &lt;ul class=&quot;tabs&quot;&gt;
      &lt;li&gt;&lt;a&gt;十元套餐&lt;/a&gt;&lt;/li&gt;
      &lt;li class=&quot;active&quot;&gt;&lt;a&gt;二十元套餐&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a&gt;三十元套餐&lt;/a&gt;&lt;/li&gt;
  &lt;/ul&gt;
</code></pre><p>21、添加新的元素</p>
<pre><code>核心DOM：
  var li = document.createElement(&apos;li&apos;)    //创建子节点
  //修改li的属性....                    //设置其属性
  ul.appendChild( li );                    //添加到父节点
jQuery：
  var li = $(&apos;&lt;li class=&quot;item&quot;&gt;内容&lt;/li&gt;&apos;)    //创建子节点
  //li.click(fn)
  $(&apos;ul&apos;).append( li );                //在父节点最后追加子节点
  $(li).appendTo( &apos;ul&apos; )            //子节点追加到父节点最后
   -------可以简写为------------------------------
  $(&apos;ul&apos;).append( &apos;&lt;li class=&quot;item&quot;&gt;内容&lt;/li&gt;&apos; )
练习：添加和删除小盒子

  function rc(){            //Random Color:  返回一个随机的颜色
      var r = Math.floor(Math.random()*256)
      var g = Math.floor(Math.random()*256)
      var b = Math.floor(Math.random()*256)
      return `rgb(  ,  ,  )`;
  }
</code></pre><p>22、删除已有的元素</p>
<pre><code>核心DOM：
  ul.removeChild( li )            //由父元素删除孩子
jQuery：
  $(&apos;li&apos;).remove()                //删除当前选定元素
</code></pre><p>23、替换已有元素</p>
<pre><code>核心DOM：
  parent.replaceChild(oldChild,  newChild);
jQuery：
  $(&apos;oldChild&apos;).replaceWith( newChild )    //已有节点用新节点替换，返回被删除的旧节点
  $(&apos;newChild&apos;).replaceAll( oldChild )    //新节点替换所有的旧节点，返回新节点
练习：实现英雄选择效果    div#chosen        div#list
</code></pre><p>24克隆节点</p>
<pre><code>核心DOM：
  var copy = element.cloneNode( )
jQuery：
  var copy = $(..).clone()        //返回选定元素的副本
  var copy = $(..).clone(copyListener)   //参数指示是否复制选定元素绑定的监听函数，默认为false，不复制监听函数
练习：改进“英雄选择”应用，要求点击某个小飞机后，下方仍然有该飞机，上方选中区域出现当前飞机的一个副本
</code></pre><p>25、jQuery函数第二部分：事件处理函数</p>
<pre><code>jQuery的历史上先后出现了若干事件处理函数：
(1)bind() / unbind()            已废弃
(2)one(事件名称, fn)    仅对指定事件监听一次
(3)live() / die()                已废弃
(4)delegate() / undelegate()    已废弃
(5)on() / off()
(6)click() / mouseover() / mouseout() / keyup() ...
  $(..).click(fn)  &lt;=&gt;  $(..).on(&apos;click&apos;, fn)

  on()函数的第一种使用方法——直接绑定在事件源上：
      $(&apos;事件源&apos;).on(&apos;事件名称&apos;, fn)    //绑定监听函数
      $(&apos;事件源&apos;).off(&apos;事件名称&apos;)        //取消所有监听函数
  练习：点击“开始抽奖”按钮，命令行中输出“抽奖中”，按钮上的文字也变为“抽奖中”；要求此后此按钮再被点击无任何处理函数了。
  on()的第一种用法有两个限制：
      (1)若选中元素很多，每个都会有一个监听函数
      (2)无法为后添加的元素执行绑定
  on()函数的第二种使用方法——委托给父元素进行事件代理：
      $(&apos;parent&apos;).on(&apos;事件名称&apos;, &apos;子元素选择器&apos;, fn)
</code></pre><p>26、 DOM中为元素绑定监听函数：</p>
<pre><code>btn.onclick = function(){  }
btn.addEventListener(&apos;click&apos;, function(){  })
jQuery中的on()函数底层是addEventListener
</code></pre><p>27、DOM操作——增删改查</p>
<pre><code>(1)查找元素：  $(&apos;选择器&apos;)   jQuery(&apos;选择器&apos;)
(2)操作元素的属性： $(..).attr()
(3)操作元素的内容： $(..).html()  $(..).text()
(4)操作元素的样式： $(..).css()
    $(..).addClass()   $(..)removeClass()
    $(..).hasClass()  $(..).toggleClass(&apos;.btn&apos;)
 (5)操作元素的值：  $(..).val()
 (6)遍历元素：
    $(..).parent()
    $(..).children()-直接子代
    $(..).find()-所有子元素
    $(..).next()        $(..).nextAll()
    $(..).prev()        $(..).prevAll()
    $(..).siblings()
(7)插入节点：  $(..).append()   $(..).prepend()
(8)删除节点：  $(..).remove()   $(..).empty()
(9)替换节点：  $(..).replaceWith()  $(..).replaceAll()
(10)克隆节点： $(..).clone()
</code></pre><p>28、事件处理函数：</p>
<pre><code>(1)$(&apos;.btn&apos;).one(&apos;click&apos;, fn)
(2)$(&apos;.btn&apos;).click(fn) ....
(3)$(&apos;.btn&apos;).on(&apos;click&apos;, fn)        off(..)
  $(&apos;.container&apos;).on(&apos;click&apos;, &apos;.btn&apos;, fn)  off(..)

  让jQuery放弃使用 $ ：
  jQuery.noConflict()
</code></pre><p>29、面试题：window.onload和$(document).ready()的异同？</p>
<pre><code>window.onload是核心DOM的写法：
  window.onload = function(){ ... }
  只能为绑定一次；
  只有全部的网页内容(html/css/js/图片....)加载完成才能触发。

$(document).ready()是jQuery的写法：
  $(document).ready(function(){ ... })
  底层是addEventListener(&apos;DOMContentLoaded&apos;, fn)，可以先后绑定多次；
  只要“DOM内容(只包括html/js)加载完成”即可触发。
</code></pre><p>30、补充：jQuery中的hover()函数</p>
<pre><code>jQuery监听“鼠标进入+鼠标离开”有如下三种方法：
(1) $(..).mouseover(fn)   +  $(..).mouseout(fn)
(2) $(..).mouseenter(fn)   +   $(..).mouseleave(fn)
(3) $(..).hover( fn, fn )
注意：方法3等同于方法2
</code></pre><p>31、补充：jQuery中的trigger()函数</p>
<pre><code>使用JS代码代替用户触发指定的事件，调用之前绑定的监听函数。
$(&apos;.btn&apos;).trigger( &apos;click&apos; )
可以简写为：
$(&apos;.btn&apos;).click( )
</code></pre><p>32、jQuery中的函数第三部分：动画函数 —— 隐藏和显示动画</p>
<pre><code>隐藏和显示函数通过使用定时器修改目标元素的width / height / opcaity三个样式的值来实现动画：
$(..).show()      $(..).show(&apos;slow/normal/fast&apos;)  $(..).show(3000)
$(..).hide()    $(..).hide(&apos;slow/normal/fast&apos;)  $(..).hide(3000)
$(..).toggle()     ...  在隐藏和显示之间切换
</code></pre><p>33、jQuery中的函数第三部分：动画函数 —— 折叠展开/收起动画</p>
<pre><code>折叠展开/收起动画函数通过使用定时器修改目标元素的height一个样式的值来实现动画：
$(..).slideUp( )    $(..).slideUp( &apos;slow/normal/fast&apos; )   $(..).slideUp( 300 )
$(..).slideDown( )  ....
$(..).slideToggle( )   ....

练习：仿写Bootstrap中的响应式导航条在手机中的效果
&lt;div class=&quot;navbar&quot;&gt;
  &lt;div class=&quot;navbar-header&quot;&gt;
      &lt;a class=&quot;navbar-brand&quot;&gt;TARENA&lt;/a&gt;
      &lt;a class=&quot;navbar-toggle&quot;&gt;三&lt;/a&gt;
  &lt;/div&gt;
  &lt;div class=&quot;navbar-collapse&quot;&gt;
      ul&gt;li&gt;a
  &lt;/div&gt;
&lt;/div&gt;
</code></pre><p>34、jQuery中的函数第三部分：动画函数 —— 淡入/淡出动画</p>
<pre><code>淡入/淡出动画函数通过使用定时器修改目标元素的opacity一个样式的值来实现动画：
$(..).fadeIn( )  $(..).fadeIn(&apos;slow/normal/fast&apos;)  $(..).fadeIn(300)
$(..).fadeOut( )
$(..).fadeToggle( )
提示：上述六个动画函数都可以在最后接收一个参数——函数
  $(..).fadeOut( 300,  function(){ //在动画结束时的回调函数 })
练习：点击小星星后，闪动3次，最后消失
</code></pre><p>35、jQuery中的函数第三部分：动画函数 —— animate()</p>
<pre><code>$(..).animate({
  属性1: 值1;
  ...
}, 300, fn)
动画排队：执行完一个动画后，再执行另一个
动画并发：同时执行多个属性的动画效果

animate({})可以对哪些CSS属性执行动画？
(1)width、height、opacity、fontSize....等等有可渐变属性值（数值型）的样式可以执行动画
(2)display、fontFamily、transform、颜色类属性等没有渐变属性值的样式不能执行动画
</code></pre><p>36、Web应用中可用的动画技术：</p>
<pre><code>(1)CSS3 Transition
(2)CSS3 Keyframes
(3)定时器 + 属性修改            jQuery1/2动画函数
(4)requestAnimationFrame       jQuery3
</code></pre><p>37、jQuery类数组对象的操作</p>
<pre><code>  window.$  &lt;=&gt; window.jQuery
$()函数或jQuery()返回值是一个“类数组对象”—— 有点像数组，但不是Array类型的实例，其中封装着查找到的所有DOM元素。该对象称为“jQuery对象”，其类数组相关操作：
  $(..).length        获取类数组中封装的DOM对象的数量
  $(..)[index]        获取类数组中封装的第index个DOM对象
  $(..).get(index)        获取类数组中封装的第index个DOM对象
  $(..).each(fn)        遍历类数组中封装的每一个DOM对象，针对每个DOM元素执行一次指定的回调函数
  $(..).index(domObj)    返回指定的DOM元素在当前类数组中的下标
</code></pre><p>38、补充：页面DOM内容加载完成后执行指定的函数</p>
<pre><code>$(document).ready(fn)
$().ready(fn)
$(fn)
</code></pre><p>39、jQuery中的插件函数</p>
<pre><code> Plugin：插件，在现有的功能基础上添加更多的功能，扩展整体的应用。
jQuery中的插件（即函数）分为两类：
 1.jQuery全局插件函数
   原本要声明的工具函数（如max()/min()）如果声明为全局函数，会造成“全局对象(window)的污染；
   为了避免污染全局对象，可以把这些函数纳入到 jQuery对象的名下——与jQuery没有必然的关系：
   声明方式：    jQuery.max = function(arr){  }
               jQuery.extend({ max: fn,  min: fn})
   调用方式：    jQuery.max([10,38,50])
 2.jQuery对象插件函数
   jQuery对象插件函数就是为所有的jQuery对象（$()函数的返回值）添加的公共函数，用于操作当前选定的DOM元素。
   声明方式：    jQuery.fn.max = function( ){  }
               jQuery.fn.extend({ max: fn,   min: fn})
   调用方式：    $(&apos;li&apos;).max( )

   jQuery(..) 或 $(..) 的返回值是一个类数组对象——“jQuery对象”，所有的jQuery对象的原型： jQuery.fn;
   若想给所有的jQuery对象都添加一个扩展函数，只需要加给jQuery.fn即可

  3.复杂插件的编写：轮播广告
       $(&apos;..&apos;).carousel( );

  4.复杂插件的编写：滚动监听
       $(&apos;..&apos;).scrollspy( );
</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;1、 DOM分为三部分：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;(1)核心DOM：操作任意标签树
(2)HTML DOM：操作HTML标签树
(3)XML DOM：操作XML标签树
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;2、常用的核心DOM操作&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;(1)查找元
    
    </summary>
    
      <category term="学习笔记" scheme="www.wangchengzou.cn/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="javaScript" scheme="www.wangchengzou.cn/tags/javaScript/"/>
    
      <category term="JQuery" scheme="www.wangchengzou.cn/tags/JQuery/"/>
    
  </entry>
  
  <entry>
    <title>git使用基础知识</title>
    <link href="www.wangchengzou.cn/2017/07/22/git/"/>
    <id>www.wangchengzou.cn/2017/07/22/git/</id>
    <published>2017-07-22T15:48:26.000Z</published>
    <updated>2017-07-23T14:58:04.095Z</updated>
    
    <content type="html"><![CDATA[<p>git  config  –global   user.name   “name”<br>git  config  –global   user.email   “email@qq.com”</p>
<p>git  status               查看工作区所有文件状态<br>git  add  1.jpg          把指定文件添加到暂存区<br>git  add  <em>.jpg          把指定后缀名的文件添加到暂存区<br>git  add  </em>              把所有文件添加到暂存区<br>git  add  .              把所有文件添加到暂存区<br>git  commit  -m  “消息内容”   把暂存区的修改提交给仓库<br>git  log                 查看仓库中所有的提交记录</p>
<p>git  reset  –hard  版本号     工作区回退到指定的版本<br>git  log       查看当前已经生效的所有版本号<br>git  reflog     查看当前已经生效&amp;撤销生效的所有版本号</p>
<p>git  clone  远程仓库的地址<br>git  clone  git@github.com:jquery/jquery.git<br>git  clone  <a href="https://github.com/jquery/jquery.git" target="_blank" rel="external">https://github.com/jquery/jquery.git</a></p>
<p>git  init           本地创建一个空白仓库<br>git  remote       查看当前仓库关联到哪些远程仓库<br>git  remote  add  关联仓库名  远程仓库的地址<br>git  pull  关联仓库名  master    从远程仓库“拉取(pull)”已有的文件和版本信息到本地仓库<br>git  add  .        修改本地仓库中的文件，添加到本地暂存区，提交给本地的仓库<br>git  commit   -m   “说明信息”<br>git  push  远程仓库名  master    把本地仓库中的新的版本信息“推送(push)”给远程仓库</p>
<p>git subtree push –prefix=dist origin gh-pages  建立分支结构</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;git  config  –global   user.name   “name”&lt;br&gt;git  config  –global   user.email   “email@qq.com”&lt;/p&gt;
&lt;p&gt;git  status               查看工作区所有文
    
    </summary>
    
      <category term="学习笔记" scheme="www.wangchengzou.cn/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="git" scheme="www.wangchengzou.cn/tags/git/"/>
    
      <category term="打包" scheme="www.wangchengzou.cn/tags/%E6%89%93%E5%8C%85/"/>
    
  </entry>
  
  <entry>
    <title>MySql常用方法知识</title>
    <link href="www.wangchengzou.cn/2017/07/22/MySql/"/>
    <id>www.wangchengzou.cn/2017/07/22/MySql/</id>
    <published>2017-07-22T15:48:26.000Z</published>
    <updated>2017-07-23T16:08:55.461Z</updated>
    
    <content type="html"><![CDATA[<p>添加用户方法 grant</p>
<pre><code>&gt;grant select,insert,update,delete,create,drop
&gt;on tutorials.*
&gt;to &apos;zara&apos;@&apos;localhost&apos;
&gt;identified by &apos;zara123&apos;;
以上为为指定数据库tutorials添加用户zara 密码为zara123

&gt;use数据库名；--选择操作的数据库
&gt;show databases;   ---列出所有数据库
&gt;show tables;      ---列出数据库所有表
&gt;show columns from 数据表；----显示数据表属性，属性类型，主键信息
&gt;show index from 数据表； ---显示数据表索引信息
&gt;show table status like 数据表\G; ---输出统计信息
&gt;create database库名； ----创建库名
&gt;drop database库名；   ----弹出框显示是否删除库名
&gt;int bigint double varchar datetime now()  四大数据类型
&gt;create table 表名；  ---创建数据表
&gt;drop table 表名；    ---删除表
&gt;insert into 表名（列，列）values(值，值)；---添加数据
&gt;select 列名 from 表名 where 条件；  ----查询
&gt;update 表名 set 列=值，列=值 where 条件  ----更新或修改数据
&gt;delete from 表名 where 条件； ---直接删除表内记录列
&gt;drop database if exists 库名  ---判断是否存在数据库，存在就删除
&gt;create database 库名 charset=utf8；  ---指定库名编码
&gt;set names utf8  -----设置语句编码
&gt;primary key auto_increment  --- 主键自增加，指定位置用null代替
&gt;$_request[&apos;title&apos;];--获取表单中的参数
&gt;desc 表名；----将查看该表里面的所有类型
&gt;require();  ---引用初始化PHP文件
多表查询方法（
    SELECT n.title,n.ctime,u.uname    多表联系
    FROM t_user u,t_news n;           创建别名
    WHERE u.id==n.uid          条件关系
）

{命令窗口使用SQL文件加载数据库，中文显示
    &gt;set names utf8        --文件转换编码格式
    &gt;source 文件位置    --加载文件位置
    &gt;set names gbk        --临时使用gbk格式显示中文
}
</code></pre><p>php学习基本函数</p>
<pre><code>phpinfo();显示软件版本信息
var_dump();输出数组元素
count();输出数组里面元素的个数
foreach($arr as $k=&gt;$v);用于处理关联数组遍历问题
</code></pre><p>使用php操作mhsql服务器步骤(四步走)</p>
<pre><code>1创建到MySQL服务器的连接
  $conn=mysqli_connect(...);
    服务器地址IP    本机127.0.0.1：8081
    用户名      root
    密码          p
    选择库      库名
2向MySQL服务器发送sql指令，等待服务器执行
  $sql=&quot;...&quot;;//insert/delete/update
3读取MySQL服务器返回结果
  $result=mysqli_query($conn,$sql);
4判断返回结果是否成功
  if($result===false);
5断开与MySQL服务器连接
  mysqli_close($conn);
</code></pre><p>php mysql查询操作</p>
<pre><code>1:连接数据库
  $conn=mysqli_connect(...);
  服务器地址IP    本机127.0.0.1：8081
  用户名            root
  密码          p
  选择库      库名
2:发送查询sql   SELECT
   $sql=&quot;...&quot;;    SELECT * FROM t_user;
3:读取MySQL服务器返回结果 是不是true/false
   $result=mysqli_query($conn,$sql);
4:抓取结果中数据并且转换数组
   a:抓取一行数据{关联数组}
    mysqli_fetch_assoc(结果集对象);
   b:抓取一行数据{索引数组
    mysqli_fetch_row(结果集对象);
5:断开与MySQL服务器连接
   mysqli_close($conn);
</code></pre><p>php常用函数说明</p>
<pre><code>die($str);终止当前php文件执行，并向客户输出一个终止原因说明
@    压制住当前行代码警告消息，在行首位置添加！
#time() 返回当前系统时间，以毫秒为单位整数
#mysqli_insert _id($conn) 返回连接上刚刚执行insert 语句产生ID值
#mysqli_affected_rows($conn),返回刚刚连接上执行增删改语句影响行数
location.href   为跳转方式
</code></pre><p>ajax  GET的使用方法</p>
<pre><code>1.创建Ajax对象
    var xhr= new XMLHttpRequest();
2.绑定事件
    xhr.onreadystatechange=function(){
        alert(xhr.responseText);--输出事件运行文本状态
    }
3.打开连接
    xhr.open(&apos;GET&apos;,&apos;url&apos;,true);
4.发送请求
    xhr.send(null)
</code></pre><p>Ajax 常用对象和属性事件方法</p>
<pre><code>xhr对象：向web服务器发送请求并接收返回响应消息
    var xhr =new XMLHttpRequest();
    兼容性问题，老IE8以下不支持
    采用 new ActiveXObject(&quot;Microsoft.XMLHTTP&quot;)
    对兼容性做判断 if（window.XMLHttpRequest）确认使用创建对象方法

readyState ;xhr对象当前状态，会自动改变
    对应值：0 UNSENT 请求消息未发送
        1 OPENED XHR已经找开连接
        2 HEADERS_RECEVIED xhr已经接收信息
        3 LOADING  XHR正在加载消息
        4 DONE XHR接收完成消息

status  表示服务器返回的状态码
responseText  表示服务器响应文本
responseXML   表示服务器响应XML文本

属性使用方法
    open(method,url.isAsyn)  表示打开服务器连接
        method：请求方式，GET POST
        Ulr  请求地址
        isasyn：请求方式是异步TRUE还是同步FALSE

    send（data）请求消息发送web服务器
        data：请示消息主体内容:
           GET为send(null)
           POST 为数据放在里面如send（‘id=10&amp;name=tome&amp;age=19&apos;）
</code></pre><p>#AJAX POST  标准语法和用法</p>
<pre><code>1.创建AJAX对象
 xhr=new XMLHttpRequest()
2.绑定事件
    xhr.onreadystatechange=function(){
    判断事件输出信息，返回数据
    if(xhr.readyState===4&amp;&amp;xhr.status===200){
        if(parseInt(xhr.responseText)&gt;0){
            作输出 ，返回成功结果
        }else{
            输出 失败结果
        }
    }
  }
3.打开连接
  xhr.open(&apos;POST&apos;,&apos;URL&apos;,ture)
  修改头部信息
   xhr.setRequestHeader(&apos;Content-Type&apos;,&apos;application/x-www-form-urlencoded&apos;);
4.发送请求
  xhr.send(发送参数);
</code></pre><p>修改头部信息–php首行加头部信息</p>
<pre><code>纯文本text
    header(&quot;Content-Type:text/plain&quot;);
        html-&gt;ajax
        xhr.responseText
网页页面HTML
    header(&quot;Content-Type:text/html;charset=utf-8&quot;);
        html-&gt;ajax
        xhr.responseText;
javascript
    header(&quot;Content-Type:application/javascript;charset=utf-8&quot;);
     echo &quot;var msg=&apos;hello&apos;;alert(msg)&quot;;
                html-&gt;ajax
      eval(xhr.responseText);
      示例:国际化
       当前浏览器 zh-CN  你好
                 en-US   hello
</code></pre><p>json语法和要求</p>
<pre><code>一个JSON字符串有且只有一个根，可以是{}对象 []一个数组
JSON中可以表示 数字 bool null 字符串，字符串必须用双引号
数组中可以包含多值 ，用， 分开
对象中可以包含多个键值，使用逗号分开，

怎么处理JSON数据
服务器端PHP
    header(&quot;Content-Type:application/json;charset=utf-8&quot;);
    $str=json_encode($arr)
    echo $str;

javascript 接收
    var obj=JSON.parse(xhr.responstText);
</code></pre><p>XML语法要求</p>
<pre><code>XML 文档声明
    &lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
整篇xml字符串只能一个根元素 标签有开始有结束 不能交叉
所有属性必须用双引号

XML方法
    服务器PHP
    header(&quot;Content-Type:application/xml;charset=utf-8&quot;);
    echo &quot; xml....&quot;;
    客户端JS
    AJXX请求接收数据
    var xmlDoc=xhr.responseXML;---
    获取所有标签
    var book=xmlDoc.querySelectorAll(&quot;book&quot;)
    获取其中属性
    var name=xmldDoc.querySelector(&quot;name&quot;)
</code></pre><p>jquery 常用AJAX函数</p>
<pre><code>$.get(url,callback);    发送get请求
$.post(url,data,callback);   发送post请求
$.getJSON(url,callback);    发送JSON请求‘
$.load(url);       加载
$.getScript(url.callback);
$.ajax({})   全能
    全能使用方法
    ajax({
        type:&quot;GET&quot;        请求方式post,pub,delete
        url:&quot;  url&quot;        请求地址
        data:&quot;{---:--,--:--}&quot;
            请求服务器数据
        beforeSend:fn
            请求消息发送前调用函数
        success:fn
            响应完成并且成功调用函数
        error:fn
            响应完成但是有问题的调用函数
        complete:fn
            响应完成但是无论成功与否都调用函数
    })
</code></pre><p>开发项目</p>
<pre><code>开发流程
    需求说明书---技术经理，美工
    剪切图片集---UI
    静态网页----前端
    动态网页---后端
    部署服务器----运维
    测试---------功能
    上线-----
    调试---加新功能--升级
</code></pre><p>针对cookie作了解</p>
<pre><code>添加
    document.cookie = &apos;uid=10&apos;;
    document.cookie = &apos;uname=qiangdong&apos;;

读取
    function getCookieVal(key){
            //  [&quot;uid=10&quot;,&quot;uname=qiangdong&quot;]
        var rs = null;
            //1:创建变量保存最终返回结果值
        var line = document.cookie;
        var arr = line.split(&quot;;&quot;);
            //2:按照;拆分cookie中字符串
        for(var i=0;i&lt;arr.length;i++){
            //3:循环数组中每一个键值
            var kv = arr[i];
            var option = kv.split(&quot;=&quot;);
            //4:按照=拆分
            var k = option[0].trim();
            //5:下标0 k  ---  trim()去除字符串前后空格
            var v = option[1];
            //6:下标0 v
            if(key===k){
                //7:判断如果参数中指定
                key == k
                return v;
                //8:返回v
            }
        }
        return rs;
        //9:否则返回 null
    }
     var rs = getCookieVal(&quot;uid&quot;);    //调用函数
         console.log(rs);
     var rs = getCookieVal(&quot;uname&quot;);
         console.log(rs);
     var age = getCookieVal(&quot;age&quot;);
         console.log(age);
</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;添加用户方法 grant&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;gt;grant select,insert,update,delete,create,drop
&amp;gt;on tutorials.*
&amp;gt;to &amp;apos;zara&amp;apos;@&amp;apos;localhost&amp;
    
    </summary>
    
      <category term="学习笔记" scheme="www.wangchengzou.cn/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="MySql" scheme="www.wangchengzou.cn/tags/MySql/"/>
    
      <category term="PhP" scheme="www.wangchengzou.cn/tags/PhP/"/>
    
      <category term="Ajax" scheme="www.wangchengzou.cn/tags/Ajax/"/>
    
  </entry>
  
  <entry>
    <title>Vue快速上手知识</title>
    <link href="www.wangchengzou.cn/2017/07/22/Vue%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B%E7%9F%A5%E8%AF%86/"/>
    <id>www.wangchengzou.cn/2017/07/22/Vue快速上手知识/</id>
    <published>2017-07-22T15:48:26.000Z</published>
    <updated>2017-07-23T15:38:48.212Z</updated>
    
    <content type="html"><![CDATA[<p>1、基本绑定：</p>
<pre><code>new Vue(
    {
        el:&apos;#elID&apos;,
        data:{
            // data obj
        },
        computed:{
            // computed obj
        },
        methods:{
            // methods obj
        },
    }
);
</code></pre><p>2、指令：</p>
<pre><code>前缀为v-
*v-if, v-for, v-bind, v-on...
*特性插值会转为v-bind绑定: href=&apos;{{url}}&apos; --&gt; v-bind:href=&apos;url&apos;
</code></pre><p>3、数据绑定只接受单个表达式：</p>
<pre><code>{{number+1}}                                    ok
{{ok?'yes':'no'}}                                ok
{{message.split('').reverse().join('')}}        ok
{{var a=1}}                                        no
{{if(ok){return message}}}                        no
</code></pre><p>4、过滤器：</p>
<pre><code>管道式的写法 --&gt; {{message|capitalize}}
*可以串联: filterA|filterB
*可以带参数: filterA &apos;arg1&apos; arg2
</code></pre><p>5、修饰符</p>
<pre><code>前缀为.
*v-bind:href.literal=&apos;a/b/c&apos;
</code></pre><p>6、缩写</p>
<pre><code>v-bind:href=&apos;url&apos; --&gt; :href=&apos;url&apos;
v-on:click=&apos;dosomething&apos; --&gt; @click=&apos;dosomething&apos;
</code></pre><p>7、计算setter</p>
<pre><code>computed:{
    fullName:{
        get:function(){
            // getter
        }
        set:function(newValue){
            //setter
        }
    }
}
</code></pre><p>8、Class与Style绑定</p>
<pre><code>*变量语法：v-bind:class=&quot;{&apos;class-a&apos;:isA, &apos;class-b&apos;:isB}&quot;
 --&gt;        data:{isA:true, isB:false}
*对象语法：v-bind:class=&quot;classObj&quot;
--&gt;        data:{classObj:{&apos;class-a&apos;:true, &apos;class-b&apos;:false}}
*数组语法：v-bind:class=&apos;[classA, classB]&apos;
 --&gt;        data:{classA:&apos;class-a&apos;, classB:&apos;class-b&apos;}
</code></pre><p>9、条件渲染</p>
<pre><code>*v-if, v-show, v-else
*&lt;h1 v-if=&quot;ok&quot;&gt;Yes&lt;/h1&gt; &lt;h1 v-else&gt;No&lt;/h1&gt;
*&lt;h1 v-show=&quot;ok&quot;&gt;Yes&lt;/h1&gt; &lt;h1 v-else&gt;No&lt;/h1&gt;
*show只是简单的display:none
</code></pre><p>10、列表渲染</p>
<pre><code>v-for
*内置变量：{{$index}}
*用法：v-for=&apos;item in items&apos;
       v-for=&apos;(index, item) in items&apos;    *数组则是索引，遍历对象则是键
</code></pre><p>11、数组变动检测</p>
<pre><code>能触发视图更新的方法：
*push, pop, shift, unshift, splice, sort, reverse
// 变异方法
*filter, concat, slice
// 替换数组
*尽可能复用DOM: track-by
    v-for=&quot;item in items&quot; track-by=&quot;_uid&quot;
    track-by=&apos;$index&apos;
    // 根据index追踪，不是很明白！...片段不被移动，
    // 简单地已对应索引的新值刷新,也能处理数据数组中重复的值...

不能检测到以下变化：
    1.直接用索引设置元素：    vm.items[0]={};
    // vue解决方案：vm.items.$set(0, { childMsg: &apos;Changed!&apos;}),
                    vm.items.$remove(item)
    2.修改数据的长度：        vm.items.length=0;
    // js中常见的清空, vue解决方案：直接用空数组替换
</code></pre><p>12、对象v-for</p>
<pre><code>内置变量：$key
</code></pre><p>13、值域v-for</p>
<pre><code>&lt;span v-for=&quot;n in 10&quot;&gt;{{ n }}&lt;/span&gt;
</code></pre><p>14、内置的过滤器</p>
<pre><code>filterBy 和 orderBy
</code></pre><p>15、方法与事件处理器</p>
<pre><code>·v-on 监听DOM事件
    &lt;button v-on:click=&quot;greet&quot;&gt;&lt;/button&gt;
    &lt;button v-on:click=&quot;greet(&apos;xx&apos;, $event)&quot;&gt;&lt;/button&gt;
    // 内联语句处理器, $event为内置变量，原生的DOM事件
·事件修饰符
    &lt;a v-on:click.stop.prevent=&apos;doThis&apos; /&gt;
    // 阻止冒泡和默认行为，修饰符可以串联
·按键修饰符
    &lt;input v-on:keyup.13=&apos;submit&apos; &gt;
    // 键盘事件后面可接keyCode
    常见的按键有提供别名：
        ·enter
        ·tab
        ·delete
        ·esc
        ·space
        ·up
        ·down
        ·left
        ·right
</code></pre><p>16、表单控件绑定</p>
<pre><code>·v-model绑定字段
    &lt;input type=&quot;checkbox&quot; id=&quot;checkbox&quot; v-model=&quot;checked&quot;&gt;
    // 绑定的值通常是静态字符串，勾选框是布尔值
·参数特性
    lazy        // 延迟到change事件中同步(原为input)
    number        // 仅允许输入数字
    debounce    // 延时同步
</code></pre><p>17、过渡</p>
<pre><code>典型的过渡：
    &lt;div v-if=&quot;show&quot; transition=&quot;expand&quot;&gt;&lt;/div&gt;
    需要添加CSS样式：
        .expand-transition(必须), .expand-enter, .expand-leave
        *如果未设置, 默认为.v-transition, .v-enter, .v-leave
    同时提供钩子：
        Vue.transition(&apos;expand&apos;,{...});
        ·beforeEnter, enter, afterEnter, enterCancelled,
        beforeLeave, leave, afterLeave, leaveCancelled
    渐近过渡：
        &lt;div v-for=&apos;list&apos; transition stagger=&apos;100&apos;&gt;&lt;/div&gt;
        *钩子stagger, 延时过渡
</code></pre><p>18、组件</p>
<pre><code>·创建组件：        var c = Vue.extend({
                    template:&apos;&lt;div&gt;A custom component!&lt;/div&gt;&apos;,
                });
·注册组件:        Vue.component(&apos;my-component&apos;, c);
// 如果名字是myComponent, html中必须写成my-component
·使用组件：        &lt;div id=&apos;app&apos;&gt;&lt;my-component&gt;&lt;/my-component&gt;&lt;/div&gt;
// html
                new Vue({el:&apos;#app&apos;});
                // js

*注册可缩写为    vue.component(&apos;my-component&apos;,{
                    template:&apos;&lt;div&gt;A custom component!&lt;/div&gt;&apos;,
                });
局部注册：
    var c = Vue.extend({});
    var parentComponent = Vue.extend({
        components:{
            &apos;my-component&apos;: c,
        }
    });
组件选项：
    var c = Vue.extend({
        data:function(){
            return {a:1};
        }
    });

is特性：
    *table中限制其他的节点不能放置其中
    &lt;table&gt;
        &lt;tr is=&apos;my-component&apos;&gt;&lt;/tr&gt;
    &lt;/table&gt;

Props:
    props用以从父组件接收数据:
        使用：
            Vue.component(&apos;child&apos;,{
                props:[&apos;msg&apos;],
                template:&apos;&lt;span&gt;{{msg}}&lt;/span&gt;&apos;
            });
        声明：
            &lt;child msg=&apos;hello!&apos;&gt;&lt;/child&gt;            // 字面量语法
            &lt;child v-bind:msg=&apos;parentMsg&apos;&gt;&lt;/child&gt;    // 动态语法
        *如果props是myMsg, html中需要用my-msg
        (即：camelCase - kebab-case, 因为html的特性是不区分大小写)
        *字面量和动态语法稍有不同
            &lt;comp some-prop=&quot;1&quot;&gt;&lt;/comp&gt;        // 传递了一个字符串 &quot;1&quot;
            &lt;comp :some-prop=&quot;1&quot;&gt;&lt;/comp&gt;    // 传递实际的数字

Props绑定类型：
    &lt;child :msg=&quot;parentMsg&quot;&gt;&lt;/child&gt;        // 默认为单向绑定
    &lt;child :msg.sync=&quot;parentMsg&quot;&gt;&lt;/child&gt;    // 双向绑定
    &lt;child :msg.once=&quot;parentMsg&quot;&gt;&lt;/child&gt;    //单次绑定
    *如果prop是一个对象或数组，是按引用传递。不管使用哪种绑定方式，都将是双向绑定

Props验证：
    props:{            // 此时props是一个对象
        propA: Number,
        propB:{
            type: String,
            // 类型(原生构造器：String, Number, Boolean, Function, Object, Array)
            required: true,
            // 是否必须项
            default: &apos;thyiad&apos;,
            // 默认值(如果是Object, 默认值需由一个函数返回)
            validator: function(value){
            // 验证
                return value === &apos;thyiad&apos;;
            },
            coerce:function(val){
                return val+&apos;&apos;;
                // 将值强制转换为字符串
                return JSON.parse(val);
                // 将JSON字符串转换为对象
            }
        }
    }

父子组件通信：
    this.$parent        // 子组件访问父组件
    this.$root            // 访问根实例
    this.$children        // 父组件的所有子元素
    *不建议在子组件中修改父组件的状态

自定义事件：
    $on()                // 监听事件
    $emit()                // 触发事件
    $dispatch()            // 派发事件，沿着父链冒泡
    $broadcast()        // 广播事件, 向下传递给所有的后代
    使用：
        子组件中绑定函数派发事件：
            methods:{
                notify:function(){
                    this.$dispatch(&apos;child-msg&apos;,this.msg);
                }
            }
        父组件中定义事件：
            events:{
                &apos;child-msg&apos;:function(msg){
                    this.messages.push(msg);
                }
            }
        *更直观的声明方式：
            &lt;child v-on:child-msg=&apos;handleIt&apos;&gt;&lt;/child&gt;
            // 直观的为父组件定义事件(child-msg), 并且触发父组件的handleIt函数, 子组件只关注触发事件

子组件索引：
    &lt;child v-ref:profile&gt;&lt;/child&gt;
    var child = parent.$refs.profile;

使用Slot分发内容：
    单个Slot:
        父组件的内容将被抛弃，除非子组件包含&lt;slot&gt;.
        如果只有一个没有特性的slot, 整个内容将被插到它所在的地方, 替换slot.
            父组件：
            &lt;child&gt;
                &lt;p&gt;parent content&lt;/p&gt;
            &lt;/child&gt;
            子组件模板：
            &lt;div&gt;
                &lt;h1&gt;child content&lt;/h1&gt;
                &lt;slot&gt;
                    如果父节点没有设置内容，这里才会被显示
                &lt;/slot&gt;
            &lt;/div&gt;
    命名Slot：
        父组件模板：
            &lt;child&gt;
                &lt;p slot=&apos;one&apos;&gt;One&lt;/p&gt;
                &lt;p slot=&apos;two&apos;&gt;two&lt;/p&gt;
                &lt;p&gt;Default A&lt;/p&gt;
            &lt;/child&gt;
        子组件模板：
            &lt;div&gt;
                &lt;slot name=&apos;one&apos;&gt;&lt;/slot&gt;
                &lt;slot&gt;&lt;/slot&gt;
                // 默认slot, 找不到匹配内容的回退插槽, 如果没有默认的slot, 不匹配内容将被抛弃
                &lt;slot name=&apos;two&apos;&gt;&lt;/slot&gt;
            &lt;/div&gt;

    动态组件：
        可以在不同组件之间切换：
            new Vue({
                el:&apos;body&apos;,
                data:{
                    currentView:&apos;home&apos;,
                },
                components:{
                    home:{},
                    posts:{},
                    archive:{},
                }
            });
            父组件：
                &lt;component :is=&apos;currentView&apos; keep-alive&gt;&lt;/component&gt;
                // component是Vue保留的元素
                *keep-alive用来把切换出去的组件保留在内存中, 可以保留它的状态避免重新渲染
        activate钩子：
            用以在切入前做一些异步操作：
                activate:function(done){
                    var self = this;
                    loadDataAsync(function(data){
                        self.someData=data;
                        done();
                    });
                }
        transition-mode
            指定列两个动态组件之间如何过渡：
                &lt;component :is=&apos;currentView&apos; transition=&apos;fade&apos; transition-mode=&apos;out-in&apos;&gt;&lt;/component&gt;
                *默认进入与离开平滑地过渡, 可以指定另外两种模式：in-out, out-in (先进入or先离开)

    组件和v-for:
        &lt;child v-for=&apos;item in items&apos; :item=&apos;item&apos; :index=&apos;$index&apos;&gt;&lt;/child&gt;
        *因为组件的作用域是孤立的, v-for里的item无法直接传递给组件, 必须像上面一样使用props传递数据

    异步组件
    资源命名约定
    递归组件
    片段实例
        *推荐模板只有一个根节点(使用template选项时)
    内联模板
        组件把它的内容当做它的模板
        &lt;child inline-template&gt;&lt;/child&gt;
        *不推荐
</code></pre><p>19、深入响应式原理</p>
<pre><code>·如何追踪变化
    *使用Object.defineProperty设置getter/setter
·变化检测问题
    *不能检测到对象属性的添加或删除
    *vm.$set(&apos;b&apos;, 2);
     Vue.set(object, key, value);
·初始化数据
    *推荐在data对象上声明所有的响应属性
·异步更新队列
    *默认异步更新DOM, 下次事件循环时清空队列, 执行必要的DOM更新
    *Vue.nextTick(callback);
·计算属性的秘密
    *计算属性是有缓存的, 除非显示设置为不缓存
        computed:{
            attr:function(){
                return Date.now()+this.msg;
            }
        }
        TO:
        computed:{
            attr:{
                cache: false,
                get: function(){
                    return Date.now()+this.msg;
                }
            }
        }
        *但只是在JS中访问是这样的, 数据绑定仍是依赖驱动的。
</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;1、基本绑定：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;new Vue(
    {
        el:&amp;apos;#elID&amp;apos;,
        data:{
            // data obj
        },
        computed:{

    
    </summary>
    
      <category term="学习笔记" scheme="www.wangchengzou.cn/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Vue，App" scheme="www.wangchengzou.cn/tags/Vue%EF%BC%8CApp/"/>
    
  </entry>
  
  <entry>
    <title>Zetpojs基础知识</title>
    <link href="www.wangchengzou.cn/2017/07/22/Zeptojs/"/>
    <id>www.wangchengzou.cn/2017/07/22/Zeptojs/</id>
    <published>2017-07-22T15:48:26.000Z</published>
    <updated>2017-07-23T15:56:58.353Z</updated>
    
    <content type="html"><![CDATA[<p>一、zeptojs概述</p>
<pre><code>目标：实现一个10k以内的非常轻量的移动端用的方便DOM操作的js库
what？ 是一个js库
where？现代高级浏览器（移动端）
why？轻量（放弃了对ie等低端浏览器的支持）
how？类似jQuery的用法 只需要引入js文件，调用方法即可
特点：
    学习成本低
    轻量
注意：zeptojs官网下载的包 默认包含5个模块（zepto\ie\ajax\event\form）,
        如果要用到其他模块，去zeptoBuilder
        官网：http://github.e-sites.nl/zeptobuilder/
        选择需要用到的模块，勾选，下载即可
</code></pre><p>二、使用Zepto</p>
<pre><code>1、核心模块
    集合、数据、类型判断的操作
    选择器
    DOM增删改查

2、detect
    如果不是默认的模块，可以到zeptoBuilder下载对应的模块文件。
    $.os $.browser

3、event模块
    on off one trigger

4、Ajax模块
    $.get
    $.post
    $.ajax
    $.load

5、form模块
    serialize  将表单中的输入组件的name属性和对应的值 处理成urlEncoded的字符串
    serializeArray  将表单中的输入组件的name属性和对应的值（放在value中） [{name:&apos;&apos;,value:&apos;&apos;},{...}]
    submit 表单指定submit触发时 执行的处理函数

6、Touch模块
    点按事件：tap singleTap doubleTap longTap
    滑动事件：swipe swipeLeft swipeRight swipeUp swipeDown

7、Effects（Animate）模块
    show/hide/fadeIn/fadeOut/fadeToggle
    animate
</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;一、zeptojs概述&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;目标：实现一个10k以内的非常轻量的移动端用的方便DOM操作的js库
what？ 是一个js库
where？现代高级浏览器（移动端）
why？轻量（放弃了对ie等低端浏览器的支持）
how？类似jQuery的用法 只需要
    
    </summary>
    
      <category term="学习笔记" scheme="www.wangchengzou.cn/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="App" scheme="www.wangchengzou.cn/tags/App/"/>
    
      <category term="Zetpojs" scheme="www.wangchengzou.cn/tags/Zetpojs/"/>
    
  </entry>
  
  <entry>
    <title>javaScript高级知识</title>
    <link href="www.wangchengzou.cn/2017/07/22/javaScript%E9%AB%98%E7%BA%A7%E7%9F%A5%E8%AF%86/"/>
    <id>www.wangchengzou.cn/2017/07/22/javaScript高级知识/</id>
    <published>2017-07-22T15:48:26.000Z</published>
    <updated>2017-07-31T00:07:33.953Z</updated>
    
    <content type="html"><![CDATA[<p>错误处理:</p>
<pre><code>错误bug: 程序执行过程中，导致程序无法正常执行的情况
后果: 程序会强行中断退出
错误处理: 即使程序出现错误，也保证程序不异常中断的机制。
如何: try{//始终执行
       //可能出错的代码
     }catch(err){//只有发生错误时才执行
       //err: 错误对象: 发生错误时，自动创建的，封装错误信息的对象
       //出错时，执行的错误处理代码:
         //比如: 通知用户，记录日志，保存进度
     }[finally{//无论是否出错，都必须执行的代码
       //一般用于释放资源
     }]//可有可无，因为放在try catch之后的代码本来就总是执行的。
问题: 放在try catch中的代码，执行效率会降低
解决: 2种:
  1. 尽量少的将代码放入try catch
  2. 如果可提前预知错误原因，可用if...else代替try catch，提前预防错误。

抛出自定义异常:
throw new Error(&quot;错误信息&quot;)

js中错误对象的类型: 6种
  SyntaxError: 语法错误: 程序的语法写错了
  ReferenceError: 引用错误: 要用的变量没找到
  TypeError: 类型错误: 错误的使用对象的类型:
     比如: 对非数组使用[]
           对非函数使用()
           对null/undefined用.xxx
           要调用的函数，对象中没有:
             比如: console.write();
                  document.log();
  RangeError: 范围错误: 参数值超规定范围:
         比如: toFixed(d) d: 0~20之间 如果写-2

  URIError, EvelError;
</code></pre><p>Functions:</p>
<pre><code>创建: 3种:
  1. 声明: function 函数名(参数列表){
            函数体;
            return 返回值;
          }
     问题: 被声明提前
     解决:
  2. 函数直接量: var函数名=function (参数列表){...}
     优点: 不会被声明提前
     揭示: 函数是一个引用类型的对象
           函数名只是一个引用函数对象的普通变量
  3. 用new: 了解
    var函数名=new Function(&quot;参数&quot;,&quot;参数&quot;,&quot;函数体;...&quot;)
 鄙视: 以下创建函数方式正确的是:
    function fun(a,b){return a-b};
    var fun=function(a,b){return a-b};
    var fun=new Function(a,b,&quot;return a-b&quot;); X
    var fun=new Function(&quot;a&quot;,&quot;b&quot;,&quot;return a-b&quot;);
</code></pre><p>重载: overload</p>
<pre><code>什么是: 相同函数名，不同参数列表的多个函数，在调用时可自动根据传入参数的不同，选择对应的函数执行。
为什么: 减少API的名字，减轻调用者的负担
何时: 只要一项任务，可能根据不同的参数执行不同的逻辑时。
问题: js语法默认不支持重载
     为什么: js中不允许多个相同名称的函数同时存在
            后定义的同名函数，会覆盖先定义的。
解决: 2步:
 1. 将多个函数合并为一个函数，省略参数列表
 2. 函数内，用arguments接住所有传入的变量值
   arguments: 每个函数中自动创建的
             自动接收所有参数值的类数组对象
    类数组对象: 长的像数组的对象:
      vs 数组: 相同: 1. 下标, 2. length, 3. for遍历
              不同: 类型不同, 类数组对象不能使用数组的API
      比如: childNodes  children

 参数变量依然必要:
   1. 参数变量可指导调用者正确的使用函数
   2. 参数名都是有意义的，便于维护/提高程序可读性
   3. 自定义的参数名通常简洁
</code></pre><p>匿名函数:</p>
<pre><code>什么是: 定义函数时，不指定函数名的函数
为什么: 节约内存!
何时: 只要一个函数只使用一次时
  2种:
    1. 回调callback: 将一个函数作为参数传给另一个函数中调用
       比如: arr.sort(function(a,b){return a-b;})
            str.replace(reg,function(kw){return ......})
            addEventListener(&quot;click&quot;,function(){...})
            setInterval/Timeout(function(){...}, ms )
    特例: 如果函数可能被反复调用或可能被多个元素共享时，应该用有名的函数。
    2. 匿名函数自调:
    定义一个函数后，立刻调用该函数，调用后立即释放
    何时: 划分临时作用域，避免全局变量污染时
    如何: 2种:
      1. (function([参数列表]){...})([参数值])
      2. +function(...){}(...)
</code></pre><p>作用域和作用域链:</p>
<pre><code>作用域(scope): 变量的可用范围
  包含2种:
    1. 全局作用域对象window
       全局变量: 优: 可重复使用，随处可用
                 缺: 极易造成全局污染
                    ——今后尽量避免使用全局变量
    2. 函数作用域对象AO
       局部变量: 优: 仅函数内可用，不会造成全局污染
                 缺: 不可重用！
作用域链(scope chain):
 什么是: 由各级作用域对象连续引用，形成的链式结构
 函数的声明周期:
   1. 程序开始执行前:
      程序会创建全局作用域对象window
   2. 定义函数时
      在window中创建函数名变量引用函数对象
      函数对象的隐藏属性scope指回函数来自的全局作用域对象window——就好像人的祖籍
   3. 调用函数时
      创建本次函数调用时使用的AO对象
      在AO对象中添加函数的局部变量
      设置AO的隐藏属性parent 指向函数的祖籍作用域对象。——执行时，如果AO中没有的变量可延parnet向祖籍作用域对象找。
   4. 函数调用后
      函数作用域对象AO释放
        导致AO中局部变量释放
 作用域链: 2项任务：
   1. 保存了所有的变量
   2. 控制了变量的使用顺序: 先用局部，局部没有才延作用域链向下查找。
</code></pre><p>闭包(closure)</p>
<pre><code>什么是: 即重用变量，又保护变量不被污染的一种结构
为什么: 全局变量: 优: 可重用, 缺: 全局污染
        局部变量: 优: 不会被污染, 缺: 不可重用
何时: 只要希望重用一个变量，并保护变量不被污染。
如何: 3步:
  1. 使用外层函数包裹受保护的变量和操作变量的内层函数
  2. 外层函数将内层函数返回到外部
  3. 调用者用外部变量接住返回的内层函数
问题: 闭包结构比普通函数占用更多的内存: 外层函数的函数作用域对象
解决: 使用完闭包后，要主动释放闭包:
  将引用内层函数的外部变量置为null

鄙视: 画简图:
  1. 找受保护的变量:
      是外层函数的局部变量
      同时, 在内层函数中被使用
  2. 找外层函数都返回了哪些内层函数用于操作受保护的变量: 2种手段:
    1. return function
    2. 可直接给一个全局变量赋值一个function
</code></pre><p>什么是面向对象: 程序中都是用对象结构来描述现实中一个具体事务的属性和功能</p>
<pre><code>为什么: 便于维护
何时: 今后几乎所有大型项目都采用面向对象的思想
如何: 三大特点: 封装，继承，多态
</code></pre><p>封装: 用一个对象结构集中保存现实中一个事物的多个属性和功能。</p>
<pre><code>什么是对象: 封装一个事物的属性，并提供操作事物的功能的数据结构。
为什么: 现实中任何一个数据或一项功能都属于一个具体事物。——便于维护
何时: 今后只要使用面向对象的方式，首先都要创建对象。
如何: 3种:
 1. 对象直接量: var obj={
                 属性名:值,
                    ... : ... ,
                   方法:function(){
                     ...this.属性名...
                   }
                    ... : ...
               }
     属性，其实就是保存在对象中的一个普通变量
     方法，其实就是保存在对象中的一个普通函数
     问题: 对象自己的方法，通常要使用对象自己的属性值
       错误: 直接使用属性名当变量
       正确: this: 引用正在调用函数的.前的对象的关键词
         今后，只要对象自己的方法要使用对象自己的属性，必须用this.属性名

    访问对象的成员: 成员=属性+方法
    访问属性: 对象.属性名  用法和普通变量完全一样
      特殊: 要访问的属性不存在，不报错！
           返回undefined
    调用方法: 对象.方法名() 用法和普通函数完全一样！
 2. 用new: 2步:
    var obj=new Object(); //先创建一个空对象
    obj.属性名=属性值;//再向空对象中添加属性和方法
    obj.方法名=function(){
      ...this.属性名...
    }
   其实js中的对象可在任何时候添加新属性和方法
   特殊: 要赋值的属性不存在，不报错!
         而是在对象中动态添加该属性
js中对象的本质，就是关联数组。
  其实访问成员: 对象[&quot;属性名&quot;]
                对象[&quot;方法名&quot;]()
    . vs [] : 如果要访问的属性名是固定的，就用.访问
         如果要访问的属性名是动态生成的，就用[]
    问题: 只能创建一个单独的对象
          反复创建多个相同结构的对象时，代码重复严重
    解决: 构造函数
3. 用构造函数反复创建多个相同结构的对象
什么是构造函数: 描述同一类型的所有对象共同成员结构的函数。
为什么: 代码重用！
何时: 只要反复创建同一类型的多个对象时
如何: 2步:
 1. 定义构造函数:
    function 类型名(属性参数列表){
       this.属性名=参数;
             ... = ... ;
       this.方法名=function(){
         ...this.属性名...
       }
    }
 2. 调用构造函数创建一个对象:
    var obj=new 类型名(属性值列表)
原理: new: 4件事:
  1. 创建新的空对象，将构造函数中的this-&gt;新对象
  2. 让新对象自动继承构造函数的原型对象
  3. 执行构造函数中的语句，向新对象中添加新成员并赋值
  4. 返回新对象地址保存到变量中
</code></pre><p>继承: 父对象的成员，子对象无需重复创建，就可直接使用。</p>
<pre><code>为什么: 代码重用，节约内存
如何:
原型对象: 集中保存同一类型的子对象共有成员的父对象
    创建: 在定义构造函数时，自动创建(买一赠一)
    如何:
      1. 使用构造函数创建子对象时，会自动设置子对象继承构造函数的原型对象
      2. 放在原型对象中的成员，所有子对象共用
    如何访问构造函数的原型对象:
      构造函数.prototype.成员名=值/function(){...}
总结: 今后，只要希望所有子对象共有的成员，都要添加到构造函数的原型对象中。而不应该放在构造函数内。

共有属性和自有属性:
  共有属性: 添加到原型对象中，所有子对象共有的属性
  自有属性: 直接保存在对象本地的属性
  访问: 读取: 两者用法完全相同: 对象.属性
             先在对象本地找，没有，才去父对象中找
        修改: 自有属性: 对象.属性=值
              共有属性: 子对象不允许修改共有属性
                  必须通过构造函数
                  构造函数.prototype.属性=值
  判断属性是否可用/包含:
    &quot;成员&quot;  in 对象
    返回bool
       强调: in不仅判断自有属性，而且判断父对象中的共有属性。

内置对象的原型对象:
内置对象，也有构造函数和原型对象
  构造函数负责创建指定类型的对象
  原型对象负责保存该类型子对象共有的API
  解决新旧浏览器API兼容性问题: 2步:
    1. 判断当前浏览器是否支持API
    2. 如果不支持，就自定义一个API放入该类型的原型对象中

原型链: 由多级父对象逐级继承形成的链式结构
  保存了所有对象的成员(属性和方法)
  定义了成员的使用顺序:
     先用自有成员, 自己没有，才延原型链向父对象查找
  vs 作用域链:
     保存了所有变量(全局/局部)
     定义了变量的使用顺序: 先用局部，没有，才延作用域链先父级作用域查找
总结: 只要不需要对象. 就可直接访问的变量都存在作用域链。
      只要必须用对象.才能访问的对象成员都存在原型链中。
</code></pre><p>多态: 同一个方法，在不同情况下表现出不同的状态。</p>
<pre><code>js中仅支持重写(override)
什么是重写: 如果子对象觉得父对象的成员不好用，可自定义自有成员，覆盖父对象中的成员。
为什么: 从父对象继承来的成员，不一定总是想要的
何时: 只要子对象觉得父对象的成员不好用
</code></pre><p>自定义继承:</p>
<pre><code>1. 仅修改两个对象间的继承关系
   Object.setPrototypeOf(child, father)
    让child继承father( 设置child的__proto__继承father)
   问题: 一次只能修改一个对象的继承关系
   解决:
2. 修改构造函数的原型对象来修改所有子对象的父对象
    构造函数.prototype=新father
   强调: 必须在创建子对象之前更换

3. 两种类型间的继承:
  问题: 如果两种类型间有部分相同的属性结构和方法
  优化: 3步:
    1. 定义抽象父类型:
         父类型构造函数中定义公共的属性结构
         父类型原型对象中定义公共的方法
    2. 在子类型构造函数中借用父类型构造函数
      错误: 直接调用父类型构造函数()
        因为如果一个函数没有用new或任何对象.调用，则this默认-&gt;window
      正确: 用call/apply，将父类型构造中的this临时替换为子类型构造函数中的this
        父类型构造.call(this,参数....)
    3. 设置子类型的原型对象继承父类型的原型对象
</code></pre><p>ES5: 保护对象:</p>
<pre><code>保护属性:
  命名属性: 可用.直接访问的属性
    数据属性: 实际存储属性值的属性
      如何保护: 每个属性其实由四大特性组成:
        {
         value: 值, //实际存储属性值
         writable: true, //控制是否可修改
         enumerable:true,//控制是否可用for in遍历到
                       //即使不能for in，用.也能访问
         configurable:true,//控制是否可修改其他特性
                        //控制能否删除该属性
                        //改为false后不可逆
        }
      获取一个对象的属性的四大特性:
      Object.getOwnPropertyDescriptor(obj,&quot;属性名&quot;)
      修改一个对象的属性的四大特性:
      Object.defineProperty(obj,&quot;属性名&quot;,{
        特性名:特性值,
           ... : ... ,
      });
      问题: 一次只能修改一个属性
      解决: 同时修改多个属性
      Object.defineProperties(obj,{
        属性名:{
          特性名:特性值,
             ... : ...
        },
        属性名:{
          特性名:特性值,
             ... : ...
        },
      })
      强调: 必须启用严格模式才能报错！
      问题: 只能进行简单的保护，无法自定义保护规则
      解决:
    访问器属性: 不实际存储属性值，仅提供对另一个属性值的保护。
     何时: 只要使用自定义规则保护属性时
     如何定义: 2步:
       1. 必须先定义一个隐藏的属性来实际存储属性值
       2. 定义访问器属性，提过对受保护的属性的读写操作和验证。
       Object.defineProperty(obj,&quot;属性名&quot;,{
         get:function(){
            return //受保护的属性值
         },
         set:function(val){
            //如果val符合规则
              受保护的属性=val
            //否则
              抛出自定义错误
         },
         enumerable:true, configurable:true,
       })
       强调:访问器属性中要使用对象自己的属性，也必须加this.
       如何使用: 访问器属性的用法和普通属性的用法完全一样。
         只不过: 获取访问器属性值时，自动调用get方法，实际获得的是受保护的隐藏属性的值
                修改访问器属性值时，自动调用set方法，自动将新值传给val，
                经过验证才，实际保存到受保护的隐藏属性中。
   内部属性: 不可用.访问的属性: __proto__
   防篡改: 防止在对象创建后，修改对象的结构/内容
  3个级别:
  1. 防扩展: 禁止给对象添加任何新属性
    Object.preventExtensions(obj);
  2. 密封: seal 在防扩展基础上，再禁止删除现有属性
    Object.seal(obj)
    相当于将所有属性的configurable特性都改为false
  3. 冻结: 禁止对对象做任何修改(包括结构和值)
    Object.freeze(obj);
    三件事: 1. 禁止扩展
           2. 修改所有属性的configurable为false
           3. 修改所有属性的writable为false
</code></pre><p>数组API: 3组</p>
<pre><code> 1. 判断: 判断数组中的元素是否符合要求:
   every: 判断数组中的元素是否*都*符合要求:
     如何: var bool=arr.every(function(val,i,arr){
            //val, 当前元素值
            //i, 当前位置
            //arr, 当前数组
            return 判断条件
          })
   some: 判断数组中是否*包含*符合要求的元素:
 2. 遍历: 对每个元素执行相同操作
   forEach: 对原数组中每个元素执行相同操作
          直接修改原数组
     arr.forEach(function(val,i,arr){
       arr[i]=新值;
     })
   map: 取出原数组中每个元素，执行相同操作后，放入一个新数组中返回
          不修改原数组，仅返回新数组
     var 新数组=arr.map(function(val,i,arr){
       return 新值;
     });
 3. 过滤和汇总:
   过滤: 筛选出原数组中符合条件的元素组成新数组。
         原数组不变。
     var subArr=arr.filter(function(val,i,arr){
       return 判断条件
     })
   汇总: 将数组中每个元素的值，汇总成一个最终结果
     返回值: 一个汇总结果
     var result=arr.reduce(function(prev,val,i,arr){
       return prev+val;//累加
     },base);
  问题: 仅简化了代码，未提高程序的性能
       所有遍历API中使用的都是for循环遍历每个元素

Object.create方法: 直接用父对象创建子对象，并扩展子对象的自有属性:
  何时: 如果只有父对象，也想创建子对象时
  如何:  var child=Object.create(father,{
           新属性:{四大特性},
              ... : ...
         });
</code></pre><p>call/apply/bind: 替换函数中不想要的this</p>
<pre><code>  call/apply : 临时替换函数中的this
   差别: call，要求传入函数的参数必须单独传入
        apply, 要求传入函数的参数必须放入数组中整体传入。apply会将数组打散为单个参数值分别传入
  强调: call/apply相当于调用函数，立刻执行。
  bind: 永久绑定函数中的this
   3件事: 1. 创建一个和原函数功能完全一样的新函数
          2. 将新函数中的this永久绑定为指定对象
          3. 将新函数中的部分固定参数提前永久绑定
   强调: bind绑定在新函数中的this，无法被call/apply再替换。

  总结: 如果临时调用一个函数，立刻执行时——call/apply
        如果创建一个函数提前绑定this时，不一定立刻执行时——bind

严格模式:
  1. 禁止给未声明的变量赋值
  2. 将静默失败升级为错误
</code></pre><p>ES6: 模板字符串: 简化字符串拼接</p>
<pre><code>何时: 只要一个字符串需要动态拼接而成时
如何: 反引号
let: 解决声明提前的问题
何时: 今后只要声明一个变量，首选let
特点: 2个:
  1. let会将变量的作用域，限制在一个块内部
      ——增加了块级作用域
  2. let之前不允许再出现未声明的同名变量
      ——避免了声明提前
</code></pre><p>箭头函数: 简化所有回调函数:</p>
<pre><code>如何:
  1. 去掉function，在()和{}之间加=&gt;
  2. 更简化:
    如果只有一个参数，可省略()
      如果没有参数，必须保留()
    如果函数体只有一句话，可省略{}
      如果函数体只有一句话，且是return，可省了{}和return

强调: 箭头函数简写后，函数中的this和外部this一致了
  所以: 当回调函数内外的this不相同时，不能使用箭头函数简化。
  反之: 如果希望函数内外公用一个this时，就可用箭头函数简化回调函数。
</code></pre><p>for…of: 简化普通for循环遍历:</p>
<pre><code>for(var i=0;i&lt;arr.length;i++){
  arr[i] //当前元素值
}
for(var val of arr){
  val //当前元素值
}
问题1: 仅适用于读取元素值的情况，不能修改原数组元素。
问题2: 只能遍历数字下标的索引数组和类数组对象。不能遍历关联数组中的元素值。
</code></pre><p>class: 简化: 封装,继承,多态</p>
<pre><code>创建一个类型:
  1. 用class结构包裹构造函数和原型对象方法, 将类型名定义在class后
  2. 构造函数的function 函数名，改为constructor
  3. 所有原型方法省略&quot;类型.prototype&quot;和&quot;=function&quot;
两种类型间的继承:
  1. 不再需要Object.setPrototype
     而是class 子类型 extends 父类型
  2. 借用构造函数不再用call/apply，而用super(...)
     其中super中省略this
</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;错误处理:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;错误bug: 程序执行过程中，导致程序无法正常执行的情况
后果: 程序会强行中断退出
错误处理: 即使程序出现错误，也保证程序不异常中断的机制。
如何: try{//始终执行
       //可能出错的代码
     }catch
    
    </summary>
    
      <category term="学习笔记" scheme="www.wangchengzou.cn/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="javaScript" scheme="www.wangchengzou.cn/tags/javaScript/"/>
    
  </entry>
  
  <entry>
    <title>bootStrap基础知识</title>
    <link href="www.wangchengzou.cn/2017/07/22/bootStrap/"/>
    <id>www.wangchengzou.cn/2017/07/22/bootStrap/</id>
    <published>2017-07-22T15:48:26.000Z</published>
    <updated>2017-07-23T13:23:05.120Z</updated>
    
    <content type="html"><![CDATA[<p>webstorm<br>    lorem 随机测试文本</p>
<p>1、响应式网页</p>
<pre><code>responsive web page  一个页面可以在电脑浏览器中浏览也可以在手机平板中浏览，并且配合不同设备有不同的响应结果
响应式网页特点：
    页面上的图片和文字要随着屏幕尺寸发生改变
    页面的布局随着屏幕尺寸而发生改变
如何测试响应式网页
    使用真实的物理设备
        优势：测试结果真实
        不足：设备太多，成本太大，测试任务量大
        方法：搭建本地服务器，部署项目 ，移动终端与服务接入相同网络
    使用三方模拟设备
        优势：无须添加更多设备
        不足：效率偏低，加载慢
    使用浏览器自带模拟器（emulator）
        优势：功能丰富
        不足：****
视口-viewport
    IOS中的safari最早引入的概念
    移动设备中，浏览器里显示网页的一块区域（Pc端会忽略）
    对于响应式网页，设置视口的信息：
        视口的宽度：要与设备宽度一致
        视口的缩放倍率：设置为1，即为不缩放
        视口的手动缩放：不允许缩放网页
    在html中指定视口信息：
        &lt;meta name=&quot;viewport&quot; content=&quot; &quot;&gt;
            视口的宽度：width
                取值：device-width
                     具体数值
            视口的初始缩放倍率：initial-scale
                取值：1  原始大小
            视口是否允许手动缩放：user-scalable
                取值：1、0、yes、no
        &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width,initial-scale=1,user-scalable=no&quot;&gt;
        快键--meta:vp
        以上代码，移动端必备！！！！
</code></pre><p>2、如何编写响应式网页</p>
<pre><code>必须声明视口
文字必须使用相对尺寸（em/rem），尽量不用绝对尺寸(px)
    css中的1px并不代表真实物理设备的1px
    EM    :父元素字体大小倍数
    REM  ：根元素字体大小倍数
容器元素使用相对尺寸（%，auto），尽量不用绝对尺寸(px)
图片使用相对尺寸（%,auto）,尽量不用绝对尺寸（px）
页面元素使用流式布局
    流式布局特点：
        元素默认靠向容器的左上方
        横向排列，排列不下则换行
    方法：float 浮动
         display:inline-block; 行内块
响应式网页都要使用CSS3 Media Query技术，最重要
</code></pre><p>3、CSS3 Media Query</p>
<pre><code>作用：可以根据不同的媒体类型以及特性执行不同的css
    Media:媒体，指浏览网页设备的类型，
        如：screen(pc/pad/phone),tv,tty
    语法：通过@media 规则进行声明
        @media MEDIA-TYPE and|not|only (MEDIA-FEATURE)
        MEDIA-TYPE:媒体类型
            取值：all 默认值，所有设备
                 screen ：电脑屏幕，智能手机 平板电脑
                 tv     :电视设备
        MEDIA-FEATURE:媒体特性
            取值：width:指定浏览器窗口大小
                 min-width:指定浏览器窗口宽度的最小值
                 max-width:指定浏览器窗口宽度的最大值
@media用法：
    有选择性的执行某个外部CSS文件
    &lt;link rel=&quot;&quot; href=&apos;&quot; media=&quot;screen&quot;&gt;
    &lt;link rel=&quot;&quot; href=&quot;&quot; media=&quot;screen&quot;and(max-width:px)&gt;
        不足：即使不满足当前设备条件的css文件也会被请求，但不会生效
    有选择性执行CSS片段中的内容
        在样式表中 @media screen and(max-width:px){
                        选择器{属性：值}
                    }
常见屏幕尺寸：
    超小屏幕（Extra Small:xs）
        width&lt;=767px
    小型屏幕（Small: sm）
        768&lt;=width&lt;=991px
    中型屏幕（Medium:md）
        992&lt;=width&lt;=1199px
    大型屏幕(Large:lg)
        width&gt;=1200px

大公司成型的大型框架（BOOT STRAP）开发公司Twitter
    官网：http://getbootstrap.com
    中文官网:http://www.bootcss.com
    重点： bootstrap.css   提供了上千个class  依赖于JS库-jquery
</code></pre><p>4、 bootstrap 第一步 起步</p>
<pre><code>基本模板：
    &lt;html lang=&quot;zh-cn&quot;&gt; 指定当前文件的基础语言
        作用：为浏览器的自动翻译功能指定语言基础
             为读屏软件指定基础发音
    &lt;meta name=&quot;viewport&quot;&gt;  必须
    &lt;meta http-equiv=&quot;x-ua-compatible&quot; content=&quot;ie=edge&quot;&gt;
        x-ua-compatible
            cross useragent compatible 跨（IE）浏览器兼容性
                指定用哪个IE的内核进行页面渲染
            IE=6  指定用IE6内核渲染页面
            IE=7  ...
            ..
            IE=edge  采用IE最新内核渲染页面
    两个Js 必须引用
          html5shiv.min.js  第三方的JS 自调函数，用于让老IE支持html5新标记（IE8以下）
          respond.min.js    第三方的JS 自调函数，用于让老IE支持CSS3媒体查询技术，响应式必备
          通过头部引用HACK判断是否为IE8以下的浏览器
              &lt;!--[if lt IE 9]&gt;
                 &lt;script src=&quot;***.js&quot;&gt;&lt;/script&gt;
             &lt;![endif]--&gt;
    两个JS 引用页面
        jquery.js  引入到页面中（先）
        bootstrap.js 引入到页面中（后）
        建议:尽量将以上两个文件放在页面最底端引入
</code></pre><p>5、 bootstrap 第二步， 全局CSS样式</p>
<pre><code>BOOTSTRAP 默认将屏幕分成四大类
    大型PC屏幕LG  width:1200px
    中型PC屏幕md  1199--992px
    小型PAD屏幕SM  768---991px
    超小型phone屏幕xs width:767px
bootstrap 提供两种容器
    定宽容器
    在大小不同的设备上，提供不同的width固定值
    类：container
        lg:width:1170px
        md:width:970px
        sm:width:750px
        xs:width:100%
变宽容器
    在任何设备中，宽度都是100%
    类：container-fluid
        width:100%
</code></pre><p>6、 bootstrap 按钮</p>
<pre><code>.btn
.btn-default 白底深色字
.btn-danger/success/warning/info/primary   五种不同颜色按钮
.btn-lg/sm/xs   几种大小按钮
.btn-block     块级按钮
</code></pre><p>7、 bootstrap 列表</p>
<pre><code>.list-unstyled 不带标识的列表
.list-inline   行内列表
.dl-horizontal 定义列表
</code></pre><p>8、 bootstrap 图像图片</p>
<pre><code>.img-rounded        圆角边框图像
.img-circle            圆形边框图像
.img-thumbnail        带几像素内边距边框图像缩进图片
.img-responsive     响应式布局图片
</code></pre><p>9、 bootstrap 表格</p>
<pre><code>.table
.table-bordered        带边框表格
.table-striped        隔行变色
.table-hover        悬停突出效果
.table-responsive    响应式表格   需要加在表格父元素
</code></pre><p>10、 bootstrap 文本和排版</p>
<pre><code>文本颜色
.text-danger
.text-success
.text-warning
.text-info
.text-primary
文本背景颜色
.bg-danger
.bg-success
.bg-warning
.bg-info
.bg-primary
文本大小写
.text-uppercase     全大写
.text-lowercase        全小写
.text-capitalize    首字母大写
文本对齐方式
.text-left
.text-center
.text-right
浮动
.pull-left        左浮动
.pull-right        右浮动
.clearfix        清浮动
</code></pre><p>11、 bootstrap 栅格布局</p>
<pre><code>table 布局
    好处:简单，容易控制
    不足:效率低
div+css 布局
    好处：效率高，
    不足：太灵活，不易控制
栅格布局
    好处：效率高 易控制轻松实现响应式
    不足：。。。。
    实际上就是由div组成的table样式的响应式结构
使用方法：
    系统最外层，必须是bootstrap提供的容器
        .container  .container-fluid
    允许在容器中放置若干行  div.row
        每行中最多等分为12列
    行中放置 div.col 即列，每列都需要指定宽度 1/12 n/12
        语法：&lt;div class=&quot;container&quot;&gt;
                &lt;div class=&quot;row&quot;&gt;
                    &lt;div class=&quot;col-*-*&quot;&gt;&lt;/div&gt;
                &lt;/div&gt;
            &lt;/div&gt;

    列 根据适用屏幕分成四个类型        N最大12列宽
        .col-xs-n   在超小屏幕中占N列宽
        .col-sm-n   在小型屏幕中占N列宽
        .col-md-n      在中型屏幕中占N列宽
        .col-lg-n   在大型屏幕中占N列宽
    列偏移数量
        每个列都可以指定向右偏移几列数量
        .col-xs-offset-n       在超小屏幕中当前列向右偏移N列距离
        .col-sm-offset-n
        .col-md-offset-n
        .col-lg-offset-n


    栅格布局系统可以嵌套
        .container&gt;.row.col-*_*&gt;.row&gt;.col-*-*

    适用于不同屏幕的列的class(xs/sm/md/lg)可以兼容更大的屏幕
        大屏幕class不能适应小屏幕  会垂直显示
        小屏幕class可适应大屏幕

    可以在一个div中指定在不同屏幕下的宽度占比
        &lt;div class=&quot;col-xs-9 col-sm-6 col-md-3&quot;&gt;&lt;/div&gt;

    指定列在特定屏幕下不显示
        .hidden-lg  在lg下隐藏
        .hidden-md
        .hidden-sm
        .hidden-xs
</code></pre><p>12、 全局样式  表单</p>
<pre><code>默认表单
    .form-group            定义表单控件组
    .form-control        定义表单控件
    .control-label        定义控件对应的label
    .help-block            定义提示文本

行内表单
    为&lt;form&gt;添加class=&quot;form-inline&quot;其它同上

水平表单
    水平表单=表单+栅格布局系统
    栅格：最外层：.container/.container-fluid
         行：.div.row
         列：.div.col-*-*

    水平表单栅格系统
        最外层：form.form-horizontal/.container
        行：div.form-group/div.row
        列：div.col-*-*
</code></pre><p> bootstrap</p>
<p> 13、    下拉菜单</p>
<pre><code>&lt;select&gt; &lt;option&gt;&lt;/option&gt;&lt;/select&gt;

外层必须是.dropdown/.dropup  或position:relative;
内层：为&lt;button&gt;或&lt;a&gt;
    class=“dropdown-toggle”
    data-toggle=&quot;dropdown&quot;        切换内容和隐藏
内层内容：ul 或 div 来组成
    class=&quot;dropdown-menu&quot;

    li.divider:      分割线效果
    li.disabled:    禁用菜单项
    li.dropdown-header    标题
</code></pre><p> 14、导航菜单</p>
<pre><code>标签页式导航
    &lt;ul class=&quot;nav nav-tabs&quot;&gt;
        &lt;li class=&quot;active&quot;&gt;
            &lt;a href=&quot;#&quot; data-toggle=&quot;tab&quot;&gt;...&lt;/a&gt;
        &lt;/li&gt;
    &lt;/ul&gt;
li.active        默认被激活
li.data-toggle=&quot;data&quot;    允许切换并且指定切换方式
</code></pre><p>15、图标字体</p>
<pre><code>在页面中，显示为图标，本质上是文字，可以设置字体，颜色，大小
在web程序中常用的图标字体：
    giyphicons 字体，收费中，
    fontawesome  免费

由于客户端不具备bootstrap中的图标字体，所以使用自定义的图标字体，必须声明
在服务器端做以下操作：
    ***.css
    声明字体
    @font-face{font-family:名称： src:url(地址)}
    对使用字体图标的选择器进行声明
    .glyphicon{ font-family:&quot;名称&quot;}

使用方法：    必须为空元素
    &lt;span class=&quot;glyphicon glyphicon-**&quot;&gt;&lt;/span&gt;
</code></pre><p>16、按钮组</p>
<pre><code>将多个按钮放在一个组中（btn-group）
    &lt;div&gt; class=&quot;btn-group&quot;
        &lt;button class=&quot;btn btn-deftult&quot;&gt;***&lt;/button&gt;
        &lt;button class=&quot;btn btn-deftult&quot;&gt;***&lt;/button&gt;
        &lt;button class=&quot;btn btn-deftult&quot;&gt;***&lt;/button&gt;
        &lt;button class=&quot;btn btn-deftult&quot;&gt;***&lt;/button&gt;
    &lt;/div&gt;
将一组btn-group 组合进一个.btn-boolbar(按钮工具栏)
按钮组尺寸
    .btn-group 增加.btn-group-** lg/md/sm/xs
两端对齐按钮组
    .btn-group .btn-group-justified
垂直放置的按钮组
    .btn-group-vertical
</code></pre><p>17、警告框</p>
<pre><code>允许将任意字符与可选的关闭按钮组合在一起的结构
所有警告框依赖于.alert
.alert
.alert-warning
...
...

允许关闭的警告框
    .alert-dismissible
    &lt;div class=&quot;alert alert-danger alert-dismissible&quot;&gt;
        lorem
        &lt;button class=&quot;close&quot; data-dismiss=&quot;alert&quot;&gt;&amp;times;&lt;/button&gt;
    &lt;/div&gt;
警告框中的链接
    &lt;a class=&quot;alert-link&quot;&gt;&lt;/a&gt;
</code></pre><p>18、面包屑导航/路径导航</p>
<pre><code>.breadcrumb
&lt;ul class=&quot;breadcrumb&quot;&gt;
    &lt;li&gt;
        &lt;a href=&quot;#&quot;&gt;首页&lt;/a&gt;
    &lt;/li&gt;
    &lt;li&gt;
        &lt;a href=&quot;#&quot;&gt;产品大全&lt;/a&gt;
    &lt;/li&gt;
&lt;/ul&gt;
</code></pre><p>19、分页条</p>
<pre><code>.pagination
.active : 被激活的页码
&lt;ul class=&quot;pagination&quot;&gt;
    &lt;li&gt;
        &lt;a href=&quot;#&quot;&gt;上一页&lt;/a&gt;
    &lt;/li&gt;
    &lt;li&gt;
        &lt;a href=&quot;#&quot;&gt;1&lt;/a&gt;
    &lt;/li&gt;
    &lt;li class=&quot;active&quot;&gt;
        &lt;a href=&quot;#&quot;&gt;2&lt;/a&gt;
    &lt;/li&gt;
    &lt;li&gt;
        &lt;a href=&quot;#&quot;&gt;...&lt;/a&gt;
    &lt;/li&gt;
    &lt;li&gt;
        &lt;a href=&quot;#&quot;&gt;下一页&lt;/a&gt;
    &lt;/li&gt;
&lt;/ul&gt;
</code></pre><p>20、分页器</p>
<pre><code>.pager
&lt;ul class=&quot;pager&quot;&gt;
&lt;/ul&gt;
</code></pre><p>21、标签</p>
<pre><code>所有的标签都依赖于 .label
.label
.label-default
.label-danger
.label-success
...
&lt;span class=&quot;label label-danger&quot;&gt;标签内容&lt;/span&gt;
</code></pre><p>22、徽章</p>
<pre><code>.badge
&lt;span class=&quot;badge&quot;&gt;35&lt;/span&gt;
</code></pre><p>23、巨幕</p>
<pre><code>.jumbotron
</code></pre><p>24、页头</p>
<pre><code>允许为 标题元素 增加适当的空间,与其他元素有一定的间隔
.page-header
</code></pre><p>25、Well (水井)</p>
<pre><code>.well
</code></pre><p>26、进度条</p>
<pre><code>外层：.progress
内层：
    .progress-bar
    .progress-bar-danger
    .progress-bar-success
    ...
    .progress-bar-striped
    .active : 被激活的
    通过 给内层元素 增加 style=&quot;width:50%&quot; 增加宽度
</code></pre><p>27、缩略图</p>
<pre><code>.thumbnail
.caption
&lt;div class=&quot;thumbnail&quot;&gt;
    &lt;img&gt;
    &lt;div class=&quot;caption&quot;&gt;
        &lt;p&gt;文本1&lt;/p&gt;
        &lt;p&gt;文本2&lt;/p&gt;
        &lt;p&gt;按钮&lt;/p&gt;
    &lt;/div&gt;
&lt;/div&gt;
</code></pre><p>28、媒体对象</p>
<pre><code>&lt;div class=&quot;media&quot;&gt;
    &lt;div class=&quot;media-left&quot;&gt;
        &lt;img&gt;
    &lt;/div&gt;
    &lt;div class=&quot;media-body&quot;&gt;
        &lt;h2 class=&quot;media-heading&quot;&gt;标题&lt;/h2&gt;
        形容的文本
    &lt;/div&gt;
    &lt;div class=&quot;media-right&quot;&gt;
        &lt;img&gt;
    &lt;/div&gt;
&lt;/div&gt;
</code></pre><p>29、列表组</p>
<pre><code>ul : class=&quot;list-group&quot;
li : class=&quot;list-group-item&quot;
</code></pre><p>30、面版</p>
<pre><code>呈现头部 主体 尾部 结构的组件
&lt;div class=&quot;panel panel-default panel-primary&quot;&gt;
    &lt;div class=&quot;panel-heading&quot;&gt;
        &lt;h2 class=&quot;panel-title&quot;&gt;标题文本&lt;/h2&gt;
    &lt;/div&gt;
    &lt;div class=&quot;panel-body&quot;&gt;
        主体内容
    &lt;/div&gt;
    &lt;div class=&quot;panel-footer&quot;&gt;
        脚注内容
    &lt;/div&gt;
&lt;/div&gt;
</code></pre><p>31、导航条</p>
<pre><code>基本导航条
    .navbar .navbar-default
    有需要的话允许增加div.container
    .navbar-header,内部允许包含class带有.navbar-brand&lt;a&gt;元素
    允许向导航条中添加链接列表，只需要增加
导航条中的表单
    导航中的表单不适用bootstrap中默认class使用时.navbar-form,配合.navbar-left/.navbar-right
导航条中的按钮
    class.navbar-btn 允许向不在form中的button(a)增加样式
导航条中的文本
    普通文本的话，需要增加class.navbar-text属性来设置样式
组件的对齐方式
    允许通过.navbar-left 实现左浮动
    允许通过.navbar-right 实现右浮动
导航栏的固定
    不会随着滚动条发生滚动，一直在可视化区域中
    固定在页面顶端：.navbar-fixed-top
    固定在页面底端：.navbar-fixed-bottom
    注意：最好为body设置内边距至少50px
</code></pre><p>32、 JS插件plugin</p>
<pre><code>Bootstrap 基于 jQuery ，在jQuery 基础上提供了十几个插件函数，
        每个都是一个独立的JS文件,可以一次性引入全部的JS操作 - bootstrap.js
每个插件函数都有两种调用方式：
1、data-* 方式调用
    &lt;a data-toggle=&quot;dropdown&quot;&gt;&lt;/a&gt;
2、JS编程方式
    手动编写JS代码完成行为的调用
    &lt;script&gt;
        $(&quot;选择器&quot;) : 在 Javascript(jQuery) 中获取页面指定选择器的元素
            $(&quot;#id&quot;)
            $(&quot;.class&quot;)
            $(&quot;div p&quot;)
        下拉列表：
         $(&quot;选择器&quot;).dropdown();
    &lt;/script&gt;
3、警告框
    父元素 class =&quot;alert alert-danger alert-dismissible&quot;
    关闭：&lt;button class=&quot;close&quot; data-dismiss=&quot;alert&quot;&gt;&lt;/button&gt;
    JS :
        $(&quot;关闭选择器&quot;).click(function(){
            $(this).alert(&quot;close&quot;);
        });
4、按钮
    1、设置按钮的操作文本
        为 按钮元素 添加 data-loading-text=&quot;显示的文本&quot;
        &lt;button class=&quot;btn btn-default&quot; data-loading-text=&quot;请稍后....&quot;&gt;文本&lt;/button&gt;

        //点击按钮时，改变按钮的文字为 data-loading-text
        $(&quot;按钮选择器&quot;).click(function(){
            $(this).button(&quot;loading&quot;);
        });


    2、设置 单选按钮 / 复选框
        1、将 若干 单选按钮 / 复选框 放到 btn-group中  ， 为btn-group增加属性 data-toggle=&quot;buttons&quot;
5、工具提示
    为元素增加
        data-toggle=&quot;tooltip&quot;
        data-palcement=&quot;top/right/bottom/left&quot;
        title=&quot;提示的文本&quot;
    配合 JS 代码
        $(&quot;选择器&quot;).tooltip();
6、弹出框
    为元素增加
        data-toggle=&quot;popover&quot; //指定为弹出框方式
        data-placement=&quot;top/right/bottom/left&quot;//方向
        data-content=&quot;弹出框内容区域的文本&quot;
        title=&quot;弹出框的标题&quot;;
    配合 JS 代码如下:
        $(&quot;选择器&quot;).popover();
7、标签页
    1、为导航组件里面 a 增加：
        1、data-toggle = &quot;tab&quot;
        2、href=&quot;#对应元素内容的ID&quot;
    2、创建内容组
        1、class 为 tab-content
        2、在 内容组中 增加对应显示的内容模块
            1、增加id属性
            2、增加 class=&quot;tab-pane active&quot;
    ex:
        &lt;div class=&quot;container&quot;&gt;
            &lt;ul class=&quot;nav nav-tabs&quot;&gt;
                &lt;li class=&quot;active&quot;&gt;
                    &lt;a href=&quot;#tab1&quot; data-toggle=&quot;tab&quot;&gt;&lt;/a&gt;
                &lt;/li&gt;
            &lt;/ul&gt;
            &lt;div class=&quot;tab-content&quot;&gt;
                &lt;!-- 内容1 --&gt;
                &lt;div class=&quot;tab-pane&quot; id=&quot;tab1&quot;&gt;
                    ....
                &lt;/div&gt;
            &lt;/div&gt;
        &lt;/div&gt;
8、模态对话框
    模态对话框：父窗口中弹出一个子窗口，只要子窗口不关闭，父窗口就无法获得输入的焦点
    模态对话框由两部分组成：
    1、触发元素，通常 a / button 组成
        &lt;a href=&quot;#模态框ID&quot; data-toggle=&quot;modal&quot;&gt;&lt;/a&gt;

        &lt;button data-toggle=&quot;model&quot; data-target=&quot;#模态框ID&quot;&gt;&lt;/button&gt;
    2、模态框元素
        // 提供了半透明的遮罩层
        &lt;div class=&quot;modal&quot; id=&quot;&quot; data-backdrop=&quot;static&quot;&gt;
            // 提供了 宽度，高度，定位
            &lt;div class=&quot;modal-dialog&quot;&gt;
                //背景色，边框，倒角，阴影
                &lt;div class=&quot;model-content&quot;&gt;
                    &lt;div class=&quot;modal-header&quot;&gt;
                        &lt;h4&gt;&lt;/h4&gt;
                        &lt;button&gt; ... &lt;/button&gt;
                    &lt;/div&gt;
                    &lt;div class=&quot;modal-body&quot;&gt;
                        显示主题内容
                    &lt;/div&gt;
                    &lt;div class=&quot;modal-footer&quot;&gt;
                        脚注信息
                    &lt;/div&gt;
                &lt;/div&gt;
            &lt;/div&gt;
        &lt;/div&gt;
9、折叠效果
    1、触发元素
        &lt;a data-toggle=&quot;collapse&quot; href=&quot;#id&quot;&gt;&lt;/a&gt;

        &lt;button data-toggle=&quot;collapse&quot; data-target=&quot;#id&quot;&gt;&lt;/button&gt;
    2、被折叠元素
        &lt;div class=&quot;collapse&quot; id=&quot;id&quot;&gt;
            ... ...
        &lt;/div&gt;
    特殊效果：
        1、手风琴(Accordion)
            Accordion = 面板组(panel-group) + 折叠插件
</code></pre><p>33、折叠</p>
<pre><code>响应式导航条
    当屏幕尺寸大于768时候，可以正常显示出所有的内容，
    当屏幕尺寸小于768时候一部分内容就会隐藏，通过点击弹出

响应式导航条由两部分组成
    .navbar-head
        用于显示navbar-brand和折叠点击按钮
        .navbar-brand:定义brand内容
        折叠按钮：屏幕大于768不显示
                屏幕小于768显示
                .navbar-toggle完成以上操作

    .navbar-collapse
        被折叠的内容，当屏幕大于768正常显示
                    当屏幕小于768就隐藏
        通过点击按钮完成展开显示
</code></pre><p>34、广告轮播 carousel</p>
<pre><code>基本class
    .carousel    data-ride=&quot;carousel&quot;
        .carousel-inner
            .item
            img
指定轮播时间
    父元素增加.data-interval=&quot;200s&quot;

图片说明文本
    img图片下放div.carousel-caption
        显示在图片正中间

带方向按钮的轮播
    &lt;a herf=&quot;#carousel的ID&quot;
        class=&quot;carousel-control left
        data-slide=&quot;prev&quot; &gt;
        &lt;span class=&quot;glyphicon glyphicon-chevron-left&quot;&gt;&lt;/span&gt;
    &lt;/a&gt;        这是左边
    &lt;a herf=&quot;#carousel的ID&quot;
        class=&quot;carousel-control right
        data-slide=&quot;next&quot; &gt;
        &lt;span class=&quot;glyphicon glyphicon-chevron-right&quot;&gt;&lt;/span&gt;
    &lt;/a&gt;        这是右边

带数字圆点导航的轮播
    &lt;ul class=&quot;carousel-indicators&quot;&gt;
        &lt;li class=&quot;active
            data-target=&quot;#carousel的ID&quot;
            data-slide-to=&quot;数字值&quot;&gt;
        &lt;/li&gt;
</code></pre><p>35、Less 和 Bootstrap 定制</p>
<pre><code>样式语言的分类
    静态样式语言：css
        可以被浏览器直接解析处理，但CSS并不是合格语言，
        缺少了基本的要素，如：变量 运算符 函数
        可维护维护性差
    动态样式语言：less sass、scSS 、stylus
        不可以被浏览器直接解析处理；必须经过编译（compile）得到CSS文件后才能使用

less语言        http://lesscss.org   中文 http://less.bootcss.com
    less是一本预处理语言，扩充了CSS，在纯静态的CSS基础上增加一部分内容 如：变量 混合，

在web项目中使用less的两种方式：
    在客户端浏览器中编译less，不推荐使用
        编写.less文件
        编写.html 引入.less再引入less.js
        浏览器访问.html会自行下载文件，并且在客户端进行编译转换成.css
    在服务器端编译less   推荐使用
        编写.less
        在服务器端搭建less编译器，把.less转换为CSS
        编写HTML直接引入CSS文件

搭建less服务器端编译环境   ！！！
    less编译器实际上是由JavaScript编写
    安装独立的js解释器 node.exe
        命令行中：执行 node -v显示：版本号
    在webstrorm中配置filewatchers（文件监视器）
        由ws自动检测less文件的编写与更改，自动进行编译，得到CSS文件
        配置filewatchers
        ws--&gt;file--&gt;settings--&gt;toos--&gt;filewiathcers
        --&gt;添加选择less--&gt;指定lessc.cmd文件地址
less语法
    less完全支持CSS语法
    less支持多行注释和单选注释，只有多行注释能被编译到CSS中
        多行：/***/
        单选：//注释  只一行
    less支持变量（variable）
        变量：在less中可以变化的数据
        语法：@变量名：值；
        使用变量：变量作为值，出现在CSS属性名称后
            @变量名;
    less变量可以使用运算符 +  - * % /

less支持在一组样式中混入另一种样式 名称为混合（mixin） 嵌套
    带参数的混合：声明选择器的时候，允许使用参数来表示暂时不确定的数据，在调用时将具体数值传递进来
        语法：选择器（@参数名1，@参数名2）{
                        width：@参数名1
                        height：@参数名2
                    }
    使用带参混合写法：
        选择器2{
            选择器（值1，值2）
        }
    使用默认值的混合写法：
        选择器2 (参数名1：默认值，参数名2：默认值){
              选择器（值1，值2）
       }
       当没有设定值时，为默认值输出，有设定值时，为设定值输出

嵌套规则
    在less中，允许在一个选择器内再声明另一个选择器，以便完成父子或后代结构
    语法：选择器1{
            --；
            --；
            选择器2{
                ---；
                ---；
            }
        }
    编译结果为
         选择器1{
             ---；
         }
         选择器1 选择器2{
             ---；
         }

    声明子代嵌套：选择器1{
                       --；
                       --；
                       &gt;选择器2{
                           ---；
                           ---；
                       }
                   }

less中提供的功能函数
    lighten（@color，20%）    返回一个变亮的颜色值(颜色减淡)
    darken(@color，30%)         返回一个变暗的颜色值（颜色加深）
    image-width(&quot;**.jpg&quot;)    返回指定图片的宽度
    image-height(&quot;**.jpg&quot;)    返回指定图片的高度
    ceil（@num）                对数字向上取整 返回四舍五入
    floor（@num）            对数字向下取整
    percentage（@num）        返回小数转换为%数字

@import功能
    在less中的@import，在服务器端将多个less文件内容整合一个less文件中
    语法：  @import&quot;***.less&quot;;
</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;webstorm&lt;br&gt;    lorem 随机测试文本&lt;/p&gt;
&lt;p&gt;1、响应式网页&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;responsive web page  一个页面可以在电脑浏览器中浏览也可以在手机平板中浏览，并且配合不同设备有不同的响应结果
响应式网页特点：
    
    
    </summary>
    
      <category term="学习笔记" scheme="www.wangchengzou.cn/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="bootStrap" scheme="www.wangchengzou.cn/tags/bootStrap/"/>
    
  </entry>
  
  <entry>
    <title>hexo使用基础知识</title>
    <link href="www.wangchengzou.cn/2017/07/22/hexo/"/>
    <id>www.wangchengzou.cn/2017/07/22/hexo/</id>
    <published>2017-07-22T15:48:26.000Z</published>
    <updated>2017-07-23T15:10:17.259Z</updated>
    
    <content type="html"><![CDATA[<p>安装</p>
<pre><code>$ npm install -g hexo-cli
Hexo 将会在指定文件夹
$ hexo init
新建完成后 文件夹的目录如下
    .
    ├── _config.yml
    ├── package.json
    ├── scaffolds
    ├── source
    |   ├── _drafts
    |   └── _posts
    └── themes
</code></pre><p>配置</p>
<pre><code>_config.yml 中修改大部份的配置
title    网站标题
subtitle    网站副标题
description    网站描述
author    您的名字
language    网站使用的语言
timezone    网站时区。Hexo 默认使用您电脑的时区。时区列表。
    比如说：America/New_York, Japan, 和 UTC 。
网站存放在子目录
    例如 http://yoursite.com/blog，则请将您的 url 设为 http://yoursite.com/blog 并把 root 设为 /blog/
</code></pre><p>目录</p>
<pre><code>source_dir    资源文件夹，这个文件夹用来存放内容。    source
public_dir    公共文件夹，这个文件夹用于存放生成的站点文件。    public
tag_dir    标签文件夹    tags
archive_dir    归档文件夹    archives
category_dir    分类文件夹    categories
code_dir    Include code 文件夹    downloads/code
i18n_dir    国际化（i18n）文件夹    :lang
skip_render    跳过指定文件的渲染，您可使用 glob 表达式来匹配路径。
</code></pre><p>文章</p>
<pre><code>new_post_name    新文章的文件名称    :title.md
default_layout    预设布局    post
auto_spacing    在中文和英文之间加入空格    false
titlecase    把标题转换为 title case    false
external_link    在新标签中打开链接    true
filename_case    把文件名称转换为 (1) 小写或 (2) 大写    0
render_drafts    显示草稿    false
post_asset_folder    启动 Asset 文件夹    false
relative_link    把链接改为与根目录的相对位址    false
future    显示未来的文章    true
highlight    代码块的设置
</code></pre><p>分类 &amp; 标签</p>
<pre><code>default_category    默认分类    uncategorized
category_map    分类别名
tag_map    标签别名
</code></pre><p>日期 / 时间格式</p>
<pre><code>date_format    日期格式    YYYY-MM-DD
time_format    时间格式    H:mm:ss
</code></pre><p>分页</p>
<pre><code>per_page    每页显示的文章量 (0 = 关闭分页功能)    10
pagination_dir    分页目录    page
</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;安装&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ npm install -g hexo-cli
Hexo 将会在指定文件夹
$ hexo init
新建完成后 文件夹的目录如下
    .
    ├── _config.yml
    ├── package.json
    ├
    
    </summary>
    
      <category term="学习笔记" scheme="www.wangchengzou.cn/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="打包" scheme="www.wangchengzou.cn/tags/%E6%89%93%E5%8C%85/"/>
    
      <category term="hexo" scheme="www.wangchengzou.cn/tags/hexo/"/>
    
  </entry>
  
  <entry>
    <title>Angular基础知识</title>
    <link href="www.wangchengzou.cn/2017/07/22/Angular/"/>
    <id>www.wangchengzou.cn/2017/07/22/Angular/</id>
    <published>2017-07-22T15:48:26.000Z</published>
    <updated>2017-07-27T12:53:02.708Z</updated>
    
    <content type="html"><![CDATA[<p>1、设计原则和设计模式</p>
<pre><code>拙劣的设计：
①僵化
②脆弱
③不必要的复杂
④晦涩。。

1、YAGNI（不要写不需要的代码）
you aren&apos;t gonna need it

2、KISS （越简单越好）
keep it simple and stupid
语义化的标记、命名规则、减少嵌套

3、DRY（善于使用封装和重用）
Don&apos;t Repeat Yourself

4、高内聚 低耦合（High cohesion,low coupling）
内聚：一个组件（模块）内部的不同部分的关系
耦合：不同组件（模块）之间的关系

5、SRP 单一责任原则
Single Responsibility Principle
实现功能的时候，尽可能的做到每一个模块实现一个单一的功能

6、OCP原则(对于扩展开放、对于修改关闭)
open close principle

7、LCP（迪米特法则）
Least Knowledge Principle 最少知识法则：封装的功能单位要尽可能的小，尽量做到只与自己相关

常用的设计模式分为3大类：①创建 ②结构 ③行为

常用的设计模式：工厂方法模式、单例模式、组合模式、迭代子模式、适配器。。
先去实现功能，在迭代的过程中优化代码。
</code></pre><p>2、AngularJS</p>
<pre><code>认识新东西最好的方式：
①官网
②维基百科 wikipedia.org
what?--ng(AngularJS)是一个开源的js框架
where？--用来实现SPA应用程序（单一页面应用程序single page application）
Gmail邮箱是由Google退出的前端历史中第一个SPA应用
why？
四大特征：
①采用了MVC的设计模式
Model 模型数据
View  视图
Controller 控制器
</code></pre><p>3、MVC的工作原理：</p>
<pre><code>View视图 接收用户的输入，通过控制器（Controller）当中的方法，完成对于Model的增删改查的操作。
1.数据绑定：将数据和视图绑定起来，一旦数据被修改了，视图就会更新
2.双向数据绑定
    数据-》视图
    视图用户的输入 -》 数据
3.依赖注入
4.模块化设计
</code></pre><p>4、使用ng</p>
<pre><code>1、基本语法
    &lt;any&gt;{{表达式}} &lt;/any&gt;
    直接按照上述方法写，结果是不对的，解决方案：在html标签写上了ng-app

2、常用指令
    ngApp
        ①启动ng
        ②指定作用范围，将指令写在根标签
    快捷键：在webStorm中alt+f2,快速选中要去执行在哪个浏览器。
    ngInit 指令 来完成数据的初始化
    &lt;any ng-init=&quot;num=2&quot;&gt;&lt;/any&gt;
        ①不需要在通过ngInit指令定义数据时候，加上var关键字
        ②ngInit所初始化的变量是可以在整个html去使用变量
</code></pre><p>5、常用指令</p>
<pre><code>ng中指令：由angularJS提供了，可以用在html中作为扩展属性、扩展标签。。

作为扩展属性来使用：
    &lt;div ng-**&gt;&lt;/div&gt;
    ngInit  --&gt; ng-init
    ngApp --&gt; ng-app
作为扩展标签来使用：
    &lt;ngView/&gt;
①ngApp
    启动ng
    指定作用范围，将指令写在根标签
    注意事项：调用一次ngApp
②ngInit
    通过ngInit调用一次，初始化多个变量？？
    &lt;any ng-init=&quot;a=1;b=2&quot;/&gt;
③ngRepeat
    重复实例化模板
    两种语法：
    &lt;any ng-repeat=&quot;临时变量的名称 in 集合的名称&quot;&gt;&lt;/any&gt;
    &lt;any ng-repeat=&quot;（key,value） in 集合的名称&quot;&gt;&lt;/any&gt;

    注意事项：在使用ngRpeat的时候要遍历的集合默认是不允许有重复的数据，
        可以通过 track by $index来指定一个不会重复的值就可以解决报错的问题。

④ngIf、ngShow、ngHide、ngSrc、ngDisabled、ngChecked
    ngIf-》选择是否要显示出来（挂载到DOM，从DOM中删除）
    ngShow/ngHide -&gt;选择是否要显示出来(显示或者隐藏)
    &lt;any ng-if=&quot;表达式&quot;&gt;&lt;/any&gt;
    &lt;any ng-show=&quot;表达式&quot;&gt;&lt;/any&gt;
    &lt;any ng-hide=&quot;表达式&quot;&gt;&lt;/any&gt;
    注意事项：在使用ngSrc去读取变量中值的时候，要记得加上双花括号
    &lt;img ng-src=&quot;img/{{imgUrl}}&quot; /&gt; 如果你写的不是ngSrc而是src，显示是ok的，
    但是控制台是会报错的，通过ngSrc去指定就搞定了
    &lt;any ng-disabled=&apos;表达式&apos;&gt;&lt;/any&gt;
    &lt;input type=&apos;checkbox&apos; ng-checked=&quot;表达式&quot;/&gt;
</code></pre><p>6、MVC</p>
<pre><code>在ng中：
    Model 模型数据：在ng中定义的一些变量
    View  视图：通过ng指令和表达式增强版的html
    Controller 控制器：负责数据的增删改查的
MVC的好处:在实现大型应用程序，可以通过将视图和数据隔离开，有效的降低代码的复杂度、耦合度
在ng中应该怎么做才能实现一个SPA？
准备工作：
①创建一个模块
    因为在ng中是以模块为基本单位的
    var app = angular.module(&apos;模块的名称&apos;，[&apos;依赖模块1&apos;,&apos;依赖模块2&apos;])
②使用模块
    采用ngApp指令
    &lt;html ng-app=&quot;模块的名称&quot;&gt;&lt;/html&gt;
③创建一个控制器
    app.controller(&apos;控制器的名称&apos;,function(){})
    第二个参数时控制器被调用时，要执行的方法
④调用控制器
    采用ngController指令来调用控制器
    &lt;div ng-controller=&apos;控制器的名称&apos;&gt;&lt;/div&gt;
    实现数据的创建和显示等：
⑤操作数据、显示出来

$scope是一个对象，称之为作用域对象，是一个非常重要的概念，
    建立起控制器中的数据和控制器的所指定的视图的桥梁

绑定事件的时候，在ng的做法： &lt;any ng-eventName=&quot;handle()&quot;&gt;
&lt;button ng-click=&quot;handleClick()&quot;&gt;&lt;/button&gt;

注意事项：
由于ngInit和$scope都可以完成数据的初始化，建议使用$scope,因为ngInit会增加代码的耦合度和复杂度。
</code></pre><p>7、ng是由很多指令的：</p>
<pre><code>ngApp ngRepeat ngIf ngShow ngHide ngChecked ngDisabled ngSrc
ngBind ngClass ngStyle

在webStorm中创建一个文件模板的基本步骤：
①拷贝要使用的代码
②点击左上角的file，选择new
③选择Edit File Templates
④点击弹窗中右上角的+号
⑤修改name和extension为创建的文件模板的名称以及格式，点击ok保存即可
</code></pre><p>8、自定义指令</p>
<pre><code>1、如何自定义？？
    angular.module()
    app.controller()
    //创建指令
    app.directive(&apos;指令的名称&apos;，function(){
        return {}
    })
    指令的命令规则：指令的名称由两部分构成，前缀：一般使我们模块或者项目的名字缩写；
    后缀：用来描述指令的功能
    属性：
    template：指定要显示的模板内容
    restrict: &quot;EAC&quot; //E(Element)A(Attribute)C(Class)M(Comment)
    replace: true,替换并显示出来
    scope

2、如何使用自定义的指令？？
    注意事项：指令在命名时是要遵循驼峰式命名规则；在使用时要遵循烤串式用方
    &apos;tsHello&apos; --&gt; ts-hello
    根据配置指令时的restrict属性所对应的值，在合适的场景下使用指令。

3、自定义指令传递参数
    怎么传？
        在调用指令的时候可以传 将参数作为属性对应的值
    怎么接受？
        scope
</code></pre><p>9、双向数据绑定</p>
<pre><code>方向1：从&apos;数据&apos;绑定到&apos;视图&apos;
绑定方式：
①常用指令： ngRepeat/ngIf/ngShow...
②双花括号：{{}}

方向2：从‘视图中用户的输入’绑定到‘数据’
绑定方式：指令：ngModel

如果要监听数据的变化：
$scope.$watch(&apos;txt&apos;,function(){

})

在实现下拉框的过程中，如果数据是动态的，可以通过ngOptions将数据绑定到视图中。
ngOptions语法：
 &lt;select
    ng-model=&quot;city&quot;
    ng-options=&quot;city.cityName for city in cities&quot;&gt;
 &lt;/select&gt;
</code></pre><p>10、过滤器</p>
<pre><code>a.内置的过滤器
    ng中的过滤器为了实现对于表达式结果的筛选、过滤、格式化，达到更好的表现效果。
    过滤器的语法：支持多重过滤和传参
    {{expression | 过滤器名称 : '参数' | 过滤器名称2：‘参数’ }
            | => 管道
            常用的过滤器：
                currency 货币样式的过滤器
                date 日期
                uppercase/lowercase 大小写的处理
                orderBy 对指定的数组进行升序或者降序排列
                number 格式化数字为文本（对有小数点的数据的处理）
                limitTo 限定数组或者字符串要显示的个数
        b.自定义过滤器
            自定义过滤器方式：
            app.filter('过滤器名称',function(){
                return function(input，arg){
                        //input是传递给过滤器的数据
                        //arg 是过滤器本身的参数
                    return '过滤后的结果'
                }
            })
            使用自定义的过滤器:
            和内置的过滤器用法是一样的

11、ng模块内置的方法

        序列化、反序列化
        toJson:将对象或者数组 序列化 为json格式的字符串
        fromJson：相反的过程

12、服务

    服务的本质是一个单例对象，提供数据和对象。
    两大类：
    ①内置服务
        $location、$http、$window、$scope...
        使用内置服务中提供的方法：
            第一步 将需要用到的服务注入进来 function($scope,$location)
            第二步 调用服务中提供的方法 数据。。
    ②自定义的服务
        面试题：$scope与$rootScope之间的关系
        1、不同的控制器之间的数据是彼此隔离的
        2、不同的控制器之间如何共享数据？？
        $scope的id是从2开始依次往上递增，
        id为1的是谁？ $rootScope是根作用域对象，其余的$scope都是子对象
            方式1：借助于$rootScope
                把要共享的数据存在$rootScope,所有的子对象就可以读取该数据
            方式2：借助于控制器之间的嵌套
                在调用控制器的元素 之间的嵌套关系
                @@div ng-controller='myCtrl02'>
                    @@<div ng-controller="myCtrl03"></div>
                @@
            方式3：触发事件传递参数
                绑定事件：
                $scope.$on('事件名称',function(event,data){

                })
        触发事件：
        //从子作用对象 向 父作用域对象 传递事件
        $scope.$emit()
        //从父作用对象 向 子作用域对象 传递事件
        $scope.$broadcaset()

13、服务

        双向数据绑定的工作原理：
        绑定时，ng会自动添加一个监听watcher,当数据发生变化时，会执行更新DOM操作的函数。
        怎么知道数据发生了变化？
        在ng中有一个循环$digest,会不断的对比数据，
        需要手工的触发循环做对比，可以通过：
        $scope.$digest();
        $scope.$apply();//触发$rootScope.$digest();

14、ng内置的服务：

        $location $scope $rootScope $window $interval $timeout
        1、在ng中定时器相关的处理--》$interval $timeout
        2、$http
        $http({method:'',url:''}).success().error()
        $http.get()
        $http.post()
        注意：如果需要发起post请求，需要设置:
         app.run(function ($http) {
                $http.defaults.headers.post =
        {'Content-Type':'application/x-www-form-urlencoded'};})

        在发起post请求时，如果需要对参数进行序列化:
        借助于$httpParamSerializer服务，首先注入进来，$httpParamSerializer（obj）。

15、自定义服务

        服务的目的是为了封装业务逻辑，提高代码的复用率
        自定义指令 app.directive
        自定义过滤器 app.filter
        自定义服务的方法：
        app.factory ('服务名称',function(){//普通方法 return {}})
app.service(&apos;服务名称&apos;,function(){//构造函数})
app.constant(&apos;服务名称&apos;，{})//创建常量服务
app.value(&apos;服务名称&apos;，{})//创建变量服务

注意事项：
自定义的服务 需要用到其它服务中方法
图：两个按钮：开始 结束。
</code></pre><p>16、依赖注入</p>
<pre><code>将代码部署到线上，都会对代码做压缩。
使用YUI-Compressor.jar （有java的运行环境）
①借助于CLI（command line）
    java -jar yui**.jar  c:\demo10.js &gt; c:\demo10.min.js

②IDE（webStorm）
    file-&gt;settings-&gt;tools-&gt;fileWathchers-&gt;+-&gt;选中YUI-Compressor JS，
    在弹窗中的program选中对应的jar，保存即可
压缩效果：
会删除所有的注释、删除没有语义的空白字符、尽可能的简化变量的名称（混淆），
但是数字、字符串、关键字是不会改变的。

解决压缩后的问题方式：
依赖注入：将依赖的服务或者其他，通过参数形式注入进来，背后ng框架会帮助对服务等做实例化的操作，
让我们可以去直接使用

注入的方式：
①推断式（猜测）
    这种方式在进行压缩会有问题
    app.controller(&apos;myCtrl&apos;,function($scope){});

②标记式
    由于文件压缩时，关键数据 字符串 关键字等不会被处理的；将所需要用到的服务，
    存在一个字符串（服务名称）数组。
    注意事项：在数组中服务名称的顺序和创建对应的处理函数参数的顺序是要保持一致的
    实现方式：
    1、将处理函数单独的存在一个变量中
    2、给变量设置$inject，值是一个由字符串构成的数组
    3、使用服务即可
③行内式（内联式）
    在构建一个ng对象时，允许将一个字符型数组 作为对象的参数，
    在数组中可以：服务名称、函数（必须是在数组的最后一个元素）
    app.controller(&apos;myCtrl&apos;,[&apos;$scope&apos;,function($scope){}])
    依赖注入3种方式，官方推荐采用行内式依赖注入。
    依赖注入的背后：$injector 注入器：快速的定位到应用需要用到的各种该服务，
    整个ng应用的注入对象都是由$injector定位和创建。
    $injector.has(&apos;服务名称&apos;) ==》判断指定的服务是否存在
    $injector.get(&apos;服务名称&apos;) ==》 得到指定的服务对应的实例
</code></pre><p>17、模块化设计</p>
<pre><code>ng有4大特征：
①MVC
②双向数据绑定
③依赖注入
④模块化设计

高内聚低耦合，在ng中有两种：①内置的模块 ②自定义的模块

如何自定义模块？
angular.module();

使用模块？
ng-app=&quot;&quot;
在创建模块时，在第二个参数所对应的数组中写上服务的名称

一个ng的模块都可以包含哪些？
控制器：对应部分业务逻辑的封装
服务：经常用到的重复代码封装
指令：扩展html标签、属性
过滤器：针对数据做一些筛选 过滤 格式化的处理
</code></pre><p>18、ngRoute（路由模块）</p>
<pre><code>ng是主要实现SPA（单一页面应用程序）
SPA的工作原理：
    1、页面url
    http://127.0.0.1/index.html#/路由地址
    例如：http://127.0.0.1/index.html#/start
    2、解析index.html 是一个完整的html页面，再解析路由地址(start)
    3、在路由词典中寻找路由地址(start)所对应的路由信息
    4、在路由信息所对应的对象中找到真实的模板页面地址
    5、（发起异步ajax）加载模板页面到指定的容器中，实现局部刷新

ngRoute（路由模块）可以定义路由词典，自动解析路由地址，查找路由词典，
自动发起ajax请求加载页面显示。
    0、在创建自定义模块，在依赖列表中指定ngRoute
    1、指定盛放代码片段的容器
    2、配置路由词典

使用ngRoute的基本步骤：
①创建一个完整的html页面
    记得引入angular.js angular-route.js

②创建模块，并指定依赖于ngRoute模块
    angular.module(&apos;myApp&apos;,[&apos;ng&apos;,&apos;ngRoute&apos;])

③使用指令创建一个盛放代码片段的容器
    调用ngView指令：创建一个容器，代码片段会加载到这里

④创建模板页面

⑤配置路由词典
    $routeProvider
    when是用来添加一条路由信息的(路由地址的字符串是以/开始)
    $routeProvider.when(&apos;/myStart&apos;,{controller:&apos;&apos;,template/templateUrl:&apos;&apos;})
    otherwise是用来指定异常的处理
    $routePriovder.otherwise({redirectTo:&apos;路由地址&apos;})

SPA在ng实现过程，代码片段的跳转：
①直接修改地址栏中的路由地址
    http://localhost:63342/day4/demo03_SPA%E7%BB%83%E4%B9%A0.html#/myLogin
    http://localhost:63342/day4/demo03_SPA%E7%BB%83%E4%B9%A0.html#/myRegister
②通过js的方式
    $location.path(&apos;路由地址&apos;)
③超链接的方式
    a href=&quot;#/myRegister&quot;
    login-&gt;start 10

SPA应用程序通过ngRoute来传递参数：
①搞明白 发送 接收
②配置接收方的路由
    $routeProvider.when(&apos;/myStart/:num&apos;,{
    templateUrl:&apos;tpl/start.html&apos;
    })
③拿到传递过来的参数
    $routeParams.num
④发送
    a href=&apos;#/myStart/10&apos;
    $location.path(&apos;/myStart/10&apos;)

注意事项：配置接收方路由时的冒号后的变量名称要和通过$routeParams解析参数的属性是要保持一致
    myStart/:id $routeParams.id

练习：实现一个SPA
完整的html manager.html
代码片段： checkProduct.html pay.html send.html

要求：能够实现不同页面的跳转以及参数的传递
checkProduct.html 能够a跳转到pay，传递price，在pay接收传递过来的参数显示在pay页面
pay 点击button跳转到send
send button以及a跳转到check.html

优化思路：如果多个控制器需要用到同一个方法或者数据，
    ①将方法和数据封装成一个服务
    ②$rootScope
    ③控制器之间的嵌套
    ④借助于事件

由于不同的代码片段都显示在了body的子元素中：body是所有代码片段的父元素，可以在body指定控制器，
控制器中的方法和数据，代码片段就可以用了。
①发送 接收
    checkProduct --&gt; pay

②配置接收方路由
    .when(&apos;/myPay/:price&apos;,{})

③$routeParams
    $routeParams.price

④发送参数
    href=&apos;#/myPay/20&apos;
    $location.path(&apos;/myPay/20&apos;)

ngInclude 引入多个地方同时需要用到的，比如页头、页尾。。。

要求：给综合练习的3个代码片段加上头信息(显示一个p标签)

注意事项：在使用ngInclude进行赋值的时候，对应的路径字符串要在双引号内 加上一对单引号
</code></pre><p>19、ngAnimate（动画模块）</p>
<pre><code>在angularJS添加动画效果，需要用到ngAnimate模块
基本步骤：
①引入对应的js文件
    angular-animate.js
②指定自定义模块依赖于ngAnimate
    angular.module(&apos;myModule&apos;,[&apos;ng&apos;,&apos;ngRoute&apos;,&apos;ngAnimate&apos;])
③css给ng应用程序添加动画效果：
    ngEnter 准备进入
    ngEnterActive 进入完成
    ngLeave 准备离开
    ngLeaveActive 离开完成
④引入对应的css文件

如果用到其它的模块整体思路：
    ①在ng每一个模块都有自己的js文件，用到哪个模块，把指定模块的js文件引入进来
    ②在创建模块，指定依赖列表
    ③根据模块中所提供的指令、服务。。结合业务需要进行
</code></pre><p>20、表单验证</p>
<pre><code>在ng中，针对表单和空间提供了属性，用于验证控件交互的状态
布尔类型：
$valid
$invalid
$dirty
$pristine
对象：
$error

注意事项：
①给表单以及表单组件 加上name属性
②给需要用到的表单组件 ，加上ngModel
③属性的用法
myForm.t_age.$dirty/$pristine/$valid/$invalid/$error
</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;1、设计原则和设计模式&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;拙劣的设计：
①僵化
②脆弱
③不必要的复杂
④晦涩。。

1、YAGNI（不要写不需要的代码）
you aren&amp;apos;t gonna need it

2、KISS （越简单越好）
keep it simple 
    
    </summary>
    
      <category term="学习笔记" scheme="www.wangchengzou.cn/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Angular" scheme="www.wangchengzou.cn/tags/Angular/"/>
    
  </entry>
  
  <entry>
    <title>html和css3</title>
    <link href="www.wangchengzou.cn/2017/07/22/css3+HTML5%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    <id>www.wangchengzou.cn/2017/07/22/css3+HTML5面试题/</id>
    <published>2017-07-22T15:48:26.000Z</published>
    <updated>2017-07-28T01:27:39.844Z</updated>
    
    <content type="html"><![CDATA[<p>1、    CSS3有哪些新特性？</p>
<pre><code>1. CSS3实现圆角（border-radius），阴影（box-shadow），
2. 对文字加特效（text-shadow、），线性渐变（gradient），旋转（transform）
3.transform:rotate(9deg) scale(0.85,0.90) translate(0px,-30px)
 skew(-9deg,0deg);// 旋转,缩放,定位,倾斜
4. 增加了更多的CSS选择器  多背景 rgba
5. 在CSS3中唯一引入的伪元素是 ::selection.
6. 媒体查询，多栏布局
7. border-image
</code></pre><ol>
<li>html5有哪些新特性、移除了那些元素？如何处理HTML5新标签的浏览器兼容问题？<br>如何区分 HTML 和 HTML5？<br>新特性：<ol>
<li>拖拽释放(Drag and drop) API</li>
<li>语义化更好的内容标签（header,nav,footer,aside,article,section）</li>
<li>音频、视频API(audio,video)</li>
<li>画布(Canvas) API</li>
<li>地理(Geolocation) API</li>
<li>本地离线存储 localStorage 长期存储数据，浏览器关闭后数据不丢失；</li>
<li>sessionStorage 的数据在浏览器关闭后自动删除</li>
<li>表单控件，calendar、date、time、email、url、search</li>
<li>新的技术webworker, websocket, Geolocation<br>移除的元素：</li>
<li>纯表现的元素：basefont，big，center，font, s，strike，tt，u；</li>
<li>对可用性产生负面影响的元素：frame，frameset，noframes；<br>支持HTML5新标签：</li>
<li>IE8/IE7/IE6支持通过 document.createElement 方法产生的标签，<br>可以利用这一特性让这些浏览器支持 HTML5 新标签，浏览器支持新标签后，<br>还需要添加标签默认的样式（当然最好的方式是直接使用成熟的框架、使用最多的是html5shim框架）：<!--[if lt IE 9]>
<script> src="http://html5shim.googlecode.com/svn/trunk/html5.js"</script>
<![endif]-->
如何区分：<br>DOCTYPE声明新增的结构元素、功能元素</li>
</ol>
</li>
</ol>
<p>3、    本地存储（Local Storage ）和cookies（储存在用户本地终端上的数据）之间的区别是什么？</p>
<pre><code>Cookies:服务器和客户端都可以访问；大小只有4KB左右；有有效期，过期后将会删除；
本地存储：只有本地浏览器端可访问数据，服务器不能访问本地存储直到故意通过POST
或者GET的通道发送到服务器；每个域5MB；没有过期数据，它将保留知道用户从浏览器
清除或者使用Javascript代码移除
</code></pre><p>6、    什么是响应式设计？</p>
<pre><code>它是关于网页制作的过程中让不同的设备有不同的尺寸和不同的功能。
响应式设计是让所有的人能在这些设备上让网站运行正常
</code></pre><p>7、    新的 HTML5 文档类型和字符集是？</p>
<pre><code>HTML5文档类型：&lt;!doctype html&gt;
HTML5使用的编码&lt;meta charset=”UTF-8”&gt;
</code></pre><p>8、    HTML5 Canvas 元素有什么用？</p>
<pre><code>Canvas 元素用于在网页上绘制图形，该元素标签强大之处在于可以直接
在 HTML 上进行图形操作。
</code></pre><p>9、    HTML5 存储类型有什么区别？</p>
<pre><code>Media API、Text Track API、Application Cache API、
User Interaction、Data Transfer API、Command API、
Constraint Validation API、History API
</code></pre><p>11、    CSS3新增伪类有那些？</p>
<pre><code>p:first-of-type 选择属于其父元素的首个 &lt;p&gt; 元素的每个 &lt;p&gt; 元素。
p:last-of-type  选择属于其父元素的最后 &lt;p&gt; 元素的每个 &lt;p&gt; 元素。
p:only-of-type  选择属于其父元素唯一的 &lt;p&gt; 元素的每个 &lt;p&gt; 元素。
p:only-child    选择属于其父元素的唯一子元素的每个 &lt;p&gt; 元素。
p:nth-child(2)  选择属于其父元素的第二个子元素的每个 &lt;p&gt; 元素。
:enabled、:disabled 控制表单控件的禁用状态。
:checked，单选框或复选框被选中。
</code></pre><p>14、    html5\CSS3有哪些新特性、移除了那些元素？如何处理HTML5新标签的浏览器兼容问题？<br>    如何区分 HTML 和 HTML5？</p>
<pre><code>HTML5 现在已经不是 SGML 的子集，主要是关于图像，位置，存储，地理定位等功能的增加。
* 绘画 canvas 元素
  用于媒介回放的 video 和 audio 元素
  本地离线存储 localStorage 长期存储数据，浏览器关闭后数据不丢失；
  sessionStorage 的数据在浏览器关闭后自动删除
  语意化更好的内容元素，比如 article、footer、header、nav、section
  表单控件，calendar、date、time、email、url、search
  CSS3实现圆角，阴影，对文字加特效，增加了更多的CSS选择器  多背景 rgba
  新的技术webworker, websockt, Geolocation
移除的元素
纯表现的元素：basefont，big，center，font, s，strike，tt，u；
对可用性产生负面影响的元素：frame，frameset，noframes；
* 是IE8/IE7/IE6支持通过document.createElement方法产生的标签，
  可以利用这一特性让这些浏览器支持HTML5新标签，
  浏览器支持新标签后，还需要添加标签默认的样式：
* 当然最好的方式是直接使用成熟的框架、使用最多的是html5shim框架
&lt;!--[if lt IE 9]&gt;
&lt;script&gt; src=&quot;http://html5shim.googlecode.com/svn/trunk/html5.js&quot;&lt;/script&gt;
&lt;![endif]--&gt;
</code></pre><p>16、    你能描述一下渐进增强和优雅降级之间的不同吗?</p>
<pre><code>渐进增强 progressive enhancement：针对低版本浏览器进行构建页面，
保证最基本的功能，然后再针对高级浏览器进行效果、交互等改进和追加功能达到更好的用户体验。
优雅降级 graceful degradation：一开始就构建完整的功能，然后再针对低版本浏览器进行兼容。
　　区别：优雅降级是从复杂的现状开始，并试图减少用户体验的供给，而渐进增强则是
从一个非常基础的，能够起作用的版本开始，并不断扩充，以适应未来环境的需要。
降级（功能衰减）意味着往回看；而渐进增强则意味着朝前看，同时保证其根基处于安全地带。　
　
</code></pre><p>19、    请描述一下cookies，sessionStorage和localStorage的区别？<br>　　<br>    　　  sessionStorage用于本地存储一个会话（session）中的数据，<br>    这些数据只有在同一个会话中的页面才能访问并且当会话结束后数据也随之销毁。<br>    因此sessionStorage不是一种持久化的本地存储，仅仅是会话级别的存储。<br>    而localStorage用于持久化的本地存储，除非主动删除数据，<br>    否则数据是永远不会过期的。<br>    web storage和cookie的区别<br>    Web Storage的概念和cookie相似，区别是它是为了更大容量存储设计的。<br>    Cookie的大小是受限的，并且每次你请求一个新的页面的时候Cookie都会被发送过去，<br>    这样无形中浪费了带宽，另外cookie还需要指定作用域，不可以跨域调用。<br>    除此之外，Web Storage拥有setItem,getItem,removeItem,clear等方法，<br>    不像cookie需要前端开发者自己封装setCookie，getCookie。<br>    但是Cookie也是不可以或缺的：Cookie的作用是与服务器进行交互，<br>    作为HTTP规范的一部分而存在 ，而Web Storage仅仅是为了在本地“存储”数据而生。</p>
<p>20、    知道css有个content属性吗？有什么作用？有什么应用？</p>
<pre><code>css的content属性专门应用在 before/after 伪元素上，用来插入生成内容。
最常见的应用是利用伪类清除浮动。
//一种常见利用伪类清除浮动的代码
.clearfix:after {
    content:&quot;.&quot;; //这里利用到了content属性
    display:block;
    height:0;
    visibility:hidden;
    clear:both; }
.clearfix {
    *zoom:1;
}
after伪元素通过 content 在元素的后面生成了内容为一个点的块级素，
再利用clear:both清除浮动。
</code></pre><p>　　<br>21、    如何在 HTML5 页面中嵌入音频?</p>
<pre><code>HTML 5 包含嵌入音频文件的标准方式，支持的格式包括 MP3、Wav 和 Ogg：
&lt;audio controls&gt;
  &lt;source src=&quot;jamshed.mp3&quot; type=&quot;audio/mpeg&quot;&gt;
   Your browser does&apos;nt support audio embedding feature.
&lt;/audio&gt;
</code></pre><p>22、    如何在 HTML5 页面中嵌入视频？</p>
<pre><code>和音频一样，HTML5 定义了嵌入视频的标准方法，支持的格式包括：MP4、WebM 和 Ogg：
&lt;video width=&quot;450&quot; height=&quot;340&quot; controls&gt;
  &lt;source src=&quot;jamshed.mp4&quot; type=&quot;video/mp4&quot;&gt;
   Your browser does&apos;nt support video embedding feature.
&lt;/video&gt;
</code></pre><p>23、    HTML5 引入什么新的表单属性？</p>
<pre><code>Datalist   datetime   output   keygen  date  month  week
time  number   range   emailurl
</code></pre><p>26、    cookie在浏览器和服务器间来回传递。 sessionStorage和localStorage区别</p>
<pre><code>sessionStorage和localStorage的存储空间更大；
sessionStorage和localStorage有更多丰富易用的接口；
sessionStorage和localStorage各自独立的存储空间；
</code></pre><p>30、    HTML5的离线储存？</p>
<pre><code>localStorage    长期存储数据，浏览器关闭后数据不丢失；
sessionStorage  数据在浏览器关闭后自动删除。
</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;1、    CSS3有哪些新特性？&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;1. CSS3实现圆角（border-radius），阴影（box-shadow），
2. 对文字加特效（text-shadow、），线性渐变（gradient），旋转（transform）
3.transf
    
    </summary>
    
      <category term="面试题目" scheme="www.wangchengzou.cn/categories/%E9%9D%A2%E8%AF%95%E9%A2%98%E7%9B%AE/"/>
    
    
      <category term="html" scheme="www.wangchengzou.cn/tags/html/"/>
    
      <category term="H5" scheme="www.wangchengzou.cn/tags/H5/"/>
    
  </entry>
  
  <entry>
    <title>http状态码总表</title>
    <link href="www.wangchengzou.cn/2017/07/22/http%E7%8A%B6%E6%80%81%E7%A0%81/"/>
    <id>www.wangchengzou.cn/2017/07/22/http状态码/</id>
    <published>2017-07-22T15:48:26.000Z</published>
    <updated>2017-07-27T14:13:07.866Z</updated>
    
    <content type="html"><![CDATA[<p>简单版</p>
<pre><code>100  Continue   继续，一般在发送post请求时，已发送了http header之后服务端将返回此信息，表示确认，之后发送具体参数信息
200  OK         正常返回信息
201  Created    请求成功并且服务器创建了新的资源
202  Accepted   服务器已接受请求，但尚未处理
301  Moved Permanently  请求的网页已永久移动到新位置。
302 Found       临时性重定向。
303 See Other   临时性重定向，且总是使用 GET 请求新的 URI。
304  Not Modified 自从上次请求后，请求的网页未修改过。
400 Bad Request  服务器无法理解请求的格式，客户端不应当尝试再次使用相同的内容发起请求。
401 Unauthorized 请求未授权。
403 Forbidden   禁止访问。
404 Not Found   找不到如何与 URI 相匹配的资源。
500 Internal Server Error  最常见的服务器端错误。
503 Service Unavailable 服务器端暂时无法处理请求（可能是过载或维护）。     ]
</code></pre><p>完整版</p>
<pre><code>1**(信息类)：表示接收到请求并且继续处理
   100——客户必须继续发出请求
   101——客户要求服务器根据请求转换HTTP协议版本
2**(响应成功)：表示动作被成功接收、理解和接受
   200——表明该请求被成功地完成，所请求的资源发送回客户端
   201——提示知道新文件的URL
   202——接受和处理、但处理未完成
   203——返回信息不确定或不完整
   204——请求收到，但返回信息为空
   205——服务器完成了请求，用户代理必须复位当前已经浏览过的文件
   206——服务器已经完成了部分用户的GET请求
3**(重定向类)：为了完成指定的动作，必须接受进一步处理
   300——请求的资源可在多处得到
   301——本网页被永久性转移到另一个URL
   302——请求的网页被转移到一个新的地址，但客户访问仍继续通过原始URL地址，
       重定向，新的URL会在response中的Location中返回，浏览器将会使用新的URL发出新的Request。
   303——建议客户访问其他URL或访问方式
   304——自从上次请求后，请求的网页未修改过，服务器返回此响应时，不会返回网页内容，
       代表上次的文档已经被缓存了，还可以继续使用     305——请求的资源必须从服务器指定的地址得到
   306——前一版本HTTP中使用的代码，现行版本中不再使用
   307——申明请求的资源临时性删除
4**(客户端错误类)：请求包含错误语法或不能正确执行
   400——客户端请求有语法错误，不能被服务器所理解
   401——请求未经授权，这个状态代码必须和WWW-Authenticate报头域一起使用
   HTTP 401.1 - 未授权：登录失败     　　
   HTTP 401.2 - 未授权：服务器配置问题导致登录失败     　　
   HTTP 401.3 - ACL 禁止访问资源     　　
   HTTP 401.4 - 未授权：授权被筛选器拒绝
   HTTP 401.5 - 未授权：ISAPI 或 CGI 授权失败
   402——保留有效ChargeTo头响应
   403——禁止访问，服务器收到请求，但是拒绝提供服务
   HTTP 403.1 禁止访问：禁止可执行访问     　　
   HTTP 403.2 - 禁止访问：禁止读访问     　　
   HTTP 403.3 - 禁止访问：禁止写访问     　　
   HTTP 403.4 - 禁止访问：要求 SSL     　　
   HTTP 403.5 - 禁止访问：要求 SSL 128     　　
   HTTP 403.6 - 禁止访问：IP 地址被拒绝     　　
   HTTP 403.7 - 禁止访问：要求客户证书     　　
   HTTP 403.8 - 禁止访问：禁止站点访问     　　
   HTTP 403.9 - 禁止访问：连接的用户过多     　　
   HTTP 403.10 - 禁止访问：配置无效     　　
   HTTP 403.11 - 禁止访问：密码更改     　　
   HTTP 403.12 - 禁止访问：映射器拒绝访问     　　
   HTTP 403.13 - 禁止访问：客户证书已被吊销     　　
   HTTP 403.15 - 禁止访问：客户访问许可过多     　　
   HTTP 403.16 - 禁止访问：客户证书不可信或者无效
   HTTP 403.17 - 禁止访问：客户证书已经到期或者尚未生效
   404——一个404错误表明可连接服务器，但服务器无法取得所请求的网页，请求资源不存在。
   405——用户在Request-Line字段定义的方法不允许
   406——根据用户发送的Accept拖，请求资源不可访问
   407——类似401，用户必须首先在代理服务器上得到授权
   408——客户端没有在用户指定的饿时间内完成请求
   409——对当前资源状态，请求不能完成
   410——服务器上不再有此资源且无进一步的参考地址
   411——服务器拒绝用户定义的Content-Length属性请求
   412——一个或多个请求头字段在当前请求中错误
   413——请求的资源大于服务器允许的大小
   414——请求的资源URL长于服务器允许的长度
   415——请求资源不支持请求项目格式
   416——请求中包含Range请求头字段，在当前请求资源范围内没有range指示值，请求也不包含If-Range请求头字段
   417——服务器不满足请求Expect头字段指定的期望值，如果是代理服务器，可能是下一级服务器不能满足请求长。
5**(服务端错误类)：服务器不能正确执行一个正确的请求
    HTTP 500 - 服务器遇到错误，无法完成请求     　　
    HTTP 500.100 - 内部服务器错误 - ASP 错误     　　
    HTTP 500-11 服务器关闭     　　
    HTTP 500-12 应用程序重新启动     　　
    HTTP 500-13 - 服务器太忙     　　
    HTTP 500-14 - 应用程序无效     　　
    HTTP 500-15 - 不允许请求 global.asa     　　
    Error 501 - 未实现
    HTTP 502 - 网关错误
    HTTP 503：由于超载或停机维护，服务器目前无法使用，一段时间后可能恢复正常
</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;简单版&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;100  Continue   继续，一般在发送post请求时，已发送了http header之后服务端将返回此信息，表示确认，之后发送具体参数信息
200  OK         正常返回信息
201  Created    请求成功
    
    </summary>
    
      <category term="面试题目" scheme="www.wangchengzou.cn/categories/%E9%9D%A2%E8%AF%95%E9%A2%98%E7%9B%AE/"/>
    
    
      <category term="html" scheme="www.wangchengzou.cn/tags/html/"/>
    
      <category term="http" scheme="www.wangchengzou.cn/tags/http/"/>
    
  </entry>
  
  <entry>
    <title>js高级</title>
    <link href="www.wangchengzou.cn/2017/07/22/javaScript%E9%AB%98%E7%BA%A7%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    <id>www.wangchengzou.cn/2017/07/22/javaScript高级面试题/</id>
    <published>2017-07-22T15:48:26.000Z</published>
    <updated>2017-07-28T01:07:55.104Z</updated>
    
    <content type="html"><![CDATA[<p>1、    JQuery一个对象可以同时绑定多个事件，这是如何实现的？</p>
<pre><code>jQuery可以给一个对象同时绑定多个事件，低层实现方式是使用addEventListner
或attachEvent兼容不同的浏览器实现事件的绑定，这样可以给同一个对象注册多个事件。
</code></pre><p>2、    知道什么是webkit么? 知道怎么用浏览器的各种工具来调试和debug代码么?</p>
<pre><code>Webkit是浏览器引擎，包括html渲染和js解析功能，手机浏览器的主流内核，
与之相对应的引擎有Gecko（Mozilla Firefox 等使用）和Trident（也称MSHTML，IE 使用）。
对于浏览器的调试工具要熟练使用，主要是页面结构分析，后台请求信息查看，
js调试工具使用，熟练使用这些工具可以快速提高解决问题的效率
</code></pre><p>10、实现一个函数clone，可以对JavaScript中的5种主要的数据类型（<br>    包括Number、String、Object、Array、Boolean）进行值复制<br>    考察点1：对于基本数据类型和引用数据类型在内存中存放的是值还是指针这一区别是否清楚<br>    考察点2：是否知道如何判断一个变量是什么类型的<br>    考察点3：递归算法的设计<br>    // 方法一：<br>        Object.prototype.clone = function(){<br>           var o = this.constructor === Array ? [] : {};<br>           for(var e in this){<br>            o[e] = typeof this[e] === “object” ? this[e].clone() : this[e];<br>           }<br>           return o;<br>        }<br>    //方法二：<br>      /**</p>
<pre><code> * 克隆一个对象
 * @param Obj
 * @returns
 */
function clone(Obj) {
    var buf;
    if (Obj instanceof Array) {
        buf = [];//创建一个空的数组
        var i = Obj.length;
        while (i--) {
            buf[i] = clone(Obj[i]);
        }
        return buf;
    }else if (Obj instanceof Object){
        buf = {};//创建一个空对象
        for (var k in Obj) { //为这个对象添加新的属性
            buf[k] = clone(Obj[k]);
        }
        return buf;
    }else{ //普通变量直接赋值
        return Obj;
    }
}
</code></pre><p>11、如何消除一个数组里面重复的元素？</p>
<pre><code>var arr=[1,2,3,3,4,4,5,5,6,1,9,3,25,4];
    function deRepeat(){
        var newArr=[];
        var obj={};
        var index=0;
        var l=arr.length;
        for(var i=0;i&lt;l;i++){
            if(obj[arr[i]]==undefined)
              {
                obj[arr[i]]=1;
                newArr[index++]=arr[i];
              }
            else if(obj[arr[i]]==1)
              continue;
        }
        return newArr;
    }
    var newArr2=deRepeat(arr);
    alert(newArr2); //输出1,2,3,4,5,6,9,25
</code></pre><p>12、小贤是一条可爱的小狗(Dog)，它的叫声很好听(wow)，<br>    每次看到主人的时候就会乖乖叫一声(yelp)。从这段描述可以得到以下对象：</p>
<pre><code>    function Dog() {
      this.wow = function() {
               alert(’Wow’);
      }
      this.yelp = function() {
              this.wow();
      }
    }
小芒和小贤一样，原来也是一条可爱的小狗，可是突然有一天疯了(MadDog)，
一看到人就会每隔半秒叫一声(wow)地不停叫唤(yelp)。
请根据描述，按示例的形式用代码来实。（继承，原型，setInterval）
function MadDog() {
this.yelp = function() {
      var self = this;
      setInterval(function() {
            self.wow();
      }, 500);
  }
}
MadDog.prototype = new Dog();
//for test
var dog = new Dog();
dog.yelp();
var madDog = new MadDog();
madDog.yelp();
</code></pre><p>13、下面这个ul，如何点击每一列的时候alert其index?（闭包）</p>
<pre><code>    &lt;ul id=”test”&gt;
        &lt;li&gt;这是第一条&lt;/li&gt;
        &lt;li&gt;这是第二条&lt;/li&gt;
        &lt;li&gt;这是第三条&lt;/li&gt;
    &lt;/ul&gt;
 // 方法一：
    var lis=document.getElementById(&apos;2223&apos;).getElementsByTagName(&apos;li&apos;);
    for(var i=0;i&lt;3;i++)
    {
        lis[i].index=i;
        lis[i].onclick=function(){
            alert(this.index);
        };
    }
//方法二：
    var lis=document.getElementById(&apos;2223&apos;).getElementsByTagName(&apos;li&apos;);
    for(var i=0;i&lt;3;i++){
        lis[i].index=i;
        lis[i].onclick=(function(a){
            return function() {
                alert(a);
            }
        })(i);
    }
</code></pre><p>14、编写一个JavaScript函数，输入指定类型的选择器(仅需支持id，class，tagName<br>    三种简单CSS选择器，无需兼容组合选择器)可以返回匹配的DOM节点，需考虑浏览器兼容性和性能。</p>
<pre><code>/*** @param selector {String} 传入的CSS选择器。* @return {Array}*/
    var query = function(selector) {
var reg = /^(#)?(\.)?(\w+)$/img;
var regResult = reg.exec(selector);
var result = [];
//如果是id选择器
if(regResult[1]) {
if(regResult[3]) {
if(typeof document.querySelector === &quot;function&quot;) {
result.push(document.querySelector(regResult[3]));
    }else {
      result.push(document.getElementById(regResult[3]));
    }
  }
  }
  //如果是class选择器
  else if(regResult[2]) {
   if(regResult[3]) {
      if(typeof document.getElementsByClassName === &apos;function&apos;) {
        var doms = document.getElementsByClassName(regResult[3]);
        if(doms) {
          result = converToArray(doms);
        }
      }
     //如果不支持getElementsByClassName函数
     else {
      var allDoms = document.getElementsByTagName(&quot;*&quot;) ;
       for(var i = 0, len = allDoms.length; i &lt; len; i++) {
         if(allDoms[i].className.search(new RegExp(regResult[2])) &gt; -1) {
           result.push(allDoms[i]);
        }
       }
    }
 }
}
 //如果是标签选择器
 else if(regResult[3]) {
   var doms = document.getElementsByTagName(regResult[3].toLowerCase());
   if(doms) {
     result = converToArray(doms);
   }
 }
 return result;
 }
 function converToArray(nodes){
    var array = null;
    try{
     array = Array.prototype.slice.call(nodes,0);//针对非IE浏览器
   }catch(ex){
    array = new Array();
   for( var i = 0 ,len = nodes.length; i &lt; len ; i++ ) {
     array.push(nodes[i])
   }
  }
  return array;
}
</code></pre><p>16、给String对象添加一个方法，传入一个string类型的参数，然后将string的每个字符间价格空格返回，</p>
<pre><code>例如：addSpace(“hello world”) // -&gt; ‘h e l l o  w o r l d’
String.prototype.spacify = function(){
  return this.split(&apos;&apos;).join(&apos; &apos;);
};
</code></pre><p>17、定义一个log方法，让它可以代理console.log的方法。</p>
<pre><code>可行的方法一：
function log(msg)　{
    console.log(msg);
}
log(&quot;hello world!&quot;) // hello world!
如果要传入多个参数呢？显然上面的方法不能满足要求，所以更好的方法是：
function log(){
    console.log.apply(console, arguments);
};
到此，追问apply和call方法的异同。
对于apply和call两者在作用上是相同的，即是调用一个对象的一个方法，
以另一个对象替换当前对象。将一个函数的对象上下文从初始的上下文改变为
由 thisObj 指定的新对象。
但两者在参数上有区别的。对于第一个参数意义都一样，但对第二个参数：
 apply传入的是一个参数数组，也就是将多个参数组合成为一个数组传入，
 而call则作为call的参数传入（从第二个参数开始）。
 如 func.call(func1,var1,var2,var3)
 对应的apply写法为：func.apply(func1,[var1,var2,var3]) 。
</code></pre><p>18、在Javascript中什么是伪数组？如何将伪数组转化为标准数组？</p>
<pre><code>伪数组（类数组）：无法直接调用数组方法或期望length属性有什么特殊的行为，
但仍可以对真正数组遍历方法来遍历它们。典型的是函数的argument参数，
还有像调用getElementsByTagName,document.childNodes之类的,
它们都返回NodeList对象都属于伪数组。可以使用Array.prototype.slice.call(fakeArray)
将数组转化为真正的Array对象。
</code></pre><p>19、对作用域上下文和this的理解，看下列代码：</p>
<pre><code>var User = {
  count: 1,
  getCount: function() {
    return this.count;
  }
};
console.log(User.getCount());  // what?
var func = User.getCount;
console.log(func());  // what?
问两处console输出什么？为什么？
答案是1和undefined。
func是在winodw的上下文中被执行的，所以会访问不到count属性。
继续追问，那么如何确保Uesr总是能访问到func的上下文，即正确返回1。
正确的方法是使用Function.prototype.bind。兼容各个浏览器完整代码如下：
Function.prototype.bind = Function.prototype.bind || function(context){
   var self = this;
   return function(){
      return self.apply(context, arguments);
   };
}
var func = User.getCount.bind(User);
console.log(func());
</code></pre><p>20、原生JS的window.onload与Jquery的$(document).ready(function(){})有什么不同？<br>    如何用原生JS实现Jq的ready方法？</p>
<pre><code>window.onload()方法是必须等到页面内包括图片的所有元素加载完毕后才能执行。
$(document).ready()是DOM结构绘制完毕后就执行，不必等到加载完毕。
/*
 * 传递函数给whenReady()
 * 当文档解析完毕且为操作准备就绪时，函数作为document的方法调用
 */
var whenReady = (function() {               //这个函数返回whenReady()函数
    var funcs = [];             //当获得事件时，要运行的函数
    var ready = false;          //当触发事件处理程序时,切换为true
    //当文档就绪时,调用事件处理程序
    function handler(e) {
        if(ready) return;       //确保事件处理程序只完整运行一次
        //如果发生onreadystatechange事件，但其状态不是complete的话,那么文档尚未准备好
        if(e.type === &apos;onreadystatechange&apos; &amp;&amp; document.readyState !== &apos;complete&apos;) {
            return;
        }
        //运行所有注册函数
        //注意每次都要计算funcs.length
        //以防这些函数的调用可能会导致注册更多的函数
        for(var i=0; i&lt;funcs.length; i++) {
            funcs[i].call(document);
        }
        //事件处理函数完整执行,切换ready状态, 并移除所有函数
        ready = true;
        funcs = null;
    }
    //为接收到的任何事件注册处理程序
    if(document.addEventListener) {
        document.addEventListener(&apos;DOMContentLoaded&apos;, handler, false);
        document.addEventListener(&apos;readystatechange&apos;, handler, false);
        //IE9+
        window.addEventListener(&apos;load&apos;, handler, false);
    }else if(document.attachEvent) {
        document.attachEvent(&apos;onreadystatechange&apos;, handler);
        window.attachEvent(&apos;onload&apos;, handler);
    }
    //返回whenReady()函数
    return function whenReady(fn) {
        if(ready) { fn.call(document); }
        else { funcs.push(fn); }
    }
})();
如果上述代码十分难懂，下面这个简化版：
function ready(fn){
    if(document.addEventListener) {//标准浏览器
        document.addEventListener(&apos;DOMContentLoaded&apos;, function() {
            //注销事件, 避免反复触发
            document.removeEventListener(&apos;DOMContentLoaded&apos;,arguments.callee, false);
            fn();//执行函数
        }, false);
    }else if(document.attachEvent) {//IE
        document.attachEvent(&apos;onreadystatechange&apos;, function() {
            if(document.readyState == &apos;complete&apos;) {
                document.detachEvent(&apos;onreadystatechange&apos;, arguments.callee);
                fn();//函数执行
            }
        });
    }
};
</code></pre><p>21、（设计题）想实现一个对页面某个节点的拖曳？如何做？（使用原生JS）</p>
<pre><code>1.    给需要拖拽的节点绑定mousedown, mousemove, mouseup事件
2.    mousedown事件触发后，开始拖拽
3.    mousemove时，需要通过event.clientX和clientY获取拖拽位置，并实时更新位置
4.    mouseup时，拖拽结束
5.    需要注意浏览器边界的情况
</code></pre><p>24、    Javascript作用链域?</p>
<pre><code>理解变量和函数的访问范围和生命周期，全局作用域与局部作用域的区别，
JavaScript中没有块作用域，函数的嵌套形成不同层次的作用域，
嵌套的层次形成链式形式，通过作用域链查找属性的规则需要深入理解。
</code></pre><p>25、    谈谈This对象的理解。</p>
<pre><code>理解不同形式的函数调用方式下的this指向，理解事件函数、
定时函数中的this指向，函数的调用形式决定了this的指向。
</code></pre><p>26、    eval是做什么的？</p>
<pre><code>它的功能是把对应的字符串解析成JS代码并运行；应该避免使用eval，
不安全，非常耗性能（2个步骤，一次解析成js语句，一次执行）
</code></pre><p>27、    关于事件，IE与火狐的事件机制有什么区别？ 如何阻止冒泡？</p>
<pre><code>[1].在IE中,事件对象是作为一个全局变量来保存和维护的.所有的浏览器事件,
不管是用户触发的，还是其他事件,都会更新window.event对象.所以在代码中，
只要调用window.event就可以获取事件对象， 再event.srcElement就可以取得
触发事件的元素进行进一步处理.
[2].在FireFox中，事件对象却不是全局对象，一般情况下，是现场发生，现场使用，
FireFox把事件对象自动传给事件处理程序.
关于事件的兼容性处理要熟练掌握，事件对象具体哪些属性存在兼容性问题，IE与标准
事件模型事件冒泡与事件捕获的支持要理解
</code></pre><p>28、    什么是闭包（closure），为什么要用它？</p>
<pre><code>简单的理解是函数的嵌套形成闭包，闭包包括函数本身已经它的外部作用域
使用闭包可以形成独立的空间，延长变量的生命周期，报存中间状态值
</code></pre><p>29、javascript 代码中的”use strict”;是什么意思 ? 使用它区别是什么？</p>
<pre><code>意思是使用严格模式，使用严格模式，一些不规范的语法将不再支持
</code></pre><p>30、如何判断一个对象是否属于某个类？</p>
<pre><code>Instanceof   constructor
</code></pre><p>31、new操作符具体干了什么呢?</p>
<pre><code>1、创建一个空对象，并且 this 变量引用该对象，同时还继承了该函数的原型。
2、属性和方法被加入到 this 引用的对象中。
3、新创建的对象由 this 所引用，并且最后隐式的返回 this 。
</code></pre><p>33、Javascript中，有一个函数，执行时对象查找时，永远不会去查找原型，这个函数是？</p>
<pre><code>HasOwnProperty
</code></pre><p>34、对JSON的了解？</p>
<p>轻量级数据交互格式，可以形成复杂的嵌套格式，解析非常方便</p>
<p>36、模块化开发怎么做？</p>
<pre><code>理解模块化开发模式：
浏览器端requirejs，seajs；
服务器端nodejs；
ES6模块化；
fis、webpack等前端整体模块化解决方案；
grunt、gulp等前端工作流的使用
</code></pre><p>37、AMD（Modules/Asynchronous-Definition）、CMD（Common Module Definition）规范区别？</p>
<pre><code>理解这两种规范的差异，主要通过requirejs与seajs的对比，
理解模块的定义与引用方式的差异以及这两种规范的设计原则
</code></pre><p>38、requireJS的核心原理是什么？（如何动态加载的？如何避免多次加载的？如何 缓存的？）</p>
<pre><code>核心是js的加载模块，通过正则匹配模块以及模块的依赖关系，
保证文件加载的先后顺序，根据文件的路径对加载过的文件做了缓存
</code></pre><p>39、让你自己设计实现一个requireJS，你会怎么做？</p>
<pre><code>核心是实现js的加载模块，维护js的依赖关系，控制好文件加载的先后顺序
</code></pre><p>40、谈一谈你对ECMAScript6的了解？</p>
<pre><code>ES6新的语法糖，类，模块化等新特性
</code></pre><p>41、ECMAScript6 怎么写class么，为什么会出现class这种东西?</p>
<pre><code>class Point {
  constructor(x, y) {
    this.x = x;
    this.y = y;
  }
  toString() {
     return &apos;(&apos;+this.x+&apos;, &apos;+this.y+&apos;)&apos;;
  }
}
</code></pre><p>42、异步加载的方式有哪些？</p>
<pre><code>方案一：&lt;script&gt;标签的async=&quot;async&quot;属性（详细参见：script标签的async属性）
方案二：&lt;script&gt;标签的defer=&quot;defer&quot;属性
方案三：动态创建&lt;script&gt;标签
方案四：AJAX eval（使用AJAX得到脚本内容，然后通过eval_r(xmlhttp.responseText)来运行脚本）
方案五：iframe方式
</code></pre><p>43、documen.write和 innerHTML的区别?</p>
<pre><code>document.write是重写整个document, 写入内容是字符串的html
innerHTML是HTMLElement的属性，是一个元素的内部html内容
</code></pre><p>44、DOM操作——怎样添加、移除、移动、复制、创建和查找节点?</p>
<pre><code>（1）创建新节点
      createDocumentFragment()    //创建一个DOM片段
      createElement_x()   //创建一个具体的元素
      createTextNode()   //创建一个文本节点
（2）添加、移除、替换、插入
      appendChild()
      removeChild()
      replaceChild()
      insertBefore()
（3）查找
      getElementsByTagName()    //通过标签名称
      getElementsByName()    //通过元素的Name属性的值
      getElementById()    //通过元素Id，唯一性
</code></pre><p>45、call() 和 .apply() 的含义和区别？</p>
<pre><code>apply的参数是数组形式，call的参数是单个的值，除此之外在使用上没有差别，
重点理解这两个函数调用的this改变
</code></pre><p>46、数组和对象有哪些原生方法，列举一下？</p>
<pre><code>Array.concat( ) 连接数组
Array.join( ) 将数组元素连接起来以构建一个字符串
Array.length 数组的大小
Array.pop( ) 删除并返回数组的最后一个元素
Array.push( ) 给数组添加元素
Array.reverse( ) 颠倒数组中元素的顺序
Array.shift( ) 将元素移出数组
Array.slice( ) 返回数组的一部分
Array.sort( ) 对数组元素进行排序
Array.splice( ) 插入、删除或替换数组的元素
Array.toLocaleString( ) 把数组转换成局部字符串
Array.toString( ) 将数组转换成一个字符串
Array.unshift( ) 在数组头部插入一个元素

Object.hasOwnProperty( ) 检查属性是否被继承
Object.isPrototypeOf( ) 一个对象是否是另一个对象的原型
Object.propertyIsEnumerable( ) 是否可以通过for/in循环看到属性
Object.toLocaleString( ) 返回对象的本地字符串表示
Object.toString( ) 定义一个对象的字符串表示
Object.valueOf( ) 指定对象的原始值
</code></pre><p>47、JS 怎么实现一个类。怎么实例化这个类</p>
<pre><code>严格来讲js中并没有类的概念，不过js中的函数可以作为构造函数来使用，
通过new来实例化，其实函数本身也是一个对象。
</code></pre><p>48、JavaScript中的作用域与变量声明提升？</p>
<pre><code>理解JavaScript的预解析机制，js的运行主要分两个阶段：js的预解析和运行，
预解析阶段所有的变量声明和函数定义都会提前，但是变量的赋值不会提前
</code></pre><p>49、如何编写高性能的Javascript？</p>
<pre><code>使用 DocumentFragment 优化多次 append
通过模板元素 clone ，替代 createElement
使用一次 innerHTML 赋值代替构建 dom 元素
使用 firstChild 和 nextSibling 代替 childNodes 遍历 dom 元素
使用 Array 做为 StringBuffer ，代替字符串拼接的操作
将循环控制量保存到局部变量
顺序无关的遍历时，用 while 替代 for
将条件分支，按可能性顺序从高到低排列
在同一条件子的多（ &gt;2 ）条件分支时，使用 switch 优于 if
使用三目运算符替代条件分支
需要不断执行的时候，优先考虑使用 setInterval
</code></pre><p>50、那些操作会造成内存泄漏？</p>
<pre><code>闭包，循环
</code></pre><p>51、javascript对象的几种创建方式？</p>
<pre><code>1. 工厂模式
2. 构造函数模式
3. 原型模式
4. 混合构造函数和原型模式
5. 动态原型模式
6. 寄生构造函数模式
7. 稳妥构造函数模式
</code></pre><p>52、javascript继承的 6 种方法？</p>
<pre><code>1. 原型链继承
2. 借用构造函数继承
3. 组合继承(原型+借用构造)
4. 原型式继承
5. 寄生式继承
6. 寄生组合式继承
</code></pre><p>53、eval是做什么的？</p>
<pre><code>1. 它的功能是把对应的字符串解析成JS代码并运行
2. 应该避免使用eval，不安全，非常耗性能（2次，一次解析成js语句，一次执行）
</code></pre><p>54、JavaScript 原型，原型链 ? 有什么特点？</p>
<pre><code>1. 原型对象也是普通的对象，是对象一个自带隐式的 __proto__ 属性，
原型也有可能有自己的原型，如果一个原型对象的原型不为 null 的话，我们就称之为原型链
2. 原型链是由一些用来继承和共享属性的对象组成的（有限的）对象链
</code></pre><p>55、事件、IE与火狐的事件机制有什么区别？ 如何阻止冒泡？</p>
<pre><code>1. 我们在网页中的某个操作（有的操作对应多个事件）。
例如：当我们点击一个按钮就会产生一个事件。是可以被 JavaScript 侦测到的行为
2. 事件处理机制：IE是事件冒泡、firefox同时支持两种事件模型，
也就是：捕获型事件和冒泡型事件
3. ev.stopPropagation();
注意旧ie的方法：ev.cancelBubble = true;
</code></pre><p>56、简述一下Sass、Less，且说明区别？</p>
<pre><code>他们是动态的样式语言，是CSS预处理器,CSS上的一种抽象层。
他们是一种特殊的语法/语言而编译成CSS。
变量符不一样，less是@，而Sass是$;
Sass支持条件语句，可以使用if{}else{},for{}循环等等。而Less不支持;
Sass是基于Ruby的，是在服务端处理的，而Less是需要引入less.js来处理Less代码输出Css到浏览器
</code></pre><p>57、关于javascript中apply()和call()方法的区别？</p>
<pre><code>相同点:两个方法产生的作用是完全一样的
不同点:方法传递的参数不同
Object.call(this,obj1,obj2,obj3)
Object.apply(this,arguments)
apply()接收两个参数，一个是函数运行的作用域(this)，另一个是参数数组。
call()方法第一个参数与apply()方法相同，但传递给函数的参数必须列举出来。
</code></pre><p>58、简述一下JS中的闭包？</p>
<pre><code>闭包用的多的两个作用：读取函数内部的变量值；让这些变量值始终保存着(在内存中)。
同时需要注意的是：闭包慎用，不滥用，不乱用，由于函数内部的变量都被保存在内存中，
会导致内存消耗大。
</code></pre><p>59、说说你对this的理解？</p>
<pre><code>在JavaScript中，this通常指向的是我们正在执行的函数本身，或者是，指向该函数所属的对象。
全局的this → 指向的是Window
函数中的this → 指向的是函数所在的对象
对象中的this → 指向其本身
</code></pre><p>60、分别阐述split(),slice(),splice(),join()？</p>
<pre><code>join()用于把数组中的所有元素拼接起来放入一个字符串。
所带的参数为分割字符串的分隔符，默认是以逗号分开。归属于Array
split()即把字符串分离开，以数组方式存储。归属于Stringstring
slice() 方法可从已有的数组中返回选定的元素。该方法并不会修改数组，
而是返回一个子数组。如果想删除数组中的一段元素，应该使用方法 Array.splice()
splice() 方法向/从数组中添加/删除项目，然后返回被删除的项目。
返回的是含有被删除的元素的数组。
</code></pre><p>61、事件委托是什么？</p>
<pre><code>让利用事件冒泡的原理，让自己的所触发的事件，让他的父元素代替执行！
</code></pre><p>62、如何阻止事件冒泡和默认事件？</p>
<pre><code>阻止浏览器的默认行为
window.event?window.event.returnValue=false:e.preventDefault();
停止事件冒泡
window.event?window.event.cancelBubble=true:e.stopPropagation();
原生JavaScript中，return false;只阻止默认行为，不阻止冒泡，
jQuery中的return false;既阻止默认行为，又阻止冒泡
</code></pre><p>63、添加 删除 替换 插入到某个接点的方法？</p>
<pre><code>obj.appendChidl()
obj.removeChild()
obj.replaceChild()
obj.innersetBefore()
</code></pre><p>64、你用过require.js吗？它有什么特性？</p>
<pre><code>（1）实现js文件的异步加载，避免网页失去响应；
（2）管理模块之间的依赖性，便于代码的编写和维护。
</code></pre><p>65、谈一下JS中的递归函数，并且用递归简单实现阶乘？</p>
<pre><code>递归即是程序在执行过程中不断调用自身的编程技巧，
当然也必须要有一个明确的结束条件，不然就会陷入死循环。
</code></pre><p>66、请用正则表达式写一个简单的邮箱验证。</p>
<pre><code>/^[a-zA-Z0-9_-]+@[a-zA-Z0-9_-]+(\.[a-zA-Z0-9_-]+)+$/;
</code></pre><p>67、简述一下你对web性能优化的方案？</p>
<pre><code>1、尽量减少 HTTP 请求
2、使用浏览器缓存
3、使用压缩组件
4、图片、JS的预载入
5、将脚本放在底部
6、将样式文件放在页面顶部
7、使用外部的JS和CSS
8、精简代码
</code></pre><p>68、在JS中有哪些会被隐式转换为false</p>
<pre><code>Undefined、null、关键字false、NaN、零、空字符串
</code></pre><p>69、定时器setInterval有一个有名函数fn1，setInterval（fn1,500）<br>    与setInterval（fn1(),500）有什么区别？</p>
<pre><code>第一个是重复执行每500毫秒执行一次，后面一个只执行一次。
</code></pre><p>71、谈谈浏览器的内核，并且说一下什么是内核？</p>
<pre><code>Trident ([&apos;traɪd(ə)nt])--
IE，Gecko ([&apos;gekəʊ])--
Firefox, Presto ([&apos;prestəʊ])--
opera,webkit—谷歌和Safari
浏览器内核又可以分成两部分：渲染引擎和 JS 引擎。
它负责取得网页的内容（HTML、XML、图像等等）、整理讯息（例如加入 CSS 等），
以及计算网页的显示方式，然后会输出至显示器或打印机。
JS 引擎则是解析 Javascript 语言，执行 javascript 语言来实现网页的动态效果。
</code></pre><p>72、JavaScript原型，原型链 ? 有什么特点？</p>
<pre><code>*  原型对象也是普通的对象，是对象一个自带隐式的 __proto__ 属性，
原型也有可能有自己的原型，如果一个原型对象的原型不为null的话，我们就称之为原型链。
*  原型链是由一些用来继承和共享属性的对象组成的（有限的）对象链。
* JavaScript的数据对象有那些属性值？
　　writable：这个属性的值是否可以改。
　　configurable：这个属性的配置是否可以删除，修改。
　　enumerable：这个属性是否能在for…in循环中遍历出来或在Object.keys中列举出来。
　　value：属性值。
* 当我们需要一个属性的时，Javascript引擎会先看当前对象中是否有这个属性，
 如果没有的话，就会查找他的Prototype对象是否有这个属性。
 function clone(proto) {
　　function Dummy() { }
　　Dummy.prototype = proto;
　　Dummy.prototype.constructor = Dummy;
　　return new Dummy(); //等价于Object.create(Person);
 }
        function object(old) {
         function F() {};
         F.prototype = old;
         return new F();
        }
    var newObj = object(oldObject);
</code></pre><p>73、写一个通用的事件侦听器函数</p>
<pre><code>// event(事件)工具集，来源：https://github.com/markyun
markyun.Event = {
    // 页面加载完成后
    readyEvent : function(fn) {
        if (fn==null) {
            fn=document;
        }
        var oldonload = window.onload;
        if (typeof window.onload != &apos;function&apos;) {
            window.onload = fn;
        } else {
            window.onload = function() {
                oldonload();
                fn();
            };
        }
    },
    // 视能力分别使用dom0||dom2||IE方式 来绑定事件
    // 参数： 操作的元素,事件名称 ,事件处理程序
    addEvent : function(element, type, handler) {
        if (element.addEventListener) {
            //事件类型、需要执行的函数、是否捕捉
            element.addEventListener(type, handler, false);
        } else if (element.attachEvent) {
            element.attachEvent(&apos;on&apos; + type, function() {
                handler.call(element);
            });
        } else {
            element[&apos;on&apos; + type] = handler;
        }
    },
    // 移除事件
    removeEvent : function(element, type, handler) {
        if (element.removeEnentListener) {
            element.removeEnentListener(type, handler, false);
        } else if (element.datachEvent) {
            element.detachEvent(&apos;on&apos; + type, handler);
        } else {
            element[&apos;on&apos; + type] = null;
        }
    },
    // 阻止事件 (主要是事件冒泡，因为IE不支持事件捕获)
    stopPropagation : function(ev) {
        if (ev.stopPropagation) {
            ev.stopPropagation();
        } else {
            ev.cancelBubble = true;
        }
    },
    // 取消事件的默认行为
    preventDefault : function(event) {
        if (event.preventDefault) {
            event.preventDefault();
        } else {
            event.returnValue = false;
        }
    },
    // 获取事件目标
    getTarget : function(event) {
        return event.target || event.srcElement;
    },
    // 获取event对象的引用，取到事件的所有信息，确保随时能使用event；
    getEvent : function(e) {
        var ev = e || window.event;
        if (!ev) {
            var c = this.getEvent.caller;
            while (c) {
                ev = c.arguments[0];
                if (ev &amp;&amp; Event == ev.constructor) {
                    break;
                }
                c = c.caller;
            }
        }
        return ev;
    }
};
</code></pre><p>77、new操作符具体干了什么呢?</p>
<pre><code>1、创建一个空对象，并且 this 变量引用该对象，同时还继承了该函数的原型。
2、属性和方法被加入到 this 引用的对象中。
3、新创建的对象由 this 所引用，并且最后隐式的返回 this 。
  var obj  = {};
  obj.__proto__ = Base.prototype;
  Base.call(obj);
</code></pre><p>78、JSON 的了解</p>
<pre><code>JSON(JavaScript Object Notation) 是一种轻量级的数据交换格式。
它是基于JavaScript的一个子集。数据格式简单, 易于读写, 占用带宽小
{&apos;age&apos;:&apos;12&apos;, &apos;name&apos;:&apos;back&apos;}
</code></pre><p>79、js延迟加载的方式有哪些</p>
<pre><code>defer和async、动态创建DOM方式（用得最多）、按需异步载入js
</code></pre><p>81、异步加载的方式</p>
<pre><code>(1) defer，只支持IE
(2) async：
(3) 创建script，插入到DOM中，加载完毕后callBack
    documen.write和 innerHTML的区别
    document.write只能重绘整个页面
    innerHTML可以重绘页面的一部分
</code></pre><p>82、告诉我答案是多少？</p>
<pre><code>(function(x){
    delete x;
    alert(x);
})(1+5);
函数参数无法delete删除，delete只能删除通过for in访问的属性。
当然，删除失败也不会报错，所以代码运行会弹出“1”。
</code></pre><p>83、JS中的call()和apply()方法的区别？</p>
<pre><code>例子中用 add 来替换 sub，add.call(sub,3,1) == add(3,1) ，所以运行结果为：alert(4);
注意：js 中的函数其实是对象，函数名是对 Function 对象的引用。
function add(a,b){
    alert(a+b);
}
function sub(a,b){
    alert(a-b);
}
add.call(sub,3,1);
</code></pre><p>84、Jquery与jQuery UI 有啥区别？</p>
<pre><code>*jQuery是一个js库，主要提供的功能是选择器，属性修改和事件绑定等等。
*jQuery UI则是在jQuery的基础上，利用jQuery的扩展性，设计的插件。
提供了一些常用的界面元素，诸如对话框、拖动行为、改变大小行为等等
</code></pre><p>85、jquery 中如何将数组转化为json字符串，然后再转化回来？</p>
<pre><code>jQuery中没有提供这个功能，所以你需要先编写两个jQuery的扩展：
$.fn.stringifyArray = function(array) {
        return JSON.stringify(array)
    }
    $.fn.parseArray = function(array) {
        return JSON.parse(array)
    }
    然后调用：
    $(&quot;&quot;).stringifyArray(array)
</code></pre><p>86、JavaScript中的作用域与变量声明提升？</p>
<pre><code>（HTTP、正则、优化、重构、响应式、移动端、团队协作、SEO、UED、职业生涯）
*基于Class的选择性的性能相对于Id选择器开销很大，因为需遍历所有DOM元素。
*频繁操作的DOM，先缓存起来再操作。用Jquery的链式调用更好。
 比如：var str=$(&quot;a&quot;).attr(&quot;href&quot;);
*for (var i = size; i &lt; arr.length; i++) {}
 for 循环每一次循环都查找了数组 (arr) 的.length 属性，
 在开始循环的时候设置一个变量来存储这个数字，可以让循环跑得更快：
 for (var i = size, length = arr.length; i &lt; length; i++) {}
</code></pre><p>87、前端开发的优化问题（看雅虎14条性能优化原则）。</p>
<pre><code>（1） 减少http请求次数：CSS Sprites, JS、CSS源码压缩、图片大小控制合适；
网页Gzip，CDN托管，data缓存 ，图片服务器。
（2） 前端模板 JS+数据，减少由于HTML标签导致的带宽浪费，
前端用变量保存AJAX请求结果，每次操作本地变量，不用请求，减少请求次数
（3） 用innerHTML代替DOM操作，减少DOM操作次数，优化javascript性能。
（4） 当需要设置的样式很多时设置className而不是直接操作style。
（5） 少用全局变量、缓存DOM节点查找的结果。减少IO读取操作。
（6） 避免使用CSS Expression（css表达式)又称Dynamic properties(动态属性)。
（7） 图片预加载，将样式表放在顶部，将脚本放在底部  加上时间戳。
（8） 避免在页面的主体布局中使用table，table要等其中的内容完全下载之后才会显示出来
，显示比div+css布局慢。
</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;1、    JQuery一个对象可以同时绑定多个事件，这是如何实现的？&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;jQuery可以给一个对象同时绑定多个事件，低层实现方式是使用addEventListner
或attachEvent兼容不同的浏览器实现事件的绑定，这样可以给同一个对象注
    
    </summary>
    
      <category term="面试题目" scheme="www.wangchengzou.cn/categories/%E9%9D%A2%E8%AF%95%E9%A2%98%E7%9B%AE/"/>
    
    
      <category term="javaScript" scheme="www.wangchengzou.cn/tags/javaScript/"/>
    
  </entry>
  
  <entry>
    <title>javaScript面试题</title>
    <link href="www.wangchengzou.cn/2017/07/22/js%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    <id>www.wangchengzou.cn/2017/07/22/js面试题/</id>
    <published>2017-07-22T15:48:26.000Z</published>
    <updated>2017-07-28T02:00:58.577Z</updated>
    
    <content type="html"><![CDATA[<p>javascript的typeof返回哪些数据类型</p>
<pre><code>alert(typeof [1, 2]); //object
   alert(typeof &apos;leipeng&apos;); //string
   var i = true;
   alert(typeof i); //boolean
   alert(typeof 1); //number
   var a;
   alert(typeof a); //undefined
   function a(){;};
   alert(typeof a) //function
</code></pre><p>例举3种强制类型转换和2种隐式类型转换?</p>
<pre><code>强制（parseInt(),parseFloat(),Number()）
隐式（== ,!!）
</code></pre><p>split() 、join() 的区别</p>
<pre><code>前者是切割成数组的形式，后者是将数组转换成字符串
</code></pre><p>数组方法pop() push() unshift() shift()</p>
<pre><code>Push()尾部添加 pop()尾部删除
Unshift()头部添加 shift()头部删除
</code></pre><p>事件绑定和普通事件有什么区别</p>
<pre><code>普通添加事件的方法：
var btn = document.getElementById(&quot;hello&quot;);
btn.onclick = function(){
    alert(1);
}
btn.onclick = function(){
    alert(2);
}
执行上面的代码只会alert 2   重叠覆盖

事件绑定方式添加事件：
var btn = document.getElementById(&quot;hello&quot;);
btn.addEventListener(&quot;click&quot;,function(){
    alert(1);
},false);  冒泡事件，
btn.addEventListener(&quot;click&quot;,function(){
    alert(2);
},false);
执行上面的代码会先alert 1 再 alert 2  不会重叠前面的绑定的事件
普通添加事件的方法不支持添加多个事件，最下面的事件会覆盖上面的，
而事件绑定（addEventListener）方式添加事件可以添加多个。
addEventListener不兼容低版本IE
普通事件无法取消
addEventLisntener还支持事件冒泡+事件捕获，
removeEventLIstener取消绑定事件
</code></pre><p>IE和标准下有哪些兼容性的写法：事件对象event</p>
<pre><code>Var ev = ev || window.event
document.documentElement.clientWidth || document.body.clientWidth
Var target = ev.srcElement||ev.target
</code></pre><p>call和apply的区别</p>
<pre><code>call方法:
语法：call(thisObj，Object1,Object2...)
定义：调用一个对象的一个方法，以另一个对象替换当前对象。
也就是改变当前的this指向的问题
说明：
call 方法可以用来代替另一个对象调用一个方法。
call 方法可将一个函数的对象上下文从初始的上下文改变为由 thisObj 指定的新对象。
如果没有提供 thisObj 参数，那么 Global 对象被用作 thisObj。

apply方法：
语法：apply(thisObj，[argArray])
定义：应用某一对象的一个方法，用另一个对象替换当前对象。
说明：
如果 argArray 不是一个有效的数组或者不是 arguments 对象，
那么将导致一个 TypeError。
如果没有提供 argArray 和 thisObj 任何一个参数，
那么 Global 对象将被用作 thisObj， 并且无法被传递任何参数。
</code></pre><p>如何阻止事件冒泡和默认事件</p>
<pre><code>canceBubble()只支持IE,return false,stopPropagation()
e.predefiut()
</code></pre><p>添加 删除 替换 插入到某个节点的方法</p>
<pre><code>obj.appendChid()
obj.insertBefore()
obj.replaceChild()
obj.removeChild()
</code></pre><p>javascript的本地对象，内置对象和宿主对象</p>
<pre><code>本地对象为array obj regexp等可以new实例化
内置对象为gload Math 等不可以实例化的
宿主为浏览器自带的document,window 等
</code></pre><p>window.onload 和document.ready的区别</p>
<pre><code>引入js文件的两种方式：一种原生的 一种是jQuery库的入口函数
window.onload 是在dom文档树加载完和所有文件加载完之后
执行一个函数Document.ready原生种没有这个方法，
jquery中有 $(document).ready(function(){代码}),
在dom文档树加载完之后执行一个函数（注意，这里面的文档树加载完不代表全部文件加载完）。
$(document).ready要比window.onload先执行，执行的上下文不同，
window.onload只能出来一次，$(document).ready可以出现多次
</code></pre><p>”==”和“===”的不同</p>
<pre><code>前者会自动转换类型，只是比较数值，不比较数据类型，
后者不会：即比较数据类型也有比较数值
</code></pre><p>javascript的同源策略</p>
<pre><code>一段脚本只能读取来自于同一来源的窗口和文档的属性，这里的同一来源指的是主机名、议和端口号的组合
</code></pre><p>JavaScript是一门什么样的语言，它有哪些特点？</p>
<pre><code>javaScript一种直译式脚本语言，是一种动态类型、弱类型、基于原型的语言，
内置支持类型。它的解释器被称为JavaScript引擎，为浏览器的一部分，
广泛用于客户端的脚本语言，最早是在HTML网页上使用，用来给HTML网页增加动态功能
。JavaScript兼容于ECMA标准，因此也称为ECMAScript。
基本特点
1．是一种解释性脚本语言（代码不进行预编译）。
2．主要用来向HTML（标准通用标记语言下的一个应用）页面添加交互行为。
3．可以直接嵌入HTML页面，但写成单独的js文件有利于结构和行为的分离。
4．跨平台特性，在绝大多数浏览器的支持下，可以在多种平台下运行
</code></pre><p>JavaScript的数据类型都有什么？</p>
<pre><code>基本数据类型：String,boolean,Number,Undefined, Null
引用数据类型：Object(Array,Date,RegExp,Function)
那么问题来了，如何判断某变量是否为数组数据类型？
方法一.判断其是否具有“数组性质”，如slice()方法。可自己给该变量定义slice方法，故有时会失效
方法二.obj instanceof Array 在某些IE版本中不正确
方法三.方法一二皆有漏洞，在ECMA Script5中定义了新方法Array.isArray(),
保证其兼容性，最好的方法如下：
if(typeof Array.isArray===&quot;undefined&quot;)
{
  Array.isArray = function(arg){
        return Object.prototype.toString.call(arg)===&quot;[object Array]&quot;
    };
}
</code></pre><p>希望获取到页面中所有的checkbox怎么做？(不使用第三方框架)</p>
<pre><code>var domList = document.getElementsByTagName(‘input’)
var checkBoxList = [];
var len = domList.length;　　//缓存到局部变量
while (len--) {　　//使用while的效率会比for循环更高
　　if (domList[len].type == ‘checkbox’) {
    　　checkBoxList.push(domList[len]);
　　}
}
</code></pre><p>设置一个已知ID的DIV的html内容为xxxx，字体颜色设置为黑色(不使用第三方框架)</p>
<pre><code>var dom = document.getElementById(“ID”);
dom.innerHTML = “xxxx”
dom.style.color = “#000”
</code></pre><p>当一个DOM节点被点击时候，我们希望能够执行一个函数，应该怎么做？</p>
<pre><code>直接在DOM里绑定事件：&lt;div onclick=”test()”&gt;&lt;/div&gt;
在JS里通过onclick绑定：xxx.onclick = test
通过事件添加进行绑定：addEventListener(xxx, ‘click’, test)
那么问题来了，Javascript的事件流模型都有什么？
“事件冒泡”：事件开始由最具体的元素接受，然后逐级向上传播
“事件捕捉”：事件由最不具体的节点先接收，然后逐级向下，一直到最具体的
“DOM事件流”：三个阶段：事件捕捉，目标阶段，事件冒泡
</code></pre><p>怎样添加、移除、移动、复制、创建和查找节点</p>
<pre><code>1）创建新节点
createDocumentFragment()    //创建一个DOM片段
createElement()   //创建一个具体的元素
createTextNode()   //创建一个文本节点
2）添加、移除、替换、插入
appendChild()      //添加
removeChild()      //移除
replaceChild()      //替换
insertBefore()      //插入
3）查找
getElementsByTagName()    //通过标签名称
getElementsByName()     //通过元素的Name属性的值
getElementById()        //通过元素Id，唯一性
</code></pre><p>有这样一个URL：<a href="http://item.taobao.com/item.htm?a=1&amp;b=2&amp;c=&amp;d=xxx&amp;e，" target="_blank" rel="external">http://item.taobao.com/item.htm?a=1&amp;b=2&amp;c=&amp;d=xxx&amp;e，</a><br>请写一段JS程序提取URL中的各个GET参数(参数名和参数个数不确定)，<br>将其按key-value形式返回到一个json结构中，如{a:’1′, b:’2′, c:”, d:’xxx’, e:undefined}。</p>
<pre><code>function serilizeUrl(url) {
var urlObject = {};
if (/\?/.test(url)) {
    var urlString = url.substring(url.indexOf(&quot;?&quot;) + 1);
    var urlArray = urlString.split(&quot;&amp;&quot;);
    for (var i = 0, len = urlArray.length; i &lt; len; i++) {
        var urlItem = urlArray[i];
        var item = urlItem.split(&quot;=&quot;);
        urlObject[item[0]] = item[1];
    }
    return urlObject;
}
return null;
}
</code></pre><p>正则表达式构造函数var reg=new RegExp(“xxx”)与正则表达字面量var reg=//有什么不同？<br>匹配邮箱的正则表达式？</p>
<pre><code>答案：当使用RegExp()构造函数的时候，不仅需要转义引号（即\”表示”），
并且还需要双反斜杠（即\\表示一个\）。使用正则表达字面量的效率更高。
邮箱的正则匹配：
var regMail = /^([a-zA-Z0-9_-])+@([a-zA-Z0-9_-])+((.[a-zA-Z0-9_-]{2,3}){1,2})$/;
</code></pre><p>Javascript中callee和caller的作用</p>
<pre><code>caller是返回一个对函数的引用，该函数调用了当前函数；
callee是返回正在被执行的function函数，也就是所指定的function对象的正文。

那么问题来了？如果一对兔子每月生一对兔子；一对新生兔，从第二个月起就开始生兔子；
假定每对兔子都是一雌一雄，试问一对兔子，第n个月能繁殖成多少对兔子？（使用callee完成）
var result=[];
function fn(n){  //典型的斐波那契数列
   if(n==1){
        return 1;
   }else if(n==2){
           return 1;
   }else{
        if(result[n]){
                return result[n];
        }else{
                //argument.callee()表示fn()
                result[n]=arguments.callee(n-1)+arguments.callee(n-2);
                return result[n];
        }
   }
}
</code></pre><p>列举浏览器对象模型BOM里常用的至少4个对象，并列举window对象的常用方法至少5个</p>
<pre><code>对象：window, document, location, screen, history, navigator
方法：alert(), confirm(), prompt(), open(), close()
</code></pre><p>简述列举文档对象模型DOM里document的常用的查找访问节点的方法并做简单说明</p>
<pre><code>Document.getElementById 根据元素id查找元素
Document.getElementByName 根据元素name查找元素
Document.getElementTagName 根据指定的元素名查找元素
</code></pre><p>希望获取到页面中所有的checkbox怎么做？(不使用第三方框架)</p>
<pre><code>var domList = document.getElementsByTagName(‘input’)
var checkBoxList = [];
var len = domList.length;　　//缓存到局部变量
while (len--) {　　//使用while的效率会比for循环更高
　　if (domList[len].type == ‘checkbox’) {
    　　checkBoxList.push(domList[len]);
　　}
}
</code></pre><p>简述创建函数的几种方式</p>
<pre><code>第一种（函数声明）：
function sum1(num1,num2){
   return num1+num2;
}
第二种（函数表达式）：
var sum2 = function(num1,num2){
   return num1+num2;
}
第三种（函数对象方式）：
var sum3 = new Function(&quot;num1&quot;,&quot;num2&quot;,&quot;return num1+num2&quot;);
</code></pre><p>Javascript如何实现继承？</p>
<pre><code>1.构造继承法
2.原型继承法
3.实例继承法
</code></pre><p>Javascript创建对象的几种方式？</p>
<pre><code>1、var obj = {};（使用json创建对象）
如：obj.name = &apos;张三&apos;;
obj.action = function ()
{
alert(&apos;吃饭&apos;);
};
2、var obj = new Object();（使用Object创建对象）
如：obj.name = &apos;张三&apos;;
obj.action = function ()
{
alert(&apos;吃饭&apos;);
};
3、通过函数创建对象。
(1)、使用this关键字
如：var obj = function (){
this.name =&apos;张三&apos;;
this.age = 19;
this.action = function ()
{
alert(&apos;吃饭&apos;);
};
}
(2)、使用prototype关键字
如：function obj (){}
       obj.prototype.name =&apos;张三&apos;;
obj.prototype.action=function ()
{
alert(&apos;吃饭&apos;);
};
4、通过Window创建对象。
如：window.name = &apos;&apos;张三&apos;;
window.age = 19;
window.action= function()
{
alert(&apos;吃饭&apos;);
};
5、使用内置对象创建对象。
如：var str = new String(&quot;实例初始化String&quot;);
var str1 = &quot;直接赋值的String&quot;;
var func = new Function(&quot;x&quot;,&quot;alert(x)&quot;);//示例初始化func
var obj = new Object();//示例初始化一个Object
</code></pre><p>iframe的优缺点？</p>
<pre><code>优点：
1. 解决加载缓慢的第三方内容如图标和广告等的加载问题
2. Security sandbox
3. 并行加载脚本
缺点：
1. iframe会阻塞主页面的Onload事件
2. 即时内容为空，加载也需要时间
3. 没有语意
</code></pre><p>请你谈谈Cookie的弊端？</p>
<pre><code>缺点：
1.Cookie数量和长度的限制。每个domain最多只能有20条cookie，
每个cookie长度不能超过4KB，否则会被截掉。
2.安全性问题。如果cookie被人拦截了，那人就可以取得所有的session信息。
即使加密也与事无补，因为拦截者并不需要知道cookie的意义，
他只要原样转发cookie就可以达到目的了。
3.有些状态不可能保存在客户端。例如，为了防止重复提交表单，
我们需要在服务器端保存一个计数器。如果我们把这个计数器保存在客户端，那么它起不到任何作用。
</code></pre><p>事件委托是什么</p>
<p>让利用事件冒泡的原理，让自己的所触发的事件，让他的父元素代替执行！</p>
<p>闭包是什么，有什么特性，对页面有什么影响</p>
<pre><code>闭包就是能够读取其他函数内部变量的函数。
在本质上，闭包就是将函数内部和函数外部连接起来的一座桥梁。
function outer(){
var num = 1;
function inner(){
    var n = 2;
    alert(n + num);
}
return inner;
}
outer()();
</code></pre><p>解释jsonp的原理，以及为什么不是真正的ajax</p>
<pre><code>动态创建script标签，回调函数
Ajax是页面无刷新请求数据操作
</code></pre><p>javascript的本地对象，内置对象和宿主对象</p>
<pre><code>本地对象为array obj regexp等可以new实例化
内置对象为gload Math 等不可以实例化的
宿主为浏览器自带的document,window 等
</code></pre><p>javascript 中的垃圾回收机制？</p>
<pre><code>在Javascript中，如果一个对象不再被引用，那么这个对象就会被GC回收。
如果两个对象互相引用，而不再  被第3者所引用，那么这两个互相引用的对象也会被回收
。因为函数a被b引用，b又被a外的c引用，这就是为什么  函数a执行后不会被回收的原因。
</code></pre><p>如何在HTML中添加事件，几种方法？</p>
<pre><code>1、标签之中直接添加 onclick=&quot;fun()&quot;;
2、JS添加 Eobj.onclick = method;
3、现代事件  IE： obj.attachEvent(&apos;onclick&apos;, method)；
            FF: obj.addEventListener(&apos;click&apos;, method, false);
</code></pre><p>BOM对象有哪些，列举window对象？</p>
<pre><code>1、window对象 ，是JS的最顶层对象，其他的BOM对象都是window对象的属性；
2、document对象，文档对象；
3、location对象，浏览器当前URL信息；
4、navigator对象，浏览器本身信息；
5、screen对象，客户端屏幕信息；
6、history对象，浏览器访问历史信息；
</code></pre><p>请问代码实现 outerHTML</p>
<pre><code>//说明：outerHTML其实就是innerHTML再加上本身；
Object.prototype.outerHTML = function(){
    var innerCon = this.innerHTML, //获得里面的内容
        outerCon = this.appendChild(innerCon); //添加到里面
    alert(outerCon);
}
演示代码：
 &lt;!doctype html&gt;
 &lt;html&gt;
  &lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;title&gt;Document&lt;/title&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;div id=&quot;outer&quot;&gt;
       hello
    &lt;/div&gt;
  &lt;script&gt;
    Object.prototype.outerHTML = function(){
    var innerCon = this.innerHTML, //获得里面的内容
    outerCon = this.appendChild(innerCon); //添加到里面
    alert(outerCon);
      }
    function $(id){
   return document.getElementById(id);
   }
   alert($(&apos;outer&apos;).innerHTML);
   alert($(&apos;outer&apos;).outerHTML);
  &lt;/script&gt;
 &lt;/body&gt;
 &lt;/html&gt;
</code></pre><p>JS中的简单继承 call方法！</p>
<pre><code>//顶一个父母类，注意：类名都是首字母大写的哦！
function Parent(name, money){
        this.name = name;
        this.money = money;
        this.info = function(){
            alert(&apos;姓名： &apos;+this.name+&apos; 钱： &apos;+ this.money);
        }
    }
    //定义孩子类
    function Children(name){
        Parent.call(this, name); //继承 姓名属性，不要钱。
        this.info = function(){
            alert(&apos;姓名： &apos;+this.name);
        }
    }
    //实例化类
    var per = new Parent(&apos;parent&apos;, 800000000000);
    var chi = new Children(&apos;child&apos;);
    per.info();
    chi.info();
</code></pre><p>bind(), live(), delegate()的区别</p>
<pre><code>bind： 绑定事件，对新添加的事件不起作用，方法用于将一个处理程序附加到
每个匹配元素的事件上并返回jQuery对象。
live： 方法将一个事件处理程序附加到与当前选择器匹配的所有元素
（包含现有的或将来添加的）的指定事件上并返回jQuery对象。
delegate： 方法基于一组特定的根元素将处理程序附加到匹配选择器的所有元素
（现有的或将来的）的一个或多个事件上。
</code></pre><p>请尽可能详尽的解释ajax的工作原理</p>
<pre><code>Ajax的工作原理相当于在用户和服务器之间加了—个中间层，使用户操作与服务器响应异步化
。这样把以前的一些服务器负担的工作转嫁到客户端，利于客户端闲置的处理能力来处理，
减轻服务器和带宽的负担，从而达到节约ISP的空间及带宽租用成本的目的。

简单来说通过XmlHttpRequest对象来向服务器发异步请求，从服务器获得数据，
然后用javascript来操作DOM而更新页面。这其中最关键的一步就是从服务器获
得请求数据。要清楚这个过程和原理，我们必须对 XMLHttpRequest有所了解。
</code></pre><p>为什么扩展javascript内置对象不是好的做法？</p>
<pre><code>因为你不知道哪一天浏览器或javascript本身就会实现这个方法，
而且和你扩展的实现有不一致的表现。到时候你的javascript代码可能
已经在无数个页面中执行了数年，而浏览器的实现导致所有使用扩展原型的代码都崩溃
</code></pre><p>三种弹窗的单词以及三种弹窗的功能</p>
<pre><code>1.alert
//弹出对话框并输出一段提示信息
    function ale() {
        //弹出一个对话框
        alert(&quot;提示信息！&quot;);

    }

2.confirm
    //弹出一个询问框，有确定和取消按钮
    function firm() {
        //利用对话框返回的值 （true 或者 false）
        if (confirm(&quot;你确定提交吗？&quot;)) {
            alert(&quot;点击了确定&quot;);
        }
        else {
            alert(&quot;点击了取消&quot;);
        }
    }

3.prompt
    //弹出一个输入框，输入一段文字，可以提交
    function prom() {
        var name = prompt(&quot;请输入您的名字&quot;, &quot;&quot;); //将输入的内容赋给变量 name ，
        //这里需要注意的是，prompt有两个参数，前面是提示的话，后面是当对话框出来后，在对话框里的默认值
        if (name)//如果返回的有内容
        {
            alert(&quot;欢迎您：&quot; + name)
        }

    }
</code></pre><p>主流浏览器内核</p>
<pre><code>IE trident        火狐gecko    谷歌苹果webkit    Opera：Presto
</code></pre><p>jQuery框架中$.ajax()的常用参数有哪些？写一个post请求并带有发送数据和返回数据的样例</p>
<pre><code>async是否异步
url请求地址
contentType发送信息至服务器时内容编码类型
data发送到服务器的数据
dataType预期服务器返回的数据类型
type请求类型
success请求成功回调函数
error请求失败回调函数

$.ajax({
        url: &quot;/jquery/test1.txt&quot;,
        type: &apos;post&apos;,
        data: {
            id: 1
        },
        success: function(data) {
            alert(data);
        }
    }
</code></pre><p>列出3条以上ff和IE的脚本兼容问题</p>
<pre><code>(1) window.event：
表示当前的事件对象，IE有这个对象，FF没有，FF通过给事件处理函数传递事件对象

(2) 获取事件源
IE用srcElement获取事件源，而FF用target获取事件源

(3) 添加，去除事件
IE：element.attachEvent(“onclick”, function)
element.detachEvent(“onclick”, function)
FF：element.addEventListener(“click”, function, true)
element.removeEventListener(“click”, function, true)

(4) 获取标签的自定义属性
IE：div1.value或div1[“value”]
FF：可用div1.getAttribute(“value”)
</code></pre><p>用正则表达式，写出由字母开头，其余由数字、字母、下划线组成的6~30的字符串？</p>
<pre><code>^[a-zA-Z]{1}[\w]{5,29}$
</code></pre><p>列举浏览器对象模型BOM里常用的至少4个对象，并列举window对象的常用方法至少5个</p>
<pre><code>对象：Window document location screen history navigator
方法：Alert() confirm() prompt() open() close()
</code></pre><p>在Javascript中什么是伪数组？如何将伪数组转化为标准数组？</p>
<pre><code>伪数组（类数组）：无法直接调用数组方法或期望length属性有什么特殊的行为，
但仍可以对真正数组遍历方法来遍历它们。典型的是函数的argument参数，
还有像调用getElementsByTagName,document.childNodes之类的,
它们都返回NodeList对象都属于伪数组。
可以使用Array.prototype.slice.call(fakeArray)将数组转化为真正的Array对象。
</code></pre><p>请写一个正则表达式：要求最短6位数，最长20位，阿拉伯数和英文字母（不区分大小写）组成</p>
<pre><code>^(?=.*\d)(?=.*[a-z])(?=.*[A-Z])[a-zA-Z\d]{6,20}$
</code></pre><p>请写出一个程序，在页面加载完成后动态创建一个form表单，<br>并在里面添加一个input对象并给它任意赋值后义post方式提交到：<a href="http://127.0.0.1/save.php" target="_blank" rel="external">http://127.0.0.1/save.php</a></p>
<pre><code>window.onload=function(){
var form=document.createElement(&quot;form&quot;);
form.setAttribute(&quot;method&quot;, &quot;post&quot;);
form.setAttribute(&quot;action&quot;, &quot;http://127.0.0.1/save.php&quot;);
var input=document.createElement(&quot;input&quot;);
form.appendChild(input);
document.body.appendChild(form);
input.value=&quot;cxc&quot;;
form.submit();//提交表单
}
</code></pre><p>用程序实现找到html中id名相同的元素？</p>
<pre><code>&lt;body&gt;
&lt;form id=&apos;form1&apos;&gt;
&lt;div id=&apos;div1&apos;&gt;&lt;/div&gt;
&lt;div id=&apos;div2&apos;&gt;&lt;/div&gt;
&lt;div id=&apos;div3&apos;&gt;&lt;/div&gt;
&lt;div id=&apos;div4&apos;&gt;&lt;/div&gt;
&lt;div id=&apos;div5&apos;&gt;&lt;/div&gt;
&lt;div id=&apos;div3&apos;&gt;id名重复的元素&lt;/div&gt;
&lt;/form&gt;
&lt;/body&gt;
var nodes=document.querySelectorAll(&quot;#form1&gt;*&quot;);
for(var i=0,len=nodes.length;i&lt;len;i++){
var attr=nodes[i].getAttribute(&quot;id&quot;);
var s=1;
for(var j=i+1;j&lt;len;j++){
if(nodes[j].getAttribute(&quot;id&quot;)==attr){
s++;
alert(&quot;id为：&quot;+attr+&quot;的元素出现&quot;+s+&quot;次&quot;);
}
    }
}
</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;javascript的typeof返回哪些数据类型&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;alert(typeof [1, 2]); //object
   alert(typeof &amp;apos;leipeng&amp;apos;); //string
   var i = true;
 
    
    </summary>
    
      <category term="面试题目" scheme="www.wangchengzou.cn/categories/%E9%9D%A2%E8%AF%95%E9%A2%98%E7%9B%AE/"/>
    
    
      <category term="javaScript" scheme="www.wangchengzou.cn/tags/javaScript/"/>
    
  </entry>
  
</feed>
