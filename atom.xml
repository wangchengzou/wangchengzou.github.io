<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>~~博客园~~</title>
  <subtitle>千帆渡</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="www.wangchengzou.cn/"/>
  <updated>2017-09-20T12:52:30.359Z</updated>
  <id>www.wangchengzou.cn/</id>
  
  <author>
    <name>汪成邹</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>ES6 精简语法</title>
    <link href="www.wangchengzou.cn/2017/09/20/es6%E7%B2%BE%E7%AE%80%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95/"/>
    <id>www.wangchengzou.cn/2017/09/20/es6精简学习方法/</id>
    <published>2017-09-20T12:48:26.000Z</published>
    <updated>2017-09-20T12:52:30.359Z</updated>
    
    <content type="html"><![CDATA[<p>ES6语法精简总结</p>
<p>1、块级作用域，和常量声明</p>
<pre><code>let  const
</code></pre><p> 2、解构赋值</p>
<pre><code>1，基本类型
    [a,b]=[1,2]
    [a,...b]=[1,2,3,4,5]//“...”表示其对应的参数集合数组
2.变量交换
    [a,b]=[b,a]
3，选择性接收数据--采用空格的形式分开
4，在不确定元素时，采用“...”
5，对象解构定义两个对象，属性名相同，定义值为所赋值
</code></pre><p>3、正则扩展</p>
<pre><code>1，修饰符和表达式可以分开写，定义时第一个参数为表达式，第二个参数为修饰符
2，字符串对正则使用的四大方法
    str.search(&apos;表达式&apos;)//匹配结果的起始位置
    srt.replace(&quot;表达式&quot;)//匹配结果替换
    str.match(&quot;表达式&quot;)//匹配结果输出组成数组
    str.split(&quot;表达式&quot;)//匹配结果拆分成数组
3，修饰符
        y修饰符-- 从头部位置开始匹配
        u修饰符---用于处理两字节数据
        r.sticky--判断是否设置了y修饰符
        r.flags---返回正则表达式的所有修饰符
</code></pre><p>4、字符串的扩展</p>
<pre><code>1，对于两个字节的表示数据，用“｛｝”包起来
2，code编码格式api
        str.length
        str.charAt()
        str.charCodeAt()
        str.charPointAt()----处理两字节数据编码
        String.fromCodePoint()---反编码两字节数据
3，针对两字节的遍历方法使用for---of
        for(let code of str){}
4，判断字符串结构
        str.includes(&quot;str&quot;) ---是否包含“str”
        str.statrsWith(&quot;str&quot;)--- 是否以str开头
        str.endsWith(&quot;str)---是否以str结尾
5，字符串复制
        str.repeat(2)---复制两次
6，补全功能
        padStart(2,&quot;0&quot;)---向前补全
        padEnd(2 ,&quot;0&quot;)---向后补全
7，转义字符失效
        String.raw(&quot;表达式&quot;)
</code></pre><p>5、数值扩展</p>
<pre><code>console.log(Number.isFinite(15))//是不是有尽值
console.log(Number.isFinite(NaN))
console.log(Number.isFinite(1/0))
console.log(Number.isNaN(NaN));//判断是不是数
console.log(Number.isInteger(25))//判断是不是整数
console.log(Number.isInteger(25.0))//判断是不是整数
console.log(Number.isInteger(25.2))//判断是不是整数
console.log(Number.isInteger(&apos;21432&apos;))//判断是不是整数
console.log(Number.MAX_SAFE_INTEGER)
console.log(Number.MIN_SAFE_INTEGER)//表示数值的上下限
console.log(Number.isSafeInteger(67))//表示数值在不在这个范围内
console.log(4.1,Math.trunc(4.1))//4
console.log(4.9,Math.trunc(4.9))//4
console.log(Math.sign(-5))//-1
console.log(Math.sign(0))//0
console.log(Math.sign(5))//判断正负还是零 1
console.log(Math.cbrt(-1))//-1
console.log(Math.cbrt(8))//立方根 2
</code></pre><p>6、数组扩展</p>
<pre><code>Array.of(3,4,5)---将参数转换成对应类型
Array.from(obj)---将类数组转换成真正数组

arr.fill(7)        替换，将所有数据替换成7
arr.fill(7,1,3)  将位置1到3位置结束替换成7

for(let index of arr.keys()){}--遍历出键名
for(let value of arr.values()){}--遍历出键值
for(let [index,value] of arr.entries()){}--遍历出所有数据

arr.copyWithin(x,y,z)--将y和z范围内的值替换到x位置上
===》[1,2,3,4,5].copywithin(0,3,4)----[4,2,3,4,5]

arr.find()---匹配值返回
arr,findIndex()---匹配值的下标返回

arr.includes(x)----数组中是否包含x
</code></pre><p>7、函数扩展</p>
<pre><code>1，处理默认参数
    function test(x,y=&quot;text&quot;){}
2，箭头函数使用  （）=&gt;{}
</code></pre><p>8、对象扩展</p>
<pre><code>1，属性使用
      es6={o,k}  =&gt;es5={o:o,k:k}
2，方法使用
      methed={
          hello(){},
          test(){}
      }
3，拷贝方法
      for(let  [key,value] of Object.entries(text)){}
</code></pre><p>9、symbol使用</p>
<pre><code>1，作用
        设置的变量为独一无二，变量名相同，比较也为false
2，如何取symbol值

    for(let [key,value] of Object.entries(obj)){
        console.log(key,value);
    }//不能取到symbols定义的值
    Object.getOwnPropertySymbols(obj).forEach(function(item){
        console.log(obj[item])
    });//只能取到symbols的值
    Reflect.ownKeys(obj).forEach(function (item){
        console.log(item,obj[item])
    })//能同时取到所有值
</code></pre><p>10、set和map的使用</p>
<pre><code>1，数据结构对比，增查改删
    let map=new Map()
    let array=[]

    //添加
    map.set(&apos;t&apos;,1)
    array.push({t:1})
    console.info(map,array)

    //  查
    let map_exist=map.has(&apos;t&apos;)
    let array_exist=array.find(item=&gt;item.t)
    console.info(map_exist,array_exist)

    //改
    map.set(&apos;t&apos;,2)
    array.forEach(item=&gt;item.t?item.t=2:&apos;&apos;)
    console.info(map_exist,array_exist)

    //删除
    map.delete(&apos;t&apos;)
    let index=array.findIndex(item=&gt;item.t)
    array.splice(index,1)

2，SET对数据 的对比
    let set=new Set()
    let  array=[]

    //增
    set.add({t:1})

    //查
    set.has({t:1})

    //改
    set.forEach(item=&gt;item.t?item.t=2:&apos;&apos;)

    //删
    set.forEach(item=&gt;item.t?set.delete(item):&apos;&apos;)

3，map set对Object对比
    let item={t:1}
    let map=new Map()
    let set=new Set()
    let obj={}

    //增
    map.set(&apos;t&apos;,1)
    set.add(item)
    obj[&apos;t&apos;]=1

    //查
    console.info({
        a:map.has(&apos;t&apos;),
        b:set.has(item),
        c:&apos;t&apos; in obj
    })

    //改
    map.set(&apos;t&apos;,2)
    item.t=2
    obj[&apos;t&apos;]=2

    //删
    map.delete(&apos;t&apos;)
    set.delete(item)
    delete obj[&apos;t&apos;]

4，wrekSet wrekMap使用方法一样，但是只针对Object对象
</code></pre><p>12、proxy和reflect的使用（拦截器、代理器）</p>
<pre><code>let monitor=new Proxy(obj, {
    //拦截对象属性的读取
    get (target, key) {}

    //拦对象设置属性
    set (target, key, value) {}

    has(target, key) {}

    deleteProperty(target, key) {}

    //拦截object.keys,objoct.getownpropertysymbols.
    ownKeys() {}
}
</code></pre><p>13、类和对象的使用</p>
<pre><code>1，创建方法
{
    class Parent{
        constructor(name=&apos;wang&apos;){
            this.name=name;
        }
    }
2，继承方法
    class child extends Parent{//子继承父
        constructor(name=&apos;child&apos;){
            super(name);//表示父对象里面的属性和方法
            this.type=&apos;child&apos;
        }
    }

    let parent1=new Parent(&apos;cheng&apos;)
    console.log(parent1)
    console.log(new child())
}
3，静态方法使用，用于子对象专有，其它对像不能使用（static）
{
    class parent{
        constructor(name=&apos;wang&apos;){
            this.name=name;
        }
        static tell(){
            console.log(&apos;tell&apos;)
        }
    }
    parent.tell()
    parent.type=&apos;3454354&apos;
}
</code></pre><p>14、promise异步操作的使用</p>
<pre><code>{
  let ajax=function(){
    console.log(&apos;执行2&apos;);
    return new Promise(function(resolve,reject){
      setTimeout(function () {
        resolve()
      }, 1000);
    })
  };

  ajax().then(function(){
    console.log(&apos;promise&apos;,&apos;timeout2&apos;);
  })
}

{
  let ajax=function(){
    console.log(&apos;执行3&apos;);
    return new Promise(function(resolve,reject){
      setTimeout(function () {
        resolve()
      }, 1000);
    })
  };

  ajax()
    .then(function(){
    return new Promise(function(resolve,reject){
      setTimeout(function () {
        resolve()
      }, 2000);
    });
  })
    .then(function(){
    console.log(&apos;timeout3&apos;);
  })
}

{
  let ajax=function(num){
    console.log(&apos;执行4&apos;);
    return new Promise(function(resolve,reject){
      if(num&gt;5){
        resolve()
      }else{
        throw new Error(&apos;出错了&apos;)
      }
    })
  }

  ajax(6).then(function(){
    console.log(&apos;log&apos;,6);
  }).catch(function(err){
    console.log(&apos;catch&apos;,err);
  });

  ajax(3).then(function(){
    console.log(&apos;log&apos;,3);
  }).catch(function(err){
    console.log(&apos;catch&apos;,err);
  });
}
</code></pre><p>15、iterator的使用（遍历器方法，使用next（）下一步）</p>
<pre><code>{
  let arr=[&apos;hello&apos;,&apos;world&apos;];
  let map=arr[Symbol.iterator]();
  console.log(map.next());
  console.log(map.next());
  console.log(map.next());
}
</code></pre><p>16、generator的使用（异步编辑方法，使用*表示）</p>
<pre><code>{
  // genertaor基本定义
  let tell=function* (){
    yield &apos;a&apos;;
    yield &apos;b&apos;;
    return &apos;c&apos;
  };

  let k=tell();
  console.log(k.next());
  console.log(k.next());
  console.log(k.next());
  console.log(k.next());
}

{
  let obj={};
  obj[Symbol.iterator]=function* (){
    yield 1;
    yield 2;
    yield 3;
  }

  for(let value of obj){
    console.log(&apos;value&apos;,value);
  }
}

{
  let state=function* (){
    while(1){
      yield &apos;A&apos;;
      yield &apos;B&apos;;
      yield &apos;C&apos;;
    }
  }
  let status=state();
  console.log(status.next());
  console.log(status.next());
  console.log(status.next());
  console.log(status.next());
  console.log(status.next());
}
</code></pre><p>17、decorator的使用(修饰器的使用)</p>
<pre><code>{
  let readonly=function(target,name,descriptor){
    descriptor.writable=false;
    return descriptor
  };

  class Test{
    @readonly//修饰器使用方法
    time(){
      return &apos;2017-03-11&apos;
    }
  }
</code></pre><p>18、模块化使用方法</p>
<pre><code> export let A=123;

 export function test(){}

 export class Hello{
   test(){}
 }

export default {
  test,
  Hello
}
</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;ES6语法精简总结&lt;/p&gt;
&lt;p&gt;1、块级作用域，和常量声明&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;let  const
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt; 2、解构赋值&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;1，基本类型
    [a,b]=[1,2]
    [a,...b]=[1,2,
    
    </summary>
    
      <category term="学习笔记" scheme="www.wangchengzou.cn/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="javaScript" scheme="www.wangchengzou.cn/tags/javaScript/"/>
    
      <category term="ES6" scheme="www.wangchengzou.cn/tags/ES6/"/>
    
  </entry>
  
  <entry>
    <title>ES6 语法</title>
    <link href="www.wangchengzou.cn/2017/09/18/es6%E8%AF%AD%E6%B3%95/"/>
    <id>www.wangchengzou.cn/2017/09/18/es6语法/</id>
    <published>2017-09-18T12:48:26.000Z</published>
    <updated>2017-09-18T12:52:21.107Z</updated>
    
    <content type="html"><![CDATA[<p>ES6语法</p>
<p>1、let_const</p>
<pre><code>块级作用域，和常量声明
 function text(){
    for(let i=1;i&lt;3;i++){
        console.log(i)
    }
}
function last(){
    const PI=3.1415926;
    const k={
        a:1
    }
    k.b=3;
    console.log(PI,k)
}

text();
last();
</code></pre><p> 2、解构赋值</p>
<pre><code>//  { ... }这是一个块作用域的方法
{
    let a,b,rest;
    [a,b]=[1,2];
    console.log(a,b);//2 1
}
{
    let a,b,rest;
    [a,b,c=3]=[1,2];
    console.log(a,b,c);//1 2 3
}
{
    let a,b,rest;
    [a,b,...rest]=[1,2,3,4,5,6]
    console.log(a,b,rest)  //1 2 [3 4 5 6]
}
{
    let a,b;
    ({a,b}={a:1,b:2})
    console.log(a,b) //1 2
}
//变量交换
{
    let a=1;
    let b=2;
    [a,b]=[b,a];
    console.log(a,b) //2 1
}
{
    function f(){
        return [1,2]
    }
    let a,b;
    [a,b]=f();
    console.log(a,b) //1 2
}
//选择性接收数据
{
    function f(){
        return [1,2,3,4,5]
    }
    let a,b,c;
    [a,,,b]=f();
    console.log(a,b) //1 4
}
//不确定元素时使用方法
{
    function f(){
        return [1,2,3,4,5]
    }
    let a,b,c;
    [a,...b]=f();
    console.log(a,b) //1 [2 3 4 5]
}

//对象解构
{
    let o={p:42,q:true}
    let {p,q}=o;
    console.log(p,q)  //42 true
}
{
    let {a=10,b=5}={a:3}
    console.log(a,b)  //3 5
}
//json数据格式的处理,嵌套的使用方法
{
    let metaData={
        title:&apos;abc&apos;,
        test:[{
            title:&apos;text&apos;,
            desc:&apos;description&apos;
        }]
    }
    let {title:estitle,test:[{title:cntitle}]}=metaData;
    console.log(estitle,cntitle)  //abc text
}
</code></pre><p>3、正则扩展</p>
<pre><code>{
    // #构造函数#
    let regex = new RegExp(&apos;xyz&apos;, &apos;i&apos;);
    //第一个参数是字符串，第二个是修饰符
    let regex2 = new RegExp(/xyz/i);
    //第一个参数是正则表达式，不接受第二个参数，否则会报错
    console.log(regex.test(&apos;xyz123&apos;), regex2.test(&apos;xyz123&apos;));//true true
    console.log(regex.test(&apos;xyZ123&apos;), regex2.test(&apos;xyZ123&apos;));//true true

    let regex3 = new RegExp(/abc/ig, &apos;i&apos;);//i
    console.log(regex3.flags); //原有正则对象的修饰符是ig，它会被第二个参数i覆盖

}

// 字符串对象的4个使用正则表达式的方法：
    match(),replace(),search(),split()
    这四个方法全部调用RegExp的实例的方法。

{
    let regex = new RegExp(&apos;xyz&apos;, &apos;ig&apos;);
    console.log(regex.test(&apos;xyz0XYZ1xyz2&apos;), regex.exec(&apos;xyz0XYZ1xyz2&apos;));
}   //true [&quot;XYZ&quot;, index: 4, input: &quot;xyz0XYZ1xyz2&quot;]

{
    // y修饰符
    let s = &apos;bbbb_bbb_bb_b&apos;;
    var a1 = /b+/g;
    var a2 = /b+/y;

    console.log(a1.exec(s), a2.exec(s)); // [&quot;bbbb&quot;],[&quot;bbbb&quot;]
    console.log(a1.exec(s), a2.exec(s)); // [&quot;bbb&quot;],null

    console.log(a1.sticky, a2.sticky); //false true 表示是否开启了粘连模式
}

{
    console.log(&apos;u修饰符&apos;,/^\uD83D/.test(&apos;\uD83D\uDC2A&apos;)); // true
    console.log(&apos;u修饰符&apos;,/^\uD83D/u.test(&apos;\uD83D\uDC2A&apos;)); // false
    // 大括号表示Unicode字符，只有加上u才能识别
    console.log(/\u{61}/.test(&apos;a&apos;)); // false
    console.log(/\u{61}/u.test(&apos;a&apos;)); // true
    console.log(/\u{20BB7}/u.test(&apos;𠮷&apos;)); // true
    // 点（.）字符不能识别码点大于0xFFFF的Unicode字符，必须加上u修饰符。
    let s = &apos;𠮷&apos;;
    console.log(&apos;大于0xFFFF的Unicode字符&apos;,/^.$/.test(s)); // false
    console.log(&apos;使用u字符&apos;,/^.$/u.test(s)); // true

    // 使用u修饰符后，所有量词都会正确识别大于码点大于0xFFFF的Unicode字符。
    console.log(&apos;量词&apos;,/a{2}/.test(&apos;aa&apos;)); // true
    console.log(&apos;量词&apos;,/a{2}/u.test(&apos;aa&apos;)); // true
    console.log(&apos;量词&apos;,/𠮷{2}/.test(&apos;𠮷𠮷&apos;)); // false
    console.log(&apos;量词&apos;,/𠮷{2}/u.test(&apos;𠮷𠮷&apos;)); // true
}

{
    // #正则表达式中，点（.）是一个特殊字符，代表任意的单个字符，
    但是行终止符（line terminator character）除外
    // U+000A 换行符（\n）
    // U+000D 回车符（\r）
    // U+2028 行分隔符（line separator）
    // U+2029 段分隔符（paragraph separator）
    // 只是一个提案目前还不支持
    // let reg=/test.go/s;
    // console.log(reg.test(&apos;test\ngo&apos;));
    // console.log(reg.test(&apos;test\ngo&apos;));
    console.log(&apos;s变通方法&apos;,/foo.bar/.test(&apos;foo\nbar&apos;));//false
    console.log(&apos;s变通方法&apos;,/foo[^]bar/.test(&apos;foo\nbar&apos;));//true
}
</code></pre><p>4、字符串的扩展</p>
<pre><code>{
  console.log(&apos;a&apos;,`\u0061`);//a
  console.log(&apos;s&apos;,`\u20BB7`);//超出范围--乱码
  console.log(&apos;s&apos;,`\u{20BB7}`);//吉
}

{
  let s=&apos;𠮷&apos;;
  console.log(&apos;length&apos;,s.length);//2
  console.log(&apos;0&apos;,s.charAt(0));//乱码
  console.log(&apos;1&apos;,s.charAt(1));//乱码
  console.log(&apos;at0&apos;,s.charCodeAt(0));//55367
  console.log(&apos;at1&apos;,s.charCodeAt(1));//57271

  let s1=&apos;𠮷a&apos;;
  console.log(&apos;length&apos;,s1.length);//3
  console.log(&apos;code0&apos;,s1.codePointAt(0));//134071
  console.log(&apos;code0&apos;,s1.codePointAt(0).toString(16));//20bb7
  console.log(&apos;code1&apos;,s1.codePointAt(1));//57271
  console.log(&apos;code2&apos;,s1.codePointAt(2));//97
}

{
  console.log(String.fromCharCode(&quot;0x20bb7&quot;));//乱码
  console.log(String.fromCodePoint(&quot;0x20bb7&quot;));//吉
}

{
  let str=&apos;\u{20bb7}abc&apos;;
  for(let i=0;i&lt;str.length;i++){
    console.log(&apos;es5&apos;,str[i]);//乱码abc
  }
  for(let code of str){
    console.log(&apos;es6&apos;,code);// 吉abc
  }
}

{
  let str=&quot;string&quot;;
  console.log(&apos;includes&apos;,str.includes(&quot;c&quot;));//包含在里面 false
  console.log(&apos;start&apos;,str.startsWith(&apos;str&apos;));//以它开头 true
  console.log(&apos;end&apos;,str.endsWith(&apos;ng&apos;));//以它结尾 true
}

{
  let str=&quot;abc&quot;;
  console.log(str.repeat(2));// 字符复制 abcabc
}

{
  let name=&quot;list&quot;;
  let info=&quot;hello world&quot;;
  let m=`i am ${name},${info}`;
  console.log(m);//i am list ,hello world
}

{
  console.log(&apos;1&apos;.padStart(2,&apos;0&apos;));//向前补全 01
  console.log(&apos;1&apos;.padEnd(2,&apos;0&apos;));//向后补全 10
}

{
  let user={
    name:&apos;list&apos;,
    info:&apos;hello world&apos;
  };
  console.log(abc`i am ${user.name},${user.info}`);//[&quot;list&quot; &quot;hello world&quot;]
  function abc(s,v1,v2){
    console.log(s,v1,v2);
    return s+v1+v2
  }
}//i am ,,,listhello world

{
  console.log(String.raw`Hi\n${1+2}`);//转义字符失效 Hi\n3
  console.log(`Hi\n${1+2}`); //hi  3
}
</code></pre><p>5、数值扩展</p>
<pre><code>{
    console.log(0b0101010111010)//二进制表示
    console.log(0o2746)//八进制表示
}
{
    console.log(Number.isFinite(15))//是不是有尽值
    console.log(Number.isFinite(NaN))
    console.log(Number.isFinite(1/0))
}
{
    console.log(Number.isNaN(NaN));//判断是不是数
}
{
    console.log(Number.isInteger(25))//判断是不是整数
    console.log(Number.isInteger(25.0))//判断是不是整数
    console.log(Number.isInteger(25.2))//判断是不是整数
    console.log(Number.isInteger(&apos;21432&apos;))//判断是不是整数
}
{
    console.log(Number.MAX_SAFE_INTEGER)
    console.log(Number.MIN_SAFE_INTEGER)//表示数值的上下限
    console.log(Number.isSafeInteger(67))//表示数值在不在这个范围内
}
{
    console.log(4.1,Math.trunc(4.1))//4
    console.log(4.9,Math.trunc(4.9))//4
}
{
    console.log(Math.sign(-5))//-1
    console.log(Math.sign(0))//0
    console.log(Math.sign(5))//判断正负还是零 1
}
{
    console.log(Math.cbrt(-1))//-1
    console.log(Math.cbrt(8))//立方根 2
}
</code></pre><p>6、数组扩展</p>
<pre><code>{
  let arr = Array.of(3,4,7,9,11);
  console.log(&apos;arr=&apos;,arr);//[3,4,7,9,11]参数转换成对应类型，无参为空类型

  let empty=Array.of();
  console.log(&apos;empty&apos;,empty);
}

{
  let p=document.querySelectorAll(&apos;p&apos;);
  let pArr=Array.from(p);
  pArr.forEach(function(item){
    console.log(item.textContent);
  });

  console.log(Array.from([1,3,5],function(item){return item*2}));
  //[2,6,10]
}

{
  console.log(&apos;fill-7&apos;,[1,&apos;a&apos;,undefined].fill(7));[7,7,7]
  console.log(&apos;fill,pos&apos;,[&apos;a&apos;,&apos;b&apos;,&apos;c&apos;].fill(7,1,3));[a,7,7]替换,从第1位置到3位置结束
}

{
  for(let index of [&apos;1&apos;,&apos;c&apos;,&apos;ks&apos;].keys()){
    console.log(&apos;keys&apos;,index);
  }
  for(let value of [&apos;1&apos;,&apos;c&apos;,&apos;ks&apos;].values()){
    console.log(&apos;values&apos;,value);
  }
  for(let [index,value] of [&apos;1&apos;,&apos;c&apos;,&apos;ks&apos;].entries()){
    console.log(&apos;values&apos;,index,value);
  }
}

{
  console.log([1,2,3,4,5].copyWithin(0,3,4));
  //取3，4范围内的值是‘4’替换到0的位置 [4,2,3,4,5]
}

{
    //找到第一个匹配值并返回
  console.log([1,2,3,4,5,6].find(function(item){return item&gt;3}));
  //找到第一个匹配值并返回该值的下标
  console.log([1,2,3,4,5,6].findIndex(function(item){return item&gt;3}));
}

{
  console.log(&apos;number&apos;,[1,2,NaN].includes(1));//数组中是否包含1
  console.log(&apos;number&apos;,[1,2,NaN].includes(NaN));
}
</code></pre><p>7、函数扩展</p>
<pre><code>{
    function test(x,y=&apos;world&apos;){
        console.log(x,y)
    }
    test(&apos;hello&apos;)//hello world
    test(&apos;hello&apos;,&apos;wang&apos;)//hello wang
}//处理参数默认值

{
    let x=&apos;test&apos;;
    function test1(x,y=x){
        console.log(x,y)
    }
    test1(&apos;kill&apos;) kill kill
    test1(x)//test test
    test1() undefined undefined
}
{
    function test2(...arg){
        for(let v of arg){
            console.log(&apos;rest&apos;,v)
        }
    }
    test2(1,2,3,4,5,6)
}
{
    console.log(...[1,2,3,5])//1 2 3 5
    console.log(&apos;a&apos;,...[1,2,3,5])//a 1 2 3 5
}//数组离散
{
    let arrow=v=&gt;v+2;
    console.log(arrow(3))//5
    let arrow1=()=&gt;5;
    console.log(arrow1())//5
}
{
    function tail(x){
        console.log(x)
    }
    function fx(x) {
        return tail(x)
    }
    fx(123)//123
}//尾调用
</code></pre><p>8、对象扩展</p>
<pre><code> {
  let o=1;
  let k=2;
  let es5={
      o:o,
      k:k
  };
  let es6={
      o,k
  }
  console.log(es5,es6)

  let es5_method={
      hello:function(){
          console.log(&apos;hello&apos;)
      }
  };
  let es6_method={
      hello(){
          console.log(&apos;hello&apos;)
      }
  }
  console.log(es5_method.hello(),es6_method.hello())
  }
  {
      //属性表达式
      let a=&apos;b&apos;;
      let es5_obj={
          a:&apos;c&apos;
      }
      let es6_obj={
          [a]:&apos;c&apos;
      }
      console.log(es5_obj,es6_obj)
}
  {
      //新的API 是不是同一类型
      console.log(Object.is(&apos;abc&apos;,&apos;abc&apos;),&apos;abc&apos;===&apos;abc&apos;)
      console.log(Object.is([],[]),[]===[])

      //拷北
      console.log(Object.assign({a:&apos;a&apos;},{b:&apos;b&apos;}))
      let test={k:123,o:456}
      for(let [key,value] of Object .entries(test)){
          console.log([key,value])
      }
  }
</code></pre><p>9、symbol使用</p>
<pre><code>{
    let a1=Symbol();
    let a2=Symbol();
    console.log(a1===a2);

    let a3=Symbol.for(&apos;a3&apos;)
    let a4=Symbol.for(&apos;a3&apos;)
    console.log(a3===a4)
}
{
    let a1=Symbol.for(&apos;abc&apos;);
    let obj={
        [a1]:&apos;123&apos;,
        &apos;abc&apos;:345,
        &apos;c&apos;:678
    }
    console.log(obj);

    for(let [key,value] of Object.entries(obj)){
        console.log(key,value);
    }//不能取到symbols定义的值
    Object.getOwnPropertySymbols(obj).forEach(function(item){
        console.log(obj[item])
    });//能取到symbols的值
    Reflect.ownKeys(obj).forEach(function (item){
        console.log(item,obj[item])
    })//能同时取到所有值
}
</code></pre><p>10、set和map的使用</p>
<pre><code>{
    //数据结构对比，增查改删
    let map=new Map()
    let array=[]
    //添加
    map.set(&apos;t&apos;,1)
    array.push({t:1})
    console.info(map,array)
    //  查
    let map_exist=map.has(&apos;t&apos;)
    let array_exist=array.find(item=&gt;item.t)
    console.info(map_exist,array_exist)
    //改
    map.set(&apos;t&apos;,2)
    array.forEach(item=&gt;item.t?item.t=2:&apos;&apos;)
    console.info(map_exist,array_exist)
    //删除
    map.delete(&apos;t&apos;)
    let index=array.findIndex(item=&gt;item.t)
    array.splice(index,1)
}

{
     //SET对数据 的对比
    let set=new Set()
    let  array=[]
    //增
    set.add({t:1})
    //查
    set.has({t:1})
    //改
    set.forEach(item=&gt;item.t?item.t=2:&apos;&apos;)
    //删
    set.forEach(item=&gt;item.t?set.delete(item):&apos;&apos;)
}
{
    //map set对Object对比
    let item={t:1}
    let map=new Map()
    let set=new Set()
    let obj={}
    //增
    map.set(&apos;t&apos;,1)
    set.add(item)
    obj[&apos;t&apos;]=1
    //查
    console.info({
        a:map.has(&apos;t&apos;),
        b:set.has(item),
        c:&apos;t&apos; in obj
    })
    //改
    map.set(&apos;t&apos;,2)
    item.t=2
    obj[&apos;t&apos;]=2
    //删
    map.delete(&apos;t&apos;)
    set.delete(item)
    delete obj[&apos;t&apos;]
}
</code></pre><p>11、数据结构使用</p>
<pre><code>{
    let list=new Set();
    list.add(5);//添加
    list.add(7);
    console.log(list .size)//个数。
}
{
    let arr=[1,2,3,4,5]
    let list=new Set(arr)
    console.log(list .size)
}
{
    let list=new Set()
    list.add(1)
    list.add(2)
    list.add(1)
    console.log(list.size)

    let arr=[1,2,3,4,5,6,3,4,34,5,]
    let list1=new Set(arr);
    console.log(list1)
}//此方法可以去重
{
    let arr=[&apos;add&apos;,&apos;delete&apos;,&apos;clear&apos;,&apos;has&apos;]//使用方法
    let list=new Set(arr);
    console.log(list.has(&apos;add&apos;))//是否存在
    console.log(list.delete(&apos;add&apos;))//删除一个
    console.log(list.clear())//清空
    console.log(list.add(&apos;add&apos;))//添加 一个
}
{
    let arr=[&apos;add&apos;,&apos;delete&apos;,&apos;clear&apos;,&apos;has&apos;]
    let list=new Set(arr)
    for(let [key,value] of list.entries()){
        console.log(key,value)
    }
}
{
    let weaklist=new WeakSet();
    let arg={}
    weaklist.add(arg)
    console.log(weaklist)
}//只支持对象数据
{
    let map=new Map()
    let arr=[&apos;123&apos;]
    map.set(arr,&apos;455&apos;)
    console.log(map,map.get(arr))
}
{
    let map=new Map([[&apos;a&apos;,&apos;123&apos;],[&apos;b&apos;,&apos;456&apos;]])
    console.log(map,map.size)
    console.log(map,map.delete(&apos;a&apos;))
    console.log(map,map.clear())
}
{
    let weakmap=new WeakMap()
    let o={}
    weakmap.set(o,123)
    console.log(weakmap.get(o))
}
</code></pre><p>12、proxy和reflect的使用</p>
<pre><code>{
    let obj={
        time:&apos;2017-09-11&apos;,
        name:&apos;wang&apos;,
        _r:123
    }
    let monitor=new Proxy(obj, {
        //拦截对象属性的读取
        get (target, key) {
            return target[key].replace(&apos;2017&apos;, &apos;2018&apos;)
        },
        //拦对象设置属性
        set (target, key, value) {
            if (key === &apos;name&apos;) {
                return target[key] = value;
            } else {
                return target[key]
            }

        },
        has(target, key) {
            if (key === &apos;name&apos;) {
                return target[key]
            } else {
                return false;
            }
        },
        deleteProperty(target, key) {
            if (key.indexOf(&apos;_&apos;) &gt; -1) {
                delete target[key]
            } else {
                return target[key]
            }
        },
        //拦截object.keys,objoct.getownpropertysymbols.
        ownKeys() {
        }

    })
    console.log(monitor.time)
    monitor.time=&apos;2019&apos;;
    monitor.name=&apos;cheng&apos;
    console.log(monitor,monitor.name)
}
{
    let obj={
        time:&apos;2017-09-11&apos;,
        name:&apos;wang&apos;,
        _r:123
    }
    console.log(Reflect.get(obj,&apos;time&apos;))
    Reflect.set(obj,&apos;name&apos;,&apos;cheng&apos;)
    Reflect.has(obj,&apos;name&apos;)
}

//数据验证
{
    function validator(target,validator){
        return new Proxy(target,{
            _validator:validator,
            set(target,key ,value,proxy){
                if(target.hasOwnProperty(key)){
                    let va=this._validator[key];
                    if(!!va(value)){
                        return Reflect.set(target,key,value,proxy)
                    }else{
                        throw Error(`不能设置 ${key}到${value}`)
                    }
                }else{
                    throw Error(`${key}不存在`)
                }
            }
        })
    }
    const personValidators={
        name(val){
            return typeof val===&apos;string&apos;
        },
        age(val){
            return typeof val===&apos;number&apos;&amp;&amp;val&gt;18
        }
    }
    class Person{
        constructor(name,age){
            this.name=name;
            this.age=age;
            return validator(this,personValidators)
        }
    }
    const person=new Person(&apos;wang&apos;,12)
    console.log(person)
    person.name=13;
    console.log(person)
}
</code></pre><p>13、类和对象的使用</p>
<pre><code>{
    class Parent{
        constructor(name=&apos;wang&apos;){
            this.name=name;
        }
    }

    class child extends Parent{
        constructor(name=&apos;child&apos;){
            super(name);
            this.type=&apos;child&apos;
        }
    }

    let parent1=new Parent(&apos;cheng&apos;)
    console.log(parent1)
    console.log(new child())
}
{
    class Parent{
        constructor(name=&apos;wang&apos;){
            this.name=name;
        }
        get longname(){
            return &apos;mk&apos;+this.name;
        }
        set longname(value){
            this.name=value;
        }
    }

    let parent1=new Parent()
    console.log(parent1.longname)
    parent1.longname=&apos;tsHell&apos;
    console.log(parent1.longname)

}
{
    class parent{
        constructor(name=&apos;wang&apos;){
            this.name=name;
        }
        static tell(){
            console.log(&apos;tell&apos;)
        }
    }
    parent.tell()
    parent.type=&apos;3454354&apos;
}
</code></pre><p>14、promise异步操作的使用</p>
<pre><code>{
  // 基本定义
  let ajax=function(callback){
    console.log(&apos;执行&apos;);
    setTimeout(function () {
      callback&amp;&amp;callback.call()
    }, 1000);
  };
  ajax(function(){
    console.log(&apos;timeout1&apos;);
  })
}

{
  let ajax=function(){
    console.log(&apos;执行2&apos;);
    return new Promise(function(resolve,reject){
      setTimeout(function () {
        resolve()
      }, 1000);
    })
  };

  ajax().then(function(){
    console.log(&apos;promise&apos;,&apos;timeout2&apos;);
  })
}

{
  let ajax=function(){
    console.log(&apos;执行3&apos;);
    return new Promise(function(resolve,reject){
      setTimeout(function () {
        resolve()
      }, 1000);
    })
  };

  ajax()
    .then(function(){
    return new Promise(function(resolve,reject){
      setTimeout(function () {
        resolve()
      }, 2000);
    });
  })
    .then(function(){
    console.log(&apos;timeout3&apos;);
  })
}

{
  let ajax=function(num){
    console.log(&apos;执行4&apos;);
    return new Promise(function(resolve,reject){
      if(num&gt;5){
        resolve()
      }else{
        throw new Error(&apos;出错了&apos;)
      }
    })
  }

  ajax(6).then(function(){
    console.log(&apos;log&apos;,6);
  }).catch(function(err){
    console.log(&apos;catch&apos;,err);
  });

  ajax(3).then(function(){
    console.log(&apos;log&apos;,3);
  }).catch(function(err){
    console.log(&apos;catch&apos;,err);
  });
}
</code></pre><p>15、iterator的使用</p>
<pre><code>{
  let arr=[&apos;hello&apos;,&apos;world&apos;];
  let map=arr[Symbol.iterator]();
  console.log(map.next());
  console.log(map.next());
  console.log(map.next());
}

{
  let obj={
    start:[1,3,2],
    end:[7,9,8],
    [Symbol.iterator](){
      let self=this;
      let index=0;
      let arr=self.start.concat(self.end);
      let len=arr.length;
      return {
        next(){
          if(index&lt;len){
            return {
              value:arr[index++],
              done:false
            }
          }else{
            return {
              value:arr[index++],
              done:true
            }
          }
        }
      }
    }
  }
  for(let key of obj){
    console.log(key);
  }
}

{
  let arr=[&apos;hello&apos;,&apos;world&apos;];
  for(let value of arr){
    console.log(&apos;value&apos;,value);
  }
}
</code></pre><p>16、generator的使用</p>
<pre><code>{
  // genertaor基本定义
  let tell=function* (){
    yield &apos;a&apos;;
    yield &apos;b&apos;;
    return &apos;c&apos;
  };

  let k=tell();

  console.log(k.next());
  console.log(k.next());
  console.log(k.next());
  console.log(k.next());
}

{
  let obj={};
  obj[Symbol.iterator]=function* (){
    yield 1;
    yield 2;
    yield 3;
  }

  for(let value of obj){
    console.log(&apos;value&apos;,value);
  }
}

{
  let state=function* (){
    while(1){
      yield &apos;A&apos;;
      yield &apos;B&apos;;
      yield &apos;C&apos;;
    }
  }
  let status=state();
  console.log(status.next());
  console.log(status.next());
  console.log(status.next());
  console.log(status.next());
  console.log(status.next());
}

// {
//   let state=async function (){
//     while(1){
//       await &apos;A&apos;;
//       await &apos;B&apos;;
//       await &apos;C&apos;;
//     }
//   }
//   let status=state();
//   console.log(status.next());
//   console.log(status.next());
//   console.log(status.next());
//   console.log(status.next());
//   console.log(status.next());
// }
</code></pre><p>17、decorator的使用</p>
<pre><code>{
  let readonly=function(target,name,descriptor){
    descriptor.writable=false;
    return descriptor
  };

  class Test{
    @readonly
    time(){
      return &apos;2017-03-11&apos;
    }
  }

  let test=new Test();

  // test.time=function(){
  //   console.log(&apos;reset time&apos;);
  // };

  console.log(test.time());
}


{
  let typename=function(target,name,descriptor){
    target.myname=&apos;hello&apos;;
  }

  @typename
  class Test{

  }

  console.log(&apos;类修饰符&apos;,Test.myname);
  // 第三方库修饰器的js库：core-decorators; npm install core-decorators
}
</code></pre><p>18、模块化使用方法</p>
<pre><code>// export let A=123;
//
// export function test(){
//   console.log(&apos;test&apos;);
// }
//
// export class Hello{
//   test(){
//     console.log(&apos;class&apos;);
//   }
// }

let A=123;
let test=function(){
  console.log(&apos;test&apos;);
}
class Hello{
  test(){
    console.log(&apos;class&apos;);
  }
}

export default {
  A,
  test,
  Hello
}
</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;ES6语法&lt;/p&gt;
&lt;p&gt;1、let_const&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;块级作用域，和常量声明
 function text(){
    for(let i=1;i&amp;lt;3;i++){
        console.log(i)
    }
}
functio
    
    </summary>
    
      <category term="学习笔记" scheme="www.wangchengzou.cn/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="javaScript" scheme="www.wangchengzou.cn/tags/javaScript/"/>
    
      <category term="ES6" scheme="www.wangchengzou.cn/tags/ES6/"/>
    
  </entry>
  
  <entry>
    <title>mock数据模拟</title>
    <link href="www.wangchengzou.cn/2017/08/04/mock%E6%95%B0%E6%8D%AE%E6%A8%A1%E6%8B%9F/"/>
    <id>www.wangchengzou.cn/2017/08/04/mock数据模拟/</id>
    <published>2017-08-04T02:53:05.000Z</published>
    <updated>2017-08-04T03:00:58.315Z</updated>
    
    <content type="html"><![CDATA[<p>实例</p>
<pre><code>&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;title&gt;Document&lt;/title&gt;
&lt;script src=&quot;http://cdn.bootcss.com/jquery/3.1.1/jquery.min.js&quot;&gt;&lt;/script&gt;
&lt;script src=&quot;http://mockjs.com/dist/mock.js&quot;&gt;&lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;

&lt;div&gt;
    &lt;h1 id=&quot;mockjs&quot;&gt;mockjs&lt;/h1&gt;
&lt;/div&gt;

&lt;script type=&quot;text/javascript&quot;&gt;

    //调用mock方法模拟数据
    Mock.mock(
        &apos;http://mockjs&apos;, {
            &quot;userName&quot; : &apos;@name&apos;,     //模拟名称
            &quot;age|1-100&quot;:100,          //模拟年龄(1-100)
            &quot;color&quot;    : &quot;@color&quot;,    //模拟色值
            &quot;date&quot;     : &quot;@date(&apos;yyyy-MM-dd&apos;)&quot;,  //模拟时间
            &quot;url&quot;      : &quot;@url()&quot;,     //模拟url
            &quot;content&quot;  : &quot;@cparagraph()&quot; //模拟文本
        }
    );

    //ajax请求
    $(&quot;#mockjs&quot;).click(function(){
        $.ajax({
            url        : &quot;http://mockjs&quot;,    //请求的url地址
            dataType   : &quot;json&quot;,   //返回格式为json
            async      : true, //请求是否异步，默认为异步，这也是ajax重要特性
            data       : {},    //参数值
            type       : &quot;GET&quot;,   //请求方式
            beforeSend : function() {
                //请求前的处理
            },
            success: function(req) {
                //请求成功时处理
                console.log(req);
            },
            complete: function() {
                //请求完成的处理
            },
            error: function() {
                //请求出错处理
            }
        });
    });
&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre><p>CommonJs规范</p>
<pre><code>// 加载Mock.js插件，让前端开发与后端独立
window.Mock = require(&apos;mockjs&apos;)
// 加载Mock.mock方法
window.M = window.Mock.mock;
// 加载mock.Random方法
window.R = window.Mock.Random;

console.log(R.email())
console.log(M({email:&apos;@email&apos;}))
    // 这种@的方式叫&quot;占位符&quot;。它可以用来直接生成各种数据
</code></pre><p>Mock.Random 提供的完整方法（占位符）如下：</p>
<pre><code>Type    Method
Basic    boolean, natural, integer, float, character, string,
        range, date, time, datetime, now
Image    image, dataImage
Color    color
Text    paragraph, sentence, word, title, cparagraph, csentence, cword, ctitle
Name    first, last, name, cfirst, clast, cname
Web    url, domain, email, ip, tld
Address    area, region
Helper    capitalize, upper, lower, pick, shuffle
Miscellaneous    guid, id

    // 所有@占位符，都是R对象的演变,比如@email就是如下：
    console.log(R.email())

    // basic：https://github.com/nuysoft/Mock/wiki/Basic
    console.log(M({boolean:&apos;@boolean&apos;}))
    console.log(M({natural:&apos;@natural&apos;}))
    console.log(M({integer:&apos;@integer&apos;}))
    console.log(M({float:&apos;@float&apos;}))
    console.log(M({character:&apos;@character&apos;}))
    console.log(M({range:&apos;@range&apos;}))

    // date:https://github.com/nuysoft/Mock/wiki/Date
    console.log(M({date:&apos;@date&apos;}))
    console.log(M({time:&apos;@time&apos;}))
    console.log(M({datetime:&apos;@datetime&apos;}))
    console.log(M({now:&apos;@now&apos;}))

    // Image：https://github.com/nuysoft/Mock/wiki/Image
    console.log(M({image:&quot;@image()&quot;}))
    console.log(M({image:&quot;@image(60x60)&quot;}))
    console.log(M({image:&quot;@image(60x60,#000000)&quot;}))
    console.log(M({image:&quot;@image(&apos;200x100&apos;, &apos;#00405d&apos;, &apos;#FFF&apos;, &apos;Mock.js&apos;)&quot;}))
    console.log(M({dataImage:&apos;@dataImage&apos;}))
    console.log(M({dataImage:&quot;@dataImage(&apos;200x100&apos;)&quot;}))
    console.log(M({dataImage:&quot;@dataImage(&apos;200x100&apos;, &apos;Hello Mock.js!&apos;)&quot;}))

    // color : https://github.com/nuysoft/Mock/wiki/Color
    console.log(M({color:&apos;@color&apos;}))
    console.log(M({hex:&apos;@hex&apos;}))
    console.log(M({rgb:&apos;@rgb&apos;}))
    console.log(M({rgba:&apos;@rgba&apos;}))
    console.log(M({hsl:&apos;@hsl&apos;}))

    // text : https://github.com/nuysoft/Mock/wiki/Text
    console.log(M({paragraph:&apos;@paragraph&apos;}))
    console.log(M({sentence:&apos;@sentence&apos;}))
    console.log(M({title:&apos;@title&apos;}))
    console.log(M({cparagraph:&apos;@cparagraph&apos;}))
    console.log(M({csentence:&apos;@csentence&apos;}))
    console.log(M({cword:&apos;@cword&apos;}))
    console.log(M({ctitle:&apos;@ctitle&apos;}))

    // name : https://github.com/nuysoft/Mock/wiki/Name
    console.log(M({first:&apos;@first&apos;}))
    console.log(M({last:&apos;@last&apos;}))
    console.log(M({name:&apos;@name&apos;}))
    console.log(M({cfirst:&apos;@cfirst&apos;}))
    console.log(M({clast:&apos;@clast&apos;}))
    console.log(M({cname:&apos;@cname&apos;}))

    // Web　：　https://github.com/nuysoft/Mock/wiki/Name
    console.log(M({url:&apos;@url&apos;}))
    console.log(M({domain:&apos;@domain&apos;}))
    console.log(M({email:&apos;@email&apos;}))
    console.log(M({ip:&apos;@ip&apos;}))
    console.log(M({tld:&apos;@tld&apos;}))

    // address: https://github.com/nuysoft/Mock/wiki/Name
    console.log(M({region:&apos;@region&apos;}))
    console.log(M({province:&apos;@province&apos;}))
    console.log(M({city:&apos;@city&apos;}))
    console.log(M({county:&apos;@county&apos;}))
    console.log(M({zip:&apos;@zip&apos;}))

    // helper Methods : https://github.com/nuysoft/Mock/wiki/Helper
    console.log(M({capitalize:&apos;@capitalize(`hello`)&apos;}))
    console.log(M({upper:&apos;@upper(`hello`)&apos;}))
    console.log(M({lower:&apos;@lower(`HELLO`)&apos;}))
    console.log(M({pick:&quot;@pick([&apos;a&apos;, &apos;e&apos;, &apos;i&apos;, &apos;o&apos;, &apos;u&apos;])&quot;}))
    console.log(M({shuffle:&quot;@shuffle([&apos;a&apos;, &apos;e&apos;, &apos;i&apos;, &apos;o&apos;, &apos;u&apos;])&quot;}))

    // Miscellaneous: https://github.com/nuysoft/Mock/wiki/Miscellaneous
    console.log(M({guid:&apos;@guid&apos;}))
    console.log(M({id:&apos;@id&apos;}))
    console.log(M({increment:&apos;@increment&apos;}))
</code></pre><p>概述</p>
<pre><code>Mock.js实现的功能
基于 数据模板 生成数据
基于 HTML模板 生成数据
拦截并模拟 Ajax请求
</code></pre><p>用法</p>
<pre><code>浏览器：
&lt;!-- （必选）加载 Mock --&gt;
&lt;script src=&quot;http://mockjs.com/dist/mock.js&quot;&gt;&lt;/script&gt;
&lt;script&gt;
// 使用 Mock
var data = Mock.mock({
    &apos;list|1-10&apos;: [{
        &apos;id|+1&apos;: 1
    }]
});
$(&apos;&lt;pre&gt;&apos;).text(JSON.stringify(data, null, 4))
.appendTo(&apos;body&apos;)
&lt;/script&gt;
返回值:

{
&quot;list&quot;: [
    {
        &quot;id&quot;: 1
    },
    {
        &quot;id&quot;: 2
    },
    {
        &quot;id&quot;: 3
    }
    ]
}
</code></pre><p>JQuery：</p>
<pre><code>配置模拟数据：

Mock.mock(&apos;http://g.cn&apos;, {
    &apos;name&apos;     : &apos;@name&apos;,
    &apos;age|1-100&apos;: 100,
    &apos;color&apos;    : &apos;@color&apos;
});
发送Ajax请求：

$.ajax({
    url: &apos;http://g.cn&apos;,
    dataType:&apos;json&apos;
    }).done(function(data, status, xhr){
    console.log(
    JSON.stringify(data, null, 4)
    )
})；
返回数据：

// 结果1
{
&quot;name&quot;: &quot;Elizabeth Hall&quot;,
&quot;age&quot;: 91,
&quot;color&quot;: &quot;#0e64ea&quot;
}

// 结果2
{
&quot;name&quot;: &quot;Michael Taylor&quot;,
&quot;age&quot;: 61,
&quot;color&quot;: &quot;#081086&quot;
}
</code></pre><p>Node.js：</p>
<pre><code>// 安装
npm install mockjs

// 使用
var Mock = require(&apos;mockjs&apos;);
var data = Mock.mock({
    &apos;list|1-10&apos;: [{
        &apos;id|+1&apos;: 1
    }]
});

console.log(JSON.stringify(data, null, 4))
</code></pre><p>Angular.js:</p>
<pre><code>&lt;!-- 引用 --&gt;
&lt;script src=&quot;http://mockjs.com/dist/mock-min.js&quot;&gt;&lt;/script&gt;
&lt;script src=&quot;http://cdn.staticfile.org/angular.js/1.3.0-beta.13/angular.min.js&quot;&gt;&lt;/script&gt;

&lt;!-- 兼容angular (mock.js默认不兼容angular，需额外引用兼容包)--&gt;
&lt;script src=&quot;./src/mock.angular.js&quot;&gt;&lt;/script&gt;
&lt;!-- 模拟数据 --&gt;
&lt;script src=&quot;./mockData.js&quot;&gt;&lt;/script&gt;
&lt;!-- 使用 --&gt;
&lt;script&gt;
(function() {
    (function() {
        var app;
        app = angular.module(&apos;app&apos;, []);
        //使用mockjax方法覆盖Ajax请求
        Mock.mockjax(app);
        return app.controller(&apos;appCtrl&apos;, function($scope, $http) {
            var box;
            box = $scope.box = [];
            $scope.get = function() {
                $http({
                    url: &apos;http://www.baidu.com&apos;,
                    method: &apos;POST&apos;,
                    params: {a: 1},
                    data  : {b:1}
                }).success(function(data) {
                return box.push(data);
            });

            $http({
                url: &apos;http://baidu.com&apos;
                }).success(function(data) {
                console.log(data);
                });
            };
        return $scope.get();
        });
    })();

}).call(this);
&lt;/script&gt;
</code></pre><p>mock数据mockData.js:</p>
<pre><code>Mock.mock(&apos;http://www.baidu.com&apos;, {
    &apos;name&apos;: &apos;@name()&apos;,
    &apos;age|1-100&apos;: 100,
    &apos;color&apos;: &apos;@color&apos;
});
</code></pre><p>语法</p>
<pre><code>Mock.js 的语法规范包括两部分：
数据模板定义（Data Temaplte Definition，DTD）
数据占位符定义（Data Placeholder Definition，DPD）
数据模板定义 DTD
数据模板中的每个属性由 3 部分构成：属性名、生成规则、属性值：

// 属性名   name
// 生成规则 rule
// 属性值   value
&apos;name|rule&apos;: value
注意：
属性名 和 生成规则 之间用 | 分隔。
生成规则 是可选的。
生成规则 有 7 种格式：
&apos;name|min-max&apos;: value
&apos;name|count&apos;: value
&apos;name|min-max.dmin-dmax&apos;: value
&apos;name|min-max.dcount&apos;: value
&apos;name|count.dmin-dmax&apos;: value
&apos;name|count.dcount&apos;: value
&apos;name|+step&apos;: value
生成规则 的 含义 需要依赖 属性值 才能确定。
属性值 中可以含有 @占位符。
属性值 还指定了最终值的初始值和类型。
</code></pre><p>生成规则和示例：</p>
<pre><code>1. 属性值是字符串 String
&apos;name|min-max&apos;: &apos;value&apos; 通过重复 &apos;value&apos; 生成一个字符串，重复次数大于等于 min，小于等于 max。
&apos;name|count&apos;: &apos;value&apos; 通过重复 &apos;value&apos; 生成一个字符串，重复次数等于 count。

2. 属性值是数字 Number
&apos;name|+1&apos;: 100 属性值自动加 1，初始值为 100
&apos;name|1-100&apos;: 100 生成一个大于等于 1、小于等于 100 的整数，属性值 100 只用来确定类型。
&apos;name|1-100.1-10&apos;: 100 生成一个浮点数，整数部分大于等于 1、小于等于 100，小数部分保留 1 到 10 位。
    {
    &apos;number1|1-100.1-10&apos;: 1,
    &apos;number2|123.1-10&apos;: 1,
    &apos;number3|123.3&apos;: 1,
    &apos;number4|123.10&apos;: 1.123
    }
    // =&gt;
    {
    &quot;number1&quot;: 12.92,
    &quot;number2&quot;: 123.51,
    &quot;number3&quot;: 123.777,
    &quot;number4&quot;: 123.1231091814
    }

3. 属性值是布尔型 Boolean
&apos;name|1&apos;: value 随机生成一个布尔值，值为 true 的概率是 1/2，值为 false 的概率是 1/2。
&apos;name|min-max&apos;: value 随机生成一个布尔值，值为 value 的概率是 min / (min + max)，
    值为 !value 的概率是 max / (min + max)。

4. 属性值是对象 Object
&apos;name|min-max&apos;: {} 从属性值 {} 中随机选取 min 到 max 个属性。
&apos;name|count&apos;: {} 从属性值 {} 中随机选取 count 个属性。

5. 属性值是数组 Array
&apos;name|1&apos;: [{}, {} ...] 从属性值 [{}, {} ...] 中随机选取 1 个元素，作为最终值。
&apos;name|min-max&apos;: [{}, {} ...] 通过重复属性值 [{}, {} ...] 生成一个新数组，
    重复次数大于等于 min，小于等于 max。
&apos;name|count&apos;: [{}, {} ...] 通过重复属性值 [{}, {} ...] 生成一个新数组，重复次数为 count。

6. 属性值是数组 Function
&apos;name&apos;: function(){} 执行函数 function(){}，取其返回值作为最终的属性值，上下文为 &apos;name&apos; 所在的对象。
</code></pre><p>数据占位符定义 DPD</p>
<pre><code>占位符 只是在属性值字符串中占个位置，并不出现在最终的属性值中。占位符 的格式为：
@占位符
@占位符(参数 [, 参数])

注意：
用 @ 来标识其后的字符串是 占位符。
占位符 引用的是 Mock.Random 中的方法。
通过 Mock.Random.extend() 来扩展自定义占位符。
占位符 也可以引用 数据模板 中的属性。
占位符 会优先引用 数据模板 中的属性
{
 name: {
 first: &apos;@FIRST&apos;,
 middle: &apos;@FIRST&apos;,
 last: &apos;@LAST&apos;,
 full: &apos;@first @middle @last&apos;
    }
}
// =&gt;
{
 &quot;name&quot;: {
 &quot;first&quot;: &quot;Charles&quot;,
 &quot;middle&quot;: &quot;Brenda&quot;,
 &quot;last&quot;: &quot;Lopez&quot;,
 &quot;full&quot;: &quot;Charles Brenda Lopez&quot;
    }
}
</code></pre><p>常用方法</p>
<pre><code>Mock.mock( rurl?, rtype?, template|function(options) )
根据数据模板生成模拟数据。

参数的含义和默认值如下所示：
参数 rurl：可选。表示需要拦截的 URL，可以是 URL 字符串或 URL 正则。例如 /\/domain\/list.json/、&apos;/domian/list.json&apos;。
参数 rtype：可选。表示需要拦截的 Ajax 请求类型。例如 GET、POST、PUT、DELETE 等。
参数 template：可选。表示数据模板，可以是对象或字符串。例如 { &apos;data|1-10&apos;:[{}] }、&apos;@EMAIL&apos;。
参数 function(options)：可选。表示用于生成响应数据的函数。
参数 options：指向本次请求的 Ajax 选项集。
Mock.mockjax(library)
覆盖（拦截） Ajax 请求，目前内置支持 jQuery、Zepto、KISSY。
</code></pre><p>Mock.Random</p>
<pre><code>Mock.Random 是一个工具类，用于生成各种随机数据。
Mock.Random 的方法在数据模板中称为“占位符”，
引用格式为 @占位符(参数 [, 参数]) 。

Mock.tpl(input, options, helpers, partials)
基于 Handlebars、Mustache 的 HTML 模板生成模拟数据。
</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;实例&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html lang=&amp;quot;en&amp;quot;&amp;gt;
&amp;lt;head&amp;gt;
    &amp;lt;meta charset=&amp;quot;UTF-8&amp;quot;&amp;gt;
    &amp;lt;
    
    </summary>
    
      <category term="学习笔记" scheme="www.wangchengzou.cn/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="vue" scheme="www.wangchengzou.cn/tags/vue/"/>
    
      <category term="mock" scheme="www.wangchengzou.cn/tags/mock/"/>
    
  </entry>
  
  <entry>
    <title>element-ui响应式布局</title>
    <link href="www.wangchengzou.cn/2017/08/03/element-ui%E5%93%8D%E5%BA%94%E5%BC%8F%E9%9D%A2%E5%A3%81/"/>
    <id>www.wangchengzou.cn/2017/08/03/element-ui响应式面壁/</id>
    <published>2017-08-03T14:38:34.000Z</published>
    <updated>2017-08-03T14:49:58.079Z</updated>
    
    <content type="html"><![CDATA[<p>Layout布局</p>
<p>1、创建布局</p>
<pre><code>通过Col组件的:span属性调整Layout布局，分为24栏。
    el-row&gt;
      &lt;el-col :span=&quot;24&quot;&gt;
        &lt;div class=&quot;grid-content bg-purple-dark&quot;&gt;&lt;/div&gt;
      &lt;/el-col&gt;
    &lt;/el-row&gt;
</code></pre><p>2、分栏间隔</p>
<pre><code>通过Row组件的:gutter属性来调整布局之间的宽度。
&lt;el-row :gutter=&quot;20&quot;&gt;
  &lt;el-col :span=&quot;6&quot;&gt;&lt;div class=&quot;grid-content bg-purple&quot;&gt;&lt;/div&gt;&lt;/el-col&gt;
  &lt;el-col :span=&quot;6&quot;&gt;&lt;div class=&quot;grid-content bg-purple&quot;&gt;&lt;/div&gt;&lt;/el-col&gt;
&lt;/el-row&gt;
</code></pre><p>3、分栏漂移</p>
<pre><code>通过Col组件的:offset属性调整栅格的偏移位置（每次1格/24格）。
&lt;el-row :gutter=&quot;20&quot;&gt;
  &lt;el-col :span=&quot;6&quot; :offset=&quot;6&quot;&gt;&lt;div class=&quot;grid-content bg-purple&quot;&gt;&lt;/div&gt;&lt;/el-col&gt;
  &lt;el-col :span=&quot;6&quot; :offset=&quot;6&quot;&gt;&lt;div class=&quot;grid-content bg-purple&quot;&gt;&lt;/div&gt;&lt;/el-col&gt;
&lt;/el-row&gt;
</code></pre><p>4、对齐方式</p>
<pre><code>通过Row组件的type=&quot;flex&quot;启动flex布局，再通过Row组件的justify属性调整排版方式，属性值分别有
start 居前（默认）
center 居中
end 居后
space-between 分布自适应（两边–中间，两边没有空隙）
around （中间–两边，两边会有空隙）
&lt;el-row type=&quot;flex&quot; class=&quot;row-bg&quot; justify=&quot;center&quot;&gt;
  &lt;el-col :span=&quot;6&quot;&gt;&lt;div class=&quot;grid-content bg-purple&quot;&gt;&lt;/div&gt;&lt;/el-col&gt;
  &lt;el-col :span=&quot;6&quot;&gt;&lt;div class=&quot;grid-content bg-purple-light&quot;&gt;&lt;/div&gt;&lt;/el-col&gt;
&lt;/el-row&gt;
</code></pre><p>5、响应式布局</p>
<pre><code>参考bootstrap的响应式，预设四个尺寸
xs &lt;768px
sm ≥768px
md ≥992
lg ≥1200
&lt;el-row :gutter=&quot;10&quot;&gt;
  &lt;el-col :xs=&quot;8&quot; :sm=&quot;6&quot; :md=&quot;4&quot; :lg=&quot;3&quot;&gt;&lt;div class=&quot;grid-content bg-purple&quot;&gt;&lt;/div&gt;&lt;/el-col&gt;
  &lt;el-col :xs=&quot;4&quot; :sm=&quot;6&quot; :md=&quot;8&quot; :lg=&quot;9&quot;&gt;&lt;div class=&quot;grid-content bg-purple-light&quot;&gt;&lt;/div&gt;&lt;/el-col&gt;
  &lt;el-col :xs=&quot;4&quot; :sm=&quot;6&quot; :md=&quot;8&quot; :lg=&quot;9&quot;&gt;&lt;div class=&quot;grid-content bg-purple&quot;&gt;&lt;/div&gt;&lt;/el-col&gt;
  &lt;el-col :xs=&quot;8&quot; :sm=&quot;6&quot; :md=&quot;4&quot; :lg=&quot;3&quot;&gt;&lt;div class=&quot;grid-content bg-purple-light&quot;&gt;&lt;/div&gt;&lt;/el-col&gt;
&lt;/el-row&gt;
</code></pre><p>ICON图标</p>
<pre><code>今后可以使用&lt;i&gt;来做图标，给其class添加el-icon-iconName即可。
可以在&lt;button&gt;上添加icon属性。

&lt;i class=&quot;el-icon-edit&quot;&gt;&lt;/i&gt;
&lt;i class=&quot;el-icon-share&quot;&gt;&lt;/i&gt;
&lt;i class=&quot;el-icon-delete&quot;&gt;&lt;/i&gt;
&lt;el-button type=&quot;primary&quot; icon=&quot;search&quot;&gt;搜索&lt;/el-button&gt;
</code></pre><p>Button图标</p>
<p>1、主题风格</p>
<pre><code>default
primary 蓝色
text 文字蓝色无边框
&lt;el-button&gt;默认按钮&lt;/el-button&gt;
&lt;el-button type=&quot;primary&quot;&gt;主要按钮&lt;/el-button&gt;
&lt;el-button type=&quot;text&quot;&gt;文字按钮&lt;/el-button&gt;
</code></pre><p>2、禁用状态</p>
<pre><code>通过修改:disabled的boolean值true,false来控制按钮是否禁用。
&lt;el-button :plain=&quot;true&quot; :disabled=&quot;true&quot;&gt;主要按钮&lt;/el-button&gt;
&lt;el-button type=&quot;primary&quot; :disabled=&quot;true&quot;&gt;主要按钮&lt;/el-button&gt;
&lt;el-button type=&quot;text&quot; :disabled=&quot;true&quot;&gt;文字按钮&lt;/el-button&gt;
</code></pre><p>3、颜色暗示</p>
<pre><code>默认按钮，通过type的值来控制
朴素按钮，hover显示颜色 ，通过plain的boolean值来控制
</code></pre><p>4、图标按钮</p>
<pre><code>按钮不添加字，设置icon属性即可
&lt;el-button type=&quot;primary&quot; icon=&quot;edit&quot;&gt;&lt;/el-button&gt;

按钮添加字，图标居按钮文字左侧
&lt;el-button type=&quot;primary&quot; icon=&quot;search&quot;&gt;搜索&lt;/el-button&gt;

可以在&lt;button&gt;文字右侧添加&lt;i&gt;标签，图标居按钮文字右侧
&lt;el-button type=&quot;primary&quot;&gt;上传
&lt;i class=&quot;el-icon-upload el-icon--right&quot;&gt;&lt;/i&gt;
&lt;/el-button&gt;
</code></pre><p>5、加载中</p>
<pre><code>设置loading属性为true即可
&lt;el-button type=&quot;primary&quot; :loading=&quot;true&quot;&gt;加载中&lt;/el-button&gt;
</code></pre><p>6、按钮尺寸</p>
<pre><code>设置size属性来配置
large 大
正常
small 小
mini 超小
其他
autofocus：是否默认对焦，boolean
native-type：原生type，string（button,submit,reset）
</code></pre><p>Radio单选框(label前面到底加不加：冒号)</p>
<p>1、基本用法</p>
<pre><code>v-model属性用来绑定变量
label用来赋值（想要选中该单选框，label的值必须等于v-model绑定的变量值，Number/String）
&lt;template&gt;
  &lt;el-radio class=&quot;radio&quot; v-model=&quot;radio&quot; label=&quot;1&quot;&gt;备选项&lt;/el-radio&gt;
  &lt;el-radio class=&quot;radio&quot; v-model=&quot;radio&quot; label=&quot;2&quot;&gt;备选项&lt;/el-radio&gt;
&lt;/template&gt;

&lt;script&gt;
  export default {
    data () {
      return {
        radio: &apos;1&apos;
      };
    }
  }
&lt;/script&gt;
</code></pre><p>2、禁用状态</p>
<pre><code>设置disableed的boolean值为true
&lt;template&gt;
  &lt;el-radio disabled v-model=&quot;radio1&quot; label=&quot;禁用&quot;&gt;备选项&lt;/el-radio&gt;
  &lt;el-radio disabled v-model=&quot;radio1&quot; label=&quot;选中且禁用&quot;&gt;备选项&lt;/el-radio&gt;
&lt;/template&gt;

&lt;script&gt;
  export default {
    data () {
      return {
        radio1: &apos;选中且禁用&apos;//此处变量值等于label变量值
      };
    }
  }
&lt;/script&gt;
</code></pre><p>3、单选框组</p>
<pre><code>被&lt;el-radio-group&gt; &lt;/el-radio-group&gt; 包含即可。
只需要在&lt;el-radio-group&gt;中绑定v-model，
在&lt;el-radio&gt;中设置:label即可。
（提供可一个change方法响应变化，会传入一个value值）

&lt;template&gt;
  &lt;el-radio-group v-model=&quot;radio2&quot;&gt;
    &lt;el-radio :label=&quot;3&quot;&gt;备选项&lt;/el-radio&gt;
    &lt;el-radio :label=&quot;6&quot;&gt;备选项&lt;/el-radio&gt;
    &lt;el-radio :label=&quot;9&quot;&gt;备选项&lt;/el-radio&gt;
  &lt;/el-radio-group&gt;
&lt;/template&gt;

&lt;script&gt;
  export default {
    data () {
      return {
        radio2: 3
      };
    }
  }
&lt;/script&gt;
</code></pre><p>4、按钮组（单选）</p>
<pre><code>个人炒鸡喜欢
lable就是显示的值
在按钮组当中添加&lt;el-radio-button&gt;就可以实现，
并且支持对size属性设置large和small两个属性，不设置为默认。

&lt;el-radio-group v-model=&quot;radio5&quot; :disabled=&quot;true&quot;&gt;
    &lt;el-radio-button label=&quot;上海&quot; :disabled=&quot;true&quot;&gt;
    &lt;/el-radio-button&gt;
    &lt;el-radio-button label=&quot;北京&quot;&gt;&lt;/el-radio-button&gt;
    &lt;el-radio-button label=&quot;广州&quot;&gt;&lt;/el-radio-button&gt;
    &lt;el-radio-button label=&quot;深圳&quot;&gt;&lt;/el-radio-button&gt;
  &lt;/el-radio-group&gt;
&lt;/template&gt;

&lt;script&gt;
  export default {
    data () {
      return {
        radio5: &apos;上海&apos;
      };
    }
  }
&lt;/script&gt;
</code></pre><p>CheckBox单选框<br>1、基础用法</p>
<pre><code>设置v-model属性绑定变量。
&lt;template&gt;
  &lt;!-- `checked` 为 true 或 false --&gt;
  &lt;el-checkbox v-model=&quot;checked&quot;&gt;备选项&lt;/el-checkbox&gt;
&lt;/template&gt;
&lt;script&gt;
  export default {
    data() {
      return {
        checked: true
      };
    }
  };
&lt;/script&gt;
</code></pre><p>2、禁用状态</p>
<pre><code>设置disabled属性即可。
&lt;el-checkbox v-model=&quot;checked2&quot; disabled&gt;备选项&lt;/el-checkbox&gt;
</code></pre><p>CheckBox复选框<br>  1、基本用法</p>
<pre><code>按钮是单一时，绑定v-model变量，类型为boolean值。
&lt;template&gt;
  &lt;!-- `checked` 为 true 或 false --&gt;
  &lt;el-checkbox v-model=&quot;checked&quot;&gt;备选项&lt;/el-checkbox&gt;
&lt;/template&gt;
&lt;script&gt;
  export default {
    data() {
      return {
        checked: true
      };
    }
  };
&lt;/script&gt;
</code></pre><p>  2、禁用状态</p>
<pre><code>设置其disabled属性即可。
&lt;template&gt;
  &lt;el-checkbox v-model=&quot;checked1&quot; disabled&gt;备选项1&lt;/el-checkbox&gt;
  &lt;el-checkbox v-model=&quot;checked2&quot; disabled&gt;备选项&lt;/el-checkbox&gt;
&lt;/template&gt;
&lt;script&gt;
  export default {
    data() {
      return {
        checked1: false,
        checked2: true
      };
    }
  };
&lt;/script&gt;
</code></pre><p>  3、多选框组</p>
<pre><code>1.使用&lt;checkbox-group&gt; &lt;/checkbox-group&gt;包裹即可，v-model的值绑定为Array类型变量。
在&lt;el-checkbox&gt;中的label属性为checkbox对应的值。
（标签无内容，该属性充当checkbox按钮后的介绍）

label与数组中的元素值相对应。存在则为选中，不存在则不选中。
&lt;template&gt;
  &lt;el-checkbox-group v-model=&quot;checkList&quot;&gt;
    &lt;el-checkbox label=&quot;复选框 A&quot;&gt;&lt;/el-checkbox&gt;
    &lt;el-checkbox label=&quot;复选框 B&quot;&gt;&lt;/el-checkbox&gt;
    &lt;el-checkbox label=&quot;复选框 C&quot;&gt;&lt;/el-checkbox&gt;
    &lt;el-checkbox label=&quot;禁用&quot; disabled&gt;&lt;/el-checkbox&gt;
    &lt;el-checkbox label=&quot;选中且禁用&quot; disabled&gt;&lt;/el-checkbox&gt;
  &lt;/el-checkbox-group&gt;
&lt;/template&gt;

&lt;script&gt;
  export default {
    data () {
      return {
        checkList: [&apos;选中且禁用&apos;,&apos;复选框 A&apos;]
      };
    }
  };
&lt;/script&gt;
</code></pre><p>  4、indeterminate状态</p>
<pre><code>indeterminate属性只控制样式变化。
@change当绑定值变化时，触发的事件。
&lt;template&gt;
  &lt;el-checkbox :indeterminate=&quot;isIndeterminate&quot;
      v-model=&quot;checkAll&quot; @change=&quot;handleCheckAllChange&quot;&gt;全选&lt;/el-checkbox&gt;
  &lt;div style=&quot;margin: 15px 0;&quot;&gt;&lt;/div&gt;
  &lt;el-checkbox-group v-model=&quot;checkedCities&quot; @change=&quot;handleCheckedCitiesChange&quot;&gt;
    &lt;el-checkbox v-for=&quot;city in cities&quot; :label=&quot;city&quot;&gt;{{city}}&lt;/el-checkbox&gt;
  &lt;/el-checkbox-group&gt;
&lt;/template&gt;
&lt;script&gt;
  const cityOptions = [&apos;上海&apos;, &apos;北京&apos;, &apos;广州&apos;, &apos;深圳&apos;];
  export default {
    data() {
      return {
        checkAll: true,
        checkedCities: [&apos;上海&apos;, &apos;北京&apos;],
        cities: cityOptions,
        isIndeterminate: true
      };
    },
    methods: {
      handleCheckAllChange(event) {
        this.checkedCities = event.target.checked ? cityOptions : [];
        this.isIndeterminate = false;
      },
      handleCheckedCitiesChange(value) {
        let checkedCount = value.length;
        this.checkAll = checkedCount === this.cities.length;
        this.isIndeterminate = checkedCount &gt; 0 &amp;&amp; checkedCount &lt; this.cities.length;
      }
    }
  };
&lt;/script&gt;
</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Layout布局&lt;/p&gt;
&lt;p&gt;1、创建布局&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;通过Col组件的:span属性调整Layout布局，分为24栏。
    el-row&amp;gt;
      &amp;lt;el-col :span=&amp;quot;24&amp;quot;&amp;gt;
        &amp;
    
    </summary>
    
      <category term="学习笔记" scheme="www.wangchengzou.cn/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="vue" scheme="www.wangchengzou.cn/tags/vue/"/>
    
      <category term="element-ui" scheme="www.wangchengzou.cn/tags/element-ui/"/>
    
  </entry>
  
  <entry>
    <title>vue基础知识</title>
    <link href="www.wangchengzou.cn/2017/08/02/vue%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    <id>www.wangchengzou.cn/2017/08/02/vue基础知识/</id>
    <published>2017-08-02T07:21:52.000Z</published>
    <updated>2017-08-02T07:28:49.990Z</updated>
    
    <content type="html"><![CDATA[<p>一、Vue介绍</p>
<pre><code>vuejs.com
github.com/vuejs/awesome-vue
//列举了和vue先关的官方和第三方用的比较多的资源
what？VueJS是国内的开发者尤雨溪开发的js的框架
when？ 实现UI层的渐进式的框架
从最简单的数据处理，到数据交互，到DOM操作，到路由处理等，VueJS都有完整的解决方案
why？
学习曲线比较缓和
Vue借鉴了Angular的指令、React中组件和props等优点进行设计
Vue提供了全套的解决方案

how？
两种开发模式：
1、CLI
# 全局安装 vue-cli
$ npm install --global vue-cli
# 创建一个基于 webpack 模板的新项目
$ vue init webpack my-project
# 安装依赖，走你
$ cd my-project
$ npm install
$ npm run dev

2、引入js文件
直接下载，引入js文件即可
</code></pre><p>Vue所支持的指令</p>
<pre><code>选择：
v-if v-else v-else-if

循环：
v-for

显示：
v-show

绑定属性：
v-bind
在vue中 绑定html属性，必须使用v-bind
缩写的形式： v-bind:src --&gt; :src

双向数据绑定：
v-model 修饰符：.lazy .number .trim
&lt;input    type=&apos;number&apos; v-model.number=&apos;num1&apos;/&gt;

绑定事件：
v-on:click=&quot;handleClick&quot;
缩写形式： @click=&quot;&quot;
</code></pre><p>自定义指令</p>
<pre><code>3个钩子函数：
bind：绑定
update：更新
unbind：解绑
</code></pre><p>过滤器</p>
<pre><code>作用：数据的处理
自从Vue2.0之后，就已经自带的过滤取消，不再支持，用户要想使用，有两种方法：
①https://github.com/wy-ei/vue-filter
②自定义过滤器

像ng，通过| 管道符号，支持多重过滤，而且支持给过滤器传参
过滤器的本质就是一个函数！
①自定义过滤器创建
在Vue实例的filters属性中指定：
currency:function(value,arg1,arg2){
    return &apos;处理后的数据&apos;
}
②自定义过滤器使用
依然是管道符号，只有传参方式变了：
{{ price | currency('￥','@')}}
</code></pre><p>计算属性</p>
<pre><code>计算属性其实是一个方法，定义在computed属性中的方法。
计算属性的优势：
①计算属性的方法和methods中的方法实现的功能是一样的，但是由于计算属性是有计算缓存的，
    可以让更新更高效
②让代码更方便进行维护

什么时候需要使用计算属性？
方法所依赖的数据，性能开销比较大，适合用计算属性，正常情况，在methods定义方法也是可以的。
</code></pre><p>监听属性</p>
<pre><code>watch：{
kw:function(newValue,oldValue){}
kw2:function(newValue,oldValue){}
}
</code></pre><p>vue中生命周期</p>
<pre><code>create、mount、update、destroy
每个阶段都对应着有处理函数：

beforeCreate
created
beforeMount
mounted
beforeUpdate
updated
beforeDestroy
destroyed
</code></pre><p>组件</p>
<pre><code>①React
在React中组件的创建和使用：
var MyComponent = React.createClass({
    componentWillMount:func,
    getInitialState:func,
    handleCLick:
    render:function(){}
})

&lt;MyComponent&gt;&lt;/MyComponent&gt;

②Vue
Vue.component(&apos;my-component&apos;,{
    template:
})    data:...
&lt;my-component&gt;&lt;/my-component&gt;

组件命名：建议通过烤串式的命名方式（中间有-连接起来）
</code></pre><p>复合组件</p>
<pre><code>全局组件可以在父模板中的任何一个元素（组件）去使用，
局部组件只能够用在父模板中。

比如：局部组件 item，全局组件 my-list,my-item

可以在my-list中调用my-item，但是不可以调用item（局部组件）

当将局部组件或者全局组件放在一起构成的组件称之为复合组件。
MVVM：Model+View+ViewModel
MVC：Model+View+Controller
</code></pre><p>父组件给子组件传值</p>
<pre><code>props down
步骤：
①在创建子组件 指定属性，把要传递的值给属性
&lt;son name=&apos;zhangsan&apos;&gt;&lt;/son&gt;
②在子组件内部声明props属性
props:[&apos;name&apos;]
//props数组中的元素就是属性的名称，在组件创建完成之后，只要是通过该属性传值了，
    就可以直接在props的元素中拿到传递过来的数据

注意事项：
1、在组件中，data属性必须是一个带有返回值而且返回值是对象的方法
2、如果在通过属性传值时，值是会变化，通过v-bind指令将变量绑定到属性
&lt;son v-bind:name=&apos;kw&apos;&gt;&lt;/son&gt;
&lt;son :name=&apos;kw&apos;&gt;&lt;/son&gt;
</code></pre><p>子组件和父组件通信</p>
<pre><code>events up
步骤：
要想通过事件传值，要约定事件的名称：toFather
①在调用子组件时 绑定自定义的事件
&lt;son @toFather=&quot;&quot;&gt;&lt;/son&gt;
②在子组件中触发自定义的事件，并传值
this.$emit(&apos;事件的名称&apos;,&apos;传递的数据&apos;)
this.$emit(&apos;toFather&apos;,123);
</code></pre><p>ref</p>
<pre><code>父组件操作子组件：
&lt;子组件 ref=&apos;名称&apos;&gt;&lt;/子组件&gt;
在父组件中可以通过:this.$refs.名称
(react: this.refs.名称)

子组件操作父组件：
this.$parent.属性或者方法
</code></pre><p>兄弟组件之间通信</p>
<pre><code>借助于事件
var bus = new Vue()
this.$emit()
this.$on()
</code></pre><p>angularJs 多个控制器通信：</p>
<pre><code>①$rootScope
②借助于控制器之间的嵌套
③事件 $scope.$on $scope.$broadcast $scope.$emit
④借助于service

React 组件之间的通信：
①借助于props 传值 this.props
②借助于props传递方法
</code></pre><p>vue-router 路由</p>
<pre><code>ngRoute
①引入对应的angular-router.js 指定ngRoute
②ngView创建一个盛放代码片段的容器
③路由词典
app.config(function($routeProvider){
$routeProvider.when()
.otherwise
})
跳转： $location.path a href=&apos;#/myDetail&apos;
传参： ①发送接收 ②配置接收方路由 /myDetail --&gt;/myDetail/:id ③$routeParams
</code></pre><p>ui-router:支持代码片段的嵌套</p>
<pre><code>①引入对应的js文件，ionic [&apos;ui.router&apos;]
②uiView
③配置状态
$stateProvder.state()
$urlRouterProvider.otherwise
跳转：$state.go ui-sref a
传参：①发送接收 ②配置接收方状态对应的url ③$stateParams
</code></pre><p>vue-router</p>
<pre><code>①引入对应的vue-router.js
②指定容器
&lt;router-view&gt;&lt;/router-view&gt;
③配置路由词典
3.1 定义一个对象数组
每一个对象包含两个属性：path component
var myRoutes=[{path:&apos;&apos;,component:}]
3.2 创建VueRouter对象（路由词典）
var myRouter= new VueRouter({
    routes:myRoutes=
})
3.3 在Vue的实例中，指定router属性为myRouter

跳转：
&lt;router-link to=&apos;/myMain&apos;&gt;&lt;/router-link&gt;
this.$router.push(&apos;/myLogin&apos;)
a href=&apos;#/myLogin&apos;

传参：
①发送 、接受
②配置接收方的路由
③接受参数

从注册页面 跳转到 主页面 并发送数据123：
①发送：register 接受：main
②配置main的路由
{path:&apos;/myMain&apos;,com..}--&gt;
{path:&apos;/myMain/:id&apos;,com..}
③在组件生命周期钩子函数中读取传递过来的参数
mounted:function(){
    var result= this.$route.params.id
}
④ href=&apos;#/myMain/123&apos;
router-link to=&apos;/myMain/123&apos;
this.$router.push(&apos;/myMain/123&apos;)
</code></pre><p>vue-http 网络请求</p>
<pre><code>this.$http.get/post/ajax().then(function(response){})
</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;一、Vue介绍&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;vuejs.com
github.com/vuejs/awesome-vue
//列举了和vue先关的官方和第三方用的比较多的资源
what？VueJS是国内的开发者尤雨溪开发的js的框架
when？ 实现UI层的渐进式的框架

    
    </summary>
    
      <category term="学习笔记" scheme="www.wangchengzou.cn/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="vue" scheme="www.wangchengzou.cn/tags/vue/"/>
    
  </entry>
  
  <entry>
    <title>DOM_BOM笔记</title>
    <link href="www.wangchengzou.cn/2017/07/22/DOM_BOM%E7%AC%94%E8%AE%B0/"/>
    <id>www.wangchengzou.cn/2017/07/22/DOM_BOM笔记/</id>
    <published>2017-07-22T15:48:26.000Z</published>
    <updated>2017-07-23T10:57:34.367Z</updated>
    
    <content type="html"><![CDATA[<ol>
<li><p>DOM: Document Object Model</p>
<p> DOM是专门操作网页内容的API标准<br> 为什么: 早起js操作不同浏览器的API没有标准，有严重兼容性问题<br> 所以，W3C制定了统一的操作网页内容的API标准,所有浏览器厂商都遵照执行。<br> 结果，使用DOM API操作网页内容，几乎100%兼容所有浏览器<br> 何时: 只要操作网页内容，就用DOM API查找, 修改(内容,属性,样式), 添加, 删除.</p>
</li>
</ol>
<p>DOM Tree:</p>
<pre><code>什么是: 网页中一切内容在内存中都是以树形结构存储的
       网页中每一项内容都是树上的一个节点对象
       包括: 元素, 文字, 属性...
       树只有一个根节点: document, 包含了所有网页内容
Node: 每个节点都是一个node类型的对象
      node是所有节点的父类型
</code></pre><p>三大公共: nodeType  nodeName  nodeValue</p>
<pre><code>nodeType: 节点的类型
  值: document   9
     element     1
     attribute     2
     text         3
  何时: 只要判断节点类型，就用nodeType
        因为不同类型的节点，能执行的操作是不一样的
  问题: 不能进一步区分元素的名称
  解决:
nodeName: 节点的名称
  值: document   #document
     element    全大写的标签名
     attribute    属性名
     text        #text
  何时: 只要细致鉴别元素的标签名时
    强调: nodeName返回的是全大写的标签名
nodeValue: 节点值:
  值: document   null
     element     null
     attribute     属性值
     text         文本内容
</code></pre><p>2、查找: 4种:</p>
<pre><code>  a. 不需要查找，可直接获得的元素
        html   document.documentElement
        head   document.head
        body   document.body
  b. 按节点间关系查找:
节点树: 包含所有节点: 元素和文本
  1. 父子: elem.parentNode  找elem的父节点
        elem.childNodes  找elem的所有*直接*子节点
            返回，所有直接子节点组成的集合(类数组)
        elem.firstChild   找elem的第一个*直接*子节点
        elem.lastChild   找elem的最后一个*直接*子节点
  2. 兄弟: elem.previousSibling 找elem的前一个兄弟
        elem.nextSibling   找elem的下一个兄弟
 何时: 前提: 已经获得了一个节点
      要找周围临近的节点时
 问题: 连看不见的空字符，也算文本节点——干扰
 解决:
元素树: 仅包含元素节点的树结构
       不是一棵新树，仅是节点树的子集
 1. 父子: elem.parentElement  找elem的父元素
        elem.children  找elem的所有*直接*子元素
            返回，所有直接子元素组成的集合(类数组)
        elem.firstElementChild   第一个*直接*子元素
        elem.lastElementChild   最后一个*直接*子元素
 2. 兄弟:
   elem.previousElementSibling 找elem的前一个兄弟元素
   elem.nextElementSibling   找elem的下一个兄弟元素
 何时: 只要仅关心元素节点，不关心文本节点时
 问题: IE9+
 强调: childNodes和children返回的都是动态集合！
   凡是遍历动态集合，都要先缓存元素个数，再遍历
   for(var i=0,len= childNodes.length;i&lt;len;i++)
     不会导致反复查找DOM树
</code></pre><p>3、 按HTML查找:</p>
<pre><code>    优: 范围可大可小,可设置条件
a、按id查找: var elem=document.getElementById(&quot;id&quot;)
  强调: 1. 只能在document对象上调用
       2. 返回一个元素对象
b、按标签名查找:
    var elems=parent.getElementsByTagName(&quot;标签名&quot;);
  强调: 1. 可在任意父元素上
       2. 返回多个元素组成的集合
       3. 不但查找直接子元素，还查找所有后代元素
c、按name属性查找: 了解
   专门找表单中有name属性的表单元素
    var elems=document.getElementsByName(&quot;name&quot;)
    强调: 1. 只能在document上调用
         2. 返回多个元素组成的集合
d、按class属性查找:
    var elems=parent.getElementsByClassName(&quot;class&quot;)
    强调: 1. 可在任意父元素上调用
         2. 返回多个元素组成的集合
         3. 不要求完整匹配，只要包含即可！
缺: 每次只能按一个条件查找
   如果条件复杂，就无法一句话获得想要的元素
</code></pre><p>4、 按选择器查找:</p>
<pre><code>a. 只找一个元素:
  var elem=parent.querySelector(&quot;selector&quot;);
b. 找多个元素
  var elems=parent.querySelectorAll(&quot;selector&quot;);
</code></pre><p>5、 总结:</p>
<pre><code> A首次查找:
    1. 如果条件简单: 按HTML查找: id, 标签, className
    2. 如果条件复杂: 按选择器查找:
 B已经获得一个元素，找周围相邻: 按节点间关系
鄙视: 按HTML查找 vs 按选择器查找
 1.使用的难易程度: 当条件复杂时:
    按选择器查找——简单, 按HTML查找——繁琐
 2.返回值:
    getElementsByTagName() 返回多个元素的*动态*集合
      什么是动态集合: 不实际存储对象的属性值，每次访问，都要重新查找DOM树
    querySelectorAll()  返回多个元素的*非动态*集合
      什么是非动态集合: 实际存储对象的所有属性值，即使反复访问集合，也不会导致反复查找DOM树
 3.单次效率:
    按HTML查找——效率高!
    按选择器查找——效率低
</code></pre><p>3、 修改: (内容, 属性, 样式)</p>
<pre><code>1. 修改:
标准属性: 2种:
  1. 核心DOM: 操作一切结构化文档的API(HTML，XML)
    elem.attributes集合: 保存了当前元素的所有属性节点
    获取属性值: elem.getAttribute(&quot;属性名&quot;)
    修改属性值: elem.setAttribute(&quot;属性名&quot;,&quot;值&quot;)
    判断是否包含属性: elem.hasAttribute(&quot;属性名&quot;)
    移除属性: elem.removeAttribute(&quot;属性名&quot;)
  2. HTML DOM: 对部分常用DOM API的简化版本
     HTML DOM将标准属性都预定义在元素对象中
    获取属性值: elem.属性名
    修改属性值: elem.属性名=&quot;值&quot;;
    判断是否包含属性: elem.属性名===&quot;&quot; 不包含
    移除属性: elem.属性名=&quot;&quot;
    特例: class属性和ES标准中的class重名
          -&gt; DOM -&gt; className
    自定义属性: 比如: data-toggle=&quot;dropdown&quot;
      HTML DOM不能操作自定义属性
      暂时只能用核心DOM操作:
    三大状态: disabled  selected   checked
      核心DOM无法操作三大状态属性
      HTMLDOM: elem.disabled elem.selected  elem.checked
            值都是bool类型true/false
</code></pre><p>3.1、修改css样式:</p>
<pre><code>1. 仅获取/修改内联样式:  elem.style.css属性名
  问题1: css属性名有的带-
  解决: 所有css属性名都要去横线变驼峰
     比如: background-color: backgroundColor
          list-style-type: listStyleType
  问题2: 所有数值类型的属性值都是带单位的字符串
  解决: 获取时: 都要去单位，转数值
        修改时: 将单位拼回数值
  问题3: 仅能获得内联样式, 无法获得样式表中的样式
  解决: 计算后的样式: 最终应用到元素上的完整样式
    何时: 只要希望获得元素完整的样式时
    如何: 2步:
      1. 获得完整样式对象style
        var style=getComputedStyle(elem)
      2. 获得style对象中的css属性
        style.css属性名
     强调: style对象中的样式都是只读
结论: 1. 获取样式: getComputedStyle
     2. 修改样式: elem.style.css属性名
2. 运行时修改样式表中的样式:
  Step1: 获得样式表对象:
   var sheet=document.styleSheets[i]
  Step2: 获得样式表对象中某个CSSRule(一个选择器{})
   var rule=sheet.cssRules[i]
  Step3: 修改rule.style.css属性名=值
</code></pre><p>4、 添加和删除:</p>
<pre><code>添加: 3步:
 Step1: 创建空元素:
  var a=document.createElement(&quot;a&quot;);
  &lt;a&gt;&lt;/a&gt;
 Step2: 设置关键属性:
     a.href=&quot;http://tmooc.cn&quot;
     a.innerHTML=&quot;go to tmooc&quot;;
  &lt;a href=&quot;http://tmooc.cn&quot;&gt;go to tmooc&lt;/a&gt;
 Step3: 将元素添加到DOM树: 3种:
   1. 末尾追加: parent.appendChild(child)
   2. 中间插入: parent.insertBefore(child, oldChild)
   3. 替换: parent.replaceChild(child, oldChild)
</code></pre><p>优化: 尽量少的修改DOM树</p>
<pre><code>原因: 页面加载过程:
  html -&gt; DOM Tree(松树)
           ↓
        render Tree(圣诞树)-&gt; layout(计算绝对布局)-&gt;paint
           ↑                 最耗时
  css  -&gt; cssRules(装饰品)
  每次修改DOM树，都会导致重新layout，耗时。
如何: 2种:
 1. 如果同时添加父元素和子元素时，应该先在内存将子元素都添加到父元素中，再将父元素一次性整体添加到DOM树
    结果: 只触发一次layout
</code></pre><p>1、 HTML DOM 常用对象: 对常用HTML元素操作的简化</p>
<pre><code>Select: 代表页面上的一个select元素
 属性: select.value 当前选中项的value
                 没有value，就返回选中项的内容
      select.options 保存select下所有option元素对象
        相当于: select.getElementsByTagName(&quot;option&quot;)
        select.options.length 保存select下option的个数
        清空select下所有option: select.options.length=0;
      select.length 等效于select.options.length
        清空select下所有option: select.length=0;
                               select.innerHTML=&quot;&quot;;
      select.selectedIndex 当前选中项的下标
  事件: onchange 当选中项发生改变时
  方法: select.add(option) 向select中添加一个option
         相当于: select.appendChild(option)
         不支持文档片段
       select.remove(i) 移除select中i位置的一个option
Option: 代表页面上的一个option元素
  创建: var opt=new Option(text,value);
     创建一个option对象，同时设置opt的内容为text，设置opt的值为value
     相当于: var opt=document.createElement(&quot;option&quot;);
            opt.innerHTML=text;
            opt.value=value;
  属性: .text 代替.innerHTML
       .index  表示当前option在select下的下标位置
</code></pre><p>Table: 代表网页中一个table元素</p>
<pre><code> 管着行分组：
   添加行分组: var 行分组=table.createTHead|TBody|TFoot();
       强调: 即创建，同时又将行分组添加到table
   删除行分组: table.deleteTHead|TFoot()
   获取行分组: table.tHead|tFoot
              table.tBodies[i]
行分组: THead TBody TFoot
  管着行:
   添加行: var tr=行分组.insertRow(i)
       在行分组中i位置插入一个新行
       强调: 中间插入行，原i位置的行向后顺移
       固定套路: 1. 末尾追加一个新行: 行分组.insertRow()
                2. 开头插入: 行分组.insertRow(0)
   删除行: 行分组.deleteRow(i)
       删除行分组中第i行
       强调: i是当前行在行分组内的相对下标位置
   获取行: 行分组.rows

行: tr
  管着td:
    添加td: var td=tr.insertCell(i);
        省略i表示右侧末尾追加
        insertCell不支持添加th，只能添加td
    删除td: tr.deleteCell(i);
    获取td: tr.cells

删除行:
 tr上都有一个属性: tr.rowIndex 行在整个表的绝对下标
 问题：行分组，无法使用tr.rowIndex删除行。
 解决: table.deleteRow(tr.rowIndex)
 总结: 今后，删除行都用table.deleteRow(tr.rowIndex)
</code></pre><p>form: 代表页面上一个表单元素</p>
<pre><code> 获取: var form=document.forms[i/id]
 属性: form.elements 保存了表单中所有表单元素的数组
        包括: input   select   textarea  button
      form.elements.length 获得表单中表单元素的个数
      form.length =&gt; form.elements.length
 方法: form.submit();  用于手动提交表单
 事件: form.onsubmit  以任何方式提交表单之前自动触发
          常用于在提交之前，验证所有表单元素的内容
表单元素:
 获取: var elem=form.elements[i/id/name]
        简写: 如果表单元素有name属性: form.name
 方法: elem.focus() 让elem获得焦点
      elem.blur()  让elem失去焦点

Image: 代表页面上一个img元素
  创建: var img=new Image();
</code></pre><p>DOM总结: 查找-&gt;绑定事件-&gt;查找-&gt;修改/添加/删除</p>
<pre><code>查找: 4种:
  1. 不需要查找可直接获得: html  head  body  form
  2. 节点间关系: 节点树/元素树
      鄙视: 递归遍历
  3. 按HTML: 4种: ById, ByTagName, ByName, ByClassName
  4. 按选择器: 2种:
      只找一个: querySelector()
      找多个: querySelectorAll()
修改:
  内容: .innerHTML  .textContent/.innerText  .value
  属性:
    1. 标准属性: 1. 核心DOM; 2. HTML DOM
    2. 自定义属性: 核心DOM
    3. 状态属性: HTML DOM
  样式:
    修改: elem.style.css属性=值
    获取: var style=getComputedStyle(elem)
         style.css属性 ——只读
    可通过修改class属性批量应用修改多个css属性
添加: 3步:
   1. createElement,
   2.设置关键属性,
   3. appendChild/insertBefore/replaceChild
  优化: 尽量少的操作DOM树
  如何: 2种:
   1. 同时添加父子元素: 先将子元素加入父元素，再将父元素整体添加到页面
   2. 同时添加多个平级子元素: fragment
删除: parent.removeChild(child)
HTML DOM: Select/Option  Table/...  From/Element  Image
过渡动画: 2步:
  css中: 添加transition
  js中: 修改css属性值
   不支持transition: display  zIndex
   支持: width  height  opacity   bottom/top/left/right ...
</code></pre><p>2、BOM: Browser Object Model</p>
<pre><code>什么是: 专门操作浏览器窗口的API
比如: alert prompt confirm
问题: 1. 没有标准——兼容性问题;
     2. 不可定制
window对象: 2个角色:
  1. 代替ES中的Global充当全局作用域对象
  2. 封装所有BOM和DOM的API

打开超链接: 4种:
  1. 在当前窗口打开，可后退
    html: &lt;a href=&quot;url&quot; target=&quot;_self&quot;&gt;&lt;/a&gt;
    js: /*window.*/open(&quot;url&quot;,&quot;_self&quot;)
  2. 在当前窗口打开，不可后退
    js: location.replace(&quot;url&quot;);
       用新url代替history中当前url，结果: 无法后退
  3. 在新窗口打开，可打开多个
    html: &lt;a href=&quot;url&quot; target=&quot;_blank&quot;&gt;&lt;/a&gt;
    js: open(&quot;url&quot;,&quot;_blank&quot;)
  4. 在新窗口打开，只能打开一个
    html: &lt;a href=&quot;url&quot; target=&quot;自定义name属性值&quot;&gt;&lt;/a&gt;
    js: open(&quot;url&quot;,&quot;自定义name属性值&quot;)
    原理: 内存中每个窗口都有一个唯一的name属性来唯一标示一个窗口
      浏览器规定，相同name属性的窗口只能打开一个
    其实: html中的target属性就是在设置新窗口的name属性值。
    如果target中使用自定义的窗口名，则只能打开一个
    预定义:
      _self: 默认使用当前窗口自己的name属性
           结果，新窗口覆盖当前窗口
      _blank: 意为不指定窗口名, 浏览器会随机生成不同的窗口名。
           结果: 每次打开新窗口都随机生成不同的name
                 结果: 可打开任意多个
</code></pre><p>定时器: 2种:</p>
<pre><code>1. 周期性定时器:
  什么是: 让程序按照指定时间间隔，反复执行一项任务
  何时: 只要让程序按照指定时间间隔，反复执行一项任务
  如何: 3件事:
    1. 任务函数: 让定时器反复调用的函数
    2. 启动定时器:
     var timer=setInterval(任务函数, 间隔的毫秒数)
    3. 停止定时器: clearInterval(timer)
        问题: timer中的序号会残留在timer变量中
        解决: 停止定时器后，主动清空timer
             timer=null
  停止定时器: 2种:
    1. 用户手动停止定时器: 用按钮调用clearInterval
    2. 自动停止定时器: 在任务函数中:
       1. 设定临界条件
       2. 如果达到临界条件就自动调用clearInterval

2. 一次性定时器:
 什么是: 让程序先等待一段时间，再自动执行一次任务
         执行一次后，定时器自动停止
 何时: 只要先等待，再执行一次任务
 如何: 三件事
   1. 任务函数
   2. 启动: var timer=setTimeout(任务函数, 等待的毫秒数)
   3. 停止: clearTimeout(timer)
</code></pre><p>鄙视: 定时器中的函数，只能在主程序所有程序执行后才能执行</p>
<pre><code>for(var i=0;i&lt;3;i++){
  setTimeout(function(){
    console.log(i);
  },0);
}//结果: 3 3 3
//alert(&quot;Hello&quot;) 如果不点确定，则永远不输出333
</code></pre><p>window:<br> history，location，document，navigator，screen，event</p>
<pre><code>history: 保存当前窗口打开后，成功访问过的历史记录的栈
  history封装的非常严密
  只能前进，后退，刷新: history.go(n)
   前进: go(1)  后退:go(-1)  刷新:go(0)

location: 专门保存当前窗口正在打开的url的对象
 属性: location.href 保存了完整的url
        在当前窗口打开: location.href=新url
      location.protocol: 协议
            .host: 主机名+端口号
            .hostname: 主机名
            .port: 端口号
      location.pathname: 相对路径
            .hash: 锚点地址#xxx
            .search: 表单提交后地址栏中的查询字符串
                   ?变量名=值&amp;变量名=值&amp;...
 方法:
   1. 替换history中当前url,实现进制后退:
     location.replace(&quot;新url&quot;)
   2. 在当前页面打开，可后退:
     location.assign(&quot;新url&quot;)
       =&gt; location.href=&quot;新url&quot;
        =&gt; location=&quot;新url&quot;
   3. 刷新页面:  location.reload(false/true);
     鄙视: false/true的差别
       浏览器本地是有缓存的
         浏览器的缓存中会保存css，图片等静态资源
       每次请求时，首先查看缓存中是否有想要文件
         没有想要文件，或文件过期，才去服务器下载新文件
       reload(false) 优先使用本地缓存的文件
       reload(true) 强制去服务器下载新文件
     查 浏览器缓存的原理！
</code></pre><p>1、event</p>
<pre><code>绑定事件: 2种:
 1. 在HTML中绑定: &lt;ANY on事件名=&quot;js语句&quot;
    问题: 不符合内容与行为分离的原则——不便于维护
 2. 在js中动态绑定: 2种:
    1. 一个事件只绑定一个处理函数:
       elem.on事件名=function(){
         //this-&gt;elem
       }
       解除绑定: elem.on事件名=null;
       问题: 每个事件只能绑定一个处理函数
       解决:
    2. 一个事件可同时绑定多个处理函数:
       elem.addEventListener(&quot;事件名&quot;,function(){
         //this-&gt;elem
       })
       解除绑定:
        elem.removeEventListener(&quot;事件名&quot;,&quot;函数名&quot;);
        强调: 如果一个事件处理函数可能被动态移除，则绑定时，不能使用匿名函数，必须使用有名称的函数

    事件模型: DOM标准: 3个阶段
      1. 捕获: 由外向内，记录各级父元素绑定的事件处理函数
      2. 目标触发: 首先执行目标元素上的事件处理函数
      3. 冒泡: 由内向外，反向执行捕获阶段记录的处理函数

    事件对象: 事件发生时自动创建的
             封装事件信息
             提供操作事件的API 的对象
      何时: 只要希望获得事件信息或修改事件的默认行为
      如何: 事件对象，在事件发生时，通常作为事件处理函数的第一个参数，默认自动传入！
          .on事件名=function(e){
             //e会自动获得事件对象
          }
    阻止蔓延/冒泡: e.stopPropagation();
    利用冒泡:
      优化: 尽量少的添加事件监听
      原理: 因为浏览器触发事件监听，是采用遍历查找的方式。添加的监听越多，遍历的速度越慢
      如何: 如果多个子元素都要绑定相同的事件
          只要在父元素绑定一次，所有子元素即可共用
      难题:
         1. 获得目标元素:
            不能用this, 因为this指父元素
            应该用e.target，保存实际点击的目标元素
         2. 鉴别目标元素:
            先判断目标元素的nodeName或className...
            只有目标元素符合要求时，才执行事件操作
    取消事件/阻止默认行为: e.preventDefault();
    事件坐标: 3对儿:
      1. 相对于整个屏幕左上角的坐标: e.screenX|screenY
      2. 相对于文档显示区左上角的坐标: e.clientX|clientY
      3. 相对于当前元素左上角的坐标: e.offsetX|offsetY

    页面滚动:
      事件: window.onscroll
      获得页面滚动位置: document.body.scrollTop
          页面超出文档显示区顶部的距离
</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;ol&gt;
&lt;li&gt;&lt;p&gt;DOM: Document Object Model&lt;/p&gt;
&lt;p&gt; DOM是专门操作网页内容的API标准&lt;br&gt; 为什么: 早起js操作不同浏览器的API没有标准，有严重兼容性问题&lt;br&gt; 所以，W3C制定了统一的操作网页内容的API标准,所有浏览器厂商
    
    </summary>
    
      <category term="学习笔记" scheme="www.wangchengzou.cn/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="javaScript" scheme="www.wangchengzou.cn/tags/javaScript/"/>
    
      <category term="DOM" scheme="www.wangchengzou.cn/tags/DOM/"/>
    
      <category term="BOM" scheme="www.wangchengzou.cn/tags/BOM/"/>
    
  </entry>
  
  <entry>
    <title>Ionic基础知识</title>
    <link href="www.wangchengzou.cn/2017/07/22/Ionic/"/>
    <id>www.wangchengzou.cn/2017/07/22/Ionic/</id>
    <published>2017-07-22T15:48:26.000Z</published>
    <updated>2017-07-23T15:53:37.919Z</updated>
    
    <content type="html"><![CDATA[<p>一、当前移动端开发的整体趋势</p>
<pre><code>三种趋势
WebApp:通过前端技术来实现的接近传统应用程序体验的app
NativeApp:通过（Google或者Apple）SDK（software development kit 软件开发包）提供的原生的组件和服务，编写的app称之为原生应用
HybridApp：通过前端技术与原生技术混合编程所生成的app称为hybirdApp

学习WebApp以及HybridApp。

将3中开发模式对比，hybridApp是非常有潜力的，可以实现原生应用程序的功能，支持上传到应用市场，让用户去下载 去使用

前端+原生
想要创建ios的应用程序，开发工具：xcode（apple）,模拟器需要在MacOSX
想要创建Android的应用程序，开发工具：eclipse/AndroidStudio,模拟器是可以运行PC、MacOSX、Linux
</code></pre><p>二、第一个Android应用程序–搭建Android的开发环境</p>
<pre><code>采用的开发语言：java

使用Goolge公司所提供的SDK，java

①安装jdk
    java development kit java开发工具箱
②安装eclipse
③安装sdk
    http://www.androiddevtools.cn/
    ①、下载jdk 直接安装
    ②、下载ADT bundle（集成了eclipse、sdk）
</code></pre><p>三、使用Eclipse创建第一个AndroidApp</p>
<pre><code>操作注意事项：
    工具条--》window--》show/hide toolbar 显示隐藏工具条
    工具条--》window--》reset perspective 恢复默认视图
    工具条--》window--》preferences-&gt;genaeral-&gt;apperance-&gt;color and fonts-&gt;basic-&gt; text font-&gt;edit

    sdk manager：更新SDK
    Android Virtual Device Manager:管理模拟器的创建、编辑、删除
    创建模拟器：1、testPhone 2、选中4寸的设备 3、给SD卡指定大小
    start-》launch

创建Android项目
file-&gt;new -&gt;Android Application Project-&gt;配置应用名称以及包的名称-》配置icon，finish完成Android工程的创建

运行Android项目
选中项目，点击右键，run as-&gt;Android Application Project

对于AndroidApp来说，添加权限，基本步骤：
①找到工程中根目录下的AndroidManefiest.xml文件
②打开，选中选项卡permissions
③点击add，在弹窗中选中uses permission
④在右侧的下拉菜单中选中需要用到的权限，保存即可

Android工程所对应的目录功能：
src(source) 源代码，java文件的修改
gen 自动生成的文件夹 R.java非常关键的文件，可以通过R这个类找到android工程中所有的资源文件
Android* 是google所提供的sdk文件
assets 不希望被处理的文件放在该文件夹(在将工程代码打包成可执行文件的，多数文件都会被处理)
bin 运行工程（编译、链接）时所生成的可执行文件(apk)
libs(libraries) 库文件：使用第三方的包
res（resource） 资源文件：图片、布局文件、变量
AndroidManifest.xml： 版本号、权限、图标的配置、应用的配置。。。
</code></pre><p>四、第一个hybridApp  – webView</p>
<pre><code>1、基本步骤：
①按照功能和要求 把前端代码编写完毕
②将前端代码 放到 Android工程的assets目录
③创建一个WebView（网页视图组件），配置webView加载指定的html页面
④将webView作为一个app的内容视图展现出来
⑤运行，最终是生成了安装包

2、练习：（15:40 - 15：55）
创建一个混合编程app，有一个p、有一个按钮，点击按钮将段落隐藏。
要求：创建一个新的Android。
问题：判断变量、数据，通过console.log控制台打印出来，确认是不是要的数据。
解决：借助于webview的setWebChromeClient

3、混合编程的常见的两种方式
①直接将在pc端测试好的前端代码 全部拷贝到 android工程，打包生成一个app
②将测试号的代码直接部署在服务器端， 让webview去加载指定的服务器的地址，加上网络权限


练习：将开饭啦项目部署在服务器端（本地的服务器 apache mysql），然后通过webview加载，生成app
http://localhost/chaptor4_code/angularjs/kfl/kaifanle.html
localhost替换成当前pc的真实的ip地址：windows+R-&gt;cmd-&gt;ipconfig 查看ipv4的地址
http://172.163.100.53/chaptor4_code/angularjs/kfl/kaifanle.html
注意事项：①加上网络权限 ②允许执行js

技巧：
①timeout 超时
    只需要将eclipse和模拟器关掉再打开
②ActivityManager: Warning: Activity not started, its current task has been brought to the front
    没有对原有的项目做任何的修改，又去重复去运行，会提示该警告
③android library projects can&apos;t be launched
    创建Android工程，把工程标记为了一个库项目，只能重新新建工程
ADB：Android Debug Bridge 建立起PC端和移动端的桥梁。

如何完成Android工程的创建、运行基本流程以及工作方式
学习HybridApp的创建和运行

扩展1：
js调用原生组件：
①创建一个接口类的文件
②activity配置使用接口
③在js中调用java中的一些接口

扩展2：
js调用原生组件：
①创建一个接口类的文件
    @JavascriptInterface

②activity配置使用接口
 wv.addJavascriptInterface(
new webInterfac(getApplicationContext()),&quot;android&quot;);

③在js中调用java中的一些接口
function callShowToast(){
    android.showToast();
  }
</code></pre><p>五、Ionic概述</p>
<pre><code>移动端app的开发有很多实现方案，原生、现成的框架（ionic、jQueryMobile）
Ionic是一个强大的h5的混合编程app开发框架
Ionic集成了ng、cordova、一套非常漂亮的移动的ui库
注意事项：Ionic放弃了iOS6、Android4.1以下版本的支持
特点：
    ①完美融合了ng
    ②集成了cordova，能够通过前端代码调用智能设备的底层硬件
    ③设计风格好
    ④性能优越，运行速度块
    Ionic = ng + cordova + 移动ui库
</code></pre><p>六、搭建Ionic的开发环境</p>
<pre><code>1、方式1 （命令行）
http://ionicframework.com/getting-started/
①npm install -g cordova ionic
    全局安装cordova以及ionic
②ionic start myApp tabs/sidemenu
    创建一个基于ionic的项目myApp，类型为tabs、sideMenu
③ionic serve
2、方式2：借助于官方所提供的js、css文件
</code></pre><p>七、学习Ionic样式类</p>
<pre><code>1、color
    9个常用的值 ，参考手册中最后一个color的介绍

2、button按钮
    button/button-small/button-large/button-outline/
    button-clear/buttn-block/icon-left/icon-right/
    ion-***/button-bar

3、list 列表
    list/item/item-icon-left/item-icon-right/list-inset(嵌入效果)/
    item-divider(分隔符)/badge(badge-assertive)
    item-avator/item-thumbnail-left/right

4、card 卡片式

5、form 表单
    list/item/item-input/input-label/item-stacked-label/item-floating-label
    item-toggle(ionToggle)/item-select/ionCheckbox /ionRadio

6、grid
    row/col
    col-10/20/50..(指定列的宽度)
    .col-10    10%
    .col-20    20%
    .col-25    25%
    .col-33    33.3333%
    .col-50    50%
    .col-67    66.6666%
    .col-75    75%
    .col-80    80%
    .col-90    90%(设置列与列之间的offset)

    .col-offset-10    10%
    .col-offset-20    20%
    .col-offset-25    25%
    .col-offset-33    33.3333%
    .col-offset-50    50%
    .col-offset-67    66.6666%
    .col-offset-75    75%
    .col-offset-80    80%
    .col-offset-90    90%
    col-center/col-top/col-bottom
</code></pre><p>八、IonRefresher 下拉刷新</p>
<pre><code>①指定下拉刷新的处理函数
on-refresh
②处理完之后，结束刷新动作
$scope.$broadcast(&apos;scroll.refreshComplete&apos;);
③ionContent第一个子元素
</code></pre><p>九、IonInfiniteScroll 无限滚动（上拉加载更多）</p>
<pre><code>①指定上拉的处理函数
on-infinite
②数据更新完成之后，结束刷新
scroll.infiniteScrollComplete
③ionContent最后一个子元素
immediate-check=&apos;false&apos;
</code></pre><p>十、$ionicScrollDelegate</p>
<pre><code>scrollTop/Bottom() 滚动到顶部或者底部
scrollTo(left,top) 滚动到指定的位置
getScrollPostion() 得到当前的滚动位置（返回对象：top\left）
</code></pre><p>十一、ionTabs 实现选项卡</p>
<pre><code>ionTabs 常用属性：
tabs-icon-top/left/right/bottom/only tabs-positive
http://ionicons.com/
ionTab 常用的属性：title/icon/icon-on/icon-off/on-select(ionTabs默认是第一个被选中)
                  badge/badge-style/on-select/ng-click
</code></pre><p>十二、ionSideMenus 侧边栏菜单</p>
<pre><code>ionSideMenus父级元素，在中间写上:ionSideMenuContent(正文),ionSideMenu（侧边栏菜单）
操作侧边栏菜单打开或者关闭：
1、js：
    $ionicSideMenuDelegate.toggleLeft/toggleRight(true/false);
2、滑动打开
3、属性
    menu-close 将现在打开的侧边栏菜单关掉
    menu-toggle=&apos;left/right&apos; 对左边或则右边的侧边栏菜单进行开关的切换
</code></pre><p>十三、ActionSheet</p>
<pre><code>给用户提供有多种选择的小菜单，借助于$ionicActionSheet来实现
    $ionicActionSheet.show({

    })
在show方法的对象中常用属性：titleText/cancelText/buttons/destructiveText/
cancel/buttonClicked/destructiveButtonClicked
(处理方法中，可以通过返回true，关掉当前打开的actionSheet)
</code></pre><p>十四、$ionicLoading</p>
<pre><code>在移动端当需要处理的时间比较久时，通过该服务显示一个遮盖层
$ionicLoading.show({template/templateUrl/duration/delay})
$ionicLoading.hide();
</code></pre><p>十五、$ionicPopup</p>
<pre><code>在ionic中内容弹窗（警告、确认。。）
$ionicPopup.alert/confirm/prompt/show()
</code></pre><p>十六、自定义弹窗</p>
<pre><code>$ionicModal 模态窗
①指定要去显示的模板内容
②调用fromTemplate/fromTemplateUrl加载模板，并在then方法中得到对应的ionicModal的实例:$scope.modal
③调用$scope.modal.show()
</code></pre><p>十七、uiRouter</p>
<pre><code>定位：UI-Router is a client-side router for single page web applications.
注意：uiRouter用在ng、react中
uiRouter与ngRoute最大的区别：uiRouter支持路由的嵌套。

ngRoute：
①路由的基本步骤
   自定义模块，指定ngRoute模块（angular-route.js）
   指定盛放代码片段的容器 ngView
   创建代码片段
   配置路由词典
    $routerProvider.when().otherwise()
②跳转
  直接修改地址栏
  $location.path(路由地址)
  a href=&apos;#路由地址&apos;
③参数的传递
  发送方、接收方
  配置接收方的路由
  $routeParams
  发送参数

uiRouter的基本使用步骤：
 指定依赖的模块‘ui.router’
 盛放代码片段的容器 uiView
 创建模板文件
 设置状态
    $stateProvider.state()
注意事项：在ionic中的ionic模块 本身在创建时已经指定过依赖于ui.router模块，
        在ionic的项目没有必须要指定ui.router
</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;一、当前移动端开发的整体趋势&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;三种趋势
WebApp:通过前端技术来实现的接近传统应用程序体验的app
NativeApp:通过（Google或者Apple）SDK（software development kit 软件开发包）提供的原生的组件
    
    </summary>
    
      <category term="学习笔记" scheme="www.wangchengzou.cn/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="App" scheme="www.wangchengzou.cn/tags/App/"/>
    
      <category term="Ionic" scheme="www.wangchengzou.cn/tags/Ionic/"/>
    
  </entry>
  
  <entry>
    <title>MySql常用方法知识</title>
    <link href="www.wangchengzou.cn/2017/07/22/MySql/"/>
    <id>www.wangchengzou.cn/2017/07/22/MySql/</id>
    <published>2017-07-22T15:48:26.000Z</published>
    <updated>2017-07-23T16:08:55.461Z</updated>
    
    <content type="html"><![CDATA[<p>添加用户方法 grant</p>
<pre><code>&gt;grant select,insert,update,delete,create,drop
&gt;on tutorials.*
&gt;to &apos;zara&apos;@&apos;localhost&apos;
&gt;identified by &apos;zara123&apos;;
以上为为指定数据库tutorials添加用户zara 密码为zara123

&gt;use数据库名；--选择操作的数据库
&gt;show databases;   ---列出所有数据库
&gt;show tables;      ---列出数据库所有表
&gt;show columns from 数据表；----显示数据表属性，属性类型，主键信息
&gt;show index from 数据表； ---显示数据表索引信息
&gt;show table status like 数据表\G; ---输出统计信息
&gt;create database库名； ----创建库名
&gt;drop database库名；   ----弹出框显示是否删除库名
&gt;int bigint double varchar datetime now()  四大数据类型
&gt;create table 表名；  ---创建数据表
&gt;drop table 表名；    ---删除表
&gt;insert into 表名（列，列）values(值，值)；---添加数据
&gt;select 列名 from 表名 where 条件；  ----查询
&gt;update 表名 set 列=值，列=值 where 条件  ----更新或修改数据
&gt;delete from 表名 where 条件； ---直接删除表内记录列
&gt;drop database if exists 库名  ---判断是否存在数据库，存在就删除
&gt;create database 库名 charset=utf8；  ---指定库名编码
&gt;set names utf8  -----设置语句编码
&gt;primary key auto_increment  --- 主键自增加，指定位置用null代替
&gt;$_request[&apos;title&apos;];--获取表单中的参数
&gt;desc 表名；----将查看该表里面的所有类型
&gt;require();  ---引用初始化PHP文件
多表查询方法（
    SELECT n.title,n.ctime,u.uname    多表联系
    FROM t_user u,t_news n;           创建别名
    WHERE u.id==n.uid          条件关系
）

{命令窗口使用SQL文件加载数据库，中文显示
    &gt;set names utf8        --文件转换编码格式
    &gt;source 文件位置    --加载文件位置
    &gt;set names gbk        --临时使用gbk格式显示中文
}
</code></pre><p>php学习基本函数</p>
<pre><code>phpinfo();显示软件版本信息
var_dump();输出数组元素
count();输出数组里面元素的个数
foreach($arr as $k=&gt;$v);用于处理关联数组遍历问题
</code></pre><p>使用php操作mhsql服务器步骤(四步走)</p>
<pre><code>1创建到MySQL服务器的连接
  $conn=mysqli_connect(...);
    服务器地址IP    本机127.0.0.1：8081
    用户名      root
    密码          p
    选择库      库名
2向MySQL服务器发送sql指令，等待服务器执行
  $sql=&quot;...&quot;;//insert/delete/update
3读取MySQL服务器返回结果
  $result=mysqli_query($conn,$sql);
4判断返回结果是否成功
  if($result===false);
5断开与MySQL服务器连接
  mysqli_close($conn);
</code></pre><p>php mysql查询操作</p>
<pre><code>1:连接数据库
  $conn=mysqli_connect(...);
  服务器地址IP    本机127.0.0.1：8081
  用户名            root
  密码          p
  选择库      库名
2:发送查询sql   SELECT
   $sql=&quot;...&quot;;    SELECT * FROM t_user;
3:读取MySQL服务器返回结果 是不是true/false
   $result=mysqli_query($conn,$sql);
4:抓取结果中数据并且转换数组
   a:抓取一行数据{关联数组}
    mysqli_fetch_assoc(结果集对象);
   b:抓取一行数据{索引数组
    mysqli_fetch_row(结果集对象);
5:断开与MySQL服务器连接
   mysqli_close($conn);
</code></pre><p>php常用函数说明</p>
<pre><code>die($str);终止当前php文件执行，并向客户输出一个终止原因说明
@    压制住当前行代码警告消息，在行首位置添加！
#time() 返回当前系统时间，以毫秒为单位整数
#mysqli_insert _id($conn) 返回连接上刚刚执行insert 语句产生ID值
#mysqli_affected_rows($conn),返回刚刚连接上执行增删改语句影响行数
location.href   为跳转方式
</code></pre><p>ajax  GET的使用方法</p>
<pre><code>1.创建Ajax对象
    var xhr= new XMLHttpRequest();
2.绑定事件
    xhr.onreadystatechange=function(){
        alert(xhr.responseText);--输出事件运行文本状态
    }
3.打开连接
    xhr.open(&apos;GET&apos;,&apos;url&apos;,true);
4.发送请求
    xhr.send(null)
</code></pre><p>Ajax 常用对象和属性事件方法</p>
<pre><code>xhr对象：向web服务器发送请求并接收返回响应消息
    var xhr =new XMLHttpRequest();
    兼容性问题，老IE8以下不支持
    采用 new ActiveXObject(&quot;Microsoft.XMLHTTP&quot;)
    对兼容性做判断 if（window.XMLHttpRequest）确认使用创建对象方法

readyState ;xhr对象当前状态，会自动改变
    对应值：0 UNSENT 请求消息未发送
        1 OPENED XHR已经找开连接
        2 HEADERS_RECEVIED xhr已经接收信息
        3 LOADING  XHR正在加载消息
        4 DONE XHR接收完成消息

status  表示服务器返回的状态码
responseText  表示服务器响应文本
responseXML   表示服务器响应XML文本

属性使用方法
    open(method,url.isAsyn)  表示打开服务器连接
        method：请求方式，GET POST
        Ulr  请求地址
        isasyn：请求方式是异步TRUE还是同步FALSE

    send（data）请求消息发送web服务器
        data：请示消息主体内容:
           GET为send(null)
           POST 为数据放在里面如send（‘id=10&amp;name=tome&amp;age=19&apos;）
</code></pre><p>#AJAX POST  标准语法和用法</p>
<pre><code>1.创建AJAX对象
 xhr=new XMLHttpRequest()
2.绑定事件
    xhr.onreadystatechange=function(){
    判断事件输出信息，返回数据
    if(xhr.readyState===4&amp;&amp;xhr.status===200){
        if(parseInt(xhr.responseText)&gt;0){
            作输出 ，返回成功结果
        }else{
            输出 失败结果
        }
    }
  }
3.打开连接
  xhr.open(&apos;POST&apos;,&apos;URL&apos;,ture)
  修改头部信息
   xhr.setRequestHeader(&apos;Content-Type&apos;,&apos;application/x-www-form-urlencoded&apos;);
4.发送请求
  xhr.send(发送参数);
</code></pre><p>修改头部信息–php首行加头部信息</p>
<pre><code>纯文本text
    header(&quot;Content-Type:text/plain&quot;);
        html-&gt;ajax
        xhr.responseText
网页页面HTML
    header(&quot;Content-Type:text/html;charset=utf-8&quot;);
        html-&gt;ajax
        xhr.responseText;
javascript
    header(&quot;Content-Type:application/javascript;charset=utf-8&quot;);
     echo &quot;var msg=&apos;hello&apos;;alert(msg)&quot;;
                html-&gt;ajax
      eval(xhr.responseText);
      示例:国际化
       当前浏览器 zh-CN  你好
                 en-US   hello
</code></pre><p>json语法和要求</p>
<pre><code>一个JSON字符串有且只有一个根，可以是{}对象 []一个数组
JSON中可以表示 数字 bool null 字符串，字符串必须用双引号
数组中可以包含多值 ，用， 分开
对象中可以包含多个键值，使用逗号分开，

怎么处理JSON数据
服务器端PHP
    header(&quot;Content-Type:application/json;charset=utf-8&quot;);
    $str=json_encode($arr)
    echo $str;

javascript 接收
    var obj=JSON.parse(xhr.responstText);
</code></pre><p>XML语法要求</p>
<pre><code>XML 文档声明
    &lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
整篇xml字符串只能一个根元素 标签有开始有结束 不能交叉
所有属性必须用双引号

XML方法
    服务器PHP
    header(&quot;Content-Type:application/xml;charset=utf-8&quot;);
    echo &quot; xml....&quot;;
    客户端JS
    AJXX请求接收数据
    var xmlDoc=xhr.responseXML;---
    获取所有标签
    var book=xmlDoc.querySelectorAll(&quot;book&quot;)
    获取其中属性
    var name=xmldDoc.querySelector(&quot;name&quot;)
</code></pre><p>jquery 常用AJAX函数</p>
<pre><code>$.get(url,callback);    发送get请求
$.post(url,data,callback);   发送post请求
$.getJSON(url,callback);    发送JSON请求‘
$.load(url);       加载
$.getScript(url.callback);
$.ajax({})   全能
    全能使用方法
    ajax({
        type:&quot;GET&quot;        请求方式post,pub,delete
        url:&quot;  url&quot;        请求地址
        data:&quot;{---:--,--:--}&quot;
            请求服务器数据
        beforeSend:fn
            请求消息发送前调用函数
        success:fn
            响应完成并且成功调用函数
        error:fn
            响应完成但是有问题的调用函数
        complete:fn
            响应完成但是无论成功与否都调用函数
    })
</code></pre><p>开发项目</p>
<pre><code>开发流程
    需求说明书---技术经理，美工
    剪切图片集---UI
    静态网页----前端
    动态网页---后端
    部署服务器----运维
    测试---------功能
    上线-----
    调试---加新功能--升级
</code></pre><p>针对cookie作了解</p>
<pre><code>添加
    document.cookie = &apos;uid=10&apos;;
    document.cookie = &apos;uname=qiangdong&apos;;

读取
    function getCookieVal(key){
            //  [&quot;uid=10&quot;,&quot;uname=qiangdong&quot;]
        var rs = null;
            //1:创建变量保存最终返回结果值
        var line = document.cookie;
        var arr = line.split(&quot;;&quot;);
            //2:按照;拆分cookie中字符串
        for(var i=0;i&lt;arr.length;i++){
            //3:循环数组中每一个键值
            var kv = arr[i];
            var option = kv.split(&quot;=&quot;);
            //4:按照=拆分
            var k = option[0].trim();
            //5:下标0 k  ---  trim()去除字符串前后空格
            var v = option[1];
            //6:下标0 v
            if(key===k){
                //7:判断如果参数中指定
                key == k
                return v;
                //8:返回v
            }
        }
        return rs;
        //9:否则返回 null
    }
     var rs = getCookieVal(&quot;uid&quot;);    //调用函数
         console.log(rs);
     var rs = getCookieVal(&quot;uname&quot;);
         console.log(rs);
     var age = getCookieVal(&quot;age&quot;);
         console.log(age);
</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;添加用户方法 grant&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;gt;grant select,insert,update,delete,create,drop
&amp;gt;on tutorials.*
&amp;gt;to &amp;apos;zara&amp;apos;@&amp;apos;localhost&amp;
    
    </summary>
    
      <category term="学习笔记" scheme="www.wangchengzou.cn/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="MySql" scheme="www.wangchengzou.cn/tags/MySql/"/>
    
      <category term="PhP" scheme="www.wangchengzou.cn/tags/PhP/"/>
    
      <category term="Ajax" scheme="www.wangchengzou.cn/tags/Ajax/"/>
    
  </entry>
  
  <entry>
    <title>Html5基础知识</title>
    <link href="www.wangchengzou.cn/2017/07/22/HTML5/"/>
    <id>www.wangchengzou.cn/2017/07/22/HTML5/</id>
    <published>2017-07-22T15:48:26.000Z</published>
    <updated>2017-07-23T16:50:23.596Z</updated>
    
    <content type="html"><![CDATA[<p>一、HTML5新特性 —— 十个新特性：凌乱</p>
<pre><code>(1)新的语义标签
(2)增强型表单(表单2.0)
(3)音频和视频
(4)Canvas绘图
(5)SVG绘图
(6)地理定位
(7)拖放API
(8)Web Worker
(9)Web Storage
(10)Web Socket
</code></pre><p>二、HTML5中表单的新特性</p>
<pre><code>(1)新的input type      &lt;input type=&quot;?&quot;&gt;
  H4中的input type：text、password、radio、checkbox、file、hidden、submit、reset、image
  H5中的input type：email、url、number、tel、search、range、color、date、month、week
(2)新的表单元素
  H4中的表单元素：input、textarea、select/option、label
  H5中新增的表单元素：datalist、progress、meter、output
(3)表单元素的新属性
</code></pre><p>三、H5中新增的表单元素 —— datalist</p>
<pre><code>&lt;datalist id=&quot;list3&quot;&gt;        datalist本身不可见
  &lt;option&gt;XX&lt;/option&gt;
  &lt;option&gt;YY&lt;/option&gt;
&lt;/datalist&gt;
&lt;input type=&quot;text&quot; list=&quot;list3&quot;&gt;
  datalist为input提供输入建议列表，用户可以从中选取，也可以手工输入
</code></pre><p>四、H5中新增的表单元素 —— progress</p>
<pre><code>显示一个进度条，有两种形式：
&lt;progress&gt;&lt;/progress&gt; 左右晃动的进度条
&lt;progress value=&quot;0.7&quot;&gt;&lt;/progress&gt; 具有指定进度值的进度条
</code></pre><p>五、H5中新增的表单元素 —— meter</p>
<pre><code>Meter：度量衡、刻度尺，用于标示一个值所处的范围：不可接受(红色)、可以接受(黄色)、非常优秀(绿色)
&lt;meter min=&quot;可取的最小值&quot; max=&quot;可取的最大值&quot; low=&quot;合理的下限值&quot;
      high=&quot;合理的上限值&quot; optimum=&quot;最佳值&quot;  value=&quot;当前实际值&quot;&gt;
&lt;/meter&gt;
</code></pre><p>六、H5中新增的表单元素 —— output</p>
<pre><code>output：输出，语义标签，没有任何外观样式，样式上等同于SPAN。
  商品单价: ￥3.50
购买数量：&lt;input type=&quot;number&quot; value=&quot;1&quot;&gt;
小计：&lt;output&gt;￥3.50&lt;/output&gt;
</code></pre><p>七、H5表单新特性 —— 表单元素的新属性</p>
<pre><code>H4中表单元素的属性：  &lt;input ?&gt;
  id、class、title、style、type、value、name、readonly、disabled、checked
H5中表单元素的新属性：
  (1)placeholder：占位字符
    &lt;input value=&quot;tom&quot; placeholder=&quot;请输入用户名&quot;&gt;
  (2)autofocus：自动获取输入焦点
    &lt;input autofocus&gt;
  (3)multiple：允许输入框中出现多个输入（用逗号分隔），如邮箱输入域
    &lt;input type=&quot;email&quot; multiple&gt;
  (4)form：用于把输入域放置到FORM外部
    &lt;form id=&quot;f5&quot;&gt;&lt;/form&gt;
    &lt;input form=&quot;f5&quot;&gt;
  ====输入验证相关的新属性======
  (5)required：必填项，内容不能为空
    &lt;input required&gt;
  (6)maxlength：指定字符串的最大长度
    &lt;input maxlength=&quot;9&quot;&gt;
  (7)minlength：指定字符串的最小长度
    &lt;input minlength=&quot;6&quot;&gt;
  (8)max：指定数字的最大值
    &lt;input max=&quot;60&quot;&gt;
  (9)min：指定数字的最小值
    &lt;input min=&quot;18&quot;&gt;
  (10)pattern：指定输入必需符合的正则表达式
    &lt;input pattern=&quot;1[35789]\d{9}&quot;&gt;
  上述验证属性会影响表单元素对应的JS对象的validity属性。
</code></pre><p>九、H5新特性——视频播放</p>
<pre><code>H5提供了一个新的标签用于播放视频：
  &lt;video src=&quot;res/birds.mp4&quot;&gt;&lt;/video&gt;
  &lt;video&gt;
          &lt;source src=&quot;res/birds.mp4&quot;&gt;
          &lt;source src=&quot;res/birds.ogg&quot;&gt;
          &lt;source src=&quot;res/birds.webm&quot;&gt;
          您的浏览器不支持VIDEO播放！
  &lt;/video&gt;
它本身是一个300*150的inline-block元素。
VIDEO标签/对象常用的成员：
成员属性：
  autoplay：false，是否自动播放
  controls：false，是否显示播放控件
  loop：false，是否循环播放
  muted：false，是否静音播放
  poster：&apos;&apos;，在播放第一帧之前显示的海报
  preload：视频的预加载策略，可取值：
      auto：预加载视频的元数据以及缓冲一定时长
      metadata：仅预加载视频的元数据(尺寸、时长、第一帧内容)，没有视频缓冲
      none：不预加载任何数据
   -------------JS对象属性---------------------
  currentTime：当前播放的时长
  duration：总时长
  paused：true，当前视频是否处于暂停状态
  volume：1，当前音量
  playbackRate：1，回放速率，大于1表快放，小于1表慢放
成员方法：
  play( )： 播放视频
  pause( )： 暂停播放
成员事件：
  onplay：    当视频开始播放时触发的事件
  onpause：当视频开始暂停时触发的事件
</code></pre><p>十、H5新特性——音频播放</p>
<pre><code>H5提供了一个新的标签用于播放音频：
  &lt;audio src=&quot;res/bg.mp3&quot;&gt;&lt;/audio&gt;
  &lt;audio&gt;
          &lt;source src=&quot;res/bg.mp3&quot;&gt;
          &lt;source src=&quot;res/bg.ogg&quot;&gt;
          &lt;source src=&quot;res/bg.wav&quot;&gt;
          您的浏览器不支持AUDIO播放！
  &lt;/audio&gt;
它默认是一个300*30的inline-block元素；但若没有controls属性，则display:none。
AUDIO标签/对象常用的成员：
成员属性：
  autoplay：false，是否自动播放
  controls：false，是否显示播放控件
  loop：false，是否循环播放
  muted：false，是否静音播放
  preload：视频的预加载策略，可取值：
      auto：预加载视频的元数据以及缓冲一定时长
      metadata：仅预加载视频的元数据(尺寸、时长、第一帧内容)，没有视频缓冲
      none：不预加载任何数据
   -------------JS对象属性---------------------
  currentTime：当前播放的时长
  duration：总时长
  paused：true，当前视频是否处于暂停状态
  volume：1，当前音量
  playbackRate：1，回放速率，大于1表快放，小于1表慢放
成员方法：
  play( )： 播放视频
  pause( )： 暂停播放
成员事件：
  onplay：    当视频开始播放时触发的事件
  onpause：当视频开始暂停时触发的事件
</code></pre><p>十一、网页中可用的绘图技术</p>
<pre><code>  网页中的实时走势图、统计图、在线画图板、网页游戏、地图应用都要使用到绘图技术。有三种绘图技术：
  (1)SVG绘图：2D矢量绘图技术，2000年出现，后纳入H5标准
  (2)Canvas绘图：2D位图绘图技术，H5提出的绘图技术
  (3)WebGL绘图：3D绘图技术，尚未纳入H5标准

Canvas绘图难点所在：
(1)坐标系
(2)单词比较多
</code></pre><p>十二、H5新特性——Canvas绘图技术</p>
<pre><code>Canvas：画布，是H5提供的2D绘图技术。
  &lt;canvas width=&quot;500&quot; height=&quot;400&quot;&gt;
      您的浏览器不支持Canvas标签！
  &lt;/canvas&gt;
CANVAS标签在浏览器中默认是300*150的inline-block。
画布的宽和高只能使用HTML/JS属性来赋值，不能使用CSS样式赋值！
每个画布上有且只有一个“画笔”对象——称为“绘图上下文”对象——使用该对象进行绘图！
  var ctx = canvas.getContext(&apos;2d&apos;)  //得到画布上的画笔对象
  (1)使用Canvas绘制矩形
      矩形的定位点在自己的左上角
      ctx.lineWidth = 1            描边宽度
      ctx.fillStyle = &apos;#000&apos;        填充样式/颜色
      ctx.strokeStyle = &apos;#000&apos;        描边样式/颜色
      ctx.fillRect( x, y, w, h )        填充一个矩形
      ctx.strokeRect( x, y, w, h )    描边一个矩形
      ctx.clearRect( x, y, w, h )        清除一个矩形范围内所有的绘图
  (2)使用Canvas绘制文本
    一段文字的定位点在其文本基线的起点
      ctx.textBaseline = &apos;alphabetic&apos;    文本基线
      ctx.font = &apos;12px sans-serif&apos;    文本大小和字体
      ctx.fillText( str, x, y )            填充一段文本
      ctx.strokeText( str, x, y )        描边一段文本
      ctx.measureText( str )    基于当前文字大小字体设置测量文本，返回一个对象：{width: x}
</code></pre><p>十三、Canvas绘图中使用渐变对象</p>
<pre><code>线性渐变： linearGradient
径向渐变： radialGradient
可以参考PS中的渐变效果。
var g = ctx.createLinearGradient( x1, y1,  x2,  y2 );
g.addColorStop( offset,  color )
....
g.addColorStop( offset,  color )
ctx.strokeStyle = g;
ctx.fillStyle = g;
</code></pre><p>十四、Canvas：是H5提供的2D位图绘图技术。</p>
<pre><code>&lt;canvas id=&quot;c1&quot; width=&quot;500&quot; height=&quot;400&quot;&gt;
    您的浏览器不支持Canvas
&lt;/canvas&gt;
var ctx = c1.getContext(&apos;2d&apos;)
//绘制矩形  ctx.fillRect()/strokeRect()/clearRect()
//绘制文本  ctx.fillText()/strokeText()/measureText()
//绘制路径
//绘制图像

1.Canvas的尺寸不能用CSS指定
  使用CSS指定的Canvas尺寸，实际不是修改了画布尺寸，而是进行了拉伸，上面的绘图内容也会随着进行拉伸。
  可以使用HTML标签的width和height属性，也可以使用JS对象的width和height属性。

2.使用Canvas进行绘图 —— 路径
  Path：类似于PS中的“钢笔工具”，由多个坐标点组成的任意形状，路径不可见，可用于“描边”、“填充”、“裁剪”。
  ctx.beginPath()        开始一条新路径
  ctx.closePath()        闭合当前路径
  ctx.moveTo(x, y)        移动到指定点
  ctx.lineTo(x, y)        从当前点到指定点画直线
  ctx.arc(cx, cy, r, start, end)    绘制圆拱路径

  ctx.stroke()            对当前路径描边
  ctx.fill()                对当前路径填充
  ctx.clip()            使用当前路径进行裁剪

3.使用Canvas进行绘图 —— 图像
  Canvas属于客户端技术，图片在服务器中，所以浏览器必须先下载要绘制的图片，且等待图片异步加载完成：
  var p3 = new Image();
  p3.src = &apos;img/p3.png&apos;;    //浏览器会自动异步请求图片
  console.log(p3.width);    //0
  p3.onload = function(){      //图片加载完成
        console.log(p3.width);      //200
        //开始绘制图片到画布上....
    ctx.drawImage( p3, x, y );        //原始大小绘图
    ctx.drawImage( p3, x, y, w, h );    //拉伸绘图
  }

Canvas绘图核心知识点：—— 重点
绘制矩形：
  ctx.fillRect()  ctx.strokeRect()   ctx.clearRect()
绘制文本：
  ctx.fillText()  ctx.strokeText()   ctx.measureText().width
绘制路径：
  ctx.beginPath()    ctx.closePath()
  ctx.moveTo()   ctx.lineTo()
  ctx.arc()
  ctx.stroke()   ctx.fill()    ctx.clip()
绘制图像：
  ctx.drawImage()


4.使用Canvas绘图时进行变形操作
  CSS中有变形相关样式： transform: rotate/scale/translate/skew，这些变形只能作用于某个HTML元素。
  Canvas绘图中也有变形技术，可以针对某一个图像/图形的绘制过程进行变形：rotate、scale、translate。
  ctx.rotate( 弧度 )     旋转绘图上下文对象(即画笔),轴点是画布的原点
  ctx.translate( x, y )  将整个画布的原点平移到指定的点
  ctx.save()         保存画笔当前的所有变形状态值（游戏中从存盘）
  ctx.restore()        恢复画笔变形状态到最近的一次保存（游戏中读取存盘）

5.第三方绘制统计图工具
  (1)Chart.js：免费的，提供了八种统计图表
  (2)FusionCharts.js：收费的，提供了90+中统计图表
  (3)ECharts：百度提供的免费的绘图工具，与地图整合的很好
  (4)FreeCharts ....

提示：第三方工具使用无需记忆！重点掌握自学的过程：
(1)打开官网，查看说明
    http://www.chartjs.org/
(2)仿照DEMO编写示例
    开源免费的、8种图表、基于H5 Canvas、支持响应式
(3)在实际项目中加以应用，查看详细API说明
    &lt;canvas id=&quot;c15&quot; width=&quot;500&quot; height=&quot;400&quot;&gt;
            您的浏览器不支持Canvas绘图！
    &lt;/canvas&gt;
    &lt;script src=&quot;js/Chart.js&quot;&gt;&lt;/script&gt;
    &lt;script&gt;
        new Chart(c15, {
            type: &apos;bar&apos;,//line、pie、noughnut...
            data: {},
            options: {}
            });
    &lt;/script&gt;

位图(Photoshop)：由一个又一个像素点组成，每个点各有自己的颜色，色彩细腻，但放大会失真
矢量图(Illustrator)：由一个又一个线条组成，每个线条可以指定颜色、方向，可以无限缩放，但细节不够丰富
</code></pre><p>十五、HTML5新特性——SVG绘图</p>
<pre><code>Scalable Vector Graph：可缩放的矢量图
Canvas绘图    SVG绘图
类型    2D位图    2D矢量图
如何绘图    使用JS代码绘图    使用标签绘图
事件绑定    每个图形不是元素，无法直接绑定事件    每个图形都是元素，可以直接绑定事件监听
应用场合    统计图、游戏    统计图、图标、地图
  SVG技术诞生于2000年，早期作为XML的扩展应用出现；H5标准把常用的SVG标签采纳为标准，但有些被废弃掉。

SVG技术在HTML5出现之前的使用方法：
    (1)在一个XML文档中声明要绘制的图形
    (2)再编写HTML文档，使用IMG/IFRAME应用XML文档即可
SVG技术在HTML5出现之后的使用方法：
    直接创建HTML5文档，在其中书写SVG标签即可
    &lt;svg&gt;&lt;/svg&gt;本身是一个300*150的inline-block。

使用SVG标签绘制矩形：
    &lt;rect&gt;
使用SVG标签绘制圆形：
    &lt;circle&gt;
使用SVG标签绘制椭圆：
    &lt;ellipse&gt;
使用SVG标签绘制直线：
    &lt;line&gt;
使用SVG标签绘制折线：
    &lt;polyline&gt;
使用SVG标签绘制多边形：
    &lt;polygon&gt;
</code></pre><p>十六、补充：Canvans上如何按照特定的顺序绘制图片</p>
<pre><code>Canvas绘图中若需要多张图片，他们的加载都是异步的，无法预测哪一张先加载完成！
但是绘图往往需要按照一定顺序，如先绘背景，再绘上面的内容。所以必须等待所有图片全部加载完成，才能开始绘图。
var progress = 0; //所有图片的总加载进度
var imgBg = new Image();
imgBg.src = &apos;img/bg.jpg&apos;;
imgBg.onload = function(){
  progress += 40;    //为每张图片赋一个权重值
  if(progress===100){
    startDraw();
  }
}
var imgDisc = new Image();
imgDisc.src = &apos;img/disc.png&apos;;
imgDisc.onload = function(){
  progress += 60;
  if(progress===100){
    startDraw();
  }
}
</code></pre><p>十七、补充：如何为Canvas上的图形/图像绑定事件监听</p>
<pre><code>网页中只能为HTML元素绑定监听函数，Canvas上的图形/图像都是用JS绘制的，不是DOM元素，不能直接进行事件绑定！
只能绑定给整个Canvas！然后再具体计算事件发生坐标是否处于某个图像/图形内部——仅适用于规则图像/图形。
  SVG图形中为元素绑定事件监听
  SVG图形中每个图形/图像都是一个标签，可以很方便进行事件绑定
</code></pre><p>十八、SVG绘图的特点——着重注意！</p>
<pre><code>(1)所有的图形默认只有填充色（黑色），没有描边色。
(2)SVG图形的样式可以用元素属性声明，也可以用CSS形式来声明。但用CSS声明时，只能使用SVG专用的样式，不能使用CSS样式，如边框设置只能用stroke，而不用border！
(3)图形可以使用JS来对属性赋值；但不能使用HTML DOM形式，只能用核心DOM操作，如：
  r.x = 10;   r.width = 100;    //无效
  r.setAttribute(&apos;x&apos;, 10); r.setAttribute(&apos;width&apos;, 100)//有效
(4)动态添加SVG图形可以使用两种方式：
   1)HTML字符串拼接
       var html = `&lt;rect&gt;&lt;/rect&gt;`;
       svg.innerHTML = html;
   2)使用document.createElementNS(&apos;http://www.w3.org/2000/svg&apos;,&apos;标签名&apos;)创建

4.使用SVG进行绘图——矩形
  &lt;rect width=&quot;&quot; height=&quot;&quot; x=&quot;&quot; y=&quot;&quot; fill=&quot;&quot; fill-opacity=&quot;&quot; stroke=&quot;&quot; stroke-width=&quot;&quot; stroke-opacity=&quot;&quot;&gt;&lt;/rect&gt;

5.使用SVG进行绘图——圆形
  &lt;circle r=&quot;&quot; cx=&quot;&quot; cy=&quot;&quot; fill=&quot;&quot; fill-opacity=&quot;&quot; stroke=&quot;&quot; stroke-opacity=&quot;&quot;&gt;&lt;/circle&gt;

6.使用SVG进行绘图——椭圆
  &lt;ellipse rx=&quot;&quot; ry=&quot;&quot; cx=&quot;&quot; cy=&quot;&quot;&gt;&lt;/ellipse&gt;

7.使用SVG进行绘图——直线
  &lt;line x1=&quot;&quot; y1=&quot;&quot; x2=&quot;&quot; y2=&quot;&quot; stroke=&quot;&quot; stroke-width=&quot;&quot; stroke-linecap=&quot;butt/square/round&quot;&gt;&lt;/line&gt;
 练习：使用SVG中的直线绘制如下的图标

提示：若多个SVG图形有完全一样的属性，可以抽出来，放在一个公共的父元素中（小组）
&lt;g stroke=&quot;#000&quot;&gt;
   &lt;line&gt;&lt;/line&gt;
   &lt;line&gt;&lt;/line&gt;
&lt;/g&gt;

8.使用SVG进行绘图——折线
  一条折线上可以有任意多个连续的点
  &lt;polyline points=&quot;50,50  100,300 ...&quot; fill=&quot;transparent&quot; stroke=&quot;#000&quot;&gt;&lt;/polyline&gt;
 练习：使用折线绘制如下图标

9.使用SVG进行绘图——多边形
&lt;polygon points=&quot;50,50  100,300 ...&quot; fill=&quot;&quot;&gt;&lt;/ polygon&gt;
  练习：使用多边形绘制如下两个图标

10.附加：使用SVG进行绘图——文本
  SVG画布上不允许使用普通的HTML元素绘制文本，如SPAN、P等！只能使用：
  &lt;text font-size=&quot;&quot; alignment-baseline=&quot;before-edge&quot; fill=&quot;&quot; stroke=&quot;&quot; x=&quot;&quot; y=&quot;&quot;&gt;文本内容 &lt;/text&gt;

11.附加：使用SVG进行绘图——图像
  不能使用IMG置于SVG画布上！只能使用：
  &lt;image xlink:href=&quot;disc.png&quot; width=&quot;200&quot; height=&quot;200&quot; x=&quot;&quot; y=&quot;&quot;&gt;&lt;/image&gt;
SVG绘图的主要知识点：
&lt;svg&gt;
  &lt;rect&gt;&lt;/rect&gt;
  &lt;circle&gt;&lt;/circle&gt;
  &lt;ellipse&gt;&lt;/ellipse&gt;
  &lt;line&gt;&lt;/line&gt;
  &lt;polyline&gt;&lt;/polyline&gt;
  &lt;polygon&gt;&lt;/polygon&gt;
  &lt;text&gt;&lt;/text&gt;
  &lt;image&gt;&lt;/image&gt;
&lt;/svg&gt;

12.补充小知识：如何在SVG中使用渐变
  &lt;defs&gt;      定义特效对象：渐变对象属于一种特效对象
    &lt;linearGradient id=&quot;g3&quot; x1=&quot;&quot; y1=&quot;&quot; x2=&quot;&quot; y2=&quot;&quot;&gt;
        &lt;stop offset=&quot;0&quot; stop-color=&quot;&quot; stop-opacity=&quot;&quot;/&gt;
        &lt;stop offset=&quot;1&quot; stop-color=&quot;&quot; stop-opacity=&quot;&quot;/&gt;
    &lt;/linearGradient&gt;
  &lt;/defs&gt;
  &lt;ANY fill=&quot;url(#g3)&quot;  stroke=&quot;url(#g3)&quot;&gt;&lt;/ANY&gt;
 练习：使用渐变对象，为不同的柱子分配不同的渐变色


13.补充小知识：如何在SVG中使用滤镜
  &lt;defs&gt;
    &lt;filter id=&quot;f2&quot;&gt;
        &lt;feGaussianBlur stdDeviation=&quot;3&quot;/&gt;
    &lt;/filter&gt;
  &lt;/defs&gt;
  &lt;ANY filter=&quot;url(#f2)&quot;&gt;

SVG中支持的所有滤镜：
https://developer.mozilla.org/en-US/docs/Web/SVG/Element/filter

网页中可用的绘图技术：
(1)Canvas绘图
(2)SVG绘图
(3)WebGL绘图

14.第三方绘图工具库  —— Two.js

 (1)打开官网，查看说明
    https://two.js.org/
    是一个2D绘图函数库，提供了一套API，可用于不同的技术下的绘图，如SVG/CANVAS/WEBGL。
 (2)参考DEMO，编写示例
    var two = new Two({ }).appendTo(box);
    //绘制一个圆形
    var c = two.makeCircle(200,200,100);
    //绘制一个矩形——定位点在矩形中心，而不是左上角
    var r = two.makeRectangle(600,200, 200,200);
    //把绘图对象中的内容绘制到DOM树
    two.update(); //更新DOM树
 (3)查看API，在项目中加以应用
</code></pre><p>十九、HTML5新特性之六 —— 地理定位</p>
<pre><code>  Geolocation：地理定位，使用JS获取当前浏览器所在的地理坐标
  （经度、维度、海拔、速度）数据，用于实现LBS应用(Location Based Service)，
  如饿了么、高德导航...
  手机浏览器如何获得定位信息：
    (1)首选手机中的GPS芯片与卫星通信，定位精度在米
    (2)次选手机通信基站进行定位获取，定位精度在公里
  PC浏览器如何获得定位信息：
    通过IP地址进行反向解析，定位精度取决于IP地址库的大小

HTML5中提供了一个新的对象，用于获取当前浏览器的定位信息：
  window.navigator.geolocation{
    getCurrentPosition: fn,    获得当前定位信息
    watchPosition: fn, 监视定位数据的改变
    clearWatch: fn  取消监视
  }
获得客户端的定位信息：
navigator.geolocation.getCurrentPosition(
    (pos)=&gt;{ pos.coords.latitude   pos.coords.longitude },
    (err)=&gt;{    err.code   err.message }
)

2.扩展小知识：在网页中如何嵌入百度地图
  (1)注册百度开发者账号
    http://lbsyun.baidu.com/
  (2)创建一个网站；登录百度地图，为网站申请一个地图的AccessKey
    http://lbsyun.baidu.com/apiconsole/key

  (3)在自己的网页中嵌入百度地图提供的API，嵌入百度地图
    官方手册：http://lbsyun.baidu.com/index.php?title=jspopular
    var map = new BMap.Map(&quot;container&quot;);          // 创建地图实例
    var point = new BMap.Point(116.300829,39.915836);  // 创建点坐标
    map.centerAndZoom(point, 17);   // 以指定点为中心并缩放
</code></pre><p>二十、HTML5新特性之七 —— 拖放API</p>
<pre><code>Drag &amp; Drop：拖动和释放
HTML5为拖放行为提供了7个事件，分为两组：
拖动的源对象(会动)可以触发的事件：
  dragstart：拖动开始
  drag：拖动中
  dragend：拖动结束
  整个拖动过程： dragstart*1 + drag*n + dragend*1
拖动的目标对象(不动)可以触发的事件：
  dragenter：拖动着进入
  dragover：拖动着悬停在上方
  dragleave：拖动着离开
  drop：在上方释放
  整个拖动过程1： dragenter*1 + dragover*n + dragleave*1
  整个拖动过程2： dragenter*1 + dragover*n + drop*1
注意：必须阻止dragover的默认行为，drop才可能触发！
</code></pre><p>二十一、HTML5新特性之八 —— Web Worker —— 代码就3行</p>
<pre><code>  程序：Program，指可被CPU执行的代码，存储在外存中
  进程：Process/Task，指程序被OS调入内存，分配执行空间，随时供CPU调度执行
  线程：Thread，线程是进程内执行代码基本单位

  进程和线程：
    (1)进程是操作系统分配内存的基本单位；
    (2)线程是CPU执行代码的基本单位；
    (3)线程必须处于某个进程内部；
    (4)一个进程内必须至少有一个线程；也可以有多个；
    (5)一个操作系统中可能同时存在几千个线程，它们是“并发执行的”—— 宏观上看同时执行，微观上看是依次循环执行

    Chrome浏览器中的线程模型：
    一个Chrome进程内，至少有6个线程，可以“同时/并发”向Web服务器发起HTTP请求，以获得所需的资源——资源请求线程。
    还有一个线程负责将所有内容绘制到浏览器页面中——UI主线程——不允许多线程同时绘图，防止内容布局错乱。

    5.观察如下一段代码执行特点
      &lt;button onclick=&quot;console.log(111)&quot;&gt;按钮1&lt;/button&gt;
      &lt;script src=&quot;14.js&quot;&gt;很耗时的JS任务&lt;/script&gt;
      &lt;button onclick=&quot;console.log(222)&quot;&gt;按钮

      现象：JS执行过程中，按钮1可见，但点击无效；按钮2不可见。
      原因：浏览器中执行代码的只有一个线程——UI主线程
      解决办法：创建新的线程，由它来执行耗时的JS任务；UI主线程继续执行后续的HTML渲染：
      &lt;button onclick=&quot;console.log(111)&quot;&gt;按钮1&lt;/button&gt;
      &lt;script&gt;
        var w = new Worker(&apos;14.js&apos;)
      &lt;/script&gt;
      &lt;button onclick=&quot;console.log(222)&quot;&gt;按钮

1.补充小知识：在拖动源对象和目标对象间传递数据
  如：拖动开始时(src.ondragstart)记录被拖动元素的ID，释放时(target.ondrop)根据ID查找拖动的源对象，进行相关操作。
  方法1：使用一个全局变量 —— 造成全局对象的污染
  方法2：使用H5拖放API专供的e.dataTransfer（数据传递）

  //拖动的源对象
  src.ondragstart = function(e){
    //海南：往拖拉机中装数据
    e.dataTransfer.setData(&apos;key&apos;, &apos;value&apos;)
  }
  //拖动的目标对象
  target.ondrop = function(e){
    //哈尔滨：从拖拉机中读取数据
    var data = e.dataTransfer.getData(&apos;key&apos;);            //value
  }
</code></pre><p>二十二、HTML5新特性之八——WebWorker——代码就3行，重点在理论理解</p>
<pre><code>进程：操作系统分配内存的单位 —— 工厂
线程：处于进程内部，用于执行代码 —— 生产线
线程并发：操作系统中所有的线程宏观上看“同时执行”；微观上看是“依次交替执行”
Chrome中的线程模型： 请求资源——6个线程；运行代码/渲染页面内容——1个线程
&lt;button&gt;按钮1&lt;/button&gt;
&lt;script src=&quot;x.js&quot;&gt;&lt;/script&gt;
&lt;button&gt;按钮2&lt;/button&gt;
上述代码中若x.js很耗时，按钮1无法点击，按钮2在运行js过程中不可见——所有的代码(HTML/CSS/JS)都在单线程(UI主线程)中执行

解决方案：创建一个并发执行的新线程，让它来执行耗时的JS任务

3.Worker线程的致命缺陷
浏览器不允许Worker线程操作任何的DOM&amp;BOM对象！！
原因：浏览器只允许UI主线程操作DOM&amp;BOM！若多个线程同时都可以操作DOM结构，页面将混乱。
所以，类似jQuery的脚步决不能使用Worker来加载执行。

Worker线程可以给UI主线程发数据消息：
  UI主线程：
      var w6 =new Worker(&apos;6.js&apos;);
      w6.onmessage = function(e){ e.data }
  Worker线程：
      postMessage(stringMsg)
UI主线程可以给Worker线程发数据消息：
  UI主线程：
      var w6 =new Worker(&apos;6.js&apos;);
      w6.postMessage(stringMsg)
  Worker线程：
      onmessage = function(e){ e.data }

  项目中Worker的使用场景：
  (1)只要js中有DOM&amp;BOM就不能用Worker！
  (2)Worker适合于执行耗时的JS任务！如复杂计算、加密和解密、大数据统计、路径规划......
</code></pre><p>二十三、HTML5新特性之九 —— WebStorage</p>
<pre><code>  在浏览器中存储当前用户专有的数据：访问历史、内容定制、样式定制...
  在客户端存储数据可以使用的技术：
  (1)Cookie技术：浏览器兼容性好；不能超过4KB，操作复杂
  (2)Flash存储：依赖于Flash播放器
  (3)H5 WebStorage：不能超过8MB，操作简单
  (4)IndexedDB：可存大量数据，还不是标准技术

Session：会话，浏览器从打开某个网站的一个页面开始，中间可能打开很多页面，
直到关闭浏览器，整个过程称为“浏览器与Web服务器的一次会话”。

WebStorage技术中，浏览器为用户提供了两个对象：
  (1)window.sessionStorage：类数组对象，会话级数据存储
    在浏览器进程所分得的内存存储着一次Web会话可用的数据，可供此次会话中所有的页面共同使用
    ；浏览器一旦关闭就消失了。
作用：在同一个会话中的所有页面间共享数据，如登录用户名。
    sessionStorage[key] = value            //保存一个数据
    sessionStorage.setItem(key, value)        //保存一个数据
    var v = sessionStorage[key]            //读取一个数据
    var v = sessionStorage.getItem(key)    //读取一个数据
    sessionStorage.removeItem(key)        //删除一个数据
    sessionStorage.clear()                //清除所有数据
    sessionStorage.length                //数据的数量
    sessionStorage.key(i)                //获取第i个key

  (2)window.localStorage：类数组对象，本地存储(跨会话级存储)
    在浏览器所能管理的外存(硬盘)中存储着用户的浏览数据，可供此次会话以及后续的会话中的页面共同使用；
即使浏览器关闭也不会消失——永久存在。作用：在当前客户端所对应的所有会话中共享数据，如登录用户名。
    localStorage[key] = value            //保存一个数据
    localStorage.setItem(key, value)        //保存一个数据
    var v = localStorage [key]            //读取一个数据
    var v = localStorage.getItem(key)        //读取一个数据
    localStorage.removeItem(key)        //删除一个数据
    localStorage.clear()                //清除所有数据
    localStorage.length            //数据的数量
    localStorage.key(i)                //获取第i个key

localStorage中若数据发生了修改，会触发一次window.onstorage事件，可以监听此事件，实现监视localStorage数据改变的目的，
用于在一个窗口中监视其它窗口中对localStorage数据的修改——不能监视sessionStorage数据的修改！

5.HTML5新特性之十 —— WebSocket——代码不复杂重点在原理的理解
  HTTP协议：属于“请求-响应”模型，只有客户端发起请求消息，服务器才会返回响应消息，没有请求就没有响应；
一个请求，只能得到一个响应。有些场景中，此模型就力不从心了：实时走势应用、在线聊天室。
解决方案：长轮询(Long-Polling)/心跳请求——定时器+AJAX——请求过于频繁，服务器压力过大；
不够频繁，客户端数据延迟较大。
  WebSocket协议：属于“广播-收听”模型，客户端连接到服务器就不再断开，永久的连接，双方就随时向对方发送消息，
且是全双工不对等发送。WS协议在实时走势应用、在线聊天室应用中有着特别的优势。


  WS协议的应用程序也分为客户端程序和服务器端程序：
  WS服务器端应用：
    监听指定端口，接收客户端请求，向对方发消息，并接收消息；可以使用php/java/node.js等语言编写
  WS客户端应用：
    主动发起连接请求，保持永久的连接，向对方消息，并接收消息，可以使用php/java/node.js/html5等语言编写

6.了解：使用Node.js创建WS协议的服务器
  node.js官方没有提供ws协议的模块，必须使用NPM下载第三方ws协议模块：  npm  i  ws
  查看README,编写WS协议的服务器：
  ......

7.掌握：使用HTML5创建WS协议的客户端应用
  //连接到WS服务器
  var socket = new WebSocket(&apos;ws://127.0.0.1:9001&apos;)
  //向服务器发消息
  socket.send(stringMsg)
  //接收服务器发来的消息
  socket.onmessage = function(e){
    e.data   //消息内容
  }
  //断开到WS服务器的连接
  socket.close();
</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;一、HTML5新特性 —— 十个新特性：凌乱&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;(1)新的语义标签
(2)增强型表单(表单2.0)
(3)音频和视频
(4)Canvas绘图
(5)SVG绘图
(6)地理定位
(7)拖放API
(8)Web Worker
(9)Web Stora
    
    </summary>
    
      <category term="学习笔记" scheme="www.wangchengzou.cn/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="h5" scheme="www.wangchengzou.cn/tags/h5/"/>
    
      <category term="html" scheme="www.wangchengzou.cn/tags/html/"/>
    
  </entry>
  
  <entry>
    <title>Zetpojs基础知识</title>
    <link href="www.wangchengzou.cn/2017/07/22/Zeptojs/"/>
    <id>www.wangchengzou.cn/2017/07/22/Zeptojs/</id>
    <published>2017-07-22T15:48:26.000Z</published>
    <updated>2017-07-23T15:56:58.353Z</updated>
    
    <content type="html"><![CDATA[<p>一、zeptojs概述</p>
<pre><code>目标：实现一个10k以内的非常轻量的移动端用的方便DOM操作的js库
what？ 是一个js库
where？现代高级浏览器（移动端）
why？轻量（放弃了对ie等低端浏览器的支持）
how？类似jQuery的用法 只需要引入js文件，调用方法即可
特点：
    学习成本低
    轻量
注意：zeptojs官网下载的包 默认包含5个模块（zepto\ie\ajax\event\form）,
        如果要用到其他模块，去zeptoBuilder
        官网：http://github.e-sites.nl/zeptobuilder/
        选择需要用到的模块，勾选，下载即可
</code></pre><p>二、使用Zepto</p>
<pre><code>1、核心模块
    集合、数据、类型判断的操作
    选择器
    DOM增删改查

2、detect
    如果不是默认的模块，可以到zeptoBuilder下载对应的模块文件。
    $.os $.browser

3、event模块
    on off one trigger

4、Ajax模块
    $.get
    $.post
    $.ajax
    $.load

5、form模块
    serialize  将表单中的输入组件的name属性和对应的值 处理成urlEncoded的字符串
    serializeArray  将表单中的输入组件的name属性和对应的值（放在value中） [{name:&apos;&apos;,value:&apos;&apos;},{...}]
    submit 表单指定submit触发时 执行的处理函数

6、Touch模块
    点按事件：tap singleTap doubleTap longTap
    滑动事件：swipe swipeLeft swipeRight swipeUp swipeDown

7、Effects（Animate）模块
    show/hide/fadeIn/fadeOut/fadeToggle
    animate
</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;一、zeptojs概述&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;目标：实现一个10k以内的非常轻量的移动端用的方便DOM操作的js库
what？ 是一个js库
where？现代高级浏览器（移动端）
why？轻量（放弃了对ie等低端浏览器的支持）
how？类似jQuery的用法 只需要
    
    </summary>
    
      <category term="学习笔记" scheme="www.wangchengzou.cn/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="App" scheme="www.wangchengzou.cn/tags/App/"/>
    
      <category term="Zetpojs" scheme="www.wangchengzou.cn/tags/Zetpojs/"/>
    
  </entry>
  
  <entry>
    <title>html和css3</title>
    <link href="www.wangchengzou.cn/2017/07/22/css3+HTML5%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    <id>www.wangchengzou.cn/2017/07/22/css3+HTML5面试题/</id>
    <published>2017-07-22T15:48:26.000Z</published>
    <updated>2017-07-28T01:27:39.844Z</updated>
    
    <content type="html"><![CDATA[<p>1、    CSS3有哪些新特性？</p>
<pre><code>1. CSS3实现圆角（border-radius），阴影（box-shadow），
2. 对文字加特效（text-shadow、），线性渐变（gradient），旋转（transform）
3.transform:rotate(9deg) scale(0.85,0.90) translate(0px,-30px)
 skew(-9deg,0deg);// 旋转,缩放,定位,倾斜
4. 增加了更多的CSS选择器  多背景 rgba
5. 在CSS3中唯一引入的伪元素是 ::selection.
6. 媒体查询，多栏布局
7. border-image
</code></pre><ol>
<li>html5有哪些新特性、移除了那些元素？如何处理HTML5新标签的浏览器兼容问题？<br>如何区分 HTML 和 HTML5？<br>新特性：<ol>
<li>拖拽释放(Drag and drop) API</li>
<li>语义化更好的内容标签（header,nav,footer,aside,article,section）</li>
<li>音频、视频API(audio,video)</li>
<li>画布(Canvas) API</li>
<li>地理(Geolocation) API</li>
<li>本地离线存储 localStorage 长期存储数据，浏览器关闭后数据不丢失；</li>
<li>sessionStorage 的数据在浏览器关闭后自动删除</li>
<li>表单控件，calendar、date、time、email、url、search</li>
<li>新的技术webworker, websocket, Geolocation<br>移除的元素：</li>
<li>纯表现的元素：basefont，big，center，font, s，strike，tt，u；</li>
<li>对可用性产生负面影响的元素：frame，frameset，noframes；<br>支持HTML5新标签：</li>
<li>IE8/IE7/IE6支持通过 document.createElement 方法产生的标签，<br>可以利用这一特性让这些浏览器支持 HTML5 新标签，浏览器支持新标签后，<br>还需要添加标签默认的样式（当然最好的方式是直接使用成熟的框架、使用最多的是html5shim框架）：<!--[if lt IE 9]>
<script> src="http://html5shim.googlecode.com/svn/trunk/html5.js"</script>
<![endif]-->
如何区分：<br>DOCTYPE声明新增的结构元素、功能元素</li>
</ol>
</li>
</ol>
<p>3、    本地存储（Local Storage ）和cookies（储存在用户本地终端上的数据）之间的区别是什么？</p>
<pre><code>Cookies:服务器和客户端都可以访问；大小只有4KB左右；有有效期，过期后将会删除；
本地存储：只有本地浏览器端可访问数据，服务器不能访问本地存储直到故意通过POST
或者GET的通道发送到服务器；每个域5MB；没有过期数据，它将保留知道用户从浏览器
清除或者使用Javascript代码移除
</code></pre><p>6、    什么是响应式设计？</p>
<pre><code>它是关于网页制作的过程中让不同的设备有不同的尺寸和不同的功能。
响应式设计是让所有的人能在这些设备上让网站运行正常
</code></pre><p>7、    新的 HTML5 文档类型和字符集是？</p>
<pre><code>HTML5文档类型：&lt;!doctype html&gt;
HTML5使用的编码&lt;meta charset=”UTF-8”&gt;
</code></pre><p>8、    HTML5 Canvas 元素有什么用？</p>
<pre><code>Canvas 元素用于在网页上绘制图形，该元素标签强大之处在于可以直接
在 HTML 上进行图形操作。
</code></pre><p>9、    HTML5 存储类型有什么区别？</p>
<pre><code>Media API、Text Track API、Application Cache API、
User Interaction、Data Transfer API、Command API、
Constraint Validation API、History API
</code></pre><p>11、    CSS3新增伪类有那些？</p>
<pre><code>p:first-of-type 选择属于其父元素的首个 &lt;p&gt; 元素的每个 &lt;p&gt; 元素。
p:last-of-type  选择属于其父元素的最后 &lt;p&gt; 元素的每个 &lt;p&gt; 元素。
p:only-of-type  选择属于其父元素唯一的 &lt;p&gt; 元素的每个 &lt;p&gt; 元素。
p:only-child    选择属于其父元素的唯一子元素的每个 &lt;p&gt; 元素。
p:nth-child(2)  选择属于其父元素的第二个子元素的每个 &lt;p&gt; 元素。
:enabled、:disabled 控制表单控件的禁用状态。
:checked，单选框或复选框被选中。
</code></pre><p>14、    html5\CSS3有哪些新特性、移除了那些元素？如何处理HTML5新标签的浏览器兼容问题？<br>    如何区分 HTML 和 HTML5？</p>
<pre><code>HTML5 现在已经不是 SGML 的子集，主要是关于图像，位置，存储，地理定位等功能的增加。
* 绘画 canvas 元素
  用于媒介回放的 video 和 audio 元素
  本地离线存储 localStorage 长期存储数据，浏览器关闭后数据不丢失；
  sessionStorage 的数据在浏览器关闭后自动删除
  语意化更好的内容元素，比如 article、footer、header、nav、section
  表单控件，calendar、date、time、email、url、search
  CSS3实现圆角，阴影，对文字加特效，增加了更多的CSS选择器  多背景 rgba
  新的技术webworker, websockt, Geolocation
移除的元素
纯表现的元素：basefont，big，center，font, s，strike，tt，u；
对可用性产生负面影响的元素：frame，frameset，noframes；
* 是IE8/IE7/IE6支持通过document.createElement方法产生的标签，
  可以利用这一特性让这些浏览器支持HTML5新标签，
  浏览器支持新标签后，还需要添加标签默认的样式：
* 当然最好的方式是直接使用成熟的框架、使用最多的是html5shim框架
&lt;!--[if lt IE 9]&gt;
&lt;script&gt; src=&quot;http://html5shim.googlecode.com/svn/trunk/html5.js&quot;&lt;/script&gt;
&lt;![endif]--&gt;
</code></pre><p>16、    你能描述一下渐进增强和优雅降级之间的不同吗?</p>
<pre><code>渐进增强 progressive enhancement：针对低版本浏览器进行构建页面，
保证最基本的功能，然后再针对高级浏览器进行效果、交互等改进和追加功能达到更好的用户体验。
优雅降级 graceful degradation：一开始就构建完整的功能，然后再针对低版本浏览器进行兼容。
　　区别：优雅降级是从复杂的现状开始，并试图减少用户体验的供给，而渐进增强则是
从一个非常基础的，能够起作用的版本开始，并不断扩充，以适应未来环境的需要。
降级（功能衰减）意味着往回看；而渐进增强则意味着朝前看，同时保证其根基处于安全地带。　
　
</code></pre><p>19、    请描述一下cookies，sessionStorage和localStorage的区别？<br>　　<br>    　　  sessionStorage用于本地存储一个会话（session）中的数据，<br>    这些数据只有在同一个会话中的页面才能访问并且当会话结束后数据也随之销毁。<br>    因此sessionStorage不是一种持久化的本地存储，仅仅是会话级别的存储。<br>    而localStorage用于持久化的本地存储，除非主动删除数据，<br>    否则数据是永远不会过期的。<br>    web storage和cookie的区别<br>    Web Storage的概念和cookie相似，区别是它是为了更大容量存储设计的。<br>    Cookie的大小是受限的，并且每次你请求一个新的页面的时候Cookie都会被发送过去，<br>    这样无形中浪费了带宽，另外cookie还需要指定作用域，不可以跨域调用。<br>    除此之外，Web Storage拥有setItem,getItem,removeItem,clear等方法，<br>    不像cookie需要前端开发者自己封装setCookie，getCookie。<br>    但是Cookie也是不可以或缺的：Cookie的作用是与服务器进行交互，<br>    作为HTTP规范的一部分而存在 ，而Web Storage仅仅是为了在本地“存储”数据而生。</p>
<p>20、    知道css有个content属性吗？有什么作用？有什么应用？</p>
<pre><code>css的content属性专门应用在 before/after 伪元素上，用来插入生成内容。
最常见的应用是利用伪类清除浮动。
//一种常见利用伪类清除浮动的代码
.clearfix:after {
    content:&quot;.&quot;; //这里利用到了content属性
    display:block;
    height:0;
    visibility:hidden;
    clear:both; }
.clearfix {
    *zoom:1;
}
after伪元素通过 content 在元素的后面生成了内容为一个点的块级素，
再利用clear:both清除浮动。
</code></pre><p>　　<br>21、    如何在 HTML5 页面中嵌入音频?</p>
<pre><code>HTML 5 包含嵌入音频文件的标准方式，支持的格式包括 MP3、Wav 和 Ogg：
&lt;audio controls&gt;
  &lt;source src=&quot;jamshed.mp3&quot; type=&quot;audio/mpeg&quot;&gt;
   Your browser does&apos;nt support audio embedding feature.
&lt;/audio&gt;
</code></pre><p>22、    如何在 HTML5 页面中嵌入视频？</p>
<pre><code>和音频一样，HTML5 定义了嵌入视频的标准方法，支持的格式包括：MP4、WebM 和 Ogg：
&lt;video width=&quot;450&quot; height=&quot;340&quot; controls&gt;
  &lt;source src=&quot;jamshed.mp4&quot; type=&quot;video/mp4&quot;&gt;
   Your browser does&apos;nt support video embedding feature.
&lt;/video&gt;
</code></pre><p>23、    HTML5 引入什么新的表单属性？</p>
<pre><code>Datalist   datetime   output   keygen  date  month  week
time  number   range   emailurl
</code></pre><p>26、    cookie在浏览器和服务器间来回传递。 sessionStorage和localStorage区别</p>
<pre><code>sessionStorage和localStorage的存储空间更大；
sessionStorage和localStorage有更多丰富易用的接口；
sessionStorage和localStorage各自独立的存储空间；
</code></pre><p>30、    HTML5的离线储存？</p>
<pre><code>localStorage    长期存储数据，浏览器关闭后数据不丢失；
sessionStorage  数据在浏览器关闭后自动删除。
</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;1、    CSS3有哪些新特性？&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;1. CSS3实现圆角（border-radius），阴影（box-shadow），
2. 对文字加特效（text-shadow、），线性渐变（gradient），旋转（transform）
3.transf
    
    </summary>
    
      <category term="面试题目" scheme="www.wangchengzou.cn/categories/%E9%9D%A2%E8%AF%95%E9%A2%98%E7%9B%AE/"/>
    
    
      <category term="html" scheme="www.wangchengzou.cn/tags/html/"/>
    
      <category term="H5" scheme="www.wangchengzou.cn/tags/H5/"/>
    
  </entry>
  
  <entry>
    <title>Vue快速上手知识</title>
    <link href="www.wangchengzou.cn/2017/07/22/Vue%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B%E7%9F%A5%E8%AF%86/"/>
    <id>www.wangchengzou.cn/2017/07/22/Vue快速上手知识/</id>
    <published>2017-07-22T15:48:26.000Z</published>
    <updated>2017-07-23T15:38:48.212Z</updated>
    
    <content type="html"><![CDATA[<p>1、基本绑定：</p>
<pre><code>new Vue(
    {
        el:&apos;#elID&apos;,
        data:{
            // data obj
        },
        computed:{
            // computed obj
        },
        methods:{
            // methods obj
        },
    }
);
</code></pre><p>2、指令：</p>
<pre><code>前缀为v-
*v-if, v-for, v-bind, v-on...
*特性插值会转为v-bind绑定: href=&apos;{{url}}&apos; --&gt; v-bind:href=&apos;url&apos;
</code></pre><p>3、数据绑定只接受单个表达式：</p>
<pre><code>{{number+1}}                                    ok
{{ok?'yes':'no'}}                                ok
{{message.split('').reverse().join('')}}        ok
{{var a=1}}                                        no
{{if(ok){return message}}}                        no
</code></pre><p>4、过滤器：</p>
<pre><code>管道式的写法 --&gt; {{message|capitalize}}
*可以串联: filterA|filterB
*可以带参数: filterA &apos;arg1&apos; arg2
</code></pre><p>5、修饰符</p>
<pre><code>前缀为.
*v-bind:href.literal=&apos;a/b/c&apos;
</code></pre><p>6、缩写</p>
<pre><code>v-bind:href=&apos;url&apos; --&gt; :href=&apos;url&apos;
v-on:click=&apos;dosomething&apos; --&gt; @click=&apos;dosomething&apos;
</code></pre><p>7、计算setter</p>
<pre><code>computed:{
    fullName:{
        get:function(){
            // getter
        }
        set:function(newValue){
            //setter
        }
    }
}
</code></pre><p>8、Class与Style绑定</p>
<pre><code>*变量语法：v-bind:class=&quot;{&apos;class-a&apos;:isA, &apos;class-b&apos;:isB}&quot;
 --&gt;        data:{isA:true, isB:false}
*对象语法：v-bind:class=&quot;classObj&quot;
--&gt;        data:{classObj:{&apos;class-a&apos;:true, &apos;class-b&apos;:false}}
*数组语法：v-bind:class=&apos;[classA, classB]&apos;
 --&gt;        data:{classA:&apos;class-a&apos;, classB:&apos;class-b&apos;}
</code></pre><p>9、条件渲染</p>
<pre><code>*v-if, v-show, v-else
*&lt;h1 v-if=&quot;ok&quot;&gt;Yes&lt;/h1&gt; &lt;h1 v-else&gt;No&lt;/h1&gt;
*&lt;h1 v-show=&quot;ok&quot;&gt;Yes&lt;/h1&gt; &lt;h1 v-else&gt;No&lt;/h1&gt;
*show只是简单的display:none
</code></pre><p>10、列表渲染</p>
<pre><code>v-for
*内置变量：{{$index}}
*用法：v-for=&apos;item in items&apos;
       v-for=&apos;(index, item) in items&apos;    *数组则是索引，遍历对象则是键
</code></pre><p>11、数组变动检测</p>
<pre><code>能触发视图更新的方法：
*push, pop, shift, unshift, splice, sort, reverse
// 变异方法
*filter, concat, slice
// 替换数组
*尽可能复用DOM: track-by
    v-for=&quot;item in items&quot; track-by=&quot;_uid&quot;
    track-by=&apos;$index&apos;
    // 根据index追踪，不是很明白！...片段不被移动，
    // 简单地已对应索引的新值刷新,也能处理数据数组中重复的值...

不能检测到以下变化：
    1.直接用索引设置元素：    vm.items[0]={};
    // vue解决方案：vm.items.$set(0, { childMsg: &apos;Changed!&apos;}),
                    vm.items.$remove(item)
    2.修改数据的长度：        vm.items.length=0;
    // js中常见的清空, vue解决方案：直接用空数组替换
</code></pre><p>12、对象v-for</p>
<pre><code>内置变量：$key
</code></pre><p>13、值域v-for</p>
<pre><code>&lt;span v-for=&quot;n in 10&quot;&gt;{{ n }}&lt;/span&gt;
</code></pre><p>14、内置的过滤器</p>
<pre><code>filterBy 和 orderBy
</code></pre><p>15、方法与事件处理器</p>
<pre><code>·v-on 监听DOM事件
    &lt;button v-on:click=&quot;greet&quot;&gt;&lt;/button&gt;
    &lt;button v-on:click=&quot;greet(&apos;xx&apos;, $event)&quot;&gt;&lt;/button&gt;
    // 内联语句处理器, $event为内置变量，原生的DOM事件
·事件修饰符
    &lt;a v-on:click.stop.prevent=&apos;doThis&apos; /&gt;
    // 阻止冒泡和默认行为，修饰符可以串联
·按键修饰符
    &lt;input v-on:keyup.13=&apos;submit&apos; &gt;
    // 键盘事件后面可接keyCode
    常见的按键有提供别名：
        ·enter
        ·tab
        ·delete
        ·esc
        ·space
        ·up
        ·down
        ·left
        ·right
</code></pre><p>16、表单控件绑定</p>
<pre><code>·v-model绑定字段
    &lt;input type=&quot;checkbox&quot; id=&quot;checkbox&quot; v-model=&quot;checked&quot;&gt;
    // 绑定的值通常是静态字符串，勾选框是布尔值
·参数特性
    lazy        // 延迟到change事件中同步(原为input)
    number        // 仅允许输入数字
    debounce    // 延时同步
</code></pre><p>17、过渡</p>
<pre><code>典型的过渡：
    &lt;div v-if=&quot;show&quot; transition=&quot;expand&quot;&gt;&lt;/div&gt;
    需要添加CSS样式：
        .expand-transition(必须), .expand-enter, .expand-leave
        *如果未设置, 默认为.v-transition, .v-enter, .v-leave
    同时提供钩子：
        Vue.transition(&apos;expand&apos;,{...});
        ·beforeEnter, enter, afterEnter, enterCancelled,
        beforeLeave, leave, afterLeave, leaveCancelled
    渐近过渡：
        &lt;div v-for=&apos;list&apos; transition stagger=&apos;100&apos;&gt;&lt;/div&gt;
        *钩子stagger, 延时过渡
</code></pre><p>18、组件</p>
<pre><code>·创建组件：        var c = Vue.extend({
                    template:&apos;&lt;div&gt;A custom component!&lt;/div&gt;&apos;,
                });
·注册组件:        Vue.component(&apos;my-component&apos;, c);
// 如果名字是myComponent, html中必须写成my-component
·使用组件：        &lt;div id=&apos;app&apos;&gt;&lt;my-component&gt;&lt;/my-component&gt;&lt;/div&gt;
// html
                new Vue({el:&apos;#app&apos;});
                // js

*注册可缩写为    vue.component(&apos;my-component&apos;,{
                    template:&apos;&lt;div&gt;A custom component!&lt;/div&gt;&apos;,
                });
局部注册：
    var c = Vue.extend({});
    var parentComponent = Vue.extend({
        components:{
            &apos;my-component&apos;: c,
        }
    });
组件选项：
    var c = Vue.extend({
        data:function(){
            return {a:1};
        }
    });

is特性：
    *table中限制其他的节点不能放置其中
    &lt;table&gt;
        &lt;tr is=&apos;my-component&apos;&gt;&lt;/tr&gt;
    &lt;/table&gt;

Props:
    props用以从父组件接收数据:
        使用：
            Vue.component(&apos;child&apos;,{
                props:[&apos;msg&apos;],
                template:&apos;&lt;span&gt;{{msg}}&lt;/span&gt;&apos;
            });
        声明：
            &lt;child msg=&apos;hello!&apos;&gt;&lt;/child&gt;            // 字面量语法
            &lt;child v-bind:msg=&apos;parentMsg&apos;&gt;&lt;/child&gt;    // 动态语法
        *如果props是myMsg, html中需要用my-msg
        (即：camelCase - kebab-case, 因为html的特性是不区分大小写)
        *字面量和动态语法稍有不同
            &lt;comp some-prop=&quot;1&quot;&gt;&lt;/comp&gt;        // 传递了一个字符串 &quot;1&quot;
            &lt;comp :some-prop=&quot;1&quot;&gt;&lt;/comp&gt;    // 传递实际的数字

Props绑定类型：
    &lt;child :msg=&quot;parentMsg&quot;&gt;&lt;/child&gt;        // 默认为单向绑定
    &lt;child :msg.sync=&quot;parentMsg&quot;&gt;&lt;/child&gt;    // 双向绑定
    &lt;child :msg.once=&quot;parentMsg&quot;&gt;&lt;/child&gt;    //单次绑定
    *如果prop是一个对象或数组，是按引用传递。不管使用哪种绑定方式，都将是双向绑定

Props验证：
    props:{            // 此时props是一个对象
        propA: Number,
        propB:{
            type: String,
            // 类型(原生构造器：String, Number, Boolean, Function, Object, Array)
            required: true,
            // 是否必须项
            default: &apos;thyiad&apos;,
            // 默认值(如果是Object, 默认值需由一个函数返回)
            validator: function(value){
            // 验证
                return value === &apos;thyiad&apos;;
            },
            coerce:function(val){
                return val+&apos;&apos;;
                // 将值强制转换为字符串
                return JSON.parse(val);
                // 将JSON字符串转换为对象
            }
        }
    }

父子组件通信：
    this.$parent        // 子组件访问父组件
    this.$root            // 访问根实例
    this.$children        // 父组件的所有子元素
    *不建议在子组件中修改父组件的状态

自定义事件：
    $on()                // 监听事件
    $emit()                // 触发事件
    $dispatch()            // 派发事件，沿着父链冒泡
    $broadcast()        // 广播事件, 向下传递给所有的后代
    使用：
        子组件中绑定函数派发事件：
            methods:{
                notify:function(){
                    this.$dispatch(&apos;child-msg&apos;,this.msg);
                }
            }
        父组件中定义事件：
            events:{
                &apos;child-msg&apos;:function(msg){
                    this.messages.push(msg);
                }
            }
        *更直观的声明方式：
            &lt;child v-on:child-msg=&apos;handleIt&apos;&gt;&lt;/child&gt;
            // 直观的为父组件定义事件(child-msg), 并且触发父组件的handleIt函数, 子组件只关注触发事件

子组件索引：
    &lt;child v-ref:profile&gt;&lt;/child&gt;
    var child = parent.$refs.profile;

使用Slot分发内容：
    单个Slot:
        父组件的内容将被抛弃，除非子组件包含&lt;slot&gt;.
        如果只有一个没有特性的slot, 整个内容将被插到它所在的地方, 替换slot.
            父组件：
            &lt;child&gt;
                &lt;p&gt;parent content&lt;/p&gt;
            &lt;/child&gt;
            子组件模板：
            &lt;div&gt;
                &lt;h1&gt;child content&lt;/h1&gt;
                &lt;slot&gt;
                    如果父节点没有设置内容，这里才会被显示
                &lt;/slot&gt;
            &lt;/div&gt;
    命名Slot：
        父组件模板：
            &lt;child&gt;
                &lt;p slot=&apos;one&apos;&gt;One&lt;/p&gt;
                &lt;p slot=&apos;two&apos;&gt;two&lt;/p&gt;
                &lt;p&gt;Default A&lt;/p&gt;
            &lt;/child&gt;
        子组件模板：
            &lt;div&gt;
                &lt;slot name=&apos;one&apos;&gt;&lt;/slot&gt;
                &lt;slot&gt;&lt;/slot&gt;
                // 默认slot, 找不到匹配内容的回退插槽, 如果没有默认的slot, 不匹配内容将被抛弃
                &lt;slot name=&apos;two&apos;&gt;&lt;/slot&gt;
            &lt;/div&gt;

    动态组件：
        可以在不同组件之间切换：
            new Vue({
                el:&apos;body&apos;,
                data:{
                    currentView:&apos;home&apos;,
                },
                components:{
                    home:{},
                    posts:{},
                    archive:{},
                }
            });
            父组件：
                &lt;component :is=&apos;currentView&apos; keep-alive&gt;&lt;/component&gt;
                // component是Vue保留的元素
                *keep-alive用来把切换出去的组件保留在内存中, 可以保留它的状态避免重新渲染
        activate钩子：
            用以在切入前做一些异步操作：
                activate:function(done){
                    var self = this;
                    loadDataAsync(function(data){
                        self.someData=data;
                        done();
                    });
                }
        transition-mode
            指定列两个动态组件之间如何过渡：
                &lt;component :is=&apos;currentView&apos; transition=&apos;fade&apos; transition-mode=&apos;out-in&apos;&gt;&lt;/component&gt;
                *默认进入与离开平滑地过渡, 可以指定另外两种模式：in-out, out-in (先进入or先离开)

    组件和v-for:
        &lt;child v-for=&apos;item in items&apos; :item=&apos;item&apos; :index=&apos;$index&apos;&gt;&lt;/child&gt;
        *因为组件的作用域是孤立的, v-for里的item无法直接传递给组件, 必须像上面一样使用props传递数据

    异步组件
    资源命名约定
    递归组件
    片段实例
        *推荐模板只有一个根节点(使用template选项时)
    内联模板
        组件把它的内容当做它的模板
        &lt;child inline-template&gt;&lt;/child&gt;
        *不推荐
</code></pre><p>19、深入响应式原理</p>
<pre><code>·如何追踪变化
    *使用Object.defineProperty设置getter/setter
·变化检测问题
    *不能检测到对象属性的添加或删除
    *vm.$set(&apos;b&apos;, 2);
     Vue.set(object, key, value);
·初始化数据
    *推荐在data对象上声明所有的响应属性
·异步更新队列
    *默认异步更新DOM, 下次事件循环时清空队列, 执行必要的DOM更新
    *Vue.nextTick(callback);
·计算属性的秘密
    *计算属性是有缓存的, 除非显示设置为不缓存
        computed:{
            attr:function(){
                return Date.now()+this.msg;
            }
        }
        TO:
        computed:{
            attr:{
                cache: false,
                get: function(){
                    return Date.now()+this.msg;
                }
            }
        }
        *但只是在JS中访问是这样的, 数据绑定仍是依赖驱动的。
</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;1、基本绑定：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;new Vue(
    {
        el:&amp;apos;#elID&amp;apos;,
        data:{
            // data obj
        },
        computed:{

    
    </summary>
    
      <category term="学习笔记" scheme="www.wangchengzou.cn/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Vue，App" scheme="www.wangchengzou.cn/tags/Vue%EF%BC%8CApp/"/>
    
  </entry>
  
  <entry>
    <title>css hack兼容性</title>
    <link href="www.wangchengzou.cn/2017/07/22/css_hack/"/>
    <id>www.wangchengzou.cn/2017/07/22/css_hack/</id>
    <published>2017-07-22T15:48:26.000Z</published>
    <updated>2017-08-17T11:42:03.588Z</updated>
    
    <content type="html"><![CDATA[<p>css hack解决浏览器兼容性问题</p>
<pre><code>网页设计遇到最大的麻烦之一莫过于网页对不同浏览器的兼容性问题了，
因数ie6/ic7/fox2/opera9等主流浏览器对css解析不近相同，导
致设计的页面效果不一样，用于解决这个问题的方法就是css hack，
使用特别的css定义显示网页在不同浏览器的设计风格，针对不同的浏览器去写不同的css,
最大化兼容浏览器
</code></pre><p>比较频繁使用的css hack技巧</p>
<pre><code>！important，它可以针对ie和非IE浏览器设置不同的样式
*+html{...} 只无法充分IE7做样式时候使用
IE的if条件hack
    &lt;!--[if IE]&gt; Only IE &lt;![endif]--&gt; 所有的IE可识别
    &lt;!--[if IE 5.0]&gt; Only IE 5.0 &lt;![endif]--&gt; 只有IE5.0可以识别
    &lt;!--[if gt IE 5.0]&gt; Only IE 5.0+ &lt;![endif]--&gt; IE5.0包换IE5.5都可以识别
    &lt;!--[if lt IE 6]&gt; Only IE 6- &lt;![endif]--&gt; 仅IE6可识别
    &lt;!--[if gte IE 6]&gt; Only IE 6/+ &lt;![endif]--&gt; IE6以及IE6以下的IE5.x都可识别
    &lt;!--[if lte IE 7]&gt; Only IE 7/- &lt;![endif]--&gt; 仅IE7可识别
</code></pre><p>1、CSS HACK</p>
<pre><code>以下两种方法几乎能解决现今所有HACK.
1, !important (不是很推荐，用下面的一种感觉最安全)
    随着IE7对!important的支持, !important 方法现在只针对IE6的HACK.
    (注意写法.记得该声明位置需要提前.)
    代码: &lt;style&gt;
        #wrapper {
            width: 100px!important; /* IE7+FF */
            width: 80px; /* IE6 */ }
        &lt;/style&gt;

2, IE6/IE77对FireFox &lt;from 针对firefox ie6 ie7的css样式&gt;
    *+html 与 *html 是IE特有的标签, firefox 暂不支持.而*+html 又为 IE7特有标签.
        代码: &lt;style&gt;
                    #wrapper { width: 120px; } /* FireFox */
              *html #wrapper { width: 80px;} /* ie6 fixed */
             *+html #wrapper { width: 60px;} /* ie7 fixed, 注意顺序 */
            &lt;/style&gt;
        注意:  *+html 对IE7的HACK 必须保证HTML顶部有如下声明：
        代码:  &lt;!DOCTYPE HTML PUBLIC &quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot;
        &quot;http://www.w3.org/TR/html4/loose.dtd&quot;&gt;
</code></pre><p>2、万能 float 闭合(非常重要!)</p>
<pre><code>可以用这个解决多个div对齐时的间距不对，
关于 clear float 的原理可参见 [How To Clear Floats Without Structural Markup]
将以下代码加入Global CSS 中,给需要闭合的div加上 class=”clearfix” 即可,屡试不爽.
代码: &lt;style&gt;
    /* Clear Fix */
    .clearfix:after { content:&quot;.&quot;; display:block;
                    height:0; clear:both;
                    visibility:hidden; }
    .clearfix {  display:inline-block; }  /* Hide from IE Mac \*/
    .clearfix {display:block;} /* End hide from IE Mac */
                                /* end of clearfix */
    &lt;/style&gt;
</code></pre><p>3、其它兼容性技巧</p>
<pre><code>1、FF下给div设置padding后会导致width和height增加，但ie不会
    解决：可用！important

2、居中问题
    垂直居中
        将line-heigth设置为 当前div相同高度，再通过vertical-align:middle
    水平居中
        margin:0 auto;

3、若需要给a标签内容加上样式，需要设置
    display:block;(常用于导航标签)

4、FF和IE对BOX理解的差异导致相差2px
    设为float的div在IE下margin加倍问题

5、ul标签在FF下面默认有list-style和padding

6、作为外部wrapper的div不要定死高度，最好加上overflow:hidden
    以达到高度自适应

7、 关于手形光标. cursor: pointer. 而hand 只适用于 IE
</code></pre><p>4、针对firefox ie6 ie7的css样式</p>
<pre><code>现在大部分都是用!important来hack，对于ie6和firefox测试可以正常显示，
但是ie7对!important可以正确解释，会导致页 面没按要求显示！
找到一个针对IE7不错的hack方式就是使用“*+html”，现在用IE7浏览一下，
应该没有问题了现在写一个CSS可以这样：
    #1 { color: #333; } /* Moz */
    * html #1 { color: #666; } /* IE6 */
    *+html #1 { color: #999; } /* IE7 */
    那么在firefox下字体颜色显示为#333，
    IE6下字体颜色显示为#666，
    IE7下字体颜色显示为#999。
</code></pre><p>5、css布局中的居中问题</p>
<pre><code>主要的样式定义如下：
body {TEXT-ALIGN: center;}
#center { MARGIN-RIGHT: auto; MARGIN-LEFT: auto; }
说明：
    首先在父级元素定义TEXT-ALIGN: center;这个的意思就是在父级元素内的内容居中；
    对于IE这样设定就已经可以了。但在mozilla中不能居中。
    解决办法就是在子元素定义时候设定时再加上“MARGIN-RIGHT: auto;MARGIN-LEFT: auto; ”
    需要说明的是，如果你想用这个方法使整个页面要居中，建议不要套在一个DIV里，
    你可以依次拆出多个div，只要在每个拆出的div里定义
    MARGIN-RIGHT: auto;MARGIN-LEFT: auto; 就可以了。
</code></pre><p>6、盒模型不同解释</p>
<pre><code>#box{  width:600px;
    //for ie6.0- w\idth:500px;
    //for ff+ie6.0 }
#box{  width:600px!important
    //for ff  width:600px;
    //for ff+ie6.0  width /**/:500px;
    //for ie6.0- }
</code></pre><p>7、浮动IE产生的双倍距离</p>
<pre><code>#box{float:left;width:100px;margin:0 0 0 100px;}
解决：didplay:inline
block,inline两个元素
    Block元素的特点是:总是在新行上开始,高度,宽度,行高,边距都可以控制(块元素);
inline元素的特点是:和其他元素在同一行上,…不可控制(内嵌元素);
#box{ display:block; //可以为内嵌元素模拟为块元素
      display:inline; //实现同一行排列的的效果
      diplay:table;
</code></pre><p>8、IE与宽度和高度的问题</p>
<pre><code>IE不认得min-这个定义，但实际上它把正常的width和heigth当作有min的情况来使，
如果设置了min-，则ie下就等于没有设置宽高，设置背景图片最小宽度比较重要
解决:#box{width:80px;height:35px;}
    html&gt;body #box{width:auto;heigth:auto;min-width:80px;min-height:35px;}
</code></pre><p>9、清除浮动</p>
<pre><code>#box:after{
    content:&quot;&quot;;
    display:block;
    height；0；
    clear:both;
    visibility:hidden;
    }
</code></pre><p>10、DIV浮动IE文本产生3px的bug</p>
<pre><code>左边对象浮动，右边采用外补丁的左边距定位，右边对象内的文本会离左边有3px的间距
#box{float:left;width:800px;}
#left{float:left;width:50%}
#right{width:50%}
*html #left{margin-right:-3px;}
</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;css hack解决浏览器兼容性问题&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;网页设计遇到最大的麻烦之一莫过于网页对不同浏览器的兼容性问题了，
因数ie6/ic7/fox2/opera9等主流浏览器对css解析不近相同，导
致设计的页面效果不一样，用于解决这个问题的方法就是css h
    
    </summary>
    
      <category term="学习笔记" scheme="www.wangchengzou.cn/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="css3" scheme="www.wangchengzou.cn/tags/css3/"/>
    
  </entry>
  
  <entry>
    <title>bootStrap基础知识</title>
    <link href="www.wangchengzou.cn/2017/07/22/bootStrap/"/>
    <id>www.wangchengzou.cn/2017/07/22/bootStrap/</id>
    <published>2017-07-22T15:48:26.000Z</published>
    <updated>2017-07-23T13:23:05.120Z</updated>
    
    <content type="html"><![CDATA[<p>webstorm<br>    lorem 随机测试文本</p>
<p>1、响应式网页</p>
<pre><code>responsive web page  一个页面可以在电脑浏览器中浏览也可以在手机平板中浏览，并且配合不同设备有不同的响应结果
响应式网页特点：
    页面上的图片和文字要随着屏幕尺寸发生改变
    页面的布局随着屏幕尺寸而发生改变
如何测试响应式网页
    使用真实的物理设备
        优势：测试结果真实
        不足：设备太多，成本太大，测试任务量大
        方法：搭建本地服务器，部署项目 ，移动终端与服务接入相同网络
    使用三方模拟设备
        优势：无须添加更多设备
        不足：效率偏低，加载慢
    使用浏览器自带模拟器（emulator）
        优势：功能丰富
        不足：****
视口-viewport
    IOS中的safari最早引入的概念
    移动设备中，浏览器里显示网页的一块区域（Pc端会忽略）
    对于响应式网页，设置视口的信息：
        视口的宽度：要与设备宽度一致
        视口的缩放倍率：设置为1，即为不缩放
        视口的手动缩放：不允许缩放网页
    在html中指定视口信息：
        &lt;meta name=&quot;viewport&quot; content=&quot; &quot;&gt;
            视口的宽度：width
                取值：device-width
                     具体数值
            视口的初始缩放倍率：initial-scale
                取值：1  原始大小
            视口是否允许手动缩放：user-scalable
                取值：1、0、yes、no
        &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width,initial-scale=1,user-scalable=no&quot;&gt;
        快键--meta:vp
        以上代码，移动端必备！！！！
</code></pre><p>2、如何编写响应式网页</p>
<pre><code>必须声明视口
文字必须使用相对尺寸（em/rem），尽量不用绝对尺寸(px)
    css中的1px并不代表真实物理设备的1px
    EM    :父元素字体大小倍数
    REM  ：根元素字体大小倍数
容器元素使用相对尺寸（%，auto），尽量不用绝对尺寸(px)
图片使用相对尺寸（%,auto）,尽量不用绝对尺寸（px）
页面元素使用流式布局
    流式布局特点：
        元素默认靠向容器的左上方
        横向排列，排列不下则换行
    方法：float 浮动
         display:inline-block; 行内块
响应式网页都要使用CSS3 Media Query技术，最重要
</code></pre><p>3、CSS3 Media Query</p>
<pre><code>作用：可以根据不同的媒体类型以及特性执行不同的css
    Media:媒体，指浏览网页设备的类型，
        如：screen(pc/pad/phone),tv,tty
    语法：通过@media 规则进行声明
        @media MEDIA-TYPE and|not|only (MEDIA-FEATURE)
        MEDIA-TYPE:媒体类型
            取值：all 默认值，所有设备
                 screen ：电脑屏幕，智能手机 平板电脑
                 tv     :电视设备
        MEDIA-FEATURE:媒体特性
            取值：width:指定浏览器窗口大小
                 min-width:指定浏览器窗口宽度的最小值
                 max-width:指定浏览器窗口宽度的最大值
@media用法：
    有选择性的执行某个外部CSS文件
    &lt;link rel=&quot;&quot; href=&apos;&quot; media=&quot;screen&quot;&gt;
    &lt;link rel=&quot;&quot; href=&quot;&quot; media=&quot;screen&quot;and(max-width:px)&gt;
        不足：即使不满足当前设备条件的css文件也会被请求，但不会生效
    有选择性执行CSS片段中的内容
        在样式表中 @media screen and(max-width:px){
                        选择器{属性：值}
                    }
常见屏幕尺寸：
    超小屏幕（Extra Small:xs）
        width&lt;=767px
    小型屏幕（Small: sm）
        768&lt;=width&lt;=991px
    中型屏幕（Medium:md）
        992&lt;=width&lt;=1199px
    大型屏幕(Large:lg)
        width&gt;=1200px

大公司成型的大型框架（BOOT STRAP）开发公司Twitter
    官网：http://getbootstrap.com
    中文官网:http://www.bootcss.com
    重点： bootstrap.css   提供了上千个class  依赖于JS库-jquery
</code></pre><p>4、 bootstrap 第一步 起步</p>
<pre><code>基本模板：
    &lt;html lang=&quot;zh-cn&quot;&gt; 指定当前文件的基础语言
        作用：为浏览器的自动翻译功能指定语言基础
             为读屏软件指定基础发音
    &lt;meta name=&quot;viewport&quot;&gt;  必须
    &lt;meta http-equiv=&quot;x-ua-compatible&quot; content=&quot;ie=edge&quot;&gt;
        x-ua-compatible
            cross useragent compatible 跨（IE）浏览器兼容性
                指定用哪个IE的内核进行页面渲染
            IE=6  指定用IE6内核渲染页面
            IE=7  ...
            ..
            IE=edge  采用IE最新内核渲染页面
    两个Js 必须引用
          html5shiv.min.js  第三方的JS 自调函数，用于让老IE支持html5新标记（IE8以下）
          respond.min.js    第三方的JS 自调函数，用于让老IE支持CSS3媒体查询技术，响应式必备
          通过头部引用HACK判断是否为IE8以下的浏览器
              &lt;!--[if lt IE 9]&gt;
                 &lt;script src=&quot;***.js&quot;&gt;&lt;/script&gt;
             &lt;![endif]--&gt;
    两个JS 引用页面
        jquery.js  引入到页面中（先）
        bootstrap.js 引入到页面中（后）
        建议:尽量将以上两个文件放在页面最底端引入
</code></pre><p>5、 bootstrap 第二步， 全局CSS样式</p>
<pre><code>BOOTSTRAP 默认将屏幕分成四大类
    大型PC屏幕LG  width:1200px
    中型PC屏幕md  1199--992px
    小型PAD屏幕SM  768---991px
    超小型phone屏幕xs width:767px
bootstrap 提供两种容器
    定宽容器
    在大小不同的设备上，提供不同的width固定值
    类：container
        lg:width:1170px
        md:width:970px
        sm:width:750px
        xs:width:100%
变宽容器
    在任何设备中，宽度都是100%
    类：container-fluid
        width:100%
</code></pre><p>6、 bootstrap 按钮</p>
<pre><code>.btn
.btn-default 白底深色字
.btn-danger/success/warning/info/primary   五种不同颜色按钮
.btn-lg/sm/xs   几种大小按钮
.btn-block     块级按钮
</code></pre><p>7、 bootstrap 列表</p>
<pre><code>.list-unstyled 不带标识的列表
.list-inline   行内列表
.dl-horizontal 定义列表
</code></pre><p>8、 bootstrap 图像图片</p>
<pre><code>.img-rounded        圆角边框图像
.img-circle            圆形边框图像
.img-thumbnail        带几像素内边距边框图像缩进图片
.img-responsive     响应式布局图片
</code></pre><p>9、 bootstrap 表格</p>
<pre><code>.table
.table-bordered        带边框表格
.table-striped        隔行变色
.table-hover        悬停突出效果
.table-responsive    响应式表格   需要加在表格父元素
</code></pre><p>10、 bootstrap 文本和排版</p>
<pre><code>文本颜色
.text-danger
.text-success
.text-warning
.text-info
.text-primary
文本背景颜色
.bg-danger
.bg-success
.bg-warning
.bg-info
.bg-primary
文本大小写
.text-uppercase     全大写
.text-lowercase        全小写
.text-capitalize    首字母大写
文本对齐方式
.text-left
.text-center
.text-right
浮动
.pull-left        左浮动
.pull-right        右浮动
.clearfix        清浮动
</code></pre><p>11、 bootstrap 栅格布局</p>
<pre><code>table 布局
    好处:简单，容易控制
    不足:效率低
div+css 布局
    好处：效率高，
    不足：太灵活，不易控制
栅格布局
    好处：效率高 易控制轻松实现响应式
    不足：。。。。
    实际上就是由div组成的table样式的响应式结构
使用方法：
    系统最外层，必须是bootstrap提供的容器
        .container  .container-fluid
    允许在容器中放置若干行  div.row
        每行中最多等分为12列
    行中放置 div.col 即列，每列都需要指定宽度 1/12 n/12
        语法：&lt;div class=&quot;container&quot;&gt;
                &lt;div class=&quot;row&quot;&gt;
                    &lt;div class=&quot;col-*-*&quot;&gt;&lt;/div&gt;
                &lt;/div&gt;
            &lt;/div&gt;

    列 根据适用屏幕分成四个类型        N最大12列宽
        .col-xs-n   在超小屏幕中占N列宽
        .col-sm-n   在小型屏幕中占N列宽
        .col-md-n      在中型屏幕中占N列宽
        .col-lg-n   在大型屏幕中占N列宽
    列偏移数量
        每个列都可以指定向右偏移几列数量
        .col-xs-offset-n       在超小屏幕中当前列向右偏移N列距离
        .col-sm-offset-n
        .col-md-offset-n
        .col-lg-offset-n


    栅格布局系统可以嵌套
        .container&gt;.row.col-*_*&gt;.row&gt;.col-*-*

    适用于不同屏幕的列的class(xs/sm/md/lg)可以兼容更大的屏幕
        大屏幕class不能适应小屏幕  会垂直显示
        小屏幕class可适应大屏幕

    可以在一个div中指定在不同屏幕下的宽度占比
        &lt;div class=&quot;col-xs-9 col-sm-6 col-md-3&quot;&gt;&lt;/div&gt;

    指定列在特定屏幕下不显示
        .hidden-lg  在lg下隐藏
        .hidden-md
        .hidden-sm
        .hidden-xs
</code></pre><p>12、 全局样式  表单</p>
<pre><code>默认表单
    .form-group            定义表单控件组
    .form-control        定义表单控件
    .control-label        定义控件对应的label
    .help-block            定义提示文本

行内表单
    为&lt;form&gt;添加class=&quot;form-inline&quot;其它同上

水平表单
    水平表单=表单+栅格布局系统
    栅格：最外层：.container/.container-fluid
         行：.div.row
         列：.div.col-*-*

    水平表单栅格系统
        最外层：form.form-horizontal/.container
        行：div.form-group/div.row
        列：div.col-*-*
</code></pre><p> bootstrap</p>
<p> 13、    下拉菜单</p>
<pre><code>&lt;select&gt; &lt;option&gt;&lt;/option&gt;&lt;/select&gt;

外层必须是.dropdown/.dropup  或position:relative;
内层：为&lt;button&gt;或&lt;a&gt;
    class=“dropdown-toggle”
    data-toggle=&quot;dropdown&quot;        切换内容和隐藏
内层内容：ul 或 div 来组成
    class=&quot;dropdown-menu&quot;

    li.divider:      分割线效果
    li.disabled:    禁用菜单项
    li.dropdown-header    标题
</code></pre><p> 14、导航菜单</p>
<pre><code>标签页式导航
    &lt;ul class=&quot;nav nav-tabs&quot;&gt;
        &lt;li class=&quot;active&quot;&gt;
            &lt;a href=&quot;#&quot; data-toggle=&quot;tab&quot;&gt;...&lt;/a&gt;
        &lt;/li&gt;
    &lt;/ul&gt;
li.active        默认被激活
li.data-toggle=&quot;data&quot;    允许切换并且指定切换方式
</code></pre><p>15、图标字体</p>
<pre><code>在页面中，显示为图标，本质上是文字，可以设置字体，颜色，大小
在web程序中常用的图标字体：
    giyphicons 字体，收费中，
    fontawesome  免费

由于客户端不具备bootstrap中的图标字体，所以使用自定义的图标字体，必须声明
在服务器端做以下操作：
    ***.css
    声明字体
    @font-face{font-family:名称： src:url(地址)}
    对使用字体图标的选择器进行声明
    .glyphicon{ font-family:&quot;名称&quot;}

使用方法：    必须为空元素
    &lt;span class=&quot;glyphicon glyphicon-**&quot;&gt;&lt;/span&gt;
</code></pre><p>16、按钮组</p>
<pre><code>将多个按钮放在一个组中（btn-group）
    &lt;div&gt; class=&quot;btn-group&quot;
        &lt;button class=&quot;btn btn-deftult&quot;&gt;***&lt;/button&gt;
        &lt;button class=&quot;btn btn-deftult&quot;&gt;***&lt;/button&gt;
        &lt;button class=&quot;btn btn-deftult&quot;&gt;***&lt;/button&gt;
        &lt;button class=&quot;btn btn-deftult&quot;&gt;***&lt;/button&gt;
    &lt;/div&gt;
将一组btn-group 组合进一个.btn-boolbar(按钮工具栏)
按钮组尺寸
    .btn-group 增加.btn-group-** lg/md/sm/xs
两端对齐按钮组
    .btn-group .btn-group-justified
垂直放置的按钮组
    .btn-group-vertical
</code></pre><p>17、警告框</p>
<pre><code>允许将任意字符与可选的关闭按钮组合在一起的结构
所有警告框依赖于.alert
.alert
.alert-warning
...
...

允许关闭的警告框
    .alert-dismissible
    &lt;div class=&quot;alert alert-danger alert-dismissible&quot;&gt;
        lorem
        &lt;button class=&quot;close&quot; data-dismiss=&quot;alert&quot;&gt;&amp;times;&lt;/button&gt;
    &lt;/div&gt;
警告框中的链接
    &lt;a class=&quot;alert-link&quot;&gt;&lt;/a&gt;
</code></pre><p>18、面包屑导航/路径导航</p>
<pre><code>.breadcrumb
&lt;ul class=&quot;breadcrumb&quot;&gt;
    &lt;li&gt;
        &lt;a href=&quot;#&quot;&gt;首页&lt;/a&gt;
    &lt;/li&gt;
    &lt;li&gt;
        &lt;a href=&quot;#&quot;&gt;产品大全&lt;/a&gt;
    &lt;/li&gt;
&lt;/ul&gt;
</code></pre><p>19、分页条</p>
<pre><code>.pagination
.active : 被激活的页码
&lt;ul class=&quot;pagination&quot;&gt;
    &lt;li&gt;
        &lt;a href=&quot;#&quot;&gt;上一页&lt;/a&gt;
    &lt;/li&gt;
    &lt;li&gt;
        &lt;a href=&quot;#&quot;&gt;1&lt;/a&gt;
    &lt;/li&gt;
    &lt;li class=&quot;active&quot;&gt;
        &lt;a href=&quot;#&quot;&gt;2&lt;/a&gt;
    &lt;/li&gt;
    &lt;li&gt;
        &lt;a href=&quot;#&quot;&gt;...&lt;/a&gt;
    &lt;/li&gt;
    &lt;li&gt;
        &lt;a href=&quot;#&quot;&gt;下一页&lt;/a&gt;
    &lt;/li&gt;
&lt;/ul&gt;
</code></pre><p>20、分页器</p>
<pre><code>.pager
&lt;ul class=&quot;pager&quot;&gt;
&lt;/ul&gt;
</code></pre><p>21、标签</p>
<pre><code>所有的标签都依赖于 .label
.label
.label-default
.label-danger
.label-success
...
&lt;span class=&quot;label label-danger&quot;&gt;标签内容&lt;/span&gt;
</code></pre><p>22、徽章</p>
<pre><code>.badge
&lt;span class=&quot;badge&quot;&gt;35&lt;/span&gt;
</code></pre><p>23、巨幕</p>
<pre><code>.jumbotron
</code></pre><p>24、页头</p>
<pre><code>允许为 标题元素 增加适当的空间,与其他元素有一定的间隔
.page-header
</code></pre><p>25、Well (水井)</p>
<pre><code>.well
</code></pre><p>26、进度条</p>
<pre><code>外层：.progress
内层：
    .progress-bar
    .progress-bar-danger
    .progress-bar-success
    ...
    .progress-bar-striped
    .active : 被激活的
    通过 给内层元素 增加 style=&quot;width:50%&quot; 增加宽度
</code></pre><p>27、缩略图</p>
<pre><code>.thumbnail
.caption
&lt;div class=&quot;thumbnail&quot;&gt;
    &lt;img&gt;
    &lt;div class=&quot;caption&quot;&gt;
        &lt;p&gt;文本1&lt;/p&gt;
        &lt;p&gt;文本2&lt;/p&gt;
        &lt;p&gt;按钮&lt;/p&gt;
    &lt;/div&gt;
&lt;/div&gt;
</code></pre><p>28、媒体对象</p>
<pre><code>&lt;div class=&quot;media&quot;&gt;
    &lt;div class=&quot;media-left&quot;&gt;
        &lt;img&gt;
    &lt;/div&gt;
    &lt;div class=&quot;media-body&quot;&gt;
        &lt;h2 class=&quot;media-heading&quot;&gt;标题&lt;/h2&gt;
        形容的文本
    &lt;/div&gt;
    &lt;div class=&quot;media-right&quot;&gt;
        &lt;img&gt;
    &lt;/div&gt;
&lt;/div&gt;
</code></pre><p>29、列表组</p>
<pre><code>ul : class=&quot;list-group&quot;
li : class=&quot;list-group-item&quot;
</code></pre><p>30、面版</p>
<pre><code>呈现头部 主体 尾部 结构的组件
&lt;div class=&quot;panel panel-default panel-primary&quot;&gt;
    &lt;div class=&quot;panel-heading&quot;&gt;
        &lt;h2 class=&quot;panel-title&quot;&gt;标题文本&lt;/h2&gt;
    &lt;/div&gt;
    &lt;div class=&quot;panel-body&quot;&gt;
        主体内容
    &lt;/div&gt;
    &lt;div class=&quot;panel-footer&quot;&gt;
        脚注内容
    &lt;/div&gt;
&lt;/div&gt;
</code></pre><p>31、导航条</p>
<pre><code>基本导航条
    .navbar .navbar-default
    有需要的话允许增加div.container
    .navbar-header,内部允许包含class带有.navbar-brand&lt;a&gt;元素
    允许向导航条中添加链接列表，只需要增加
导航条中的表单
    导航中的表单不适用bootstrap中默认class使用时.navbar-form,配合.navbar-left/.navbar-right
导航条中的按钮
    class.navbar-btn 允许向不在form中的button(a)增加样式
导航条中的文本
    普通文本的话，需要增加class.navbar-text属性来设置样式
组件的对齐方式
    允许通过.navbar-left 实现左浮动
    允许通过.navbar-right 实现右浮动
导航栏的固定
    不会随着滚动条发生滚动，一直在可视化区域中
    固定在页面顶端：.navbar-fixed-top
    固定在页面底端：.navbar-fixed-bottom
    注意：最好为body设置内边距至少50px
</code></pre><p>32、 JS插件plugin</p>
<pre><code>Bootstrap 基于 jQuery ，在jQuery 基础上提供了十几个插件函数，
        每个都是一个独立的JS文件,可以一次性引入全部的JS操作 - bootstrap.js
每个插件函数都有两种调用方式：
1、data-* 方式调用
    &lt;a data-toggle=&quot;dropdown&quot;&gt;&lt;/a&gt;
2、JS编程方式
    手动编写JS代码完成行为的调用
    &lt;script&gt;
        $(&quot;选择器&quot;) : 在 Javascript(jQuery) 中获取页面指定选择器的元素
            $(&quot;#id&quot;)
            $(&quot;.class&quot;)
            $(&quot;div p&quot;)
        下拉列表：
         $(&quot;选择器&quot;).dropdown();
    &lt;/script&gt;
3、警告框
    父元素 class =&quot;alert alert-danger alert-dismissible&quot;
    关闭：&lt;button class=&quot;close&quot; data-dismiss=&quot;alert&quot;&gt;&lt;/button&gt;
    JS :
        $(&quot;关闭选择器&quot;).click(function(){
            $(this).alert(&quot;close&quot;);
        });
4、按钮
    1、设置按钮的操作文本
        为 按钮元素 添加 data-loading-text=&quot;显示的文本&quot;
        &lt;button class=&quot;btn btn-default&quot; data-loading-text=&quot;请稍后....&quot;&gt;文本&lt;/button&gt;

        //点击按钮时，改变按钮的文字为 data-loading-text
        $(&quot;按钮选择器&quot;).click(function(){
            $(this).button(&quot;loading&quot;);
        });


    2、设置 单选按钮 / 复选框
        1、将 若干 单选按钮 / 复选框 放到 btn-group中  ， 为btn-group增加属性 data-toggle=&quot;buttons&quot;
5、工具提示
    为元素增加
        data-toggle=&quot;tooltip&quot;
        data-palcement=&quot;top/right/bottom/left&quot;
        title=&quot;提示的文本&quot;
    配合 JS 代码
        $(&quot;选择器&quot;).tooltip();
6、弹出框
    为元素增加
        data-toggle=&quot;popover&quot; //指定为弹出框方式
        data-placement=&quot;top/right/bottom/left&quot;//方向
        data-content=&quot;弹出框内容区域的文本&quot;
        title=&quot;弹出框的标题&quot;;
    配合 JS 代码如下:
        $(&quot;选择器&quot;).popover();
7、标签页
    1、为导航组件里面 a 增加：
        1、data-toggle = &quot;tab&quot;
        2、href=&quot;#对应元素内容的ID&quot;
    2、创建内容组
        1、class 为 tab-content
        2、在 内容组中 增加对应显示的内容模块
            1、增加id属性
            2、增加 class=&quot;tab-pane active&quot;
    ex:
        &lt;div class=&quot;container&quot;&gt;
            &lt;ul class=&quot;nav nav-tabs&quot;&gt;
                &lt;li class=&quot;active&quot;&gt;
                    &lt;a href=&quot;#tab1&quot; data-toggle=&quot;tab&quot;&gt;&lt;/a&gt;
                &lt;/li&gt;
            &lt;/ul&gt;
            &lt;div class=&quot;tab-content&quot;&gt;
                &lt;!-- 内容1 --&gt;
                &lt;div class=&quot;tab-pane&quot; id=&quot;tab1&quot;&gt;
                    ....
                &lt;/div&gt;
            &lt;/div&gt;
        &lt;/div&gt;
8、模态对话框
    模态对话框：父窗口中弹出一个子窗口，只要子窗口不关闭，父窗口就无法获得输入的焦点
    模态对话框由两部分组成：
    1、触发元素，通常 a / button 组成
        &lt;a href=&quot;#模态框ID&quot; data-toggle=&quot;modal&quot;&gt;&lt;/a&gt;

        &lt;button data-toggle=&quot;model&quot; data-target=&quot;#模态框ID&quot;&gt;&lt;/button&gt;
    2、模态框元素
        // 提供了半透明的遮罩层
        &lt;div class=&quot;modal&quot; id=&quot;&quot; data-backdrop=&quot;static&quot;&gt;
            // 提供了 宽度，高度，定位
            &lt;div class=&quot;modal-dialog&quot;&gt;
                //背景色，边框，倒角，阴影
                &lt;div class=&quot;model-content&quot;&gt;
                    &lt;div class=&quot;modal-header&quot;&gt;
                        &lt;h4&gt;&lt;/h4&gt;
                        &lt;button&gt; ... &lt;/button&gt;
                    &lt;/div&gt;
                    &lt;div class=&quot;modal-body&quot;&gt;
                        显示主题内容
                    &lt;/div&gt;
                    &lt;div class=&quot;modal-footer&quot;&gt;
                        脚注信息
                    &lt;/div&gt;
                &lt;/div&gt;
            &lt;/div&gt;
        &lt;/div&gt;
9、折叠效果
    1、触发元素
        &lt;a data-toggle=&quot;collapse&quot; href=&quot;#id&quot;&gt;&lt;/a&gt;

        &lt;button data-toggle=&quot;collapse&quot; data-target=&quot;#id&quot;&gt;&lt;/button&gt;
    2、被折叠元素
        &lt;div class=&quot;collapse&quot; id=&quot;id&quot;&gt;
            ... ...
        &lt;/div&gt;
    特殊效果：
        1、手风琴(Accordion)
            Accordion = 面板组(panel-group) + 折叠插件
</code></pre><p>33、折叠</p>
<pre><code>响应式导航条
    当屏幕尺寸大于768时候，可以正常显示出所有的内容，
    当屏幕尺寸小于768时候一部分内容就会隐藏，通过点击弹出

响应式导航条由两部分组成
    .navbar-head
        用于显示navbar-brand和折叠点击按钮
        .navbar-brand:定义brand内容
        折叠按钮：屏幕大于768不显示
                屏幕小于768显示
                .navbar-toggle完成以上操作

    .navbar-collapse
        被折叠的内容，当屏幕大于768正常显示
                    当屏幕小于768就隐藏
        通过点击按钮完成展开显示
</code></pre><p>34、广告轮播 carousel</p>
<pre><code>基本class
    .carousel    data-ride=&quot;carousel&quot;
        .carousel-inner
            .item
            img
指定轮播时间
    父元素增加.data-interval=&quot;200s&quot;

图片说明文本
    img图片下放div.carousel-caption
        显示在图片正中间

带方向按钮的轮播
    &lt;a herf=&quot;#carousel的ID&quot;
        class=&quot;carousel-control left
        data-slide=&quot;prev&quot; &gt;
        &lt;span class=&quot;glyphicon glyphicon-chevron-left&quot;&gt;&lt;/span&gt;
    &lt;/a&gt;        这是左边
    &lt;a herf=&quot;#carousel的ID&quot;
        class=&quot;carousel-control right
        data-slide=&quot;next&quot; &gt;
        &lt;span class=&quot;glyphicon glyphicon-chevron-right&quot;&gt;&lt;/span&gt;
    &lt;/a&gt;        这是右边

带数字圆点导航的轮播
    &lt;ul class=&quot;carousel-indicators&quot;&gt;
        &lt;li class=&quot;active
            data-target=&quot;#carousel的ID&quot;
            data-slide-to=&quot;数字值&quot;&gt;
        &lt;/li&gt;
</code></pre><p>35、Less 和 Bootstrap 定制</p>
<pre><code>样式语言的分类
    静态样式语言：css
        可以被浏览器直接解析处理，但CSS并不是合格语言，
        缺少了基本的要素，如：变量 运算符 函数
        可维护维护性差
    动态样式语言：less sass、scSS 、stylus
        不可以被浏览器直接解析处理；必须经过编译（compile）得到CSS文件后才能使用

less语言        http://lesscss.org   中文 http://less.bootcss.com
    less是一本预处理语言，扩充了CSS，在纯静态的CSS基础上增加一部分内容 如：变量 混合，

在web项目中使用less的两种方式：
    在客户端浏览器中编译less，不推荐使用
        编写.less文件
        编写.html 引入.less再引入less.js
        浏览器访问.html会自行下载文件，并且在客户端进行编译转换成.css
    在服务器端编译less   推荐使用
        编写.less
        在服务器端搭建less编译器，把.less转换为CSS
        编写HTML直接引入CSS文件

搭建less服务器端编译环境   ！！！
    less编译器实际上是由JavaScript编写
    安装独立的js解释器 node.exe
        命令行中：执行 node -v显示：版本号
    在webstrorm中配置filewatchers（文件监视器）
        由ws自动检测less文件的编写与更改，自动进行编译，得到CSS文件
        配置filewatchers
        ws--&gt;file--&gt;settings--&gt;toos--&gt;filewiathcers
        --&gt;添加选择less--&gt;指定lessc.cmd文件地址
less语法
    less完全支持CSS语法
    less支持多行注释和单选注释，只有多行注释能被编译到CSS中
        多行：/***/
        单选：//注释  只一行
    less支持变量（variable）
        变量：在less中可以变化的数据
        语法：@变量名：值；
        使用变量：变量作为值，出现在CSS属性名称后
            @变量名;
    less变量可以使用运算符 +  - * % /

less支持在一组样式中混入另一种样式 名称为混合（mixin） 嵌套
    带参数的混合：声明选择器的时候，允许使用参数来表示暂时不确定的数据，在调用时将具体数值传递进来
        语法：选择器（@参数名1，@参数名2）{
                        width：@参数名1
                        height：@参数名2
                    }
    使用带参混合写法：
        选择器2{
            选择器（值1，值2）
        }
    使用默认值的混合写法：
        选择器2 (参数名1：默认值，参数名2：默认值){
              选择器（值1，值2）
       }
       当没有设定值时，为默认值输出，有设定值时，为设定值输出

嵌套规则
    在less中，允许在一个选择器内再声明另一个选择器，以便完成父子或后代结构
    语法：选择器1{
            --；
            --；
            选择器2{
                ---；
                ---；
            }
        }
    编译结果为
         选择器1{
             ---；
         }
         选择器1 选择器2{
             ---；
         }

    声明子代嵌套：选择器1{
                       --；
                       --；
                       &gt;选择器2{
                           ---；
                           ---；
                       }
                   }

less中提供的功能函数
    lighten（@color，20%）    返回一个变亮的颜色值(颜色减淡)
    darken(@color，30%)         返回一个变暗的颜色值（颜色加深）
    image-width(&quot;**.jpg&quot;)    返回指定图片的宽度
    image-height(&quot;**.jpg&quot;)    返回指定图片的高度
    ceil（@num）                对数字向上取整 返回四舍五入
    floor（@num）            对数字向下取整
    percentage（@num）        返回小数转换为%数字

@import功能
    在less中的@import，在服务器端将多个less文件内容整合一个less文件中
    语法：  @import&quot;***.less&quot;;
</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;webstorm&lt;br&gt;    lorem 随机测试文本&lt;/p&gt;
&lt;p&gt;1、响应式网页&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;responsive web page  一个页面可以在电脑浏览器中浏览也可以在手机平板中浏览，并且配合不同设备有不同的响应结果
响应式网页特点：
    
    
    </summary>
    
      <category term="学习笔记" scheme="www.wangchengzou.cn/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="bootStrap" scheme="www.wangchengzou.cn/tags/bootStrap/"/>
    
  </entry>
  
  <entry>
    <title>axios使用基础知识</title>
    <link href="www.wangchengzou.cn/2017/07/22/axios/"/>
    <id>www.wangchengzou.cn/2017/07/22/axios/</id>
    <published>2017-07-22T15:48:26.000Z</published>
    <updated>2017-08-02T03:25:25.164Z</updated>
    
    <content type="html"><![CDATA[<p>axios</p>
<p>##基于http客户端的promise，面向浏览器和nodejs</p>
<pre><code>特色
浏览器端发起XMLHttpRequests请求
node端发起http请求
支持Promise API
拦截请求和返回
转化请求和返回（数据）
取消请求
自动转化json数据
客户端支持抵御XSRF（跨站请求伪造）
</code></pre><p>安装</p>
<pre><code>使用npm：

$ npm i axios
使用 bower

$ bower instal axios
使用cdn

&lt;!--国内bootCDN--&gt;
&lt;script src=&quot;https://cdn.bootcss.com/axios/0.16.0/axios.min.js&quot;&gt;&lt;/script&gt;
</code></pre><p>示例</p>
<pre><code>发起一个GET请求
//发起一个user请求，参数为给定的ID
axios.get(&apos;/user?ID=1234&apos;)
.then(function(respone){
    console.log(response);
})
.catch(function(error){
    console.log(error);
});

//上面的请求也可选择下面的方式来写
axios.get(&apos;/user&apos;,{
    params:{
        ID:12345
    }
})
    .then(function(response){
        console.log(response);
    })
    .catch(function(error){
        console.log(error)
    });

发起一个POST请求
axios.post(&apos;/user&apos;,{
    firstName:&apos;friend&apos;,
    lastName:&apos;Flintstone&apos;
})
.then(function(response){
    console.log(response);
})
.catch(function(error){
    console.log(error);
});

发起一个多重并发请求
function getUserAccount(){
    return axios.get(&apos;/user/12345&apos;);
}

function getUserPermissions(){
    return axios.get(&apos;/user/12345/permissions&apos;);
}

axios.all([getUerAccount(),getUserPermissions()])
    .then(axios.spread(function(acc,pers){
        //两个请求现在都完成
    }));
</code></pre><p>axios API</p>
<pre><code>可以对axios进行一些设置来生成请求。axios(config)

//发起 POST请求
axios({
    method:&apos;post&apos;,//方法
    url:&apos;/user/12345&apos;,//地址
    data:{//参数
        firstName:&apos;Fred&apos;,
        lastName:&apos;Flintstone&apos;
    }
});

//通过请求获取远程图片
axios({
    method:&apos;get&apos;,
    url:&apos;http://bit.ly/2mTM3Ny&apos;,
    responseType:&apos;stream&apos;
})
    .then(function(response){
        response.data.pipe(fs.createWriteStream(&apos;ada_lovelace.jpg&apos;))
    })
axios(url[,config])

//发起一个GET请求
axios(&apos;/user/12345/);
请求方法的重命名。

为了方便，axios提供了所有请求方法的重命名支持
axios.request(config)
axios.get(url[,config])
axios.delete(url[,config])
axios.head(url[,config])
axios.options(url[,config])
axios.post(url[,data[,config]])
axios.put(url[,data[,config]])
axios.patch(url[,data[,config]])

注意
当时用重命名方法时url,method,以及data属性不需要在config中指定。

并发 Concurrency
有用的方法
axios.all(iterable)
axios.spread(callback)

创建一个实例
你可以使用自定义设置创建一个新的实例
axios.create([config])
var instance = axios.create({
    baseURL:&apos;http://some-domain.com/api/&apos;,
    timeout:1000,
    headers:{&apos;X-Custom-Header&apos;:&apos;foobar&apos;}
});
实例方法

下面列出了一些实例方法。具体的设置将在实例设置中被合并。
axios#request(config)
axios#get(url[,config])
axios#delete(url[,config])
axios#head(url[,config])
axios#post(url[,data[,config]])
axios#put(url[,data[,config]])
axios#patch(url[,data[,config]])

Requese Config请求设置
以下列出了一些请求时的设置选项。只有url是必须的，如果没有指明method的话，默认的请求方法是GET.
{
    //`url`是服务器链接，用来请求
    url:&apos;/user&apos;,

    //`method`是发起请求时的请求方法
    method:`get`,

    //`baseURL`如果`url`不是绝对地址，那么将会加在其前面。
    //当axios使用相对地址时这个设置非常方便
    //在其实例中的方法
    baseURL:&apos;http://some-domain.com/api/&apos;,

    //`transformRequest`允许请求的数据在传到服务器之前进行转化。
    //这个只适用于`PUT`,`GET`,`PATCH`方法。
    //数组中的最后一个函数必须返回一个字符串或者一个`ArrayBuffer`,
        或者`Stream`,`Buffer`实例,`ArrayBuffer`,`FormData`
    transformRequest:[function(data){
        //依自己的需求对请求数据进行处理
        return data;
    }],

    //`transformResponse`允许返回的数据传入then/catch之前进行处理
    transformResponse:[function(data){
        //依需要对数据进行处理
        return data;
    }],

    //`headers`是自定义的要被发送的头信息
    headers:{&apos;X-Requested-with&apos;:&apos;XMLHttpRequest&apos;},

    //`params`是请求连接中的请求参数，必须是一个纯对象，或者URLSearchParams对象
    params:{
        ID:12345
    },

    //`paramsSerializer`是一个可选的函数，是用来序列化参数
    //例如：（https://ww.npmjs.com/package/qs,http://api.jquery.com/jquery.param/)
    paramsSerializer: function(params){
        return Qs.stringify(params,{arrayFormat:&apos;brackets&apos;})
    },

    //`data`是请求提需要设置的数据
    //只适用于应用的&apos;PUT&apos;,&apos;POST&apos;,&apos;PATCH&apos;，请求方法
    //当没有设置`transformRequest`时，必须是以下其中之一的类型（不可重复？）：
    //-string,plain object,ArrayBuffer,ArrayBufferView,URLSearchParams
    //-仅浏览器：FormData,File,Blob
    //-仅Node：Stream
    data:{
        firstName:&apos;fred&apos;
    },
    //`timeout`定义请求的时间，单位是毫秒。
    //如果请求的时间超过这个设定时间，请求将会停止。
    timeout:1000,

    //`withCredentials`表明是否跨网站访问协议，
    //应该使用证书
    withCredentials:false //默认值

    //`adapter`适配器，允许自定义处理请求，这会使测试更简单。
    //返回一个promise，并且提供验证返回（查看[response docs](#response-api)）
    adapter:function(config){
        /*...*/
    },

    //`auth`表明HTTP基础的认证应该被使用，并且提供证书。
    //这个会设置一个`authorization` 头（header），并且覆盖你在header设置的Authorization头信息。
    auth:{
        username:&apos;janedoe&apos;,
        password:&apos;s00pers3cret&apos;
    },

    //`responsetype`表明服务器返回的数据类型，这些类型的设置应该是
    //&apos;arraybuffer&apos;,&apos;blob&apos;,&apos;document&apos;,&apos;json&apos;,&apos;text&apos;,stream&apos;
    responsetype:&apos;json&apos;,

    //`xsrfHeaderName` 是http头（header）的名字，并且该头携带xsrf的值
    xrsfHeadername:&apos;X-XSRF-TOKEN&apos;，//默认值

    //`onUploadProgress`允许处理上传过程的事件
    onUploadProgress: function(progressEvent){
        //本地过程事件发生时想做的事
    },

    //`onDownloadProgress`允许处理下载过程的事件
    onDownloadProgress: function(progressEvent){
        //下载过程中想做的事
    },

    //`maxContentLength` 定义http返回内容的最大容量
    maxContentLength: 2000,

    //`validateStatus` 定义promise的resolve和reject。
    //http返回状态码，如果`validateStatus`返回true
        （或者设置成null/undefined），promise将会接受；其他的promise将会拒绝。
    validateStatus: function(status){
        return status &gt;= 200 &amp;&amp; stauts &lt; 300;//默认
    },

    //`httpAgent` 和 `httpsAgent`当产生一个http或者https请求时分别
        定义一个自定义的代理，在nodejs中。
    //这个允许设置一些选选个，像是`keepAlive`--这个在默认中是没有开启的。
    httpAgent: new http.Agent({keepAlive:treu}),
    httpsAgent: new https.Agent({keepAlive:true}),

    //`proxy`定义服务器的主机名字和端口号。
    //`auth`表明HTTP基本认证应该跟`proxy`相连接，并且提供证书。
    //这个将设置一个&apos;Proxy-Authorization&apos;头(header)，覆盖原先自定义的。
    proxy:{
        host:127.0.0.1,
        port:9000,
        auth:{
            username:&apos;cdd&apos;,
            password:&apos;123456&apos;
        }
    },

    //`cancelTaken` 定义一个取消，能够用来取消请求
    //（查看 下面的Cancellation 的详细部分）
    cancelToken: new CancelToken(function(cancel){
    })
}

返回响应概要 Response Schema
一个请求的返回包含以下信息
{
    //`data`是服务器的提供的回复（相对于请求）
    data{},

    //`status`是服务器返回的http状态码
    status:200,


    //`statusText`是服务器返回的http状态信息
    statusText: &apos;ok&apos;,

    //`headers`是服务器返回中携带的headers
    headers:{},

    //`config`是对axios进行的设置，目的是为了请求（request）
    config:{}
}

使用then，你会接受打下面的信息
axios.get(&apos;/user/12345&apos;)
    .then(function(response){
        console.log(response.data);
        console.log(response.status);
        console.log(response.statusText);
        console.log(response.headers);
        console.log(response.config);
    });
使用catch时，或者传入一个reject callback作为then的第二个参数，
那么返回的错误信息将能够被使用。
</code></pre><p>默认设置（Config Default)</p>
<pre><code>你可以设置一个默认的设置，这设置将在所有的请求中有效。
全局默认设置 Global axios defaults
axios.defaults.baseURL = &apos;https://api.example.com&apos;;
axios.defaults.headers.common[&apos;Authorization&apos;] = AUTH_TOKEN;
axios.defaults.headers.post[&apos;Content-Type&apos;]=&apos;application/x-www-form-urlencoded&apos;;
实例中自定义默认值 Custom instance default
//当创建一个实例时进行默认设置
var instance = axios.create({
    baseURL:&apos;https://api.example.com&apos;
});

//在实例创建之后改变默认值
instance.defaults.headers.common[&apos;Authorization&apos;] = AUTH_TOKEN;
设置优先级 Config order of precedence
设置(config)将按照优先顺序整合起来。首先的是在lib/defaults.js中定义的默认设置，
    其次是defaults实例属性的设置，最后是请求中config参数的设置。
    越往后面的等级越高，会覆盖前面的设置。
看下面这个例子：

//使用默认库的设置创建一个实例，
//这个实例中，使用的是默认库的timeout设置，默认值是0。
var instance = axios.create();

//覆盖默认库中timeout的默认值
//此时，所有的请求的timeout时间是2.5秒
instance.defaults.timeout = 2500;

//覆盖该次请求中timeout的值，这个值设置的时间更长一些
instance.get(&apos;/longRequest&apos;,{
    timeout:5000
});
</code></pre><p>拦截器 interceptors</p>
<pre><code>你可以在请求或者返回被then或者catch处理之前对他们进行拦截。
//添加一个请求拦截器
axios.interceptors.request.use(function(config){
    //在请求发送之前做一些事
    return config;
},function(error){
    //当出现请求错误是做一些事
    return Promise.reject(error);
});

//添加一个返回拦截器
axios.interceptors.response.use(function(response){
    //对返回的数据进行一些处理
    return response;
},function(error){
    //对返回的错误进行一些处理
    return Promise.reject(error);
});

如果你需要在稍后移除拦截器,你可以
var myInterceptor = axios.interceptors.request.use(function(){/*...*/});
axios.interceptors.rquest.eject(myInterceptor);

你可以在一个axios实例中使用拦截器
var instance = axios.create();
instance.interceptors.request.use(function(){/*...*/});
</code></pre><p>错误处理 Handling Errors</p>
<pre><code>axios.get(&apos;user/12345&apos;)
    .catch(function(error){
        if(error.response){
            //存在请求，但是服务器的返回一个状态码
            //他们都在2xx之外
            console.log(error.response.data);
            console.log(error.response.status);
            console.log(error.response.headers);
        }else{
            //一些错误是在设置请求时触发的
            console.log(&apos;Error&apos;,error.message);
        }
        console.log(error.config);
    });

你可以使用validateStatus设置选项自定义HTTP状态码的错误范围。
axios.get(&apos;user/12345&apos;,{
    validateStatus:function(status){
        return status &lt; 500;//当返回码小于等于500时视为错误
    }
});
</code></pre><p>取消 Cancellation</p>
<pre><code>你可以使用cancel token取消一个请求
axios的cancel token API是基于**cnacelable promises proposal**，其目前处于第一阶段。

你可以使用CancelToken.source工厂函数创建一个cancel token，如下：
var CancelToken = axios.CancelToken;
var source = CancelToken.source();
axios.get(&apos;/user/12345&apos;, {
    cancelToken:source.toke
}).catch(function(thrown){
    if(axiso.isCancel(thrown)){
        console.log(&apos;Rquest canceled&apos;, thrown.message);
    }else{
        //handle error
    }
});

//取消请求(信息参数设可设置的)
source.cancel(&quot;操作被用户取消&quot;);
你可以给CancelToken构造函数传递一个executor function来创建一个cancel token:
var CancelToken = axios.CancelToken;
var cancel;
axios.get(&apos;/user/12345&apos;, {
    cancelToken: new CancelToken(function executor(c){
        //这个executor 函数接受一个cancel function作为参数
        cancel = c;
    })
});

//取消请求
cancel();
注意：你可以使用同一个cancel token取消多个请求。
使用 application/x-www-form-urlencoded 格式化
默认情况下，axios串联js对象为JSON格式。为了发送application/x-wwww-form-urlencoded格式数据，
你可以使用一下的设置。
</code></pre><p>浏览器 Browser</p>
<pre><code>在浏览器中你可以如下使用URLSearchParams API:
var params = new URLSearchParams();
params.append(&apos;param1&apos;,&apos;value1&apos;);
params.append(&apos;param2&apos;,&apos;value2&apos;);
axios.post(&apos;/foo&apos;,params);
注意：URLSearchParams不支持所有的浏览器，但是这里有个垫片
（poly fill）可用（确保垫片在浏览器全局环境中）

其他方法：你可以使用qs库来格式化数据。
var qs = require(&apos;qs&apos;);
axios.post(&apos;/foo&apos;, qs.stringify({&apos;bar&apos;:123}));
Node.js

在nodejs中，你可以如下使用querystring:
var querystring = require(&apos;querystring&apos;);
axios.post(&apos;http://something.com/&apos;, querystring.stringify({foo:&apos;bar&apos;}));
你同样可以使用qs库。
promises
axios 基于原生的ES6 Promise 实现。如果环境不支持请使用垫片.

TypeScript
axios 包含TypeScript定义

import axios from &apos;axios&apos;
axios.get(&apos;/user?ID=12345&apos;)
</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;axios&lt;/p&gt;
&lt;p&gt;##基于http客户端的promise，面向浏览器和nodejs&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;特色
浏览器端发起XMLHttpRequests请求
node端发起http请求
支持Promise API
拦截请求和返回
转化请求和返回（数据）
取
    
    </summary>
    
      <category term="学习笔记" scheme="www.wangchengzou.cn/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="vue" scheme="www.wangchengzou.cn/tags/vue/"/>
    
      <category term="axios" scheme="www.wangchengzou.cn/tags/axios/"/>
    
  </entry>
  
  <entry>
    <title>CSS3高级笔记</title>
    <link href="www.wangchengzou.cn/2017/07/22/CSS3%E9%AB%98%E7%BA%A7/"/>
    <id>www.wangchengzou.cn/2017/07/22/CSS3高级/</id>
    <published>2017-07-22T15:48:26.000Z</published>
    <updated>2017-07-23T10:33:13.367Z</updated>
    
    <content type="html"><![CDATA[<p>1、复杂选择器</p>
<pre><code>1、兄弟选择器
    通过兄弟级别的位置关系来匹配页面元素
    注意，兄弟选择器，只能向后找，不能向前找
    语法：
        相邻兄弟选择器：通过相邻（紧紧挨着的）位置关系匹配元素
        选择器1+选择器2
        如：div+p   #top+.important
                通用兄弟选择器：用于匹配某元素后面所有的兄弟元素
        选择器1~选择器2
        如#d1~div
2、属性选择器
    通过元素所附带的属性及其值来匹配页面中的元素
    语法：
        基础属性选择器  [attr]
            匹配页面中的有附带attr属性的元素
        elem[attr]
            elem:表示任意元素名称
            attr:表示任意属性名称
            匹配页面中附带attr属性的elem元素
            如：div[id]:匹配页面中所有附带id属性的div元素
        [attr1][attr2][attr3]
            匹配页面中同时附带attr1和attr2属性的所有元素
            如 input[name][hype]
        [attr=value]
            匹配页面中所有attr属性的值为value的元素
            如input[type=text]
        [class~=value]
            主要使用在多类选择器上，匹配页面中class属性值中包含value选择器的元素
        [attr^=value]
            匹配以value值作为开始的attr属性的元素
        [attr$=value]
            匹配以value值作为结束的attr属性的元素
        [attr*=value]
            匹配attr属性值中包含value字符的所有元素
3、伪类选择器
    目标伪类
        突出显示活动的HTML锚元素
        语法： ：target
    结构伪类
        通过元素之间的结构关系来匹配元素
        ：first-child     获取属于其父元素中的首个子元素
        ：last-child     获取属于其父元素中的尾（最后）子元素
        :nth-child(N)  获取属于其父元素中的第N个子元素
        ：empty   空的，匹配没有子元素的元素，包含文本
        ：only-child   匹配属于其父元素中的唯一子元素
    否定伪类
        把匹配某选择器元素排除出去
        ：not(选择器 )
4、伪元素选择器
    伪类与伪元素
        伪类：匹配元素不同的状态
        伪元素：是匹配元素中的内容
    语法：
        ：first-letter
        ::first-letter  匹配某元素的首字符
        ：first-line    匹配某元素的首行字符
        ：：selection 匹配用户选取的内容部分
    ：和：：区别
        在CSS2.1中，伪类选择器和仿元素选择器都是用：来表示
        在CSS3中，所有伪类选择器用：表示，所有的伪元素选择器用：：表示
</code></pre><p>2、内容生成</p>
<pre><code>通过CSS动态的向某个元素的内容区域之前、之后增加一部分内容
伪元素选择器
    ：before   定位到元素内容区域之前
    ：after    定位到元素内容区域之后
语法：
    属性：content
    取值：普通文本
         图像，url(...)
         计数器
问题处理：
    外边距溢出问题
        为父元素添加边框
        使用父元素的内边距取代子元素的外边距
        在父元素的第一个或最后一个子元素位置处增加一个空的table
    浮动元素父元素的高度问题
</code></pre><p>3、弹性布局</p>
<pre><code>flexible box,可伸缩布局，为普通布局带来更大的灵活性
基本概念‘
    flex容器：简称容器，将元素设置为flex容器后，其子元素允许实现灵活的位置摆放
    flex项目：简称项目，存放在flex容器中的内容

语法：
    容器：display
        取值：flex 将块级元素变为flex容器
              inline-flex  将行内元素变为flex容器
        注意：将元素设置为flex布局后，子元素的float,clear,vertical-align属性将失去作用
    容器属性;
        该组属性要添加在容器元素上，控制子元素的位置
        flex-direction  决定主轴的方向（main-axsis）
            取值：
                row  主轴为水平方向的轴，起点在容器左端，默认值
                row-reverse 主轴为水平方向的轴，起点在容器右端
                column  主轴为交叉轴，起点在容器的顶端
                column-reverse 主轴为交叉轴，起点在容器的底端
        flex-wrap   当一条轴线（一行）排列不下时，子元素将如何换行
            取值：
                nowrap     默认值，不换行
                wrap        换行
                wrap-reverse  反方向换行
        flex-flow   dirextion和wrap的缩写方式
            取值：
                row nowrap 默认值
                direction wrap
        justify-content   定义项目在主轴上的对齐方式
            取值：
                flex-start   主轴起点对齐
                flex-end   主轴终点对齐
                center    居中对齐
                space-between  两端对齐，项目之间的距离是相等的
                space-around  每个项目两侧间距是相等的 项目与项目之间的间距，要比项目与父元素之间的间距大一倍
        align-items  定义项目在交叉轴的对齐方式（单行项目有效）
            取值：
                flex-start  交叉轴起点对齐
                flex-end   交叉轴终点对齐
                center     交叉轴中间对齐
                baseline   基线对齐，以所有项目中的第一行文本为准
                stretch    默认值，如果项目不设置高度或为auto时，那么项目将占满整个容器的高度
        align-content  定义了多跟轴线的对齐方式，如果项目只一根轴线，该属性无效
            取值：
                flex-start   交叉轴顶端对齐
                flex-end    交叉轴底端对齐
                center      交叉轴中间对齐
                space-between  与交叉轴两端对齐
                space-around     项目与项目间对齐
    项目属性：
        该组属性主要设置于项目中
        order  定义项目在排列顺序，值越小，越靠前，默认为0
        flex-grow  指定项目的放大比例，默认为0，即不放大
        flex-shrink 指定项目的缩小比例，默认为1，即空间不足时，等比缩小，为0时不缩小
        flex-basis  指定项目占据主轴的剩余空间大小 auto 默认值，项目本身大小
        flex  是flex-grow,flex-shrink,flex-basis 的简写模式
            取值，auto  相当于1  1   auto
                 none  相当于0 0  auto
                 flex-grow【,flex-shrink,flex-basis】
        align-self  允许定义当个项目与其他项目不一样的交叉轴对齐方式（类似于align-items）,能够覆盖align-items的效果
            取值： auto 默认值，使用
                  flex-start   主轴起点对齐
                flex-end   主轴终点对齐
                center    居中对齐
                base-line
                stretch
</code></pre><p>4、CSS Hack 兼容性</p>
<pre><code>标准模式和混杂模式和准标准模式
IE6之前，没有兼容性说法
IE6之后，各个浏览器追求标准统一，开始支持标准，IE的其它浏览器要向前兼容，所以出现各种模式
    混杂模式  无标准可言
        编写代码时，不写&lt;!doctylpe&gt;就是混杂模式，采用的是IE5.5的内核进行渲染
    标准模式  安全支持
    准标准模式，即支持标准，也同时向前兼容非标准代码
如何根据不同的浏览器编写不同的css
    css类内部Hack
        在属性名称前和值添加前后缀以便识别不同的浏览器
    选择器Hack
        在选择器前添加特殊标识以便识别不同的浏览器
    头部引用hack
        通过html的条件注释来判断浏览器版本，去执行不同的CSS
        条件注释
            条件：
                gt:判断当前浏览器是否大于指定定版本
                gte：判断当前浏览器是否大于等于指定定版本
                it:   判断当前浏览器是否小于指定版本
                ite： 判断当前浏览器是否小于等于指定版本
                !：   判断当前浏览器是否为非指定版本
                    &lt;!--[if !IE 8]&gt;
                        该段内容在除IE8以外浏览器中显示
                    &lt;![endif]--&gt;
</code></pre><p>5、转换</p>
<pre><code>说明：改变元素在页面中的形状，角度 大小 位置的一种效果
    允许进行2D和3D方向的转换
    2D转换：在平面中进行的操作
    3D转换：在空间中进行的操作
转换属性：
    rtansform:为元素应用2D或3D转换效果
        取值：none;  没有效果

            transform-functions:一组转换函数
                位移转换函数：translate()
                改变形状函数：skew()
                注意：如果指定多个转换函数的话中间用空格隔开
    转换原点：
        属性：transform-origin
        默认：转换原点在元素中心处
        取值：轴线给值
            两个轴线值：X Y
            三个轴线值：X Y Z
2D转换
    位移：改变元素在页面中的位置
        语法：transform
            fransform(x)  改变元素在X轴的位置
            fransform(X ,Y)  改变元素在两轴的位置
            fransformX(X) 只在X轴上位置移动
            fransformY(Y)  只在Y轴上位置移动
    缩放： 改变元素在页面中的大小】
        语法：transform
            scale(value)  表示两轴等比缩放
                取值：默认  为1
                    放大   为大于1的数值
                    缩小   为0~1之间小数
                    返转   负数
            sacle(X,Y)
            saclex(y)
            sacley(y)
    旋转：改变元素在页面上的角度，要根据原点实现转换效果
        语法：transform
            rotate(ndeg)
                n 取值正，顺时针旋转
                n 取值负，逆时针旋转
                deg 为角度
                0~360范围
        注意：转换原点问题
            元素坐标轴也跟着旋转
    倾斜：改变元素在页面中形状
        语法：transform
            skew(xdeg)  横向倾斜指定度数
                x 取值正，y轴逆时针倾斜一定角度
                  取值负，Y轴顺时针倾斜一定角度
            skew(xdeg,ydeg)
            skewx(xdeg)
            skewy(ydeg)
3D转换
    感觉空间
    属性：perspetive 假定人眼到投射平面的距离
    注意：该属性要放在3D转换元素的父元素上
        兼容性chrome和safari需要加前缀
            -wedkit-perspective:500px;
    旋转：以X轴中心轴旋转
            rotatex(xdeg)
          以Y轴中心轴旋转
            rotatey(ydeg)
          以Z轴中心轴旋转
            rotatez(zdeg)
        取值：正  顺时针
            负   逆时针
        以多个轴同时进行旋转
            rotate3d(x ,y, z ,ndeg)
                x y z 取值为1，该轴参与旋转
                x y z  取值为0 ，该轴不参与旋转
    位移：改变元素在Z轴上的位置
        语法：transform
            translatez(z)

            transform-style
                取值：flat  默认值，子元素不保留3D位置
                     preserve-3D  子元素保留3D位置
</code></pre><p>6、过渡</p>
<pre><code>作用效果：使得css属性值在一段时间内平缓变化的效果
要素与属性：
    指定过渡属性：指定哪个属性值在变化时使用过渡效果展示
        transition-property: 属性名称（width）
                      all   全部属性
                      none
        允许设置过渡效果的属性：
            颜色属性
            渐变属性
            取值为数字属性
            转换属性 transition-property:transform;
            visibility属性
            阴影属性
    指定过渡时长
        transition-duration: 以S、MS为单位数值
    指定过渡时速曲线函数  可选
        transition-timing-function
            取值：ease  默认值，慢速开始，快速变快，慢速结束
                 linear  匀速进行
                 ease-in   慢速开始，快速结束
                 ease-out  快速开始，慢速结束
                 ease-in-out  慢速开始和结束，先加速后减速
    指定过渡的延迟时间   可选
        transition-delay
            取值：以S或MS做为单位
    简写属性：transition:prop duration  timing-fun delay;
        多个过渡效果
            transition:prop1 duration1 timing-fun1 delay1,prop2 duration2 timing-fun2 delay2........;
触发过渡条件
    将过渡编写在元素声明的样式中，由:hover,:active等，进行触发,
    将过渡编写在:hover,:active伪类中
</code></pre><p>7、动画</p>
<pre><code>使元素从一种样式逐渐变化为另一种样式的过程，与动画相关的属性，增加浏览器前缀
动画使用步骤
    声明动画
        指定动画名称
        指定动画中的关键帧（keyframes）
            时间点（以百分比描述时间）
            元素状态（CSS样式）
    为元素调用动画
        指定调用动画的名称以及执行时长
语法：
    声明动画     注意前缀，兼容性问题
        &lt;style&gt;
            @keyframes 名称{
                0%{   动画开始时，元素的状态   }
                。。。。
                100%{  动画结束时，元素的状态  }
            }
        &lt;/style&gt;
    调用动画(animation)
        animation-name  指定调用动画名称
        animation-duration   指定动画周期时长，以S或MS为单位
        animation-timing-function  指定动画的速度时间出线函数
            取值：ease  默认值，慢速开始，快速变快，慢速结束
                 linear  匀速进行
                 ease-in   慢速开始，快速结束
                 ease-out  快速开始，慢速结束
                 ease-in-out  慢速开始和结束，先加速后减速
        animation-delay  指定动画延迟时间
        animation-iteration-count  指定动画播放次数
            取值：默认1次，具体数值
                infinite:无限次播放
        animation-direction  指定动画的播放方向
            取值：normal  从0%~100%
                reverse  从100%~0%
                alternate  轮流来回播放 奇数 0%~100%
                                 偶数 100%~0%
        animation  简写方式
            取值：name  duration  timing-fun delay  iteration-count direction;
        animation-fill-mode  指定动画播放之前、之后的填充模式
            取值：none  默认值
                 forwards  动画播放完成后，保持在最后一帧的位置
                 backwards 动画播放前，延迟时间内，动画保持在开始第一帧上的位置
                 both 同时应用在开始和最后的位置帧上
        animation-play-state  动画播放状态
            取值：paused 暂停
                 running 播放
</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;1、复杂选择器&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;1、兄弟选择器
    通过兄弟级别的位置关系来匹配页面元素
    注意，兄弟选择器，只能向后找，不能向前找
    语法：
        相邻兄弟选择器：通过相邻（紧紧挨着的）位置关系匹配元素
        选择器1+选
    
    </summary>
    
      <category term="学习笔记" scheme="www.wangchengzou.cn/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="CSS" scheme="www.wangchengzou.cn/tags/CSS/"/>
    
      <category term="CSS3" scheme="www.wangchengzou.cn/tags/CSS3/"/>
    
  </entry>
  
  <entry>
    <title>ajax面试题点</title>
    <link href="www.wangchengzou.cn/2017/07/22/ajax%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    <id>www.wangchengzou.cn/2017/07/22/ajax面试题/</id>
    <published>2017-07-22T15:48:26.000Z</published>
    <updated>2017-07-27T14:23:51.280Z</updated>
    
    <content type="html"><![CDATA[<p>1、Ajax 是什么? 如何创建一个Ajax？</p>
<pre><code>Ajax并不算是一种新的技术，全称是asychronous javascript and xml，可以说是已有技术的组合，
主要用来实现客户端与服务器端的异步通信效果，实现页面的局部刷新，早期的浏览器并不能原生支持ajax
，可以使用隐藏帧（iframe）方式变相实现异步效果，后来的浏览器提供了对ajax的原生支持
使用ajax原生方式发送请求主要通过XMLHttpRequest(标准浏览器)、
ActiveXObject(IE浏览器)对象实现异步通信效果
基本步骤：
var xhr =null;//创建对象
if(window.XMLHttpRequest){
    xhr = new XMLHttpRequest();
}else{
    xhr = new ActiveXObject(&quot;Microsoft.XMLHTTP&quot;);
}
     xhr.open(“方式”,”地址”,”标志位”);//初始化请求
     xhr.setRequestHeader(“”,””);//设置http头信息
     xhr.onreadystatechange =function(){}//指定回调函数
     xhr.send();//发送请求
</code></pre><p>3、如何解决跨域问题?</p>
<pre><code>理解跨域的概念：协议、域名、端口都相同才同域，否则都是跨域
出于安全考虑，服务器不允许ajax跨域获取数据，但是可以跨域获取文件内容，
所以基于这一点，可以动态创建script标签，使用标签的src属性访问js文件的形式获取js脚本
，并且这个js脚本中的内容是函数调用，该函数调用的参数是服务器返回的数据，
为了获取这里的参数数据，需要事先在页面中定义回调函数，在回调函数中处理服务器返回的数据
，这就是解决跨域问题的主流解决方案
</code></pre><p>4、页面编码和被请求的资源编码如果不一致如何处理？</p>
<pre><code>对于ajax请求传递的参数，如果是get请求方式，参数如果传递中文，在有些浏览器会乱码，
不同的浏览器对参数编码的处理方式不同，所以对于get请求的参数需要使用
encodeURIComponent函数对参数进行编码处理，后台开发语言都有相应的解码api。
对于post请求不需要进行编码
</code></pre><p>5、简述ajax 的过程。</p>
<pre><code>1. 创建XMLHttpRequest对象,也就是创建一个异步调用对象
2. 创建一个新的HTTP请求,并指定该HTTP请求的方法、URL及验证信息
3. 设置响应HTTP请求状态变化的函数
4. 发送HTTP请求
5. 获取异步调用返回的数据
6. 使用JavaScript和DOM实现局部刷新
</code></pre><p>6、阐述一下异步加载。</p>
<pre><code>1. 异步加载的方案： 动态插入 script 标签
2. 通过 ajax 去获取 js 代码，然后通过 eval 执行
3. script 标签上添加 defer 或者 async 属性
4. 创建并插入 iframe，让它异步执行 js
</code></pre><p>7、请解释一下 JavaScript 的同源策略。</p>
<pre><code>同源策略是客户端脚本（尤其是Javascript）的重要的安全度量标准。
它最早出自Netscape Navigator2.0，其目的是防止某个文档或脚本从多个不同源装载。
所谓同源指的是：协议，域名，端口相同，同源策略是一种安全协议，
指一段脚本只能读取来自同一来源的窗口和文档的属性。
</code></pre><p>8、GET和POST的区别，何时使用POST？</p>
<pre><code>GET：一般用于信息获取，使用URL传递参数，对所发送信息的数量也有限制，
一般在2000个字符，有的浏览器是8000个字符
POST：一般用于修改服务器上的资源，对所发送的信息没有限制
在以下情况中，请使用 POST 请求：
1. 无法使用缓存文件（更新服务器上的文件或数据库）
2. 向服务器发送大量数据（POST 没有数据量限制）
3. 发送包含未知字符的用户输入时，POST 比 GET 更稳定也更可靠
</code></pre><p>9、ajax 是什么?ajax 的交互模型?同步和异步的区别?如何解决跨域问题?</p>
<pre><code>1. 通过异步模式，提升了用户体验
2. 优化了浏览器和服务器之间的传输，减少不必要的数据往返，减少了带宽占用
3.  Ajax在客户端运行，承担了一部分本来由服务器承担的工作，减少了大用户量下的服务器负载。
</code></pre><p>10、 Ajax的最大的特点是什么。</p>
<pre><code>Ajax可以实现异步通信效果，实现页面局部刷新，带来更好的用户体验；按需获取数据，节约带宽资源；
</code></pre><p>11、ajax的缺点</p>
<pre><code>1、ajax不支持浏览器back按钮。
2、安全问题 AJAX暴露了与服务器交互的细节。
3、对搜索引擎的支持比较弱。
4、破坏了程序的异常机制。
</code></pre><p>12、ajax请求的时候get 和post方式的区别</p>
<pre><code>get一般用来进行查询操作，url地址有长度限制，请求的参数都暴露在url地址当中，
如果传递中文参数，需要自己进行编码操作，安全性较低。
post请求方式主要用来提交数据，没有数据长度的限制，
提交的数据内容存在于http请求体中，数据不会暴漏在url地址中。
</code></pre><p>13、解释jsonp的原理，以及为什么不是真正的ajax</p>
<p>　　  Jsonp并不是一种数据格式，而json是一种数据格式，<br>    jsonp是用来解决跨域获取数据的一种解决方案，具体是通过动态创建script标签，<br>    然后通过标签的src属性获取js文件中的js脚本，该脚本的内容是一个函数调用，<br>    参数就是服务器返回的数据，为了处理这些返回的数据，需要事先在页面定义好回调函数<br>    ，本质上使用的并不是ajax技术</p>
<p>14、什么是Ajax和JSON，它们的优缺点。</p>
<pre><code>Ajax是全称是asynchronous JavaScript andXML，即异步JavaScript和xml，
用于在Web页面中实现异步数据交互，实现页面局部刷新。
优点：可以使得页面不重载全部内容的情况下加载局部内容，降低数据传输量，
避免用户不断刷新或者跳转页面，提高用户体验
缺点：对搜索引擎不友好；要实现ajax下的前后退功能成本较大；
可能造成请求数的增加跨域问题限制；
JSON是一种轻量级的数据交换格式，ECMA的一个子集
优点：轻量级、易于人的阅读和编写，便于机器（JavaScript）
解析，支持复合数据类型（数组、对象、字符串、数字）
</code></pre><p>15、http常见的状态码有那些？分别代表是什么意思？<br>    200 - 请求成功<br>    301 - 资源（网页等）被永久转移到其它URL<br>    404 - 请求的资源（网页等）不存在<br>    500 - 内部服务器错误</p>
<p>16、一个页面从输入 URL 到页面加载显示完成，这个过程中都发生了什么？</p>
<pre><code>分为4个步骤：
    1. 当发送一个 URL 请求时，不管这个 URL 是 Web 页面的 URL 还是 Web 页面上每个资源的 URL
    ，浏览器都会开启一个线程来处理这个请求  ，同时在远程 DNS 服务器上启动一个 DNS 查询。
    这能使浏览器获得请求对应的 IP 地址。
    2. 浏览器与远程 Web 服务器通过 TCP 三次握手协商来建立一个 TCP/IP 连接。
    该握手包括一个同步报文，一个同步-应答报文和一个应答报    文，这三个报文在
    浏览器和服务器之间传递。该握手首先由客户端尝试建立起通信，而后服务器应答并接受客户端的请求
    ，最后由客户端发出该请求已经    被接受的报文。
    3. 一旦 TCP/IP 连接建立，浏览器会通过该连接向远程服务器发送 HTTP 的 GET 请求。
    远程服务器找到资源并使用 HTTP响应返回该资源，值为 200 的 HTTP 响应状态表示一个正确的响应。
    4. 此时，Web 服务器提供资源服务，客户端开始下载资源。
</code></pre><p>17、ajax请求的时候get 和post方式的区别</p>
<pre><code>get一般用来进行查询操作，url地址有长度限制，请求的参数都暴露在url地址当中，
如果传递中文参数，需要自己进行编码操作，安全性较低。
post请求方式主要用来提交数据，没有数据长度的限制，提交的数据内容存在于http请求体中
，数据不会暴漏在url地址中。
</code></pre><p>18、ajax请求时，如何解释json数据</p>
<pre><code>使用eval()或者JSON.parse() 鉴于安全性考虑，推荐使用JSON.parse()更靠谱，
对数据的安全性更好。
</code></pre><p>19、.javascript的本地对象，内置对象和宿主对象</p>
<pre><code>本地对象为独立于宿主环境的ECMAScript提供的对象，包括ArrayObjectRegExp等可以new实例化的对象
内置对象为Gload，Math 等不可以实例化的(他们也是本地对象，内置对象是本地对象的一个子集)
宿主对象为所有的非本地对象，所有的BOM和DOM对象都是宿主对象，如浏览器自带的document,window 等对象
</code></pre><p>20、为什么利用多个域名来存储网站资源会更有效？</p>
<pre><code>确保用户在不同地区能用最快的速度打开网站，其中某个域名崩溃用户也能通过其他郁闷访问网站，
并且不同的资源放到不同的服务器上有利于减轻单台服务器的压力。
</code></pre><p>21、请说出三种减低页面加载时间的方法</p>
<pre><code>1、压缩css、js文件
2、合并js、css文件，减少http请求
3、外部js、css文件放在最底下
4、减少dom操作，尽可能用变量替代不必要的dom操作
</code></pre><p>22、HTTP状态码都有那些。</p>
<pre><code>200 OK      //客户端请求成功
400 Bad Request  //客户端请求有语法错误，不能被服务器所理解
403 Forbidden  //服务器收到请求，但是拒绝提供服务
404 Not Found  //请求资源不存在，输入了错误的URL
500 Internal Server Error //服务器发生不可预期的错误
503 Server Unavailable  //服务器当前不能处理客户端的请求，一段时间后可能恢复正常
</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;1、Ajax 是什么? 如何创建一个Ajax？&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Ajax并不算是一种新的技术，全称是asychronous javascript and xml，可以说是已有技术的组合，
主要用来实现客户端与服务器端的异步通信效果，实现页面的局部刷新，早期的浏
    
    </summary>
    
      <category term="面试题目" scheme="www.wangchengzou.cn/categories/%E9%9D%A2%E8%AF%95%E9%A2%98%E7%9B%AE/"/>
    
    
      <category term="ajax" scheme="www.wangchengzou.cn/tags/ajax/"/>
    
      <category term="js" scheme="www.wangchengzou.cn/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>Angular基础知识</title>
    <link href="www.wangchengzou.cn/2017/07/22/Angular/"/>
    <id>www.wangchengzou.cn/2017/07/22/Angular/</id>
    <published>2017-07-22T15:48:26.000Z</published>
    <updated>2017-07-27T12:53:02.708Z</updated>
    
    <content type="html"><![CDATA[<p>1、设计原则和设计模式</p>
<pre><code>拙劣的设计：
①僵化
②脆弱
③不必要的复杂
④晦涩。。

1、YAGNI（不要写不需要的代码）
you aren&apos;t gonna need it

2、KISS （越简单越好）
keep it simple and stupid
语义化的标记、命名规则、减少嵌套

3、DRY（善于使用封装和重用）
Don&apos;t Repeat Yourself

4、高内聚 低耦合（High cohesion,low coupling）
内聚：一个组件（模块）内部的不同部分的关系
耦合：不同组件（模块）之间的关系

5、SRP 单一责任原则
Single Responsibility Principle
实现功能的时候，尽可能的做到每一个模块实现一个单一的功能

6、OCP原则(对于扩展开放、对于修改关闭)
open close principle

7、LCP（迪米特法则）
Least Knowledge Principle 最少知识法则：封装的功能单位要尽可能的小，尽量做到只与自己相关

常用的设计模式分为3大类：①创建 ②结构 ③行为

常用的设计模式：工厂方法模式、单例模式、组合模式、迭代子模式、适配器。。
先去实现功能，在迭代的过程中优化代码。
</code></pre><p>2、AngularJS</p>
<pre><code>认识新东西最好的方式：
①官网
②维基百科 wikipedia.org
what?--ng(AngularJS)是一个开源的js框架
where？--用来实现SPA应用程序（单一页面应用程序single page application）
Gmail邮箱是由Google退出的前端历史中第一个SPA应用
why？
四大特征：
①采用了MVC的设计模式
Model 模型数据
View  视图
Controller 控制器
</code></pre><p>3、MVC的工作原理：</p>
<pre><code>View视图 接收用户的输入，通过控制器（Controller）当中的方法，完成对于Model的增删改查的操作。
1.数据绑定：将数据和视图绑定起来，一旦数据被修改了，视图就会更新
2.双向数据绑定
    数据-》视图
    视图用户的输入 -》 数据
3.依赖注入
4.模块化设计
</code></pre><p>4、使用ng</p>
<pre><code>1、基本语法
    &lt;any&gt;{{表达式}} &lt;/any&gt;
    直接按照上述方法写，结果是不对的，解决方案：在html标签写上了ng-app

2、常用指令
    ngApp
        ①启动ng
        ②指定作用范围，将指令写在根标签
    快捷键：在webStorm中alt+f2,快速选中要去执行在哪个浏览器。
    ngInit 指令 来完成数据的初始化
    &lt;any ng-init=&quot;num=2&quot;&gt;&lt;/any&gt;
        ①不需要在通过ngInit指令定义数据时候，加上var关键字
        ②ngInit所初始化的变量是可以在整个html去使用变量
</code></pre><p>5、常用指令</p>
<pre><code>ng中指令：由angularJS提供了，可以用在html中作为扩展属性、扩展标签。。

作为扩展属性来使用：
    &lt;div ng-**&gt;&lt;/div&gt;
    ngInit  --&gt; ng-init
    ngApp --&gt; ng-app
作为扩展标签来使用：
    &lt;ngView/&gt;
①ngApp
    启动ng
    指定作用范围，将指令写在根标签
    注意事项：调用一次ngApp
②ngInit
    通过ngInit调用一次，初始化多个变量？？
    &lt;any ng-init=&quot;a=1;b=2&quot;/&gt;
③ngRepeat
    重复实例化模板
    两种语法：
    &lt;any ng-repeat=&quot;临时变量的名称 in 集合的名称&quot;&gt;&lt;/any&gt;
    &lt;any ng-repeat=&quot;（key,value） in 集合的名称&quot;&gt;&lt;/any&gt;

    注意事项：在使用ngRpeat的时候要遍历的集合默认是不允许有重复的数据，
        可以通过 track by $index来指定一个不会重复的值就可以解决报错的问题。

④ngIf、ngShow、ngHide、ngSrc、ngDisabled、ngChecked
    ngIf-》选择是否要显示出来（挂载到DOM，从DOM中删除）
    ngShow/ngHide -&gt;选择是否要显示出来(显示或者隐藏)
    &lt;any ng-if=&quot;表达式&quot;&gt;&lt;/any&gt;
    &lt;any ng-show=&quot;表达式&quot;&gt;&lt;/any&gt;
    &lt;any ng-hide=&quot;表达式&quot;&gt;&lt;/any&gt;
    注意事项：在使用ngSrc去读取变量中值的时候，要记得加上双花括号
    &lt;img ng-src=&quot;img/{{imgUrl}}&quot; /&gt; 如果你写的不是ngSrc而是src，显示是ok的，
    但是控制台是会报错的，通过ngSrc去指定就搞定了
    &lt;any ng-disabled=&apos;表达式&apos;&gt;&lt;/any&gt;
    &lt;input type=&apos;checkbox&apos; ng-checked=&quot;表达式&quot;/&gt;
</code></pre><p>6、MVC</p>
<pre><code>在ng中：
    Model 模型数据：在ng中定义的一些变量
    View  视图：通过ng指令和表达式增强版的html
    Controller 控制器：负责数据的增删改查的
MVC的好处:在实现大型应用程序，可以通过将视图和数据隔离开，有效的降低代码的复杂度、耦合度
在ng中应该怎么做才能实现一个SPA？
准备工作：
①创建一个模块
    因为在ng中是以模块为基本单位的
    var app = angular.module(&apos;模块的名称&apos;，[&apos;依赖模块1&apos;,&apos;依赖模块2&apos;])
②使用模块
    采用ngApp指令
    &lt;html ng-app=&quot;模块的名称&quot;&gt;&lt;/html&gt;
③创建一个控制器
    app.controller(&apos;控制器的名称&apos;,function(){})
    第二个参数时控制器被调用时，要执行的方法
④调用控制器
    采用ngController指令来调用控制器
    &lt;div ng-controller=&apos;控制器的名称&apos;&gt;&lt;/div&gt;
    实现数据的创建和显示等：
⑤操作数据、显示出来

$scope是一个对象，称之为作用域对象，是一个非常重要的概念，
    建立起控制器中的数据和控制器的所指定的视图的桥梁

绑定事件的时候，在ng的做法： &lt;any ng-eventName=&quot;handle()&quot;&gt;
&lt;button ng-click=&quot;handleClick()&quot;&gt;&lt;/button&gt;

注意事项：
由于ngInit和$scope都可以完成数据的初始化，建议使用$scope,因为ngInit会增加代码的耦合度和复杂度。
</code></pre><p>7、ng是由很多指令的：</p>
<pre><code>ngApp ngRepeat ngIf ngShow ngHide ngChecked ngDisabled ngSrc
ngBind ngClass ngStyle

在webStorm中创建一个文件模板的基本步骤：
①拷贝要使用的代码
②点击左上角的file，选择new
③选择Edit File Templates
④点击弹窗中右上角的+号
⑤修改name和extension为创建的文件模板的名称以及格式，点击ok保存即可
</code></pre><p>8、自定义指令</p>
<pre><code>1、如何自定义？？
    angular.module()
    app.controller()
    //创建指令
    app.directive(&apos;指令的名称&apos;，function(){
        return {}
    })
    指令的命令规则：指令的名称由两部分构成，前缀：一般使我们模块或者项目的名字缩写；
    后缀：用来描述指令的功能
    属性：
    template：指定要显示的模板内容
    restrict: &quot;EAC&quot; //E(Element)A(Attribute)C(Class)M(Comment)
    replace: true,替换并显示出来
    scope

2、如何使用自定义的指令？？
    注意事项：指令在命名时是要遵循驼峰式命名规则；在使用时要遵循烤串式用方
    &apos;tsHello&apos; --&gt; ts-hello
    根据配置指令时的restrict属性所对应的值，在合适的场景下使用指令。

3、自定义指令传递参数
    怎么传？
        在调用指令的时候可以传 将参数作为属性对应的值
    怎么接受？
        scope
</code></pre><p>9、双向数据绑定</p>
<pre><code>方向1：从&apos;数据&apos;绑定到&apos;视图&apos;
绑定方式：
①常用指令： ngRepeat/ngIf/ngShow...
②双花括号：{{}}

方向2：从‘视图中用户的输入’绑定到‘数据’
绑定方式：指令：ngModel

如果要监听数据的变化：
$scope.$watch(&apos;txt&apos;,function(){

})

在实现下拉框的过程中，如果数据是动态的，可以通过ngOptions将数据绑定到视图中。
ngOptions语法：
 &lt;select
    ng-model=&quot;city&quot;
    ng-options=&quot;city.cityName for city in cities&quot;&gt;
 &lt;/select&gt;
</code></pre><p>10、过滤器</p>
<pre><code>a.内置的过滤器
    ng中的过滤器为了实现对于表达式结果的筛选、过滤、格式化，达到更好的表现效果。
    过滤器的语法：支持多重过滤和传参
    {{expression | 过滤器名称 : '参数' | 过滤器名称2：‘参数’ }
            | => 管道
            常用的过滤器：
                currency 货币样式的过滤器
                date 日期
                uppercase/lowercase 大小写的处理
                orderBy 对指定的数组进行升序或者降序排列
                number 格式化数字为文本（对有小数点的数据的处理）
                limitTo 限定数组或者字符串要显示的个数
        b.自定义过滤器
            自定义过滤器方式：
            app.filter('过滤器名称',function(){
                return function(input，arg){
                        //input是传递给过滤器的数据
                        //arg 是过滤器本身的参数
                    return '过滤后的结果'
                }
            })
            使用自定义的过滤器:
            和内置的过滤器用法是一样的

11、ng模块内置的方法

        序列化、反序列化
        toJson:将对象或者数组 序列化 为json格式的字符串
        fromJson：相反的过程

12、服务

    服务的本质是一个单例对象，提供数据和对象。
    两大类：
    ①内置服务
        $location、$http、$window、$scope...
        使用内置服务中提供的方法：
            第一步 将需要用到的服务注入进来 function($scope,$location)
            第二步 调用服务中提供的方法 数据。。
    ②自定义的服务
        面试题：$scope与$rootScope之间的关系
        1、不同的控制器之间的数据是彼此隔离的
        2、不同的控制器之间如何共享数据？？
        $scope的id是从2开始依次往上递增，
        id为1的是谁？ $rootScope是根作用域对象，其余的$scope都是子对象
            方式1：借助于$rootScope
                把要共享的数据存在$rootScope,所有的子对象就可以读取该数据
            方式2：借助于控制器之间的嵌套
                在调用控制器的元素 之间的嵌套关系
                @@div ng-controller='myCtrl02'>
                    @@<div ng-controller="myCtrl03"></div>
                @@
            方式3：触发事件传递参数
                绑定事件：
                $scope.$on('事件名称',function(event,data){

                })
        触发事件：
        //从子作用对象 向 父作用域对象 传递事件
        $scope.$emit()
        //从父作用对象 向 子作用域对象 传递事件
        $scope.$broadcaset()

13、服务

        双向数据绑定的工作原理：
        绑定时，ng会自动添加一个监听watcher,当数据发生变化时，会执行更新DOM操作的函数。
        怎么知道数据发生了变化？
        在ng中有一个循环$digest,会不断的对比数据，
        需要手工的触发循环做对比，可以通过：
        $scope.$digest();
        $scope.$apply();//触发$rootScope.$digest();

14、ng内置的服务：

        $location $scope $rootScope $window $interval $timeout
        1、在ng中定时器相关的处理--》$interval $timeout
        2、$http
        $http({method:'',url:''}).success().error()
        $http.get()
        $http.post()
        注意：如果需要发起post请求，需要设置:
         app.run(function ($http) {
                $http.defaults.headers.post =
        {'Content-Type':'application/x-www-form-urlencoded'};})

        在发起post请求时，如果需要对参数进行序列化:
        借助于$httpParamSerializer服务，首先注入进来，$httpParamSerializer（obj）。

15、自定义服务

        服务的目的是为了封装业务逻辑，提高代码的复用率
        自定义指令 app.directive
        自定义过滤器 app.filter
        自定义服务的方法：
        app.factory ('服务名称',function(){//普通方法 return {}})
app.service(&apos;服务名称&apos;,function(){//构造函数})
app.constant(&apos;服务名称&apos;，{})//创建常量服务
app.value(&apos;服务名称&apos;，{})//创建变量服务

注意事项：
自定义的服务 需要用到其它服务中方法
图：两个按钮：开始 结束。
</code></pre><p>16、依赖注入</p>
<pre><code>将代码部署到线上，都会对代码做压缩。
使用YUI-Compressor.jar （有java的运行环境）
①借助于CLI（command line）
    java -jar yui**.jar  c:\demo10.js &gt; c:\demo10.min.js

②IDE（webStorm）
    file-&gt;settings-&gt;tools-&gt;fileWathchers-&gt;+-&gt;选中YUI-Compressor JS，
    在弹窗中的program选中对应的jar，保存即可
压缩效果：
会删除所有的注释、删除没有语义的空白字符、尽可能的简化变量的名称（混淆），
但是数字、字符串、关键字是不会改变的。

解决压缩后的问题方式：
依赖注入：将依赖的服务或者其他，通过参数形式注入进来，背后ng框架会帮助对服务等做实例化的操作，
让我们可以去直接使用

注入的方式：
①推断式（猜测）
    这种方式在进行压缩会有问题
    app.controller(&apos;myCtrl&apos;,function($scope){});

②标记式
    由于文件压缩时，关键数据 字符串 关键字等不会被处理的；将所需要用到的服务，
    存在一个字符串（服务名称）数组。
    注意事项：在数组中服务名称的顺序和创建对应的处理函数参数的顺序是要保持一致的
    实现方式：
    1、将处理函数单独的存在一个变量中
    2、给变量设置$inject，值是一个由字符串构成的数组
    3、使用服务即可
③行内式（内联式）
    在构建一个ng对象时，允许将一个字符型数组 作为对象的参数，
    在数组中可以：服务名称、函数（必须是在数组的最后一个元素）
    app.controller(&apos;myCtrl&apos;,[&apos;$scope&apos;,function($scope){}])
    依赖注入3种方式，官方推荐采用行内式依赖注入。
    依赖注入的背后：$injector 注入器：快速的定位到应用需要用到的各种该服务，
    整个ng应用的注入对象都是由$injector定位和创建。
    $injector.has(&apos;服务名称&apos;) ==》判断指定的服务是否存在
    $injector.get(&apos;服务名称&apos;) ==》 得到指定的服务对应的实例
</code></pre><p>17、模块化设计</p>
<pre><code>ng有4大特征：
①MVC
②双向数据绑定
③依赖注入
④模块化设计

高内聚低耦合，在ng中有两种：①内置的模块 ②自定义的模块

如何自定义模块？
angular.module();

使用模块？
ng-app=&quot;&quot;
在创建模块时，在第二个参数所对应的数组中写上服务的名称

一个ng的模块都可以包含哪些？
控制器：对应部分业务逻辑的封装
服务：经常用到的重复代码封装
指令：扩展html标签、属性
过滤器：针对数据做一些筛选 过滤 格式化的处理
</code></pre><p>18、ngRoute（路由模块）</p>
<pre><code>ng是主要实现SPA（单一页面应用程序）
SPA的工作原理：
    1、页面url
    http://127.0.0.1/index.html#/路由地址
    例如：http://127.0.0.1/index.html#/start
    2、解析index.html 是一个完整的html页面，再解析路由地址(start)
    3、在路由词典中寻找路由地址(start)所对应的路由信息
    4、在路由信息所对应的对象中找到真实的模板页面地址
    5、（发起异步ajax）加载模板页面到指定的容器中，实现局部刷新

ngRoute（路由模块）可以定义路由词典，自动解析路由地址，查找路由词典，
自动发起ajax请求加载页面显示。
    0、在创建自定义模块，在依赖列表中指定ngRoute
    1、指定盛放代码片段的容器
    2、配置路由词典

使用ngRoute的基本步骤：
①创建一个完整的html页面
    记得引入angular.js angular-route.js

②创建模块，并指定依赖于ngRoute模块
    angular.module(&apos;myApp&apos;,[&apos;ng&apos;,&apos;ngRoute&apos;])

③使用指令创建一个盛放代码片段的容器
    调用ngView指令：创建一个容器，代码片段会加载到这里

④创建模板页面

⑤配置路由词典
    $routeProvider
    when是用来添加一条路由信息的(路由地址的字符串是以/开始)
    $routeProvider.when(&apos;/myStart&apos;,{controller:&apos;&apos;,template/templateUrl:&apos;&apos;})
    otherwise是用来指定异常的处理
    $routePriovder.otherwise({redirectTo:&apos;路由地址&apos;})

SPA在ng实现过程，代码片段的跳转：
①直接修改地址栏中的路由地址
    http://localhost:63342/day4/demo03_SPA%E7%BB%83%E4%B9%A0.html#/myLogin
    http://localhost:63342/day4/demo03_SPA%E7%BB%83%E4%B9%A0.html#/myRegister
②通过js的方式
    $location.path(&apos;路由地址&apos;)
③超链接的方式
    a href=&quot;#/myRegister&quot;
    login-&gt;start 10

SPA应用程序通过ngRoute来传递参数：
①搞明白 发送 接收
②配置接收方的路由
    $routeProvider.when(&apos;/myStart/:num&apos;,{
    templateUrl:&apos;tpl/start.html&apos;
    })
③拿到传递过来的参数
    $routeParams.num
④发送
    a href=&apos;#/myStart/10&apos;
    $location.path(&apos;/myStart/10&apos;)

注意事项：配置接收方路由时的冒号后的变量名称要和通过$routeParams解析参数的属性是要保持一致
    myStart/:id $routeParams.id

练习：实现一个SPA
完整的html manager.html
代码片段： checkProduct.html pay.html send.html

要求：能够实现不同页面的跳转以及参数的传递
checkProduct.html 能够a跳转到pay，传递price，在pay接收传递过来的参数显示在pay页面
pay 点击button跳转到send
send button以及a跳转到check.html

优化思路：如果多个控制器需要用到同一个方法或者数据，
    ①将方法和数据封装成一个服务
    ②$rootScope
    ③控制器之间的嵌套
    ④借助于事件

由于不同的代码片段都显示在了body的子元素中：body是所有代码片段的父元素，可以在body指定控制器，
控制器中的方法和数据，代码片段就可以用了。
①发送 接收
    checkProduct --&gt; pay

②配置接收方路由
    .when(&apos;/myPay/:price&apos;,{})

③$routeParams
    $routeParams.price

④发送参数
    href=&apos;#/myPay/20&apos;
    $location.path(&apos;/myPay/20&apos;)

ngInclude 引入多个地方同时需要用到的，比如页头、页尾。。。

要求：给综合练习的3个代码片段加上头信息(显示一个p标签)

注意事项：在使用ngInclude进行赋值的时候，对应的路径字符串要在双引号内 加上一对单引号
</code></pre><p>19、ngAnimate（动画模块）</p>
<pre><code>在angularJS添加动画效果，需要用到ngAnimate模块
基本步骤：
①引入对应的js文件
    angular-animate.js
②指定自定义模块依赖于ngAnimate
    angular.module(&apos;myModule&apos;,[&apos;ng&apos;,&apos;ngRoute&apos;,&apos;ngAnimate&apos;])
③css给ng应用程序添加动画效果：
    ngEnter 准备进入
    ngEnterActive 进入完成
    ngLeave 准备离开
    ngLeaveActive 离开完成
④引入对应的css文件

如果用到其它的模块整体思路：
    ①在ng每一个模块都有自己的js文件，用到哪个模块，把指定模块的js文件引入进来
    ②在创建模块，指定依赖列表
    ③根据模块中所提供的指令、服务。。结合业务需要进行
</code></pre><p>20、表单验证</p>
<pre><code>在ng中，针对表单和空间提供了属性，用于验证控件交互的状态
布尔类型：
$valid
$invalid
$dirty
$pristine
对象：
$error

注意事项：
①给表单以及表单组件 加上name属性
②给需要用到的表单组件 ，加上ngModel
③属性的用法
myForm.t_age.$dirty/$pristine/$valid/$invalid/$error
</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;1、设计原则和设计模式&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;拙劣的设计：
①僵化
②脆弱
③不必要的复杂
④晦涩。。

1、YAGNI（不要写不需要的代码）
you aren&amp;apos;t gonna need it

2、KISS （越简单越好）
keep it simple 
    
    </summary>
    
      <category term="学习笔记" scheme="www.wangchengzou.cn/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Angular" scheme="www.wangchengzou.cn/tags/Angular/"/>
    
  </entry>
  
  <entry>
    <title>git/svn使用基础知识</title>
    <link href="www.wangchengzou.cn/2017/07/22/git/"/>
    <id>www.wangchengzou.cn/2017/07/22/git/</id>
    <published>2017-07-22T15:48:26.000Z</published>
    <updated>2017-09-22T10:52:47.391Z</updated>
    
    <content type="html"><![CDATA[<p>使用方法</p>
<pre><code>git  config  --global   user.name   &quot;name&quot;
git  config  --global   user.email   &quot;email@qq.com&quot;
</code></pre><p>指令说明</p>
<pre><code>git  status               查看工作区所有文件状态
git  add  1.jpg          把指定文件添加到暂存区
git  add  *.jpg          把指定后缀名的文件添加到暂存区
git  add  *              把所有文件添加到暂存区
git  add  .              把所有文件添加到暂存区
git  commit  -m  &quot;消息内容&quot;   把暂存区的修改提交给仓库
git  log                 查看仓库中所有的提交记录

git  reset  --hard  版本号     工作区回退到指定的版本
git  log       查看当前已经生效的所有版本号
git  reflog     查看当前已经生效&amp;撤销生效的所有版本号
</code></pre><p>远程仓库相关</p>
<pre><code>git  clone  远程仓库的地址
git  clone  git@github.com:jquery/jquery.git
git  clone  https://github.com/jquery/jquery.git
</code></pre><p>创建关联使用方法</p>
<pre><code>git  init           本地创建一个空白仓库
git  remote       查看当前仓库关联到哪些远程仓库
git  remote  add  关联仓库名  远程仓库的地址
git  pull  关联仓库名  master    从远程仓库“拉取(pull)”已有的文件和版本信息到本地仓库
git  add  .        修改本地仓库中的文件，添加到本地暂存区，提交给本地的仓库
git  commit   -m   &quot;说明信息&quot;
git  push  远程仓库名  master    把本地仓库中的新的版本信息“推送(push)”给远程仓库

git subtree push --prefix=dist origin gh-pages  建立分支结构
</code></pre><p>关于分支的使用方法</p>
<pre><code>1，将远程仓库克隆到本地：
    git clone https://github.com/**.git(项目克隆地址)
2，生成分支gh-pages并切换到此分支
    cd flexSupplement （进入到你克隆仓库的本地文件夹）
    git checkout - -orphan gh-pages (创建分支并切换，两个横杆)
3，将本地克隆文件(文件名为github仓库名)里面除.git文件以外的其他文件全部删除，
    再将根目录下dist文件夹里面的内容复制到克隆文件中。
    依次执行以下命令：
    git add . （将本地所有文件加到仓库里）
    git commit -m “message” （设置提交信息）
    git remote add origin https://github.com/***.git（本地仓库链接远程仓库）
    git push -u origin gh-pages （push文件到仓库中）
</code></pre><p>1、VCS系统</p>
<p>  Version Control System，版本控制系统；用于记录项目文件的开发版本，完成项目文件的存储、共享、合并、回退、回溯等功能。<br>  常见的VCS软件有：<br>    集中式VCS软件： CVS、SVN<br>    分布式VCS软件： Bitlocker、Git</p>
<p>  仓库(Repository)：用于保存项目中所有文件（文本、二进制）,以及每个文件的每次修改记录(谁/何时/修改了什么)<br>  工作区(Working Directory)：用于检出(Checkout)、编辑、提交(Commit)项目文件</p>
<p>2、SVN系统的使用</p>
<p>  服务器端：<br>    (1)安装一款SVN服务器软件(VisualSVN-Server)<br>      (2)启动SVN服务器<br>    (3)创建用户(User)和组(Group)<br>    (4)为每个项目创建一个仓库(Repository)，指定用户和组的访问权限</p>
<p>  客户端：<br>    (1)安装一款SVN客户端软件<br>    (2)选择一个目录作为工作目录(Working Directory)，检出(Checkout)服务器上的已有内容<br>    (3)修改项目文件<br>    (4)提交(Commit)项目文件到SVN服务器<br>    (5)其他项目组员可以从SVN服务器上更新(Update)你提交的项目文件</p>
<p>3、使用WebStorm作为SVN客户端</p>
<p>  只要首先安装SVN客户端，再启动WebStorm，它可以自动发现系统中安装的SVN客户端，<br>  如TortoiseSVN，可以使用WS中按钮直接实现SVN客户端的功能。</p>
<p>4、Git的使用</p>
<p>  快速入门：<a href="http://www.runoob.com/git/git-tutorial.html" target="_blank" rel="external">http://www.runoob.com/git/git-tutorial.html</a><br>  深入入门：<a href="http://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000/" target="_blank" rel="external">http://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000/</a><br>  官方手册：<a href="https://www.gitbook.com/book/bingohuang/progit2/details" target="_blank" rel="external">https://www.gitbook.com/book/bingohuang/progit2/details</a><br>    Git是一个开源的分布式版本控制系统，用于敏捷高效地处理任何或小或大的项目。<br>    Git 是 Linus Torvalds 为了帮助管理 Linux 内核开发而开发的一个开放源码的版本控制软件。<br>    Git 与常用的版本控制工具 CVS, Subversion 等不同，它采用了分布式版本库的方式，不必服务器端软件支持。<br>    SVN和Git的异同点？<br>        1、GIT是分布式的，SVN是集中式：这是GIT和其它非分布式的版本控制系统，例如SVN，CVS等，最核心的区别。<br>        2、GIT把内容按元数据方式存储，而SVN是按文件：所有的资源控制系统都是把文件的元信息隐藏在一个类似.svn,.cvs等的文件夹里。<br>        3、GIT分支和SVN的分支不同：分支在SVN中一点不特别，就是版本库中的另外的一个目录。<br>        4、GIT没有一个全局的版本号，而SVN有：目前为止这是跟SVN相比GIT缺少的最大的一个特征。<br>        5、GIT的内容完整性要优于SVN：GIT的内容存储使用的是SHA-1哈希算法。这能确保代码内容的完整性，<br>            确保在遇到磁盘故障和网络问题时降低对版本库的破坏。<br>    提示：Git系统服务器不是必需的！每个终端都自带仓库。Git账户不需要向服务器申请，自己随意指定即可，但需要为自己创建一个唯一的身份识别号。</p>
<p>5、Git系统的使用</p>
<pre><code>Git是分布式的VCS系统，每个终端都是独立的（有工作区和仓库），
账户的name和email是自己指定的，也可以为每个终端都创建一个全球唯一的身份识别号。
使用步骤：
(1)安装一款Git客户端工具——msysgit
  从官网下载：Git-2.13.0-64-bit.exe
(2)使用Git GUI为自己分配一个全球唯一的身份识别号(SSH Key)
(3)在当前系统中安装的Git全局声明一下当前用户的认证信息
  git  config  --global   user.name   &quot;LiWenhua&quot;
  git  config  --global   user.email   &quot;lwh@qq.com&quot;
(4)创建一个空白工作区，其中包含一个仓库
  git  init
  提示：工作区所在的完整目录中不允许出现中文和空白字符
(5)在工作区中添加/编写/修改/删除项目文件，添加到暂存区，永久提交给仓库，生成版本号
  git  status               查看工作区所有文件状态
  git  add  1.jpg          把指定文件添加到暂存区
  git  add  *.jpg          把指定后缀名的文件添加到暂存区
  git  add  *              把所有文件添加到暂存区
  git  add  .              把所有文件添加到暂存区
  git  commit  -m  &quot;消息内容&quot;   把暂存区的修改提交给仓库
  git  log                 查看仓库中所有的提交记录
(6)可以使用git reset命令回退到历史上的指定版本
  git  reset  --hard  版本号     工作区回退到指定的版本
  git  log       查看当前已经生效的所有版本号
  git  reflog     查看当前已经生效&amp;撤销生效的所有版本号
</code></pre><p>6、Git的常用操作：</p>
<pre><code>使用Git作为VCS的步骤：
(1)安装一款Git客户端——msysgit——一路下一步。
(2)使用OpenSSL工具为自己创建一个唯一的身份识别号——若自己的Git服务器需要和其他的Git服务器进行数据同步，需要使用此识别号。
(3)为Git客户端中设置当前用户的user.name和user.email
    git  config   --global  user.name  &quot;用户名&quot;
    git  config   --global  user.email  &quot;邮箱名&quot;
    提示：上述命令中的双引号不能改用单引号！此命令本质是在修改c:/Users/Administrator/.gitconfig文件
(4)在自己的电脑上分配一个工作空间目录(整个路径中不能有中文和空白)，初始化一个仓库
git  init
(5)编写文件，提交到Git暂存区
    git  status    查看当前工作区文件的状态
    git  add  &lt;文件名&gt;    把指定的文件添加到Git暂存区
(6)把Git暂存区中的数据提交到仓库
    git  commit   -m   &quot;此次提交的说明文字&quot;     把暂存区内容永久提交到仓库
    git  log      查看所有的提交日志
</code></pre><p>  7、从Github.com上克隆他人项目仓库的步骤：</p>
<pre><code>(1)打开https://github.com/，注册(SignUp)，登录(SignIn)
(2)把自己当前git终端的SSH Key添加给github.com
(3)克隆github.com上的项目/仓库
  git  clone  远程仓库的地址
  git  clone  git@github.com:jquery/jquery.git
  git  clone  https://github.com/jquery/jquery.git

将自己本地的仓库与Github.com上的仓库同步：
    (1)打开https://github.com/，注册(SignUp)，登录(SignIn)
    (2)把自己当前git终端的SSH Key添加给github.com
    (3)在自己的github账户下创建公共项目仓库
    (4)在本地电脑上安装Git客户端，添加远程仓库，建立本地仓库与远程仓库的关联
      git  init           本地创建一个空白仓库
      git  remote       查看当前仓库关联到哪些远程仓库
      git  remote  add  关联仓库名  远程仓库的地址
    (5)从远程仓库“拉取(pull)”已有的文件和版本信息到本地仓库
       git  pull  关联仓库名  master
    (6)修改本地仓库中的文件，添加到本地暂存区，提交给本地的仓库
      git  add  .
      git  commit   -m   &quot;说明信息&quot;
    (7)把本地仓库中的新的版本信息“推送(push)”给远程仓库
      git  push  远程仓库名  master
</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;使用方法&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;git  config  --global   user.name   &amp;quot;name&amp;quot;
git  config  --global   user.email   &amp;quot;email@qq.com&amp;quot;
&lt;/
    
    </summary>
    
      <category term="学习笔记" scheme="www.wangchengzou.cn/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="git" scheme="www.wangchengzou.cn/tags/git/"/>
    
      <category term="svn" scheme="www.wangchengzou.cn/tags/svn/"/>
    
      <category term="打包" scheme="www.wangchengzou.cn/tags/%E6%89%93%E5%8C%85/"/>
    
  </entry>
  
  <entry>
    <title>Ajax_php基础知识</title>
    <link href="www.wangchengzou.cn/2017/07/22/Ajax_php/"/>
    <id>www.wangchengzou.cn/2017/07/22/Ajax_php/</id>
    <published>2017-07-22T15:48:26.000Z</published>
    <updated>2017-07-23T13:10:35.427Z</updated>
    
    <content type="html"><![CDATA[<p> 1、如何从数据库中将数据表中数据抓取出来并且显示.</p>
<pre><code>解决方法:语言php 负责从数据库中抓取数据并且显示给用户.
  a:什么是服务器
    能够在网站中提供各种(浏览网页,收发邮件
    视频,语言)等服务器的软件与硬件集合。
    硬件服务器:高可用,高性能计算机
    软件服务器(通常):(WEB/FTP/EMAIL/DB/DNS..)
    web:apache
    db:mysql
b:数据库服务器(软件)
    数据库软件特点：所有其它软件所没有
    1:永久海量存储数据
    2:高速查询
c:数据库服务器分类
    网状数据库:
    树型数据库:
    关系型数据库:
    MySQL***/Oracle/SQLServer/DB2
    NOSQL数据库:Redis
d:什么是关系型数据库
    以横行竖列的方式保存数据,mysql
e:关系型数据库层次
    数据库软件(mysql)--&gt;库--&gt;表--&gt;行--&gt;列
f:mysql之父:马丁
    MYSQL AB(瑞典)-&gt;SUN-&gt;Oracle
g:mysql版本:
  主版本: 企业版(收费)社区版(免费)
    小版本:5.0 5.1 5.2 5.4 5.5 5.6 5.7 ..
    建议:下载哪个版本
    ?如果开发全新网站项目:新版本 5.6
    ?如果二次开发选旧版本.
g:下载
https://www.oracle.com 官网
https://www.mysql.com/downloads/
搜狐镜像
http://mirrors.sohu.com/
mysql windows(64/32)(zip/exe)
linux  unix
    mysql-5.6.34-win32.msi (32)
i:使用软件包(XAMPP)
    (包含:mysql/php/apache/..)
</code></pre><p>   2、如何使用xampp</p>
<pre><code>1:双击xampp图标
2:点击 apache  [start]启动(饭店)
     点击 mysql   [start]启动
3:点击 右侧[shell]
4:输入命令
    mysql -uroot -p
    #mysql 指令专门进入数据库系统
    #-u    指定用户名
    #root  root是mysql软件最高级别用户
    #-p    root用户密码
5:退出软件
    #exit
    #点击右上角[X]
</code></pre><p>3、 sql(结构化查询语言)专用于(增删改查)数据库中数据语言.</p>
<pre><code>使用sql两种方式:
    a:交互模式(上课)
      一行一行执行指令
       用户输入一个sql指令,mysql执行一个指令.
    b:脚本模式(做项目)
    把所有sql指令保存在一个.sql文件中一次执行在mysql中执行

  ￥sql语句的分类
    1:DDL:数据定义指令
         CREATE/DROP/ALTER/TUNCATE
    2:DML:数据操作指令
         INSERT/UPDATE/DELETE
    3:DQL:数据查询指令
         SELECT
    4:DCL:权限指令
        GRANT/REVOKE
    熟练掌握:
        [CREATE/INSERT/UPDATE/DELETE/SELECT]
</code></pre><p>  4、 #CREATE 指令功能创建(库)创建表</p>
<pre><code>指令格式:
      CREATE DATABASE 库名;(库)
建议:(库名/表名/列名)
     :英文不要数字或特殊字符开头
     :中文空格不要
    test01    ok
    2017test  error
    test 02   error
    大旭之家  error
</code></pre><p> 5、 #CREATE 指令功能创建表</p>
<pre><code>a:列数据类型(常用列类型)
     int      整型(年龄) 范围-21亿~21亿
      varchar(10)   字符串(10个字符[数字，字母，汉字])
      double(10,2)  浮点(小数)总长10位其中2位小数
      datetime      日期和时间
 分析表:商品表
     1:商品编号     int   1 2 3 5
     2:商品名称     varchar(20)
     3:商品上架时间 datetime
     4:商品价格     double(10,2)

b:创建表语法
 CREATE TABLE 表名(
     列名1 列类型,
     列名2 列类型,
     列名3 列类型
     );
 c:指令 use 库名称;
 d:查看表是否创建成功
     SHOW TABLES;
     use test001;
     CREATE TABLE t_product(id INT,name VARCHAR(20),ctime DATETIME,price DOUBLE(10,2));
     SHOW TABLES;
</code></pre><p>6、小结上午重点</p>
<pre><code>1:创建库
  CREATE DATABASE 库名; 创建库
  SHOW DATABASES;       查询库是否创建成功
2:创建表
  USE 库名;
  CREATE TABLE 表名(
     列名 列类型(int/varchar/double/datetime)
    );
  SHOW TABLES;
</code></pre><p>7、向数据库中添加记录(行)</p>
<pre><code>a:标准语法
a.1:向所有列添加数据
INSERT INTO 表名 VALUES(列值1,列值2,列值3,.);
INSERT INTO t_stu VALUES(1,&apos;wsl001&apos;,&apos;xuxu&apos;,19);
INSERT INTO t_class VALUES(1,&apos;WEB&apos;,100);
验证:
SELECT * FROM t_stu;
 #字符串类型列加单引号
 #小心中文/(英文)单引号
 #小心日期写法
 #SQL指令结束使用分号
a.2:向部分列添加数据
INSERT INTO 表名(列名1，列名2)VALUES(列值1,列值2,..);
INSERT INTO t_stu(id,no)VALUES(4,&apos;tao&apos;);

a.3:日期类型 &apos;2017-04-12&apos; 字符串
  now()        函数(当前日期时间)
INSERT INTO t_product VALUES(10,&apos;book&apos;,&apos;2010-10-10&apos;,100.99);
INSERT INTO t_product VALUES(20,&apos;js&apos;,&apos;2017-04-12&apos;,99);
INSERT INTO t_product VALUES(30,&apos;css&apos;,now(),98);
</code></pre><p> 8、删除记录(行)</p>
<pre><code>#标准语法:
条件: = &lt; &gt; &lt;= != &lt;&gt;
DELETE FROM 表名 WHERE 条件;
  示例:
  DELETE FROM t_product id = 10;   //ok
  DELETE FROM t_product price = 100.99;
  DELETE FROM t_product name = &apos;book&apos;;
</code></pre><p> 9、 更新记录(行)</p>
<pre><code>#标准语法
UPDATE 表名 SET  列名1=新值1
,列名2=新值2 ..
WHERE 条件;
UPDATE t_stu SET age = 16,name=&apos;daxu&apos;WHERE id = 1;
</code></pre><p>10、 查询记录(行)</p>
<pre><code>  语法:SELECT 列名1,列名2,...
    FROM 表名
    WHERE 条件
    ORDER BY 列名1 #排序

SELECT * FROM 表名;  # *所有列
SELECT id,name FROM t_emp;
SELECT sal FROM t_emp;
SELECT * FROM t_emp;
SELECT id,name,sal,sal*1.2 FROM t_emp;
</code></pre><p>  11、 小结SQL:</p>
<pre><code>a:分类
  DDL:数据定义语句
    CREATE/DROP
    DML:数据操作语句
    DELETE/UPDATE/INSERT
    DQL:数据查询语句
    SELECT
    DCL:
b:常用SQL
  CREATE DATABASE 库名;    创建库
SHOW DATABASES;          查询库名
CREATE TABLE 表名(
      列名1 列类型,
        ....
    );
列类型(INT/VARCHAR(10)/DOUBLE(10,2)/DATETIME)

USE 库名;    进入指定库中
SHOW TABLES; 查询表名
INSERT INTO 表名VALUES(值1,值2,,...);
INSERT INTO 表名(列1,列2)VALUES(值1);
字符串值:&apos;&apos;
日期值  :&apos;&apos; now()
DELETE FROM 表名 WHERE 条件;
UPDATE 表名 SET 列名=新值1,列名=新值2
WHERE 条件;
SELECT * FROM 表名;#*所有列
SELECT id,name FROM 表名;
ORDER BY 列名;
ORDER BY 列名 DESC;
count(列)/sum(列)/max(列)/min(列)/avg(列)
子查询
</code></pre><p>  12、 面试题:如何自学一门新的编程语言</p>
<pre><code>1)了解背景，历史，现状，发展，特点，应用领域
2)建设环境=写出HelloWorld
3)数据类型
4)变量常量
5)运算符
6)逻辑结构
7)通用小程序
8)函数,对象
9)常用函数库，类库，中间件，框架
10)实用项目

   #php 背景特点
     php是一种运行在服务器端(apache)的编程序言,用于
     生成动态网页内容.

   2000,Zend公司成立，维护php语言.发布php解释器环境
     php特点:开源，简单，(易上手),
      跨平台(windows/linux),占用资源少
      尤其适合中小型web应用开发
      (微博/微信/论坛)...

   #搭建软件环境
    1:服务器端环境创建:下载选择web服务器
          apache/Microsoft IIS/Nginx
            c:/xampp/apache/
    2:服务器端:下载并且安装php解析软件
          c:/xampp/php/php.exe
    3:服务器端:编写并保存php程序保存哪里
      c:/xampp/htdocs/1.php
    4:服务器端:启动web服务器
          [start]
    5:客户端:打开浏览器/直接输入服务器程序地址按回车
        http://127.0.0.1/1.php
</code></pre><p>13、php语法              必须掌握</p>
<pre><code>a:程序位置 c:/xampp/htdocs/??
b:创建程序 后缀.php  1.php 2.php
c:代码
    &lt;?php
    ?&gt;
d:声明一个变量
     $变量名 = 值;
    $name = &quot;tom&quot;;
e:访问程序{浏览器}
      http://127.0.0.1/1.php  回车
f:一个php程序由html/css/js/php 代码混合写
</code></pre><p>  14、 php 数据类型</p>
<pre><code>1:值类型/标量类型
    string        字符串类 &quot;&quot;
    boolean/bool  true/false
    int/integer
    float/double
2:复合类型
    object php面向对象2005年之后才出现
    array  php索引/关联数组
3:特殊类型
    null/NULL
    resource 资源:数据库连接，查询结果
4.php 练习数据类型
5.php 练习数组
6.php 综合示例
</code></pre><p>15、使用php操作数据库    重点&amp;难点</p>
<pre><code>?数据库乱码问题处理
原因:脚本文件格式不正确
解决：保存脚本文件 utf-8

php中操作mysql数据库函数
1:php官方最初提供一套连接mysql函数:mysql_xxx();
2:php官方提供增强版mysql函数:      mysqli_xxx();
</code></pre><p>16、 使用php操作mysql服务器步骤</p>
<pre><code>1:创建到mysql服务器连接
  $conn = mysqli_connect(...);
    1:数据库服务器地址ip 127.0.0.1
    2:数据库用户名       root
    3:数据库密码
    4:选库               dangdang
2:向mysql服务器发送sql指令,
  等待服务器执行
    $sql = &quot;....&quot;;//insert/delete/update
    $result = mysqli_query($conn,$sql);
3:读取mysql服务器返回结果
  if($result===false)
4:断开与mysql服务器连接--可以省略
  mysqli_close($conn);
</code></pre><p> 17、 小结:</p>
<pre><code>1:php语法
  $age = 10;
  $stop = &quot;tom $age&quot;;
  $run = &apos;tom&apos;.$age;
2:php数组
  $arr = [1,2,3,4];
  $arr[] = 5;
  $arr = [&quot;name&quot;=&gt;&quot;tom&quot;,&quot;age&quot;=&gt;10];
  foreach($arr as $k=&gt;$v){...}
3:php连接mysql
  a:创建连接
    $conn = mysqli_connect(数据库ip,数据库用户名,密码,库);
    $sql = &quot;SET NAMES UTF8&quot;;
    mysqli_query($conn,$sql);
    b:发送sql
    $sql = &quot;INSERT INTO dd_book VALUES(null,&apos;d&apos;)&quot;;
    $result = mysqli_query($conn,$sql);
    c:判断结果
    if($result === false)

  1:连接数据库
    $conn = mysqli_connect(&quot;127.0.0.1&quot;,&quot;root&quot;,&quot;&quot;,&quot;dangdang&quot;);
    $sql = &quot;SET NAMES utf8&quot;;
    mysqli_query($conn,$sql);
  2:发送sql语句
    $sql = &quot;INSERT INTO 表名....&quot;;
    $result = mysqli_query($conn,$sql);
  3:获取判断返回结果
    if($result===false)
   4:关闭连接
    mysqli_close($conn);
   小结：
      1：发送sql
         解决:在mysql命令输入sql--&gt;copy
              如果列是字符串类型一定 &apos;&apos;
            如果列是整型不用加&apos;&apos;
     2: 表单获取参数
        html: &lt;input type=&quot;text&quot; name=&quot;uid&quot;
        php :  $uid = $_REQUEST[&apos;uid&apos;]
    3:问题{乱码/set names 作用}
      乱码:?????
        解决:
        a:顺序:
          1:news.sql 按照utf-8保存
            2:set names utf8;
              source 不加分号
        b:指令:
          1:SET NAMES UTF-8;
          2:创建库编码指定错误
              CREATE DATABASE bbs CHARSET=UTF8;
        C:1.php
          SET NAMES UTF8;
</code></pre><p>18、学习总结上周重点</p>
<pre><code>1.1:mysql
      数据库软件:
       海量存储永久数据
       快速查询
    SQL:结构化查询语言(操作数据库)
      DDL:DROP/CREATE (DATABASE/TABLE)
      DML:INSERT/UPDATE/DELETE
      DQL:SELECT
      DCL:
      SET NAMES UTF8; 设置SQL编码
      SHOW TABLES;    查询当前库表名
      SHOW DATABASES; 查询当前MYSQL库名
      ..
1.2:php
  后台语言:运行在(服务器 apache)
      &lt;?php
      ?&gt;
      $age = 10;
      $str = &apos;hello php&apos;;
      $str = &quot;hello $age php&quot;;
      php mysql
      a:INSERT/UPDATE/DELETE
        1:连接数据库
          $conn = mysqli_connect(&quot;127.0.0.1&quot;,&apos;root&apos;,&apos;&apos;,&apos;dangdang&apos;);
        2:发送sql
              $sql = &quot;INSERT/UPDATE/DELETE&quot;;
          $result = mysqli_query($conn,$sql);
        3:if($result===true){
          执行成功
           }
      b:SELECT
        1:连接数据库
          $conn = mysqli_connect(&quot;127.0.0.1&quot;,&quot;root&quot;,&quot;&quot;,&quot;dangdang&quot;);
        2:发送sql
          $sql = &quot;SELECT ...&quot;;
          $result = mysqli_query($conn,$sql);
        3:返回结果集对象
        4:抓取
          $row = mysqli_fetch_row($result); 索引
          $row = mysqli_fetch_assoc($result);关联
</code></pre><p>19、 php常用函数</p>
<pre><code>1:#die($str); 终止当前php文件执行,
      并且向客户输出一个终止原因说明.
2:#@ 压制住当前行代码警告消息.
3:#time() 返回当前系统时间,以秒为单位整数
4:#$id = mysqli_insert_id($conn);
  返回连接上刚刚执行insert语句产生id值
  CREATE TABLE t_user(
      id INT PRIMARY KEY AUTO_INCREMENT,
   );
  INSERT INTO t_user VALUES(null,);
5:#$count = mysqli_affected_rows($conn)
  返回刚刚连接上执行增删改语句影响行数
6:$rows = mysql_fetch_all($result,MYSQLI_ASSOC);
  从结果集对象中抓取所有记录,返回二维数组;
</code></pre><p>20、 http协议(零碎.没有太多相关性)重点&amp;难点</p>
<pre><code>1:学习http协议目标
    1:调试AJAX应用&quot;看不见摸不着&quot;的错误
    2:进行web访问优化---高阶面试题
    2.3.1.1:URL
        统一资源定位符:
    互联网任何资源都有一个URL才能被访问
    http://www.baidu.com  网站
    https://www.baidu.com/img/bd_logo1.png 图片
    http://127.0.0.1/01.php

    a:scheme:方案 指定以哪种协议从服务器获取指定资源
    常见方案:http/https/ftp/mailto/file/telnet....
    http:获取网络资源{明文}
    https:获取网络资源{加密}
    http://www.ccb.com/cn        建行
    https://ibsbjstar.ccb.com.cn 建行登录

    b:host 主机名:资源在服务器ip地址或者域名
        http://127.0.0.1      ip地址
        http://www.baidu.com  域名(DNS 域名-&gt;ip)
        http://tmooc.cn       域名

    c:port 端口号*****(面试题)
        每一项网络服务在服务器都对应一个端口号
        ftp    21  文件上传下载
        ssh    22  安全远程登录
        telnet 23  远程登录
        smtp   25  邮件传输发送
        dns    53  域名解析
        http   80  超文本传输***(apache)
        pop3   110 邮件接收
        https  443 加密传输

    d:path
        http://127.0.0.1/ajaxday03/01.php
         e:?&lt;query&gt;
        http://127.0.0.1/ajaxday03/01.php?id=10&amp;age=10
        $id = $_REQUEST[&apos;id&apos;];
        $age = $_REQUEST[&apos;age&apos;];

      #分清一个概念:URL/URN/URI(了解)
        URL:统一资源定位符
        URN:统一资源命名符
        URI:统一资源标示符
        URI图.jpg
        URI==URL+URN
        URL:&lt;a href=&quot;login.html&quot;&gt;....&lt;/a&gt;
            &lt;img src=&quot;http://tmoo.cn/logo.jpg&quot;&gt;....&lt;/a&gt;
        URN:
           &lt;a href=&quot;mailto:admin@tmooc.cn&quot;&gt;..&lt;/a&gt;
           &lt;a href=&quot;javascript:void(0)&quot;&gt;..&lt;/a&gt;

 21、http协议概述

        作用:传输网页
        协议标准:生活标准(手机: 3g 4g 5g)
                 USB(2.0 3.0)
        国际互联网任务组(IETF)制定http协议标准
        1991: http/0.9 有严重缺陷
        1996: http/1.0 正式版本
        1999: http/1.1 当前主流版本(***)

    面试题:
    http/1.1比http/1.0改进哪些地方?
        http协议工作原理方式:请求和响应
        1:客户端浏览器发送请求 (google-&gt;apache)
        2:服务器响应请求并且返回数据
                               (apache-&gt;google)
     解答问题:
        1:支持虚拟主机技术，在一个web服务器上
          同时并存多个不同域名的网站
            个人博客:500w(128 CPU 1T 2000块)
            3网页 index.html photo.html review.html
            20/年
            d:/tmooc    www.tmooc.cn  50w
            e:/tts      www.tts.cn    50w
            ...10
            http: Host:tmooc.cn 虚拟主机域名
        2:支持持久连接技术
          不支持持久边接技术情况
            (每次客户端与服务器数据传输)
            固定流程 101(300握 400挥)
            三次握手 3--&gt;1--&gt;4
            四次握手
            http: keep-alive  (3)--101--(4)
        3:支持代理连接
            Proxy:xxx


22、 http协议规定两种消息格式:

     请求(Request) --客户端浏览器发送web服务器
     响应(Response)--web服务器发送客户端浏览器
     Message:消息/报文,是在http客户端和服务器传递数据块
     http协议规定,消息必须符合特定格式才能版此理解..
     消息内容 &quot;思维导图&quot;
</code></pre><p>23、http协议-(响应)</p>
<pre><code>http:作用传输网页
http:工作方式 请求与响应
请求消息:
 请求方式:{GET/POST/PUT/DELETE/HEAD/CONNECT/TRACE/OPTIONS}
响应消息:
 响应状态码:
 100-199 提示消息
 200-299 响应成功   200
 300-399 重定向     304
 400-499 客户端请求错误 404
 500-599 服务器错误  500
 响应主体类型:
 text/plain
 text/html
 text/css
 application/javascript
 application/json

 1：面试题:GET/POST区别?
    a:语义
        GET:客户端获取服务器上资源
        POST:客户端将数据提交服务器
    b:安全级别
        GET:不安全
        POST:不安全 {https}
    c:数据长度
        GET:通过浏览器地址栏 请求请起启 1KB   汉字20-30
        POST:通过http响应主体 长度没限制
    d:编码
        GET:不会自动编码-&gt;可能出现中文乱码
        POST:自动编码----&gt;不会中文乱码
    e:如何发起
        GET:
        1:浏览器地址栏输入地址回车
        2:标签href  &lt;a&gt;   点击发GET
            src   &lt;img&gt; 自动发GET
            css   like  自动发GET
            script src  自动发GET
        3:js自动跳转
            location.href = &quot;1.html&quot;;
        4:表单
            &lt;form method=&quot;get&quot; action=&quot;&quot;&gt;
            &lt;form action=&quot;1.ph&quot;&gt;
        5:ajax GET
            POST:
            1:表单
            &lt;form action=&quot;&quot; method=&quot;post&quot;&gt;
            2:ajax post

  2：面试题:如何使用http协议相关知识进行web优化
    提示:web访问可以很多方面考虑:
        :优化数据库
        :优化php
        :优化web服务器(apache/nginx)
        :网速
        :传输数据
        :浏览器解析速度(html/css/js)
    下面仅从http请求和响应角度考虑
         1:域名解析
           尽可能减少域名解析次数--减少跨站外
             资源引用.
             DNS(www.tmmoc.cn-&gt;120.132.68.230)
             tmooc.com
             http://www.tmooc.cn/index.html
             index.html
             &lt;img src=&quot;www.tmooc.cn/1.jpg&quot;&gt;
             &lt;script src=&quot;www.tmooc.cn/1.js&quot;&gt;&lt;/script&gt;
         2:创建连接
           努力减少连接创建次数-Connection:keep-alive
             启用持久连接
         3:减少发送请求次数
           尽量减少请求次数--合理进行资源合并，
             合理使用缓存.
         4:等待响应时间
           提交服务器运行速度-提高数据运算及查询速度
         5:接收响应
           尽可能减少响应数据长度--删除空白字符，启压缩
        http://tool.oschina.net/jscompress/
</code></pre><p>24、 ajax    重点&amp;难点 9</p>
<pre><code>a:快速入门
  ajax:异步javascript and xml
    google 推出技术--&gt;酷
    生活场景:ajax 微信餐厅
    最大不同:(发送请求和接收数据都由js完成)

b:原理细节知识
  *功能:添加新用户 msg/t_user(uname,upwd)
     *1:创建add_user.php
    a:获取参数uname,upwd
    b:创建sql insert 发送sql
    c:输出结果添加成功或失败
     *2:创建add_user_input.html
    a:创建表单(uname,upwd)
    b:在表单&lt;input type=&quot;button&quot; value=&quot;新建用户&quot;/&gt;
    c:为button按钮绑定点击事件
    c.1:获取用户名和密码
    d:通过ajax发送请求并且接收服务器
    输出一句话&quot;添加成功&quot;&quot;添加失败&quot;
    以下ajax代码固定js
    1:创建ajax对象
      var xhr = new XMLHttpRequest();
    2:绑定事件
      xhr.onreadystatechange = function(){}
    3:打开连接(连接php程序)
      xhr.open(&apos;GET&apos;,&apos;add_user.php&apos;,true);
    4:发送请求
      xhr.send(null);
</code></pre><p>25、 ajax请求并且接收响应4步</p>
<pre><code>1:创建ajax对象
  var xhr = new XMLHttpRequest();
2:绑定事件:监听xhr对象状态
  xhr.onreadystatechange = function(){
    }
3:连接web服务器php程序
  xhr.open(请求方式,请求地址,是否异步);
    xhr.open(&apos;GET&apos;,&apos;add_user.php?&apos;,true);
4:发送请求消息
  xhr.send(null);
</code></pre><p>26、 ajax原理</p>
<pre><code>a:2002年由Google搜索引擎，提示建议
    AJAX=HTML/CSS/JS/DOM/XML/HTTP
b:ajax作用:
    实现在&apos;无刷新&apos;&apos;无提交&apos;&apos;无跳转&apos;的情况下完成页面局部更新.
c:ajax应用场景
    常见场合:聊天室，在线走势图,搜索建议..
d:ajax 异步javascript and XML 异步:
    1:ajax异步请求:XHR
    2:    同步请求:
    1.1:地址栏输入地址回车
    1.2:表单 submit
    1.3:&lt;a href=&quot;1.php&quot;&gt;
    1.4:&lt;img src=&quot;1.jpg&quot;&gt;
    1.5:location.href = &apos;1.php&apos;
</code></pre><p>27、 ajax常用对象和属性事件方法</p>
<pre><code>1:xhr对象:作用，向web服务器发送请求,并接收返回响应消息.
  var xhr = new XMLHttpRequest();
#注意:产品兼容性
#老IE IE8- 不支持xhr
  new ActiveXObject(&quot;Microsoft.XMLHTTP&quot;);
#兼容性写法
  var xhr = null;
  if(window.XMLHttpRequest){
  xhr = new XMLHttpRequest();
  }else{
      xhr = new ActiveXObject(&quot;Microsoft.XMLHTTP&quot;);
  }
  alert(xhr);
2:xhr对象常用属性*****
  2.1:readyState xhr对象当前状态
    不能手工赋值，可以取值其值会随着(请求-响应)过程进行自动改变
    0 UNSENT  请求消息沿未发送
    1 OPENED  XHR己经打开web服务器连接
    2 HEADERS_RECEVIED xhr己经接收服务器响应消息头部
    3 LOADING XHR正在加载响应消息主体
    4 DONE    XHR接收完成响应消息主体

   2.2:xhr.readyState状态改变
    0 UNSEND  xhr.open();
    1 OPENED  xhr.send();
    2 HREADERS_RECEIVED   自然(不能控制)
    3 LOADING            自然(不能控制)
    4 DONE

  2.3:status
  2.4:statusText
  2.5:responseText
</code></pre><p>28、 ajax 原理与ajax接收不同类型数据</p>
<pre><code>a:核心 XMLHttpRequest    -创建对象
   var xhr = null;
   if(window.XMLHttpRequest){
       xhr = new XMLHttpRequest();
   }else{
       xhr = new ActiveXObject(&quot;Microsoft.XMLHTTP&quot;);
   }
b:xhr属性、方法、事件
  b.1:xhr.readyState 表示xhr状态
   0 未发送      UNSENT
   1 打开连接    OPENED
   2 己经接收服务器返回头信息
          HEADERS_RECEIVED
   3 接收服务器数据
          LOADING
   4 接收完成
          DONE
  B.2:status    表示服务器返回状态码===200
  B.3:responseText 表示服务器响应文本
  B.4:responseXML  表示服务器响应XML文本
    方法:
  B.5:open(method,url.isAsyn)
       表示:打开到服务器连接
       method:请求方式 GET POST
       url:   请求url地址(程序地址)
       isAsyn:请求方式是异步true   同步false
  B.6:send(data)
      表示:把请求消息发送web服务器
          data:请求消息主体内容
      GET--&gt;内容为null
      send(null);
      POST--&gt;请求数据放在里面
      send(&apos;id=10&amp;name=tom&amp;age=19&apos;);
            事件:onreadystatechange
      xhr.readyState每次改变时候触发
        事件0 1 2 3 4
</code></pre><p>29、 AJAX POST 标准语法</p>
<pre><code>1:创建ajax对象 xhr
2:绑定事件     xhr.onreadystatechange
3:打开连接
xhr.open(&apos;POST&apos;,&apos;book_add.php&apos;,true);
3.1:修改请求头信息(将参数编码)
xhr.setRequestHeader(&apos;Content-Type&apos;,&apos;application/x-www-form-urlencoded&apos;);
4:xhr.send(`id=10&amp;name=tom&amp;age=19`);

如果ajax输出
    1:创建php     地址栏输入回车
      http://127.0.0.1/ajaxday06/dangdang/book_add.php?name=1&amp;pic=2.jpg&amp;price=100&amp;pubDate=2010-10-10
    2:创建html/js
      console.log(&quot;1&quot;+变量);
    3:F12/network

  5.0 text/plain     纯文本
        php第一行
            header(&quot;Content-Type:text/plain&quot;);
            html-&gt;ajax
            xhr.responseText
  5.1 text/html      (默认)
        php第一行
        header(&quot;Content-Type:text/html;charset=utf-8&quot;);
        html-&gt;ajax
        xhr.responseText;
  5.2 javascript
        php第一行
        header(&quot;Content-Type:application/javascript;charset=utf-8&quot;);
        echo &quot;var msg=&apos;hello&apos;;alert(msg)&quot;;
      html-&gt;ajax
        eval(xhr.responseText);
        示例:国际化
        当前浏览器 zh-CN  你好
               en-US   hello
      a:编写php i18n.php
        读取客户端请求头部信息
        Accept-Language 截最后二个字符
            CN  你好
        US  hello
       b:i18n.html
     ajax 发送请求--&gt;获取服务器返回信息
    alert();
  5.3 xml       ---- 很少(代码复杂)
  5.4 json      ---- 重点&amp;难点
</code></pre><p>30、 JSON 语法</p>
<pre><code> 1:标准语法 json 要求
   1:一个JSON字符串有且只有一个根，
   可以是{}表示一个对象
       []表示一个数组
    员工信息 {&quot;name&quot;:&quot;tom&quot;,&quot;age&quot;:19}
    一组整型 [10,20,90,100]
    一组员工信息
    [
     {&quot;name&quot;:&quot;jerry&quot;,&quot;age&quot;:21},
     {&quot;name&quot;:&quot;james&quot;,&quot;age&quot;:22},
     {&quot;name&quot;:&quot;gogo&quot;,&quot;age&quot;:19}
    ]
    错误json
    {&quot;name&quot;:&quot;tom1&quot;}
    {&quot;name&quot;:&quot;tom2&quot;}
    {&quot;name&quot;:&quot;tom3&quot;}
2:JSON中可以表示，数字，bool,null,字符串
   注意:字符串必须用双引号
3:数组中可以包含多个值，使用逗号分隔
4:对象中可以包含多个键值，使用逗号分隔
  不同值，键和值之间用分号分隔,键必须是双引号.
</code></pre><p>31、 如何处理JSON数据:</p>
<pre><code>1:服务器端php
  1.1:header(&quot;Content-Type:application/json;charset=utf-8&quot;);
  1.2:$str = json_encode($arr);
  1.3:echo $str;
2:javascript 接收
  var obj = JSON.parse(xhr.responseText);
    obj--&gt;js数组   obj--&gt;js对象

 #JSON字符串格式概述
   XML是字符串数据格式，用于描述数据，
稍微有点麻烦--重量级数据格式.
10字节-&gt;XML--&gt;50字节
JSON是字符串数据格式，用于描述数据,
更加简单--轻量级数据格式.
10字节-&gt;JSON-&gt;22字节

 JSON(JavaScript Object Natation)
是一种轻量级数据交换格式,
易于编写，同时易于程序解析生成
.语法基于JS语言.但是目前被各种语句
所支持.成为一种&quot;异构系统交互数据
标准格式&quot;;
JAVA---- {JSON}   html/js/css
C#------ {JSON}   html/js/css
php----- {JSON}   html/js/css
</code></pre><p>32、ajax处理xml数据格式 – 了解</p>
<pre><code>xml:
html:超文本标记语言，所有标签都是预定义好的，
     用于描述一个网页结构.
xml:可扩展的标签语言，所有的标签都是自定义的
    用于描述一段数据--尤其是批量复合数据.

xml语法要求:
1:xml文档声明
  &lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
2:整篇xml字符串有且只能一个根元素
  &lt;booklist&gt;
    &lt;book&gt;&lt;/book&gt;
    &lt;book&gt;&lt;/book&gt;
    &lt;/booklist&gt;
3:标签有开始必须有结束
  &lt;book&gt;&lt;/book&gt;
4:标签可能嵌套不能交叉
  &lt;book&gt;&lt;name&gt;&lt;/name&gt;&lt;/book&gt;  ok
    &lt;book&gt;&lt;name&gt;&lt;id&gt;&lt;/name&gt;&lt;/id&gt;&lt;/book&gt;
5:标签所有属性&apos;值&apos;必须用双引号括起来
  &lt;book id=&quot;1&quot; name=&quot;tom&quot;&gt;&lt;/book&gt;
总结:xml和html用途不同，xml语法严格

32、 jquery 常用ajax函数

    a:$.get(url,callback);--简单
    作用含义:
         发起一个ajax的GET请求,如果服务器返回成功
         响应消息，调用callback函数,
         在方法中处理响应的数据
        callback  function(data){}
    b:$.post(url,data,callback);
    作用:
         发起一个ajax POST请求，并在请求主体中
         提交请求数据，如果服务器返回成功响应
         消息，调用callback，在cllback方法中
         处理响应数据.
      使用方法三种:
        a:$.post(url,data,callback);
        b:$.post(url,&apos;id=1&amp;name=tom&apos;,callback);
        c:$.post(url,{id:1,name:tom},callback);
        d:$.getJSON(url,callback);
        e:$.load(url);
        f:$.getScript(url,callback);
        g:$.ajax({})--功能最全最强
            万能AJAX封装函数，提供非常多的可选项,
            可以处理各种情形，前面函数都是它的
            简化版.
      $.ajax({
         type:&apos;GET&apos;      //请求方式post/pub/delete/head
         url:&quot;x.php&quot;     //请求地址
         data:&apos;k=v&amp;k1=v1&apos;//请求服务器数据
         beforeSend:fn   //请求消息发送之前调用fn
         success:fn      //响应完成并且成功调用fn
         error:fn        //响应完成但有问题调用fn
         complete:fn     //响应完成回调(无论成败)fn
    });
</code></pre><p>  33、 #ajax注意</p>
<pre><code>对于异步请求成功后创建DOM元素,
不能进行直接事件绑定! click()/bind().
因为在执行此事件绑定时，这些元素在DOM
还不存在。
必须将相关事件委托给DOM树上己经存在父元素!
</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt; 1、如何从数据库中将数据表中数据抓取出来并且显示.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;解决方法:语言php 负责从数据库中抓取数据并且显示给用户.
  a:什么是服务器
    能够在网站中提供各种(浏览网页,收发邮件
    视频,语言)等服务器的软件与硬件集合。
    
    
    </summary>
    
      <category term="学习笔记" scheme="www.wangchengzou.cn/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="ajax" scheme="www.wangchengzou.cn/tags/ajax/"/>
    
      <category term="php" scheme="www.wangchengzou.cn/tags/php/"/>
    
  </entry>
  
</feed>
